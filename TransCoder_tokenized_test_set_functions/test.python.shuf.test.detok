MAXIMUM_NUMBER_CHARACTERS_TWO_CHARACTER_STRING | def maximumChars ( str ) :
INDENT n = len ( str )
res = - 1
for i in range ( 0, n - 1 ) :
INDENT for j in range ( i + 1, n ) :
INDENT if ( str [ i ] == str [ j ] ) :
INDENT res = max ( res, abs ( j - i - 1 ) )
DEDENT DEDENT DEDENT return res
DEDENT

FIND_MIRROR_IMAGE_POINT_2_D_PLANE | def mirrorImage ( a, b, c, x1, y1 ) :
INDENT temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b )
x = temp * a + x1
y = temp * b + y1
return ( x, y )
DEDENT

EFFICIENTLY_COMPUTE_SUMS_OF_DIAGONALS_OF_A_MATRIX | def printDiagonalSums ( mat, n ) :
INDENT principal = 0
secondary = 0;

for i in range ( 0, n ) :
INDENT for j in range ( 0, n ) :
INDENT if ( i == j ) :
INDENT principal += mat [ i ] [ j ]
DEDENT if ( ( i + j ) == ( n - 1 ) ) :
INDENT secondary += mat [ i ] [ j ]
DEDENT DEDENT DEDENT print ( "Principal Diagonal:", principal )
print ( "Secondary Diagonal:", secondary )
DEDENT

COUNTS_PATHS_POINT_REACH_ORIGIN | def countPaths ( n, m ) :
INDENT if ( n == 0 or m == 0 ) :
INDENT return 1
DEDENT return ( countPaths ( n - 1, m ) + countPaths ( n, m - 1 ) )
DEDENT

FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_1 | def find3Numbers ( A, arr_size, sum ) :
INDENT A . sort ( )
for i in range ( 0, arr_size - 2 ) :
INDENT l = i + 1
r = arr_size - 1
while ( l < r ) :
INDENT if ( A [ i ] + A [ l ] + A [ r ] == sum ) :
INDENT print ( "Triplet is", A [ i ], ', ', A [ l ], ', ', A [ r ] );

return True
DEDENT elif ( A [ i ] + A [ l ] + A [ r ] < sum ) :
INDENT l += 1
DEDENT else :
INDENT r -= 1
DEDENT DEDENT DEDENT return False
DEDENT

CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT | def isMagicSquare ( mat ) :
INDENT s = 0
for i in range ( 0, N ) :
INDENT s = s + mat [ i ] [ i ]
DEDENT s2 = 0
for i in range ( 0, N ) :
INDENT s2 = s2 + mat [ i ] [ N - i - 1 ]
DEDENT if ( s != s2 ) :
INDENT return False
DEDENT for i in range ( 0, N ) :
INDENT rowSum = 0;

for j in range ( 0, N ) :
INDENT rowSum += mat [ i ] [ j ]
DEDENT if ( rowSum != s ) :
INDENT return False
DEDENT DEDENT for i in range ( 0, N ) :
INDENT colSum = 0
for j in range ( 0, N ) :
INDENT colSum += mat [ j ] [ i ]
DEDENT if ( s != colSum ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1 | def getTotalNumberOfSequences ( m, n ) :
INDENT T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ]
for i in range ( m + 1 ) :
INDENT for j in range ( n + 1 ) :
INDENT if i == 0 or j == 0 :
INDENT T [ i ] [ j ] = 0
DEDENT elif i < j :
INDENT T [ i ] [ j ] = 0
DEDENT elif j == 1 :
INDENT T [ i ] [ j ] = i
DEDENT else :
INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i //2][j-1]
DEDENTDEDENTDEDENTreturnT[m][n]
DEDENT


FIND_DIFFERENCE_BETWEEN_SUMS_OF_TWO_DIAGONALS_1 | def difference ( arr, n ) :
INDENT d1 = 0
d2 = 0
for i in range ( 0, n ) :
INDENT d1 = d1 + arr [ i ] [ i ]
d2 = d2 + arr [ i ] [ n - i - 1 ]
DEDENT return abs ( d1 - d2 )
DEDENT

MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS | def subset ( ar, n ) :
INDENT res = 0
ar . sort ( )
for i in range ( 0, n ) :
INDENT count = 1
for i in range ( n - 1 ) :
INDENT if ar [ i ] == ar [ i + 1 ] :
INDENT count += 1
DEDENT else :
INDENT break
DEDENT DEDENT res = max ( res, count )
DEDENT return res
DEDENT

DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS | def decToBin ( n ) :
INDENT if ( n == 0 ) :
INDENT return "0";

DEDENT bin = "";

while ( n > 0 ) :
INDENT if ( n & 1 == 0 ) :
INDENT bin = '0' + bin;

DEDENT else :
INDENT bin = '1' + bin;

DEDENT n = n >> 1;

DEDENT return bin;

DEDENT

FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE | def Dragon_Curve_Sequence ( n ) :
INDENT s = "1"
for i in range ( 2, n + 1 ) :
INDENT temp = "1"
prev = '1'
zero = '0'
one = '1'
for j in range ( len ( s ) ) :
INDENT temp += s [ j ]
if ( prev == '0' ) :
INDENT temp += one
prev = one
DEDENT else :
INDENT temp += zero
prev = zero
DEDENT DEDENT s = temp
DEDENT return s
DEDENT

STACK_SET_3_REVERSE_STRING_USING_STACK | def reverse ( string ) :
INDENT string = string [ : : - 1 ]
return string
DEDENT

SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER_1 | def bitonicGenerator ( arr, n ) :
INDENT i = 1
j = n - 1
if ( j % 2 != 0 ) :
INDENT j = j - 1
DEDENT while ( i < j ) :
INDENT arr [ j ], arr [ i ] = arr [ i ], arr [ j ]
i = i + 2
j = j - 2
DEDENT arr_f = [ ]
arr_s = [ ]
for i in range ( int ( ( n + 1 ) / 2 ) ) :
INDENT arr_f . append ( arr [ i ] )
DEDENT i = int ( ( n + 1 ) / 2 )
while ( i < n ) :
INDENT arr_s . append ( arr [ i ] )
i = i + 1
DEDENT arr_f . sort ( )
arr_s . sort ( reverse = True )
for i in arr_s :
INDENT arr_f . append ( i )
DEDENT return arr_f
DEDENT

GIVEN_TWO_NUMBERS_B_FIND_X_X_B | def modularEquation ( a, b ) :
INDENT if ( a < b ) :
INDENT print ( "No solution possible " )
return
DEDENT if ( a == b ) :
INDENT print ( "Infinite Solution possible " )
return
DEDENT count = 0
n = a - b
y = ( int ) ( math . sqrt ( a - b ) )
for i in range ( 1, y + 1 ) :
INDENT if ( n % i == 0 ) :
INDENT if ( n / i > b ) :
INDENT count = count + 1
DEDENT if ( i > b ) :
INDENT count = count + 1
DEDENT DEDENT DEDENT if ( y * y == n and y > b ) :
INDENT count = count - 1
DEDENT print ( count )
DEDENT

CHECK_CHARACTERS_GIVEN_STRING_CAN_REARRANGED_FORM_PALINDROME | def canFormPalindrome ( st ) :
INDENT count = [ 0 ] * ( NO_OF_CHARS )
for i in range ( 0, len ( st ) ) :
INDENT count [ ord ( st [ i ] ) ] = count [ ord ( st [ i ] ) ] + 1
DEDENT odd = 0
for i in range ( 0, NO_OF_CHARS ) :
INDENT if ( count [ i ] & 1 ) :
INDENT odd = odd + 1
DEDENT if ( odd > 1 ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

MAXIMUM_TRIPLET_SUM_ARRAY_1 | def maxTripletSum ( arr, n ) :
INDENT arr . sort ( )
return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] )
DEDENT

FIND_MEDIAN_ROW_WISE_SORTED_MATRIX | def binaryMedian ( m, r, d ) :
INDENT mi = m [ 0 ] [ 0 ]
mx = 0
for i in range ( r ) :
INDENT if m [ i ] [ 0 ] < mi :
INDENT mi = m [ i ] [ 0 ]
DEDENT if m [ i ] [ d - 1 ] > mx :
INDENT mx = m [ i ] [ d - 1 ]
DEDENT DEDENT desired = ( r * d + 1 ) //2
while(mi<mx):
INDENTmid=mi+(mx-mi)//2
place=[0];
foriinrange(r):
INDENTj=upper_bound(m[i],mid)
place[0]=place[0]+j
DEDENTifplace[0]<desired:
INDENTmi=mid+1
DEDENTelse:
INDENTmx=mid
DEDENTDEDENTprint("Median is",mi)
return
DEDENT


HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN | def findHeight ( parent, n ) :
INDENT res = 0
for i in range ( n ) :
INDENT p = i
current = 1
while ( parent [ p ] != - 1 ) :
INDENT current += 1
p = parent [ p ]
DEDENT res = max ( res, current )
DEDENT return res
DEDENT

CHECK_LARGE_NUMBER_DIVISIBLE_20 | def divisibleBy20 ( num ) :
INDENT lastTwoDigits = int ( num [ - 2 : ] )
return ( ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 == 0 ) )
DEDENT

MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING | def maxDP ( n ) :
INDENT res = list ( )
res . append ( 0 )
res . append ( 1 )
i = 2
while i < n + 1 :
INDENT res . append ( max ( i, ( res [ int ( i / 2 ) ] + res [ int ( i / 3 ) ] + res [ int ( i / 4 ) ] + res [ int ( i / 5 ) ] ) ) )
i = i + 1
DEDENT return res [ n ]
DEDENT

QUERIES_ON_ARRAY_WITH_DISAPPEARING_AND_REAPPEARING_ELEMENTS | def PerformQueries ( a, vec ) :
INDENT ans = [ ];

n = len ( a ) - 1;

q = len ( vec );

for i in range ( q ) :
INDENT t = vec [ i ] [ 0 ];

m = vec [ i ] [ 1 ];

if ( m > n ) :
INDENT ans . append ( - 1 );

continue;

DEDENT turn = t //n;
rem=t%n;
if(rem==0andturn%2==1):
INDENTans.append(-1);
continue;
DEDENTif(rem==0andturn%2==0):
INDENTans.append(a[m]);
continue;
DEDENTif(turn%2==0):
INDENTcursize=n-rem;
if(cursize<m):
INDENTans.append(-1);
continue;
DEDENTans.append(a[m+rem]);
DEDENTelse:
INDENTcursize=rem;
if(cursize<m):
INDENTans.append(-1);
continue;
DEDENTans.append(a[m]);
DEDENTDEDENTforiinans:
INDENTprint(i);
DEDENTDEDENT


FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS_1 | def minDist ( arr, n, x, y ) :
INDENT min_dist = sys . maxsize
for i in range ( n ) :
INDENT if arr [ i ] == x or arr [ i ] == y :
INDENT prev = i
break
DEDENT DEDENT while i < n :
INDENT if arr [ i ] == x or arr [ i ] == y :
INDENT if arr [ prev ] != arr [ i ] and ( i - prev ) < min_dist :
INDENT min_dist = i - prev
prev = i
DEDENT else :
INDENT prev = i
DEDENT DEDENT i += 1
DEDENT return min_dist
DEDENT

UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2 | def printUnion ( arr1, arr2, m, n ) :
INDENT i, j = 0, 0
while i < m and j < n :
INDENT if arr1 [ i ] < arr2 [ j ] :
INDENT print ( arr1 [ i ] )
i += 1
DEDENT elif arr2 [ j ] < arr1 [ i ] :
INDENT print ( arr2 [ j ] )
j += 1
DEDENT else :
INDENT print ( arr2 [ j ] )
j += 1
i += 1
DEDENT DEDENT while i < m :
INDENT print ( arr1 [ i ] )
i += 1
DEDENT while j < n :
INDENT print ( arr2 [ j ] )
j += 1
DEDENT DEDENT

WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION | def solveWordWrap ( arr, n, k ) :
INDENT dp = [ 0 ] * n
ans = [ 0 ] * n
dp [ n - 1 ] = 0
ans [ n - 1 ] = n - 1
for i in range ( n - 2, - 1, - 1 ) :
INDENT currlen = - 1
dp [ i ] = sys . maxsize
for j in range ( i, n ) :
INDENT currlen += ( arr [ j ] + 1 )
if ( currlen > k ) :
INDENT break
DEDENT if ( j == n - 1 ) :
INDENT cost = 0
DEDENT else :
INDENT cost = ( ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] )
DEDENT if ( cost < dp [ i ] ) :
INDENT dp [ i ] = cost
ans [ i ] = j
DEDENT DEDENT DEDENT i = 0
while ( i < n ) :
INDENT print ( i + 1, ans [ i ] + 1, end = " " )
i = ans [ i ] + 1
DEDENT DEDENT

COUNT_DISTINCT_SUBSEQUENCES | def countSub ( ss ) :
INDENT last = [ - 1 for i in range ( MAX_CHAR + 1 ) ]
n = len ( ss )
dp = [ - 2 for i in range ( n + 1 ) ]
dp [ 0 ] = 1
for i in range ( 1, n + 1 ) :
INDENT dp [ i ] = 2 * dp [ i - 1 ]
if last [ ord ( ss [ i - 1 ] ) ] != - 1 :
INDENT dp [ i ] = dp [ i ] - dp [ last [ ord ( ss [ i - 1 ] ) ] ]
DEDENT last [ ord ( ss [ i - 1 ] ) ] = i - 1
DEDENT return dp [ n ]
DEDENT

LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3 | def findLength ( st, n ) :
INDENT total = [ 0 ] * ( n + 1 )
for i in range ( 1, n + 1 ) :
INDENT total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) )
DEDENT ans = 0
l = 2
while ( l <= n ) :
INDENT for i in range ( n - l + 1 ) :
INDENT j = i + l - 1
if ( total [ i + int ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l / 2 ) ] ) :
INDENT ans = max ( ans, l )
DEDENT DEDENT l = l + 2
DEDENT return ans
DEDENT

MAXIMUM_PATH_SUM_MATRIX | def findMaxPath ( mat ) :
INDENT res = - 1
for i in range ( M ) :
INDENT res = max ( res, mat [ 0 ] [ i ] )
DEDENT for i in range ( 1, N ) :
INDENT res = - 1
for j in range ( M ) :
INDENT if ( j > 0 and j < M - 1 ) :
INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ], max ( mat [ i - 1 ] [ j - 1 ], mat [ i - 1 ] [ j + 1 ] ) )
DEDENT elif ( j > 0 ) :
INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ], mat [ i - 1 ] [ j - 1 ] )
DEDENT elif ( j < M - 1 ) :
INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ], mat [ i - 1 ] [ j + 1 ] )
DEDENT res = max ( mat [ i ] [ j ], res )
DEDENT DEDENT return res
DEDENT

MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING | def maxRepeating ( str ) :
INDENT l = len ( str )
count = 0
res = str [ 0 ]
for i in range ( l ) :
INDENT cur_count = 1
for j in range ( i + 1, l ) :
INDENT if ( str [ i ] != str [ j ] ) :
INDENT break
DEDENT cur_count += 1
DEDENT if cur_count > count :
INDENT count = cur_count
res = str [ i ]
DEDENT DEDENT return res
DEDENT

MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHER_0_1 | def maxLenSub ( arr, n ) :
INDENT mls = [ ]
max = 0
for i in range ( n ) :
INDENT mls . append ( 1 )
DEDENT for i in range ( n ) :
INDENT for j in range ( i ) :
INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) :
INDENT mls [ i ] = mls [ j ] + 1
DEDENT DEDENT DEDENT for i in range ( n ) :
INDENT if ( max < mls [ i ] ) :
INDENT max = mls [ i ]
DEDENT DEDENT return max
DEDENT

BREAKING_NUMBER_FIRST_PART_INTEGRAL_DIVISION_SECOND_POWER_10 | def calculate ( N ) :
INDENT length = len ( N )
l = int ( ( length ) / 2 )
count = 0
for i in range ( l + 1 ) :
INDENT s = N [ 0 : 0 + i ]
l1 = len ( s )
t = N [ i : l1 + i ]
try :
INDENT if s [ 0 ] == '0' or t [ 0 ] == '0' :
INDENT continue
DEDENT DEDENT except :
INDENT continue
DEDENT if s == t :
INDENT count += 1
DEDENT DEDENT return count
DEDENT

PROGRAM_BINARY_DECIMAL_CONVERSION | def binaryToDecimal ( n ) :
INDENT num = n;

dec_value = 0;

base = 1;

temp = num;

while ( temp ) :
INDENT last_digit = temp % 10;

temp = int ( temp / 10 );

dec_value += last_digit * base;

base = base * 2;

DEDENT return dec_value;

DEDENT

HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT | def getSum ( n ) :
INDENT sum = 0
while ( n != 0 ) :
INDENT sum = sum + int ( n % 10 )
n = int ( n / 10 )
DEDENT return sum
DEDENT

FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES | def findSDSFunc ( n ) :
INDENT DP = [ 0 ] * ( n + 1 )
DP [ 0 ] = 0
DP [ 1 ] = 1
for i in range ( 2, n + 1 ) :
INDENT if ( int ( i % 2 ) == 0 ) :
INDENT DP [ i ] = DP [ int ( i / 2 ) ]
DEDENT else :
INDENT DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] )
DEDENT DEDENT return DP [ n ]
DEDENT

NUMBER_SINK_NODES_GRAPH | def countSink ( n, m, edgeFrom, edgeTo ) :
INDENT mark = [ 0 ] * ( n + 1 )
for i in range ( m ) :
INDENT mark [ edgeFrom [ i ] ] = 1
DEDENT count = 0
for i in range ( 1, n + 1 ) :
INDENT if ( not mark [ i ] ) :
INDENT count += 1
DEDENT DEDENT return count
DEDENT

BREAK_NUMBER_THREE_PARTS | def count_of_ways ( n ) :
INDENT count = 0
for i in range ( 0, n + 1 ) :
INDENT for j in range ( 0, n + 1 ) :
INDENT for k in range ( 0, n + 1 ) :
INDENT if ( i + j + k == n ) :
INDENT count = count + 1
DEDENT DEDENT DEDENT DEDENT return count
DEDENT

PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY | def printDistinct ( arr, n ) :
INDENT for i in range ( 0, n ) :
INDENT d = 0
for j in range ( 0, i ) :
INDENT if ( arr [ i ] == arr [ j ] ) :
INDENT d = 1
break
DEDENT DEDENT if ( d == 0 ) :
INDENT print ( arr [ i ] )
DEDENT DEDENT DEDENT

MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C | def maximumSegments ( n, a, b, c ) :
INDENT dp = [ - 1 ] * ( n + 10 )
dp [ 0 ] = 0
for i in range ( 0, n ) :
INDENT if ( dp [ i ] != - 1 ) :
INDENT if ( i + a <= n ) :
INDENT dp [ i + a ] = max ( dp [ i ] + 1, dp [ i + a ] )
DEDENT if ( i + b <= n ) :
INDENT dp [ i + b ] = max ( dp [ i ] + 1, dp [ i + b ] )
DEDENT if ( i + c <= n ) :
INDENT dp [ i + c ] = max ( dp [ i ] + 1, dp [ i + c ] )
DEDENT DEDENT DEDENT return dp [ n ]
DEDENT

CHECK_VALID_SEQUENCE_DIVISIBLE_M | def isPossible ( n, index, Sum, M, arr, dp ) :
INDENT global MAX
if index == n :
INDENT if ( Sum % M ) == 0 :
INDENT return True
DEDENT return False
DEDENT if dp [ index ] [ Sum ] != - 1 :
INDENT return dp [ index ] [ Sum ]
DEDENT placeAdd = isPossible ( n, index + 1, Sum + arr [ index ], M, arr, dp )
placeMinus = isPossible ( n, index + 1, Sum - arr [ index ], M, arr, dp )
res = placeAdd or placeMinus
dp [ index ] [ Sum ] = res
return res
DEDENT

FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY | def findGreatest ( arr, n ) :
INDENT result = - 1
for i in range ( n ) :
INDENT for j in range ( n - 1 ) :
INDENT for k in range ( j + 1, n ) :
INDENT if ( arr [ j ] * arr [ k ] == arr [ i ] ) :
INDENT result = max ( result, arr [ i ] )
DEDENT DEDENT DEDENT DEDENT return result
DEDENT

MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION | def maxSubArraySumRepeated ( a, n, k ) :
INDENT max_so_far = - 2147483648
max_ending_here = 0
for i in range ( n * k ) :
INDENT max_ending_here = max_ending_here + a [ i % n ]
if ( max_so_far < max_ending_here ) :
INDENT max_so_far = max_ending_here
DEDENT if ( max_ending_here < 0 ) :
INDENT max_ending_here = 0
DEDENT DEDENT return max_so_far
DEDENT

LEONARDO_NUMBER_1 | def leonardo ( n ) :
INDENT dp = [ ];

dp . append ( 1 );

dp . append ( 1 );

for i in range ( 2, n + 1 ) :
INDENT dp . append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 );

DEDENT return dp [ n ];

DEDENT

SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER | def sumOfSubstrings ( num ) :
INDENT n = len ( num )
sumofdigit = [ ]
sumofdigit . append ( int ( num [ 0 ] ) )
res = sumofdigit [ 0 ]
for i in range ( 1, n ) :
INDENT numi = int ( num [ i ] )
sumofdigit . append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] )
res += sumofdigit [ i ]
DEDENT return res
DEDENT

PRUFER_CODE_TREE_CREATION | def printTreeEdges ( prufer, m ) :
INDENT vertices = m + 2
vertex_set = [ 0 ] * vertices
for i in range ( vertices - 2 ) :
INDENT vertex_set [ prufer [ i ] - 1 ] += 1
DEDENT print ( "The edge set E(G) is :" )
j = 0
for i in range ( vertices - 2 ) :
INDENT for j in range ( vertices ) :
INDENT if ( vertex_set [ j ] == 0 ) :
INDENT vertex_set [ j ] = - 1
print ( "(", ( j + 1 ), ", ", prufer [ i ], ") ", sep = "", end = "" )
vertex_set [ prufer [ i ] - 1 ] -= 1
break
DEDENT DEDENT DEDENT j = 0
for i in range ( vertices ) :
INDENT if ( vertex_set [ i ] == 0 and j == 0 ) :
INDENT print ( "(", ( i + 1 ), ", ", sep = "", end = "" )
j += 1
DEDENT elif ( vertex_set [ i ] == 0 and j == 1 ) :
INDENT print ( ( i + 1 ), ")" )
DEDENT DEDENT DEDENT

PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCLE | def findMinimumAngle ( arr, n ) :
INDENT l = 0
_sum = 0
ans = 360
for i in range ( n ) :
INDENT _sum += arr [ i ]
while _sum >= 180 :
INDENT ans = min ( ans, 2 * abs ( 180 - _sum ) )
_sum -= arr [ l ]
l += 1
DEDENT ans = min ( ans, 2 * abs ( 180 - _sum ) )
DEDENT return ans
DEDENT

FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH | def findMaxAverage ( arr, n, k ) :
INDENT if k > n :
INDENT return - 1
DEDENT csum = [ 0 ] * n
csum [ 0 ] = arr [ 0 ]
for i in range ( 1, n ) :
INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ];

DEDENT max_sum = csum [ k - 1 ]
max_end = k - 1
for i in range ( k, n ) :
INDENT curr_sum = csum [ i ] - csum [ i - k ]
if curr_sum > max_sum :
INDENT max_sum = curr_sum
max_end = i
DEDENT DEDENT return max_end - k + 1
DEDENT

SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES | def findS ( s ) :
INDENT _sum = 0
n = 1
while ( _sum < s ) :
INDENT _sum += n * n
n += 1
DEDENT n -= 1
if _sum == s :
INDENT return n
DEDENT return - 1
DEDENT

PROGRAM_TO_CALCULATE_AREA_OF_AN_CIRCLE_INSCRIBED_IN_A_SQUARE | def areaOfInscribedCircle ( a ) :
INDENT return ( PI / 4 ) * a * a
DEDENT

MINIMUM_NUMBER_CHARACTERS_REMOVED_MAKE_BINARY_STRING_ALTERNATE | def countToMake0lternate ( s ) :
INDENT result = 0
for i in range ( len ( s ) - 1 ) :
INDENT if ( s [ i ] == s [ i + 1 ] ) :
INDENT result += 1
DEDENT DEDENT return result
DEDENT

FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND | def findMissing ( a, b, n, m ) :
INDENT for i in range ( n ) :
INDENT for j in range ( m ) :
INDENT if ( a [ i ] == b [ j ] ) :
INDENT break
DEDENT DEDENT if ( j == m - 1 ) :
INDENT print ( a [ i ], end = " " )
DEDENT DEDENT DEDENT

REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM | def rearrange ( arr, n ) :
INDENT temp = n * [ None ]
small, large = 0, n - 1
flag = True
for i in range ( n ) :
INDENT if flag is True :
INDENT temp [ i ] = arr [ large ]
large -= 1
DEDENT else :
INDENT temp [ i ] = arr [ small ]
small += 1
DEDENT flag = bool ( 1 - flag )
DEDENT for i in range ( n ) :
INDENT arr [ i ] = temp [ i ]
DEDENT return arr
DEDENT

DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE | def lbs ( arr ) :
INDENT n = len ( arr )
lis = [ 1 for i in range ( n + 1 ) ]
for i in range ( 1, n ) :
INDENT for j in range ( 0, i ) :
INDENT if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) :
INDENT lis [ i ] = lis [ j ] + 1
DEDENT DEDENT DEDENT lds = [ 1 for i in range ( n + 1 ) ]
for i in reversed ( range ( n - 1 ) ) :
INDENT for j in reversed ( range ( i - 1, n ) ) :
INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) :
INDENT lds [ i ] = lds [ j ] + 1
DEDENT DEDENT DEDENT maximum = lis [ 0 ] + lds [ 0 ] - 1
for i in range ( 1, n ) :
INDENT maximum = max ( ( lis [ i ] + lds [ i ] - 1 ), maximum )
DEDENT return maximum
DEDENT

COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY | def countPairs ( arr, n ) :
INDENT result = 0;

for i in range ( 0, n ) :
INDENT for j in range ( i + 1, n ) :
INDENT product = arr [ i ] * arr [ j ];

for k in range ( 0, n ) :
INDENT if ( arr [ k ] == product ) :
INDENT result = result + 1;

break;

DEDENT DEDENT DEDENT DEDENT return result;

DEDENT

COUNT_SINGLE_NODE_ISOLATED_SUB_GRAPHS_DISCONNECTED_GRAPH | def compute ( graph, N ) :
INDENT count = 0
for i in range ( 1, N + 1 ) :
INDENT if ( len ( graph [ i ] ) == 0 ) :
INDENT count += 1
DEDENT DEDENT return count
DEDENT

HARDY_RAMANUJAN_THEOREM | def exactPrimeFactorCount ( n ) :
INDENT count = 0
if ( n % 2 == 0 ) :
INDENT count = count + 1
while ( n % 2 == 0 ) :
INDENT n = int ( n / 2 )
DEDENT DEDENT i = 3
while ( i <= int ( math . sqrt ( n ) ) ) :
INDENT if ( n % i == 0 ) :
INDENT count = count + 1
while ( n % i == 0 ) :
INDENT n = int ( n / i )
DEDENT DEDENT i = i + 2
DEDENT if ( n > 2 ) :
INDENT count = count + 1
DEDENT return count
DEDENT

SHORTEST_COMMON_SUPERSEQUENCE_1 | def superSeq ( X, Y, m, n ) :
INDENT dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ]
for i in range ( m + 1 ) :
INDENT for j in range ( n + 1 ) :
INDENT if ( not i ) : dp [ i ] [ j ] = j
elif ( not j ) : dp [ i ] [ j ] = i
elif ( X [ i - 1 ] == Y [ j - 1 ] ) :
INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]
DEDENT else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] )
DEDENT DEDENT return dp [ m ] [ n ]
DEDENT

POWER_SET | def printPowerSet ( set, set_size ) :
INDENT pow_set_size = ( int ) ( math . pow ( 2, set_size ) );

counter = 0;

j = 0;

for counter in range ( 0, pow_set_size ) :
INDENT for j in range ( 0, set_size ) :
INDENT if ( ( counter & ( 1 << j ) ) > 0 ) :
INDENT print ( set [ j ], end = "" );

DEDENT DEDENT print ( "" );

DEDENT DEDENT

CHECK_ARRAY_MAJORITY_ELEMENT | def isMajority ( a ) :
INDENT mp = {
}

for i in a :
INDENT if i in mp : mp [ i ] += 1
else : mp [ i ] = 1
DEDENT for x in mp :
INDENT if mp [ x ] >= len ( a ) //2:
INDENTreturnTrue
DEDENTDEDENTreturnFalse
DEDENT


PRINT_GIVEN_MATRIX_COUNTER_CLOCK_WISE_SPIRAL_FORM | def counterClockspiralPrint ( m, n, arr ) :
INDENT k = 0;
l = 0
cnt = 0
total = m * n
while ( k < m and l < n ) :
INDENT if ( cnt == total ) :
INDENT break
DEDENT for i in range ( k, m ) :
INDENT print ( arr [ i ] [ l ], end = " " )
cnt += 1
DEDENT l += 1
if ( cnt == total ) :
INDENT break
DEDENT for i in range ( l, n ) :
INDENT print ( arr [ m - 1 ] [ i ], end = " " )
cnt += 1
DEDENT m -= 1
if ( cnt == total ) :
INDENT break
DEDENT if ( k < m ) :
INDENT for i in range ( m - 1, k - 1, - 1 ) :
INDENT print ( arr [ i ] [ n - 1 ], end = " " )
cnt += 1
DEDENT n -= 1
DEDENT if ( cnt == total ) :
INDENT break
DEDENT if ( l < n ) :
INDENT for i in range ( n - 1, l - 1, - 1 ) :
INDENT print ( arr [ k ] [ i ], end = " " )
cnt += 1
DEDENT k += 1
DEDENT DEDENT DEDENT

PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD | def isPrime ( n ) :
INDENT if n <= 1 :
INDENT return False
DEDENT for i in range ( 2, n ) :
INDENT if n % i == 0 :
INDENT return False;

DEDENT DEDENT return True
DEDENT

FIND_CHARACTER_FIRST_STRING_PRESENT_MINIMUM_INDEX_SECOND_STRING | def printMinIndexChar ( Str, patt ) :
INDENT minIndex = 10 * * 9
m = len ( Str )
n = len ( patt )
for i in range ( n ) :
INDENT for j in range ( m ) :
INDENT if ( patt [ i ] == Str [ j ] and j < minIndex ) :
INDENT minIndex = j
break
DEDENT DEDENT DEDENT if ( minIndex != 10 * * 9 ) :
INDENT print ( "Minimum Index Character = ", Str [ minIndex ] )
DEDENT else :
INDENT print ( "No character present" )
DEDENT DEDENT

PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_1 | def transpose ( A, B ) :
INDENT for i in range ( N ) :
INDENT for j in range ( M ) :
INDENT B [ i ] [ j ] = A [ j ] [ i ]
DEDENT DEDENT DEDENT

COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER | def countNumber ( n ) :
INDENT result = 0
for i in range ( 1, 10 ) :
INDENT s = [ ]
if ( i <= n ) :
INDENT s . append ( i )
result += 1
DEDENT while len ( s ) != 0 :
INDENT tp = s [ - 1 ]
s . pop ( )
for j in range ( tp % 10, 10 ) :
INDENT x = tp * 10 + j
if ( x <= n ) :
INDENT s . append ( x )
result += 1
DEDENT DEDENT DEDENT DEDENT return result
DEDENT

FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X | def firstFactorialDivisibleNumber ( x ) :
INDENT i = 1;

fact = 1;

for i in range ( 1, x ) :
INDENT fact = fact * i
if ( fact % x == 0 ) :
INDENT break
DEDENT DEDENT return i
DEDENT

PRINT_EQUAL_SUM_SETS_ARRAY_PARTITION_PROBLEM_SET_2 | def printEqualSumSets ( arr, n ) :
INDENT sum_array = sum ( arr )
if ( sum_array & 1 ) :
INDENT print ( "-1" )
return
DEDENT k = sum_array >> 1
dp = np . zeros ( ( n + 1, k + 1 ) )
for i in range ( 1, k + 1 ) :
INDENT dp [ 0 ] [ i ] = False
DEDENT for i in range ( n + 1 ) :
INDENT dp [ i ] [ 0 ] = True
DEDENT for i in range ( 1, n + 1 ) :
INDENT for currSum in range ( 1, k + 1 ) :
INDENT dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ]
if ( arr [ i - 1 ] <= currSum ) :
INDENT dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] or dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] )
DEDENT DEDENT DEDENT set1, set2 = [ ], [ ]
if ( not dp [ n ] [ k ] ) :
INDENT print ( "-1" )
return
DEDENT i = n
currSum = k
while ( i > 0 and currSum >= 0 ) :
INDENT if ( dp [ i - 1 ] [ currSum ] ) :
INDENT i -= 1
set2 . append ( arr [ i ] )
DEDENT elif ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) :
INDENT i -= 1
currSum -= arr [ i ]
set1 . append ( arr [ i ] )
DEDENT DEDENT print ( "Set 1 elements:", end = " " )
for i in range ( len ( set1 ) ) :
INDENT print ( set1 [ i ], end = " " )
DEDENT print ( "\nSet 2 elements:", end = " " )
for i in range ( len ( set2 ) ) :
INDENT print ( set2 [ i ], end = " " )
DEDENT DEDENT

COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1 | def numberOfWays ( x ) :
INDENT if x == 0 or x == 1 :
INDENT return 1
DEDENT else :
INDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) )
DEDENT DEDENT

COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX | def countNegative ( M, n, m ) :
INDENT count = 0
for i in range ( n ) :
INDENT for j in range ( m ) :
INDENT if M [ i ] [ j ] < 0 :
INDENT count += 1
DEDENT else :
INDENT break
DEDENT DEDENT DEDENT return count
DEDENT

COUNT_SET_BITS_IN_AN_INTEGER | def countSetBits ( n ) :
INDENT count = 0
while ( n ) :
INDENT count += n & 1
n >>= 1
DEDENT return count
DEDENT

MODULUS_TWO_FLOAT_DOUBLE_NUMBERS | def findMod ( a, b ) :
INDENT if ( a < 0 ) :
INDENT a = - a
DEDENT if ( b < 0 ) :
INDENT b = - b
DEDENT mod = a
while ( mod >= b ) :
INDENT mod = mod - b
DEDENT if ( a < 0 ) :
INDENT return - mod
DEDENT return mod
DEDENT

FIND_A_SPECIFIC_PAIR_IN_MATRIX_1 | def findMaxValue ( mat ) :
INDENT maxValue = - sys . maxsize - 1
maxArr = [ [ 0 for x in range ( N ) ] for y in range ( N ) ]
maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ]
maxv = mat [ N - 1 ] [ N - 1 ];

for j in range ( N - 2, - 1, - 1 ) :
INDENT if ( mat [ N - 1 ] [ j ] > maxv ) :
INDENT maxv = mat [ N - 1 ] [ j ]
DEDENT maxArr [ N - 1 ] [ j ] = maxv
DEDENT maxv = mat [ N - 1 ] [ N - 1 ]
for i in range ( N - 2, - 1, - 1 ) :
INDENT if ( mat [ i ] [ N - 1 ] > maxv ) :
INDENT maxv = mat [ i ] [ N - 1 ]
DEDENT maxArr [ i ] [ N - 1 ] = maxv
DEDENT for i in range ( N - 2, - 1, - 1 ) :
INDENT for j in range ( N - 2, - 1, - 1 ) :
INDENT if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) :
INDENT maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] )
DEDENT maxArr [ i ] [ j ] = max ( mat [ i ] [ j ], max ( maxArr [ i ] [ j + 1 ], maxArr [ i + 1 ] [ j ] ) )
DEDENT DEDENT return maxValue
DEDENT

MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY | def solve ( arr, n ) :
INDENT arr . sort ( )
a = 0;
b = 0
for i in range ( n ) :
INDENT if ( i % 2 != 0 ) :
INDENT a = a * 10 + arr [ i ]
DEDENT else :
INDENT b = b * 10 + arr [ i ]
DEDENT DEDENT return a + b
DEDENT

COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2_1 | def countSolutions ( n ) :
INDENT x = 0
res = 0
yCount = 0
while ( yCount * yCount < n ) :
INDENT yCount = yCount + 1
DEDENT while ( yCount != 0 ) :
INDENT res = res + yCount
x = x + 1
while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) :
INDENT yCount = yCount - 1
DEDENT DEDENT return res
DEDENT

FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME | def findIndex ( n ) :
INDENT if ( n <= 1 ) :
INDENT return n
DEDENT a = 0
b = 1
c = 1
res = 1
while ( c < n ) :
INDENT c = a + b
res = res + 1
a = b
b = c
DEDENT return res
DEDENT

PROGRAM_OCTAL_DECIMAL_CONVERSION | def octalToDecimal ( n ) :
INDENT num = n;

dec_value = 0;

base = 1;

temp = num;

while ( temp ) :
INDENT last_digit = temp % 10;

temp = int ( temp / 10 );

dec_value += last_digit * base;

base = base * 8;

DEDENT return dec_value;

DEDENT

FIND_PERMUTED_ROWS_GIVEN_ROW_MATRIX | def permutatedRows ( mat, m, n, r ) :
INDENT s = set ( )
for j in range ( n ) :
INDENT s . add ( mat [ r ] [ j ] )
DEDENT for i in range ( m ) :
INDENT if i == r :
INDENT continue
DEDENT for j in range ( n ) :
INDENT if mat [ i ] [ j ] not in s :
INDENT j = j - 2
break;

DEDENT DEDENT if j + 1 != n :
INDENT continue
DEDENT print ( i )
DEDENT DEDENT

PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES | def noAdjacentDup ( s ) :
INDENT n = len ( s )
for i in range ( 1, n ) :
INDENT if ( s [ i ] == s [ i - 1 ] ) :
INDENT s [ i ] = "a"
while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) :
INDENT s [ i ] += 1
DEDENT i += 1
DEDENT DEDENT return s
DEDENT

SUM_MANHATTAN_DISTANCES_PAIRS_POINTS | def distancesum ( x, y, n ) :
INDENT sum = 0
for i in range ( n ) :
INDENT for j in range ( i + 1, n ) :
INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) )
DEDENT DEDENT return sum
DEDENT

PROGRAM_FIND_STRING_START_END_GEEKS | def isCornerPresent ( str, corner ) :
INDENT n = len ( str )
cl = len ( corner )
if ( n < cl ) :
INDENT return False
DEDENT return ( ( str [ : cl ] == corner ) and ( str [ n - cl : ] == corner ) )
DEDENT

LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S | def lenOfLongSubarr ( arr, n ) :
INDENT um = {
  i : 0 for i in range ( 10 ) }
  
  sum = 0
  maxLen = 0
  for i in range ( n ) :
  INDENT if arr [ i ] == 0 :
  INDENT sum += - 1
  DEDENT else :
  INDENT sum += 1
  DEDENT if ( sum == 1 ) :
  INDENT maxLen = i + 1
  DEDENT elif ( sum not in um ) :
  INDENT um [ sum ] = i
  DEDENT if ( ( sum - 1 ) in um ) :
  INDENT if ( maxLen < ( i - um [ sum - 1 ] ) ) :
  INDENT maxLen = i - um [ sum - 1 ]
  DEDENT DEDENT DEDENT return maxLen
  DEDENT

DIVIDE_CONQUER_SET_6_SEARCH_ROW_WISE_COLUMN_WISE_SORTED_2D_ARRAY | def search ( mat, fromRow, toRow, fromCol, toCol, key ) :
INDENT i = fromRow + ( toRow - fromRow ) //2;
j=fromCol+(toCol-fromCol)//2;
if(mat[i][j]==key):
INDENTprint("Found ",key," at ",i," ",j);
DEDENTelse:
INDENTif(i!=toRoworj!=fromCol):
INDENTsearch(mat,fromRow,i,j,toCol,key);
DEDENTif(fromRow==toRowandfromCol+1==toCol):
INDENTif(mat[fromRow][toCol]==key):
INDENTprint("Found ",key," at ",fromRow," ",toCol);
DEDENTDEDENTif(mat[i][j]<key):
INDENTif(i+1<=toRow):
INDENTsearch(mat,i+1,toRow,fromCol,toCol,key);
DEDENTDEDENTelse:
INDENTif(j-1>=fromCol):
INDENTsearch(mat,fromRow,toRow,fromCol,j-1,key);
DEDENTDEDENTDEDENTDEDENT


SHORTEST_COMMON_SUPERSEQUENCE | def superSeq ( X, Y, m, n ) :
INDENT if ( not m ) : return n
if ( not n ) : return m
if ( X [ m - 1 ] == Y [ n - 1 ] ) :
INDENT return 1 + superSeq ( X, Y, m - 1, n - 1 )
DEDENT return 1 + min ( superSeq ( X, Y, m - 1, n ), superSeq ( X, Y, m, n - 1 ) )
DEDENT

URLIFY_GIVEN_STRING_REPLACE_SPACES | def replaceSpaces ( string ) :
INDENT string = string . strip ( )
i = len ( string )
space_count = string . count ( ' ' )
new_length = i + space_count * 2
if new_length > MAX :
INDENT return - 1
DEDENT index = new_length - 1
string = list ( string )
for f in range ( i - 2, new_length - 2 ) :
INDENT string . append ( '0' )
DEDENT for j in range ( i - 1, 0, - 1 ) :
INDENT if string [ j ] == ' ' :
INDENT string [ index ] = '0'
string [ index - 1 ] = '2'
string [ index - 2 ] = '%'
index = index - 3
DEDENT else :
INDENT string [ index ] = string [ j ]
index -= 1
DEDENT DEDENT return '' . join ( string )
DEDENT

MAXIMUM_PATH_SUM_STARTING_CELL_0_TH_ROW_ENDING_CELL_N_1_TH_ROW | def MaximumPath ( Mat ) :
INDENT result = 0
dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N ) ]
for i in range ( N ) :
INDENT for j in range ( 1, N + 1 ) :
INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ], max ( dp [ i - 1 ] [ j ], dp [ i - 1 ] [ j + 1 ] ) ) + \
INDENT Mat [ i ] [ j - 1 ]
DEDENT DEDENT DEDENT for i in range ( N + 1 ) :
INDENT result = max ( result, dp [ N - 1 ] [ i ] )
DEDENT return result
DEDENT

COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING | def getAbs ( n ) :
INDENT mask = n >> ( SIZE_INT * CHARBIT - 1 );

return ( ( n + mask ) ^ mask );

DEDENT

COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1 | def countPS ( i, j ) :
INDENT if ( i >= n or j < 0 ) :
INDENT return 0
DEDENT if ( dp [ i ] [ j ] != - 1 ) :
INDENT return dp [ i ] [ j ]
DEDENT if ( abs ( i - j ) == 1 ) :
INDENT if ( str [ i ] == str [ j ] ) :
INDENT dp [ i ] [ j ] = 3
return dp [ i ] [ j ]
DEDENT else :
INDENT dp [ i ] [ j ] = 2
return dp [ i ] [ j ]
DEDENT DEDENT if ( i == j ) :
INDENT dp [ 1 ] [ j ] = 1
return dp [ 1 ] [ j ]
DEDENT elif ( str [ i ] == str [ j ] ) :
INDENT dp [ i ] [ j ] = ( countPS ( i + 1, j ) + countPS ( i, j - 1 ) + 1 )
return dp [ i ] [ j ]
DEDENT else :
INDENT dp [ i ] [ j ] = ( countPS ( i + 1, j ) + countPS ( i, j - 1 ) - countPS ( i + 1, j - 1 ) )
return dp [ i ] [ j ]
DEDENT DEDENT

LARGEST_SUM_CONTIGUOUS_SUBARRAY_2 | def maxSubArraySum ( a, size ) :
INDENT max_so_far = a [ 0 ]
curr_max = a [ 0 ]
for i in range ( 1, size ) :
INDENT curr_max = max ( a [ i ], curr_max + a [ i ] )
max_so_far = max ( max_so_far, curr_max )
DEDENT return max_so_far
DEDENT

COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY | def countMinOperations ( target, n ) :
INDENT result = 0;

while ( True ) :
INDENT zero_count = 0;

i = 0;

while ( i < n ) :
INDENT if ( ( target [ i ] & 1 ) > 0 ) :
INDENT break;

DEDENT elif ( target [ i ] == 0 ) :
INDENT zero_count += 1;

DEDENT i += 1;

DEDENT if ( zero_count == n ) :
INDENT return result;

DEDENT if ( i == n ) :
INDENT for j in range ( n ) :
INDENT target [ j ] = target [ j ] //2;
DEDENTresult+=1;
DEDENTforjinrange(i,n):
INDENTif(target[j]&1):
INDENTtarget[j]-=1;
result+=1;
DEDENTDEDENTDEDENTDEDENT


PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1 | def fib ( n ) :
INDENT a = 0
b = 1
if ( n >= 0 ) :
INDENT print ( a, end = ' ' )
DEDENT if ( n >= 1 ) :
INDENT print ( b, end = ' ' )
DEDENT for i in range ( 2, n + 1 ) :
INDENT print ( a + b, end = ' ' )
b = a + b
a = b - a
DEDENT DEDENT

PROGRAM_CHECK_INPUT_INTEGER_STRING | def isNumber ( s ) :
INDENT for i in range ( len ( s ) ) :
INDENT if s [ i ] . isdigit ( ) != True :
INDENT return False
DEDENT DEDENT return True
DEDENT

MINIMUM_HEIGHT_TRIANGLE_GIVEN_BASE_AREA | def minHeight ( area, base ) :
INDENT return math . ceil ( ( 2 * area ) / base )
DEDENT

FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7 | def findpos ( n ) :
INDENT i = 0
j = len ( n )
pos = 0
while ( i < j ) :
INDENT if ( n [ i ] == '4' ) :
INDENT pos = pos * 2 + 1
DEDENT if ( n [ i ] == '7' ) :
INDENT pos = pos * 2 + 2
DEDENT i = i + 1
DEDENT return pos
DEDENT

MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX | def minOperation ( arr ) :
INDENT ans = 0
for i in range ( N - 1, - 1, - 1 ) :
INDENT for j in range ( M - 1, - 1, - 1 ) :
INDENT if ( arr [ i ] [ j ] == 0 ) :
INDENT ans += 1
for k in range ( i + 1 ) :
INDENT for h in range ( j + 1 ) :
INDENT if ( arr [ k ] [ h ] == 1 ) :
INDENT arr [ k ] [ h ] = 0
DEDENT else :
INDENT arr [ k ] [ h ] = 1
DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans
DEDENT

LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2 | def findLength ( string, n ) :
INDENT Sum = [ 0 ] * ( n + 1 )
for i in range ( 1, n + 1 ) :
INDENT Sum [ i ] = ( Sum [ i - 1 ] + int ( string [ i - 1 ] ) )
DEDENT ans = 0
for length in range ( 2, n + 1, 2 ) :
INDENT for i in range ( 0, n - length + 1 ) :
INDENT j = i + length - 1
if ( Sum [ i + length //2]-Sum[i]==Sum[i+length]-Sum[i+length//2]):
INDENTans=max(ans,length)
DEDENTDEDENTDEDENTreturnans
DEDENT


MULTIPLY_LARGE_NUMBERS_REPRESENTED_AS_STRINGS | def multiply ( num1, num2 ) :
INDENT len1 = len ( num1 )
len2 = len ( num2 )
if len1 == 0 or len2 == 0 :
INDENT return "0"
DEDENT result = [ 0 ] * ( len1 + len2 )
i_n1 = 0
i_n2 = 0
for i in range ( len1 - 1, - 1, - 1 ) :
INDENT carry = 0
n1 = ord ( num1 [ i ] ) - 48
i_n2 = 0
for j in range ( len2 - 1, - 1, - 1 ) :
INDENT n2 = ord ( num2 [ j ] ) - 48
summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry
carry = summ //10
result[i_n1+i_n2]=summ%10
i_n2+=1
DEDENTif(carry>0):
INDENTresult[i_n1+i_n2]+=carry
DEDENTi_n1+=1
DEDENTi=len(result)-1
while(i>=0andresult[i]==0):
INDENTi-=1
DEDENTif(i==-1):
INDENTreturn"0"
DEDENTs=""
while(i>=0):
INDENTs+=chr(result[i]+48)
i-=1
DEDENTreturns
DEDENT


PARTITION_NUMBER_TWO_DIVISBLE_PARTS | def findDivision ( str, a, b ) :
INDENT lenn = len ( str )
lr = [ 0 ] * ( lenn + 1 )
lr [ 0 ] = ( int ( str [ 0 ] ) ) % a
for i in range ( 1, lenn ) :
INDENT lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + \ int ( str [ i ] ) ) % a
DEDENT rl = [ 0 ] * ( lenn + 1 )
rl [ lenn - 1 ] = int ( str [ lenn - 1 ] ) % b
power10 = 10
for i in range ( lenn - 2, - 1, - 1 ) :
INDENT rl [ i ] = ( rl [ i + 1 ] + int ( str [ i ] ) * power10 ) % b
power10 = ( power10 * 10 ) % b
DEDENT for i in range ( 0, lenn - 1 ) :
INDENT if ( lr [ i ] != 0 ) :
INDENT continue
DEDENT if ( rl [ i + 1 ] == 0 ) :
INDENT print ( "YES" )
for k in range ( 0, i + 1 ) :
INDENT print ( str [ k ], end = "" )
DEDENT print ( ",", end = " " )
for i in range ( i + 1, lenn ) :
INDENT print ( str [ k ], end = "" )
return
DEDENT DEDENT DEDENT print ( "NO" )
DEDENT

PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT | def bestFit ( blockSize, m, processSize, n ) :
INDENT allocation = [ - 1 ] * n
for i in range ( n ) :
INDENT bestIdx = - 1
for j in range ( m ) :
INDENT if blockSize [ j ] >= processSize [ i ] :
INDENT if bestIdx == - 1 :
INDENT bestIdx = j
DEDENT elif blockSize [ bestIdx ] > blockSize [ j ] :
INDENT bestIdx = j
DEDENT DEDENT DEDENT if bestIdx != - 1 :
INDENT allocation [ i ] = bestIdx
blockSize [ bestIdx ] -= processSize [ i ]
DEDENT DEDENT print ( "Process No. Process Size     Block no." )
for i in range ( n ) :
INDENT print ( i + 1, "         ", processSize [ i ], end = "         " )
if allocation [ i ] != - 1 :
INDENT print ( allocation [ i ] + 1 )
DEDENT else :
INDENT print ( "Not Allocated" )
DEDENT DEDENT DEDENT

FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS | def largestKSubmatrix ( a ) :
INDENT dp = [ [ 0 for x in range ( Row ) ] for y in range ( Col ) ]
result = 0
for i in range ( Row ) :
INDENT for j in range ( Col ) :
INDENT if ( i == 0 or j == 0 ) :
INDENT dp [ i ] [ j ] = 1
DEDENT else :
INDENT if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) :
INDENT dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] ), dp [ i - 1 ] [ j - 1 ] ) + 1
DEDENT else :
INDENT dp [ i ] [ j ] = 1
DEDENT DEDENT result = max ( result, dp [ i ] [ j ] )
DEDENT DEDENT return result
DEDENT

FRIENDS_PAIRING_PROBLEM_1 | def countFriendsPairings ( n ) :
INDENT dp = [ - 1 ] * 100
if ( dp [ n ] != - 1 ) :
INDENT return dp [ n ]
DEDENT if ( n > 2 ) :
INDENT dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) )
return dp [ n ]
DEDENT else :
INDENT dp [ n ] = n
return dp [ n ]
DEDENT DEDENT

FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY | def firstElement ( arr, n, k ) :
INDENT count_map = {
};

for i in range ( 0, n ) :
INDENT if ( arr [ i ] in count_map . keys ( ) ) :
INDENT count_map [ arr [ i ] ] += 1
DEDENT else :
INDENT count_map [ arr [ i ] ] = 1
DEDENT i += 1
DEDENT for i in range ( 0, n ) :
INDENT if ( count_map [ arr [ i ] ] == k ) :
INDENT return arr [ i ]
DEDENT i += 1
DEDENT return - 1
DEDENT

SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS | def sumOfSeries ( n ) :
INDENT return ( ( 0.666 ) * ( 1 - 1 / pow ( 10, n ) ) );

DEDENT

COUNT_WORDS_IN_A_GIVEN_STRING | def countWords ( string ) :
INDENT state = OUT
wc = 0
for i in range ( len ( string ) ) :
INDENT if ( string [ i ] == ' ' or string [ i ] == '\n' or string [ i ] == '\t' ) :
INDENT state = OUT
DEDENT elif state == OUT :
INDENT state = IN
wc += 1
DEDENT DEDENT return wc
DEDENT

PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_THE_DIFFERENCE_OF_SUMS_IS_MAXIMUM | def maxDifference ( arr, N, k ) :
INDENT S = 0
S1 = 0
max_difference = 0
for i in range ( N ) :
INDENT S += arr [ i ]
DEDENT arr . sort ( reverse = True )
M = max ( k, N - k )
for i in range ( M ) :
INDENT S1 += arr [ i ]
DEDENT max_difference = S1 - ( S - S1 )
return max_difference
DEDENT

HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP | def printNos ( n ) :
INDENT if n > 0 :
INDENT printNos ( n - 1 )
print ( n, end = ' ' )
DEDENT DEDENT

GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1 | def pairsInSortedRotated ( arr, n, x ) :
INDENT for i in range ( n ) :
INDENT if arr [ i ] > arr [ i + 1 ] :
INDENT break
DEDENT DEDENT l = ( i + 1 ) % n
r = i
cnt = 0
while ( l != r ) :
INDENT if arr [ l ] + arr [ r ] == x :
INDENT cnt += 1
if l == ( r - 1 + n ) % n :
INDENT return cnt
DEDENT l = ( l + 1 ) % n
r = ( r - 1 + n ) % n
DEDENT elif arr [ l ] + arr [ r ] < x :
INDENT l = ( l + 1 ) % n
DEDENT else :
INDENT r = ( n + r - 1 ) % n
DEDENT DEDENT return cnt
DEDENT

FIND_THE_ELEMENT_THAT_APPEARS_ONCE | def getSingle ( arr, n ) :
INDENT ones = 0
twos = 0
for i in range ( n ) :
INDENT twos = twos | ( ones & arr [ i ] )
ones = ones ^ arr [ i ]
common_bit_mask = ~ ( ones & twos )
ones &= common_bit_mask
twos &= common_bit_mask
DEDENT return ones
DEDENT

CASSINIS_IDENTITY | def cassini ( n ) :
INDENT return - 1 if ( n & 1 ) else 1
DEDENT

DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION | def distributingBalls ( k, n, string ) :
INDENT a = [ 0 ] * MAX_CHAR
for i in range ( n ) :
INDENT a [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1
DEDENT for i in range ( MAX_CHAR ) :
INDENT if ( a [ i ] > k ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE | def checkCount ( arr, n, k ) :
INDENT for i in range ( n ) :
INDENT count = 0
for j in range ( n ) :
INDENT if arr [ j ] == arr [ i ] :
INDENT count += 1
DEDENT if count > 2 * k :
INDENT return False
DEDENT DEDENT DEDENT return True
DEDENT

MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L | def findMaxValue ( arr, n ) :
INDENT if n < 4 :
INDENT print ( "The array should have atlest 4 elements" )
return MIN
DEDENT table1, table2 = [ MIN ] * ( n + 1 ), [ MIN ] * n
table3, table4 = [ MIN ] * ( n - 1 ), [ MIN ] * ( n - 2 )
for i in range ( n - 1, - 1, - 1 ) :
INDENT table1 [ i ] = max ( table1 [ i + 1 ], arr [ i ] )
DEDENT for i in range ( n - 2, - 1, - 1 ) :
INDENT table2 [ i ] = max ( table2 [ i + 1 ], table1 [ i + 1 ] - arr [ i ] )
DEDENT for i in range ( n - 3, - 1, - 1 ) :
INDENT table3 [ i ] = max ( table3 [ i + 1 ], table2 [ i + 1 ] + arr [ i ] )
DEDENT for i in range ( n - 4, - 1, - 1 ) :
INDENT table4 [ i ] = max ( table4 [ i + 1 ], table3 [ i + 1 ] - arr [ i ] )
DEDENT return table4 [ 0 ]
DEDENT

COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_1 | def countNegative ( M, n, m ) :
INDENT count = 0
i = 0
j = m - 1
while j >= 0 and i < n :
INDENT if M [ i ] [ j ] < 0 :
INDENT count += ( j + 1 )
i += 1
DEDENT else :
INDENT j -= 1
DEDENT DEDENT return count
DEDENT

SORT_AN_ARRAY_OF_0S_1S_AND_2S | def sort012 ( a, arr_size ) :
INDENT lo = 0
hi = arr_size - 1
mid = 0
while mid <= hi :
INDENT if a [ mid ] == 0 :
INDENT a [ lo ], a [ mid ] = a [ mid ], a [ lo ]
lo = lo + 1
mid = mid + 1
DEDENT elif a [ mid ] == 1 :
INDENT mid = mid + 1
DEDENT else :
INDENT a [ mid ], a [ hi ] = a [ hi ], a [ mid ]
hi = hi - 1
DEDENT DEDENT DEDENT

NTH_EVEN_FIBONACCI_NUMBER | def evenFib ( n ) :
INDENT if ( n < 1 ) :
INDENT return n
DEDENT if ( n == 1 ) :
INDENT return 2
DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) )
DEDENT

NEXT_GREATER_ELEMENT | def printNGE ( arr ) :
INDENT for i in range ( 0, len ( arr ), 1 ) :
INDENT next = - 1
for j in range ( i + 1, len ( arr ), 1 ) :
INDENT if arr [ i ] < arr [ j ] :
INDENT next = arr [ j ]
break
DEDENT DEDENT print ( str ( arr [ i ] ) + " -- " + str ( next ) )
DEDENT DEDENT

CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_CIRCLE_INNER_CIRCLE | def fitOrNotFit ( R, r, x, y, rad ) :
INDENT val = math . sqrt ( math . pow ( x, 2 ) + math . pow ( y, 2 ) )
if ( val + rad <= R and val - rad >= R - r ) :
INDENT print ( "Fits\n" )
DEDENT else :
INDENT print ( "Doesn't Fit" )
DEDENT DEDENT

BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS_1 | def gcdExtended ( a, b, x, y ) :
INDENT if a == 0 :
INDENT x = 0
y = 1
return b
DEDENT x1 = 1
y1 = 1
gcd = gcdExtended ( b % a, a, x1, y1 )
x = y1 - ( b / a ) * x1
y = x1
return gcd
DEDENT

FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS | def findSmallestRange ( arr, n, k ) :
INDENT i, minval, maxval, minrange, minel, maxel, flag, minind = 0, 0, 0, 0, 0, 0, 0, 0
for i in range ( k + 1 ) :
INDENT ptr [ i ] = 0
DEDENT minrange = 10 * * 9
while ( 1 ) :
INDENT minind = - 1
minval = 10 * * 9
maxval = - 10 * * 9
flag = 0
for i in range ( k ) :
INDENT if ( ptr [ i ] == n ) :
INDENT flag = 1
break
DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) :
INDENT minind = i
minval = arr [ i ] [ ptr [ i ] ]
DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) :
INDENT maxval = arr [ i ] [ ptr [ i ] ]
DEDENT DEDENT if ( flag ) :
INDENT break
DEDENT ptr [ minind ] += 1
if ( ( maxval - minval ) < minrange ) :
INDENT minel = minval
maxel = maxval
minrange = maxel - minel
DEDENT DEDENT print ( "The smallest range is [", minel, maxel, "]" )
DEDENT

FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STATION_IS_CONNECTED_IN_ONE_DIRECTION | def minCost ( cost ) :
INDENT dist = [ 0 for i in range ( N ) ]
for i in range ( N ) :
INDENT dist [ i ] = INF
DEDENT dist [ 0 ] = 0
for i in range ( N ) :
INDENT for j in range ( i + 1, N ) :
INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) :
INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ]
DEDENT DEDENT DEDENT return dist [ N - 1 ]
DEDENT

MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1 | def middleOfThree ( a, b, c ) :
INDENT if a > b :
INDENT if ( b > c ) :
INDENT return b
DEDENT elif ( a > c ) :
INDENT return c
DEDENT else :
INDENT return a
DEDENT DEDENT else :
INDENT if ( a > c ) :
INDENT return a
DEDENT elif ( b > c ) :
INDENT return c
DEDENT else :
INDENT return b
DEDENT DEDENT DEDENT

CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT | def check ( st ) :
INDENT n = len ( st )
oddDigSum = 0
evenDigSum = 0
for i in range ( 0, n ) :
INDENT if ( i % 2 == 0 ) :
INDENT oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) )
DEDENT else :
INDENT evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) )
DEDENT DEDENT return ( ( oddDigSum - evenDigSum ) % 11 == 0 )
DEDENT

COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER | def getModulo ( n, d ) :
INDENT return ( n & ( d - 1 ) )
DEDENT

COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS | def countStrings ( n, k ) :
INDENT dp = [ [ [ 0, 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ]
dp [ 1 ] [ 0 ] [ 0 ] = 1
dp [ 1 ] [ 0 ] [ 1 ] = 1
for i in range ( 2, n + 1 ) :
INDENT for j in range ( k + 1 ) :
INDENT dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] )
dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]
if j >= 1 :
INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]
DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]
DEDENT

FINDING_K_MODULUS_ARRAY_ELEMENT | def printEqualModNumbers ( arr, n ) :
INDENT arr . sort ( );

d = arr [ n - 1 ] - arr [ 0 ];

v = [ ];

i = 1;

while ( i * i <= d ) :
INDENT if ( d % i == 0 ) :
INDENT v . append ( i );

if ( i != d / i ) :
INDENT v . append ( d / i );

DEDENT DEDENT i += 1;

DEDENT for i in range ( len ( v ) ) :
INDENT temp = arr [ 0 ] % v [ i ];

j = 1;

while ( j < n ) :
INDENT if ( arr [ j ] % v [ i ] != temp ) :
INDENT break;

DEDENT j += 1;

DEDENT if ( j == n ) :
INDENT print ( v [ i ], end = " " );

DEDENT DEDENT DEDENT

CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SPIRAL_WAY | def spiralFill ( m, n, a ) :
INDENT val = 1
k, l = 0, 0
while ( k < m and l < n ) :
INDENT for i in range ( l, n ) :
INDENT a [ k ] [ i ] = val
val += 1
DEDENT k += 1
for i in range ( k, m ) :
INDENT a [ i ] [ n - 1 ] = val
val += 1
DEDENT n -= 1
if ( k < m ) :
INDENT for i in range ( n - 1, l - 1, - 1 ) :
INDENT a [ m - 1 ] [ i ] = val
val += 1
DEDENT m -= 1
DEDENT if ( l < n ) :
INDENT for i in range ( m - 1, k - 1, - 1 ) :
INDENT a [ i ] [ l ] = val
val += 1
DEDENT l += 1
DEDENT DEDENT DEDENT

FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2 | def printRepeating ( arr, size ) :
INDENT xor = arr [ 0 ]
n = size - 2
x = 0
y = 0
for i in range ( 1, size ) :
INDENT xor ^= arr [ i ]
DEDENT for i in range ( 1, n + 1 ) :
INDENT xor ^= i
DEDENT set_bit_no = xor & ~ ( xor - 1 )
for i in range ( 0, size ) :
INDENT if ( arr [ i ] & set_bit_no ) :
INDENT x = x ^ arr [ i ]
DEDENT else :
INDENT y = y ^ arr [ i ]
DEDENT DEDENT for i in range ( 1, n + 1 ) :
INDENT if ( i & set_bit_no ) :
INDENT x = x ^ i
DEDENT else :
INDENT y = y ^ i
DEDENT DEDENT print ( "The two repeating", "elements are", y, x )
DEDENT

COUNT_POSSIBLE_WAYS_TO_CONSTRUCT_BUILDINGS | def countWays ( N ) :
INDENT if ( N == 1 ) :
INDENT return 4
DEDENT countB = 1
countS = 1
for i in range ( 2, N + 1 ) :
INDENT prev_countB = countB
prev_countS = countS
countS = prev_countB + prev_countS
countB = prev_countS
DEDENT result = countS + countB
return ( result * result )
DEDENT

ONE_LINE_FUNCTION_FOR_FACTORIAL_OF_A_NUMBER | def factorial ( n ) :
INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 );

DEDENT

CHECK_GIVEN_MATRIX_SPARSE_NOT | def isSparse ( array, m, n ) :
INDENT counter = 0
for i in range ( 0, m ) :
INDENT for j in range ( 0, n ) :
INDENT if ( array [ i ] [ j ] == 0 ) :
INDENT counter = counter + 1
DEDENT DEDENT DEDENT return ( counter > ( ( m * n ) //2))
DEDENT


DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM | def knapSack ( W, wt, val, n ) :
INDENT if n == 0 or W == 0 :
INDENT return 0
DEDENT if ( wt [ n - 1 ] > W ) :
INDENT return knapSack ( W, wt, val, n - 1 )
DEDENT else :
INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ], wt, val, n - 1 ), knapSack ( W, wt, val, n - 1 ) )
DEDENT DEDENT

FIND_SUBARRAY_LEAST_AVERAGE | def findMinAvgSubarray ( arr, n, k ) :
INDENT if ( n < k ) : return 0
res_index = 0
curr_sum = 0
for i in range ( k ) :
INDENT curr_sum += arr [ i ]
DEDENT min_sum = curr_sum
for i in range ( k, n ) :
INDENT curr_sum += arr [ i ] - arr [ i - k ]
if ( curr_sum < min_sum ) :
INDENT min_sum = curr_sum
res_index = ( i - k + 1 )
DEDENT DEDENT print ( "Subarray between [", res_index, ", ", ( res_index + k - 1 ), "] has minimum average" )
DEDENT

QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING | def query ( s, i, j ) :
INDENT n = len ( s )
i %= n
j %= n
print ( "Yes" ) if s [ i ] == s [ j ] else print ( "No" )
DEDENT

A_PRODUCT_ARRAY_PUZZLE_1 | def productArray ( arr, n ) :
INDENT if n == 1 :
INDENT print ( 0 )
return
DEDENT i, temp = 1, 1
prod = [ 1 for i in range ( n ) ]
for i in range ( n ) :
INDENT prod [ i ] = temp
temp *= arr [ i ]
DEDENT temp = 1
for i in range ( n - 1, - 1, - 1 ) :
INDENT prod [ i ] *= temp
temp *= arr [ i ]
DEDENT for i in range ( n ) :
INDENT print ( prod [ i ], end = " " )
DEDENT return
DEDENT

FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS | def pairSum ( mat, n, sum ) :
INDENT for i in range ( n ) :
INDENT mat [ i ] . sort ( )
DEDENT for i in range ( n - 1 ) :
INDENT for j in range ( i + 1, n ) :
INDENT left = 0
right = n - 1
while ( left < n and right >= 0 ) :
INDENT if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) :
INDENT print ( "(", mat [ i ] [ left ], ", ", mat [ j ] [ right ], "), ", end = " " )
left += 1
right -= 1
DEDENT else :
INDENT if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :
INDENT left += 1
DEDENT else :
INDENT right -= 1
DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT

CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES | def isRotated ( str1, str2 ) :
INDENT if ( len ( str1 ) != len ( str2 ) ) :
INDENT return False
DEDENT clock_rot = ""
anticlock_rot = ""
l = len ( str2 )
anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] )
clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ]
return ( str1 == clock_rot or str1 == anticlock_rot )
DEDENT

N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN | def findNth ( n ) :
INDENT count = 0
for curr in itertools . count ( ) :
INDENT sum = 0
x = curr
while ( x ) :
INDENT sum = sum + x % 10
x = x //10
DEDENTif(sum==10):
INDENTcount=count+1
DEDENTif(count==n):
INDENTreturncurr
DEDENTDEDENTreturn-1
DEDENT


PROGRAM_FIND_SLOPE_LINE | def slope ( x1, y1, x2, y2 ) :
INDENT return ( float ) ( y2 - y1 ) / ( x2 - x1 )
DEDENT

GCD_ELEMENTS_GIVEN_RANGE | def rangeGCD ( n, m ) :
INDENT return n if ( n == m ) else 1
DEDENT

LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARRAY_1 | def alternateSubarray ( arr, n ) :
INDENT count = 1
prev = arr [ 0 ]
for i in range ( 1, n ) :
INDENT if ( ( arr [ i ] ^ prev ) == 0 ) :
INDENT while ( count ) :
INDENT print ( count, end = " " )
count -= 1
DEDENT DEDENT count += 1
prev = arr [ i ]
DEDENT while ( count ) :
INDENT print ( count, end = " " )
count -= 1
DEDENT DEDENT

FIND_UNIT_DIGIT_X_RAISED_POWER_Y | def unitDigitXRaisedY ( x, y ) :
INDENT res = 1
for i in range ( y ) :
INDENT res = ( res * x ) % 10
DEDENT return res
DEDENT

MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO | def moduloMultiplication ( a, b, mod ) :
INDENT res = 0;

a = a % mod;

while ( b ) :
INDENT if ( b & 1 ) :
INDENT res = ( res + a ) % mod;

DEDENT a = ( 2 * a ) % mod;

b >>= 1;

DEDENT return res;

DEDENT

FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SUM | def findSmallest ( m, s ) :
INDENT if ( s == 0 ) :
INDENT if ( m == 1 ) :
INDENT print ( "Smallest number is 0" )
DEDENT else :
INDENT print ( "Not possible" )
DEDENT return
DEDENT if ( s > 9 * m ) :
INDENT print ( "Not possible" )
return
DEDENT res = [ 0 for i in range ( m + 1 ) ]
s -= 1
for i in range ( m - 1, 0, - 1 ) :
INDENT if ( s > 9 ) :
INDENT res [ i ] = 9
s -= 9
DEDENT else :
INDENT res [ i ] = s
s = 0
DEDENT DEDENT res [ 0 ] = s + 1
print ( "Smallest number is ", end = "" )
for i in range ( m ) :
INDENT print ( res [ i ], end = "" )
DEDENT DEDENT

C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY | def largest ( arr, n ) :
INDENT max = arr [ 0 ]
for i in range ( 1, n ) :
INDENT if arr [ i ] > max :
INDENT max = arr [ i ]
DEDENT DEDENT return max
DEDENT

COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS | def countNums ( n, x, y ) :
INDENT arr = [ False for i in range ( n + 2 ) ]
if ( x <= n ) :
INDENT arr [ x ] = True
DEDENT if ( y <= n ) :
INDENT arr [ y ] = True
DEDENT result = 0
for i in range ( min ( x, y ), n + 1 ) :
INDENT if ( arr [ i ] ) :
INDENT if ( i + x <= n ) :
INDENT arr [ i + x ] = True
DEDENT if ( i + y <= n ) :
INDENT arr [ i + y ] = True
DEDENT result = result + 1
DEDENT DEDENT return result
DEDENT

BUBBLE_SORT_1 | def bubbleSort ( arr ) :
INDENT n = len ( arr )
for i in range ( n ) :
INDENT swapped = False
for j in range ( 0, n - i - 1 ) :
INDENT if arr [ j ] > arr [ j + 1 ] :
INDENT arr [ j ], arr [ j + 1 ] = arr [ j + 1 ], arr [ j ]
swapped = True
DEDENT DEDENT if swapped == False :
INDENT break
DEDENT DEDENT DEDENT

MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT | def maxSum ( grid, n ) :
INDENT incl = max ( grid [ 0 ] [ 0 ], grid [ 1 ] [ 0 ] )
excl = 0
for i in range ( 1, n ) :
INDENT excl_new = max ( excl, incl )
incl = excl + max ( grid [ 0 ] [ i ], grid [ 1 ] [ i ] )
excl = excl_new
DEDENT return max ( excl, incl )
DEDENT

GCD_FACTORIALS_TWO_NUMBERS | def gcdOfFactorial ( m, n ) :
INDENT return math . factorial ( min ( m, n ) )
DEDENT

AREA_OF_A_SECTOR | def SectorArea ( radius, angle ) :
INDENT pi = 22 / 7
if angle >= 360 :
INDENT print ( "Angle not possible" )
return
DEDENT else :
INDENT sector = ( pi * radius * * 2 ) * ( angle / 360 )
print ( sector )
return
DEDENT DEDENT

COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS_1 | def countSeq ( n ) :
INDENT nCr = 1
res = 1
for r in range ( 1, n + 1 ) :
INDENT nCr = ( nCr * ( n + 1 - r ) ) / r;

res += nCr * nCr;

DEDENT return res;

DEDENT

LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1 | def findLength ( string ) :
INDENT n = len ( string )
maxlen = 0
Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]
for i in range ( 0, n ) :
INDENT Sum [ i ] [ i ] = int ( string [ i ] )
DEDENT for length in range ( 2, n + 1 ) :
INDENT for i in range ( 0, n - length + 1 ) :
INDENT j = i + length - 1
k = length //2
Sum[i][j]=(Sum[i][j-k]+Sum[j-k+1][j])
if(length%2==0andSum[i][j-k]==Sum[(j-k+1)][j]andlength>maxlen):
INDENTmaxlen=length
DEDENTDEDENTDEDENTreturnmaxlen
DEDENT


SWAP_ALL_ODD_AND_EVEN_BITS | def swapBits ( x ) :
INDENT even_bits = x & 0xAAAAAAAA
odd_bits = x & 0x55555555
even_bits >>= 1
odd_bits <<= 1
return ( even_bits | odd_bits )
DEDENT

SORT_ARRAY_WAVE_FORM_2 | def sortInWave ( arr, n ) :
INDENT arr . sort ( )
for i in range ( 0, n - 1, 2 ) :
INDENT arr [ i ], arr [ i + 1 ] = arr [ i + 1 ], arr [ i ]
DEDENT DEDENT

FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN | def compute ( a, b ) :
INDENT AM = ( a + b ) / 2
GM = math . sqrt ( a * b )
HM = ( GM * GM ) / AM
return HM
DEDENT

COUNT_BALANCED_BINARY_TREES_HEIGHT_H | def countBT ( h ) :
INDENT MOD = 1000000007
dp = [ 0 for i in range ( h + 1 ) ]
dp [ 0 ] = 1
dp [ 1 ] = 1
for i in range ( 2, h + 1 ) :
INDENT dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD
DEDENT return dp [ h ]
DEDENT

MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME_WITH_PERMUTATIONS_ALLOWED | def minInsertion ( tr1 ) :
INDENT n = len ( str1 )
res = 0
count = [ 0 for i in range ( 26 ) ]
for i in range ( n ) :
INDENT count [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1
DEDENT for i in range ( 26 ) :
INDENT if ( count [ i ] % 2 == 1 ) :
INDENT res += 1
DEDENT DEDENT if ( res == 0 ) :
INDENT return 0
DEDENT else :
INDENT return res - 1
DEDENT DEDENT

SHUFFLE_A_GIVEN_ARRAY | def randomize ( arr, n ) :
INDENT for i in range ( n - 1, 0, - 1 ) :
INDENT j = random . randint ( 0, i + 1 )
arr [ i ], arr [ j ] = arr [ j ], arr [ i ]
DEDENT return arr
DEDENT

UGLY_NUMBERS | def getNthUglyNo ( n ) :
INDENT ugly = [ 0 ] * n
ugly [ 0 ] = 1
i2 = i3 = i5 = 0
next_multiple_of_2 = 2
next_multiple_of_3 = 3
next_multiple_of_5 = 5
for l in range ( 1, n ) :
INDENT ugly [ l ] = min ( next_multiple_of_2, next_multiple_of_3, next_multiple_of_5 )
if ugly [ l ] == next_multiple_of_2 :
INDENT i2 += 1
next_multiple_of_2 = ugly [ i2 ] * 2
DEDENT if ugly [ l ] == next_multiple_of_3 :
INDENT i3 += 1
next_multiple_of_3 = ugly [ i3 ] * 3
DEDENT if ugly [ l ] == next_multiple_of_5 :
INDENT i5 += 1
next_multiple_of_5 = ugly [ i5 ] * 5
DEDENT DEDENT return ugly [ - 1 ]
DEDENT

MINIMUM_COST_CUT_BOARD_SQUARES | def minimumCostOfBreaking ( X, Y, m, n ) :
INDENT res = 0
X . sort ( reverse = True )
Y . sort ( reverse = True )
hzntl = 1;
vert = 1
i = 0;
j = 0
while ( i < m and j < n ) :
INDENT if ( X [ i ] > Y [ j ] ) :
INDENT res += X [ i ] * vert
hzntl += 1
i += 1
DEDENT else :
INDENT res += Y [ j ] * hzntl
vert += 1
j += 1
DEDENT DEDENT total = 0
while ( i < m ) :
INDENT total += X [ i ]
i += 1
DEDENT res += total * vert
total = 0
while ( j < n ) :
INDENT total += Y [ j ]
j += 1
DEDENT res += total * hzntl
return res
DEDENT

DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1 | def knapSack ( W, wt, val, n ) :
INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ]
for i in range ( n + 1 ) :
INDENT for w in range ( W + 1 ) :
INDENT if i == 0 or w == 0 :
INDENT K [ i ] [ w ] = 0
DEDENT elif wt [ i - 1 ] <= w :
INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ], K [ i - 1 ] [ w ] )
DEDENT else :
INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ]
DEDENT DEDENT DEDENT return K [ n ] [ W ]
DEDENT

STACK_PERMUTATIONS_CHECK_IF_AN_ARRAY_IS_STACK_PERMUTATION_OF_OTHER | def checkStackPermutation ( ip, op, n ) :
INDENT Input = Queue ( )
for i in range ( n ) :
INDENT Input . put ( ip [ i ] )
DEDENT output = Queue ( )
for i in range ( n ) :
INDENT output . put ( op [ i ] )
DEDENT tempStack = [ ]
while ( not Input . empty ( ) ) :
INDENT ele = Input . queue [ 0 ]
Input . get ( )
if ( ele == output . queue [ 0 ] ) :
INDENT output . get ( )
while ( len ( tempStack ) != 0 ) :
INDENT if ( tempStack [ - 1 ] == output . queue [ 0 ] ) :
INDENT tempStack . pop ( )
output . get ( )
DEDENT else :
INDENT break
DEDENT DEDENT DEDENT else :
INDENT tempStack . append ( ele )
DEDENT DEDENT return ( Input . empty ( ) and len ( tempStack ) == 0 )
DEDENT

PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP | def procal ( n ) :
INDENT return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 )
DEDENT

REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS | def simplify ( Str ) :
INDENT Len = len ( Str )
res = [ None ] * Len
index = 0
i = 0
s = [ ]
s . append ( 0 )
while ( i < Len ) :
INDENT if ( Str [ i ] == '+' ) :
INDENT if ( s [ - 1 ] == 1 ) :
INDENT res [ index ] = '-'
index += 1
DEDENT if ( s [ - 1 ] == 0 ) :
INDENT res [ index ] = '+'
index += 1
DEDENT DEDENT elif ( Str [ i ] == '-' ) :
INDENT if ( s [ - 1 ] == 1 ) :
INDENT res [ index ] = '+'
index += 1
DEDENT elif ( s [ - 1 ] == 0 ) :
INDENT res [ index ] = '-'
index += 1
DEDENT DEDENT elif ( Str [ i ] == '(' and i > 0 ) :
INDENT if ( Str [ i - 1 ] == '-' ) :
INDENT x = 0 if ( s [ - 1 ] == 1 ) else 1
s . append ( x )
DEDENT elif ( Str [ i - 1 ] == '+' ) :
INDENT s . append ( s [ - 1 ] )
DEDENT DEDENT elif ( Str [ i ] == ')' ) :
INDENT s . pop ( )
DEDENT else :
INDENT res [ index ] = Str [ i ]
index += 1
DEDENT i += 1
DEDENT return res
DEDENT

FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS | def CountSquares ( a, b ) :
INDENT cnt = 0
for i in range ( a, b + 1 ) :
INDENT j = 1;

while j * j <= i :
INDENT if j * j == i :
INDENT cnt = cnt + 1
DEDENT j = j + 1
DEDENT i = i + 1
DEDENT return cnt
DEDENT

K_NUMBERS_DIFFERENCE_MAXIMUM_MINIMUM_K_NUMBER_MINIMIZED | def minDiff ( arr, n, k ) :
INDENT result = + 2147483647
arr . sort ( )
for i in range ( n - k + 1 ) :
INDENT result = int ( min ( result, arr [ i + k - 1 ] - arr [ i ] ) )
DEDENT return result
DEDENT

CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT | def checkDivisibility ( num ) :
INDENT length = len ( num )
if ( length == 1 and num [ 0 ] == '0' ) :
INDENT return True
DEDENT if ( length % 3 == 1 ) :
INDENT num = str ( num ) + "00"
length += 2
DEDENT elif ( length % 3 == 2 ) :
INDENT num = str ( num ) + "0"
length += 1
DEDENT sum = 0
p = 1
for i in range ( length - 1, - 1, - 1 ) :
INDENT group = 0
group += ord ( num [ i ] ) - ord ( '0' )
i -= 1
group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10
i -= 1
group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100
sum = sum + group * p
p *= ( - 1 )
DEDENT sum = abs ( sum )
return ( sum % 13 == 0 )
DEDENT

GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K | def printSumSimple ( mat, k ) :
INDENT if ( k > n ) :
INDENT return
DEDENT for i in range ( n - k + 1 ) :
INDENT for j in range ( n - k + 1 ) :
INDENT sum = 0
for p in range ( i, k + i ) :
INDENT for q in range ( j, k + j ) :
INDENT sum += mat [ p ] [ q ]
DEDENT DEDENT print ( sum, end = " " )
DEDENT print ( )
DEDENT DEDENT

FIND_THE_POINT_WHERE_MAXIMUM_INTERVALS_OVERLAP_1 | def maxOverlap ( start, end ) :
INDENT n = len ( start )
maxa = max ( start )
maxb = max ( end )
maxc = max ( maxa, maxb )
x = ( maxc + 2 ) * [ 0 ]
cur = 0;
idx = 0
for i in range ( 0, n ) :
INDENT x [ start [ i ] ] += 1
x [ end [ i ] + 1 ] -= 1
DEDENT maxy = - 1
for i in range ( 0, maxc + 1 ) :
INDENT cur += x [ i ]
if maxy < cur :
INDENT maxy = cur
idx = i
DEDENT DEDENT print ( "Maximum value is: {0:d}" . format ( maxy ), " at position: {0:d}" . format ( idx ) )
DEDENT

MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1 | def maxSumWO3Consec ( n ) :
INDENT if ( sum [ n ] != - 1 ) :
INDENT return sum [ n ]
DEDENT if ( n == 0 ) :
INDENT sum [ n ] = 0
return sum [ n ]
DEDENT if ( n == 1 ) :
INDENT sum [ n ] = arr [ 0 ]
return sum [ n ]
DEDENT if ( n == 2 ) :
INDENT sum [ n ] = arr [ 1 ] + arr [ 0 ]
return sum [ n ]
DEDENT sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ), maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ), arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) )
return sum [ n ]
DEDENT

C_PROGRAM_ADDITION_TWO_MATRICES | def add ( A, B, C ) :
INDENT for i in range ( N ) :
INDENT for j in range ( N ) :
INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ]
DEDENT DEDENT DEDENT

FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1 | def findMaxAverage ( arr, n, k ) :
INDENT if ( k > n ) :
INDENT return - 1
DEDENT sum = arr [ 0 ]
for i in range ( 1, k ) :
INDENT sum += arr [ i ]
DEDENT max_sum = sum
max_end = k - 1
for i in range ( k, n ) :
INDENT sum = sum + arr [ i ] - arr [ i - k ]
if ( sum > max_sum ) :
INDENT max_sum = sum
max_end = i
DEDENT DEDENT return max_end - k + 1
DEDENT

FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER | def center ( x1, x2, y1, y2 ) :
INDENT print ( int ( ( x1 + x2 ) / 2 ), end = "" )
print ( ",", int ( ( y1 + y2 ) / 2 ) )
DEDENT

TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS | def countNonDecreasing ( n ) :
INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ]
for i in range ( 10 ) :
INDENT dp [ i ] [ 1 ] = 1
DEDENT for digit in range ( 10 ) :
INDENT for len in range ( 2, n + 1 ) :
INDENT for x in range ( digit + 1 ) :
INDENT dp [ digit ] [ len ] += dp [ x ] [ len - 1 ]
DEDENT DEDENT DEDENT count = 0
for i in range ( 10 ) :
INDENT count += dp [ i ] [ n ]
DEDENT return count
DEDENT

PRINT_REVERSE_STRING_REMOVING_VOWELS | def replaceOriginal ( s, n ) :
INDENT r = [ ' ' ] * n
for i in range ( n ) :
INDENT r [ i ] = s [ n - 1 - i ]
if ( s [ i ] != 'a' and s [ i ] != 'e' and s [ i ] != 'i' and s [ i ] != 'o' and s [ i ] != 'u' ) :
INDENT print ( r [ i ], end = "" )
DEDENT DEDENT print ( )
DEDENT

FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1 | def findMissing ( a, b, n, m ) :
INDENT s = dict ( )
for i in range ( m ) :
INDENT s [ b [ i ] ] = 1
DEDENT for i in range ( n ) :
INDENT if a [ i ] not in s . keys ( ) :
INDENT print ( a [ i ], end = " " )
DEDENT DEDENT DEDENT

COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS | def countStr ( n, bCount, cCount ) :
INDENT if ( bCount < 0 or cCount < 0 ) :
INDENT return 0
DEDENT if ( n == 0 ) :
INDENT return 1
DEDENT if ( bCount == 0 and cCount == 0 ) :
INDENT return 1
DEDENT res = countStr ( n - 1, bCount, cCount )
res += countStr ( n - 1, bCount - 1, cCount )
res += countStr ( n - 1, bCount, cCount - 1 )
return res
DEDENT

GOLD_MINE_PROBLEM | def getMaxGold ( gold, m, n ) :
INDENT goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ]
for col in range ( n - 1, - 1, - 1 ) :
INDENT for row in range ( m ) :
INDENT if ( col == n - 1 ) :
INDENT right = 0
DEDENT else :
INDENT right = goldTable [ row ] [ col + 1 ]
DEDENT if ( row == 0 or col == n - 1 ) :
INDENT right_up = 0
DEDENT else :
INDENT right_up = goldTable [ row - 1 ] [ col + 1 ]
DEDENT if ( row == m - 1 or col == n - 1 ) :
INDENT right_down = 0
DEDENT else :
INDENT right_down = goldTable [ row + 1 ] [ col + 1 ]
DEDENT goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right, right_up, right_down )
DEDENT DEDENT res = goldTable [ 0 ] [ 0 ]
for i in range ( 1, m ) :
INDENT res = max ( res, goldTable [ i ] [ 0 ] )
DEDENT return res
DEDENT

COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS | def countWays ( n ) :
INDENT dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ]
dp [ 0 ] [ 1 ] = 1
dp [ 1 ] [ 1 ] = 2
for i in range ( 2, n + 1 ) :
INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ]
dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] )
DEDENT return dp [ 0 ] [ n ] + dp [ 1 ] [ n ]
DEDENT

RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1 | def maxProduct ( arr, n ) :
INDENT if ( n < 2 ) :
INDENT print ( "No pairs exists" )
return
DEDENT if ( n == 2 ) :
INDENT print ( arr [ 0 ], " ", arr [ 1 ] )
return
DEDENT posa = 0
posb = 0
nega = 0
negb = 0
for i in range ( n ) :
INDENT if ( arr [ i ] > posa ) :
INDENT posb = posa
posa = arr [ i ]
DEDENT elif ( arr [ i ] > posb ) :
INDENT posb = arr [ i ]
DEDENT if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) ) :
INDENT negb = nega
nega = arr [ i ]
DEDENT elif ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb ) ) :
INDENT negb = arr [ i ]
DEDENT DEDENT if ( nega * negb > posa * posb ) :
INDENT print ( "Max product pair is {", nega, ", ", negb, "}" )
DEDENT else :
INDENT print ( "Max product pair is {", posa, ", ", posb, "}" )
DEDENT DEDENT

POSITION_OF_RIGHTMOST_SET_BIT | def getFirstSetBitPos ( n ) :
INDENT return math . log2 ( n & - n ) + 1
DEDENT

LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_TIMES | def longestSubseqWithK ( str, k ) :
INDENT n = len ( str )
freq = [ 0 ] * MAX_CHARS
for i in range ( n ) :
INDENT freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1
DEDENT for i in range ( n ) :
INDENT if ( freq [ ord ( str [ i ] ) - ord ( 'a' ) ] >= k ) :
INDENT print ( str [ i ], end = "" )
DEDENT DEDENT DEDENT

POSSIBLE_TO_MAKE_A_DIVISIBLE_BY_3_NUMBER_USING_ALL_DIGITS_IN_AN_ARRAY | def isPossibleToMakeDivisible ( arr, n ) :
INDENT remainder = 0
for i in range ( 0, n ) :
INDENT remainder = ( remainder + arr [ i ] ) % 3
DEDENT return ( remainder == 0 )
DEDENT

AREA_SQUARE_CIRCUMSCRIBED_CIRCLE | def find_Area ( r ) :
INDENT return ( 2 * r * r )
DEDENT

FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S | def MaxDotProduct ( A, B, m, n ) :
INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ]
for i in range ( 1, n + 1, 1 ) :
INDENT for j in range ( i, m + 1, 1 ) :
INDENT dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ), dp [ i ] [ j - 1 ] )
DEDENT DEDENT return dp [ n ] [ m ]
DEDENT

FIND_DISTINCT_SUBSET_SUBSEQUENCE_SUMS_ARRAY | def printDistSum ( arr, n ) :
INDENT Sum = sum ( arr )
dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ]
for i in range ( n + 1 ) :
INDENT dp [ i ] [ 0 ] = True
DEDENT for i in range ( 1, n + 1 ) :
INDENT dp [ i ] [ arr [ i - 1 ] ] = True
for j in range ( 1, Sum + 1 ) :
INDENT if ( dp [ i - 1 ] [ j ] == True ) :
INDENT dp [ i ] [ j ] = True
dp [ i ] [ j + arr [ i - 1 ] ] = True
DEDENT DEDENT DEDENT for j in range ( Sum + 1 ) :
INDENT if ( dp [ n ] [ j ] == True ) :
INDENT print ( j, end = " " )
DEDENT DEDENT DEDENT

SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING | def splitString ( str ) :
INDENT alpha = ""
num = ""
special = ""
for i in range ( len ( str ) ) :
INDENT if ( str [ i ] . isdigit ( ) ) :
INDENT num = num + str [ i ]
DEDENT elif ( ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) or ( str [ i ] >= 'a' and str [ i ] <= 'z' ) ) :
INDENT alpha += str [ i ]
DEDENT else :
INDENT special += str [ i ]
DEDENT DEDENT print ( alpha )
print ( num )
print ( special )
DEDENT

MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM | def maxAlternateSum ( arr, n ) :
INDENT if ( n == 1 ) :
INDENT return arr [ 0 ]
DEDENT dec = [ 0 for i in range ( n + 1 ) ]
inc = [ 0 for i in range ( n + 1 ) ]
dec [ 0 ] = inc [ 0 ] = arr [ 0 ]
flag = 0
for i in range ( 1, n ) :
INDENT for j in range ( i ) :
INDENT if ( arr [ j ] > arr [ i ] ) :
INDENT dec [ i ] = max ( dec [ i ], inc [ j ] + arr [ i ] )
flag = 1
DEDENT elif ( arr [ j ] < arr [ i ] and flag == 1 ) :
INDENT inc [ i ] = max ( inc [ i ], dec [ j ] + arr [ i ] )
DEDENT DEDENT DEDENT result = - 2147483648
for i in range ( n ) :
INDENT if ( result < inc [ i ] ) :
INDENT result = inc [ i ]
DEDENT if ( result < dec [ i ] ) :
INDENT result = dec [ i ]
DEDENT DEDENT return result
DEDENT

FIND_PAIR_MAXIMUM_GCD_ARRAY | def findMaxGCD ( arr, n ) :
INDENT high = 0
i = 0
while i < n :
INDENT high = max ( high, arr [ i ] )
i = i + 1
DEDENT divisors = [ 0 ] * ( high + 1 )
i = 0
while i < n :
INDENT j = 1
while j <= math . sqrt ( arr [ i ] ) :
INDENT if ( arr [ i ] % j == 0 ) :
INDENT divisors [ j ] = divisors [ j ] + 1
if ( j != arr [ i ] / j ) :
INDENT divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ]
INDENT + 1
DEDENT DEDENT DEDENT j = j + 1
DEDENT i = i + 1
DEDENT i = high
while i >= 1 :
INDENT if ( divisors [ i ] > 1 ) :
INDENT return i
DEDENT i = i - 1
DEDENT return 1
DEDENT

FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1 | def minCoins ( coins, m, V ) :
INDENT table = [ 0 for i in range ( V + 1 ) ]
table [ 0 ] = 0
for i in range ( 1, V + 1 ) :
INDENT table [ i ] = sys . maxsize
DEDENT for i in range ( 1, V + 1 ) :
INDENT for j in range ( m ) :
INDENT if ( coins [ j ] <= i ) :
INDENT sub_res = table [ i - coins [ j ] ]
if ( sub_res != sys . maxsize and sub_res + 1 < table [ i ] ) :
INDENT table [ i ] = sub_res + 1
DEDENT DEDENT DEDENT DEDENT return table [ V ]
DEDENT

SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING | def sumAtKthLevel ( tree, k ) :
INDENT level = - 1
sum = 0
n = len ( tree )
for i in range ( n ) :
INDENT if ( tree [ i ] == '(' ) :
INDENT level += 1
DEDENT elif ( tree [ i ] == ')' ) :
INDENT level -= 1
DEDENT else :
INDENT if ( level == k ) :
INDENT sum += ( ord ( tree [ i ] ) - ord ( '0' ) )
DEDENT DEDENT DEDENT return sum
DEDENT

DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE | def lcs ( X, Y, m, n ) :
INDENT if m == 0 or n == 0 :
INDENT return 0;

DEDENT elif X [ m - 1 ] == Y [ n - 1 ] :
INDENT return 1 + lcs ( X, Y, m - 1, n - 1 );

DEDENT else :
INDENT return max ( lcs ( X, Y, m, n - 1 ), lcs ( X, Y, m - 1, n ) );

DEDENT DEDENT

CHECK_GIVEN_SENTENCE_GIVEN_SET_SIMPLE_GRAMMER_RULES | def checkSentence ( string ) :
INDENT length = len ( string )
if string [ 0 ] < 'A' or string [ 0 ] > 'Z' :
INDENT return False
DEDENT if string [ length - 1 ] != '.' :
INDENT return False
DEDENT prev_state = 0
curr_state = 0
index = 1
while ( string [ index ] ) :
INDENT if string [ index ] >= 'A' and string [ index ] <= 'Z' :
INDENT curr_state = 0
DEDENT elif string [ index ] == ' ' :
INDENT curr_state = 1
DEDENT elif string [ index ] >= 'a' and string [ index ] <= 'z' :
INDENT curr_state = 2
DEDENT elif string [ index ] == '.' :
INDENT curr_state = 3
DEDENT if prev_state == curr_state and curr_state != 2 :
INDENT return False
DEDENT if prev_state == 2 and curr_state == 0 :
INDENT return False
DEDENT if curr_state == 3 and prev_state != 1 :
INDENT return True
DEDENT index += 1
prev_state = curr_state
DEDENT return False
DEDENT

CHECK_DIVISIBILITY_LARGE_NUMBER_999 | def isDivisible999 ( num ) :
INDENT n = len ( num );

if ( n == 0 or num [ 0 ] == '0' ) :
INDENT return true
DEDENT if ( ( n % 3 ) == 1 ) :
INDENT num = "00" + num
DEDENT if ( ( n % 3 ) == 2 ) :
INDENT num = "0" + num
DEDENT gSum = 0
for i in range ( 0, n, 3 ) :
INDENT group = 0
group += ( ord ( num [ i ] ) - 48 ) * 100
group += ( ord ( num [ i + 1 ] ) - 48 ) * 10
group += ( ord ( num [ i + 2 ] ) - 48 )
gSum += group
DEDENT if ( gSum > 1000 ) :
INDENT num = str ( gSum )
n = len ( num )
gSum = isDivisible999 ( num )
DEDENT return ( gSum == 999 )
DEDENT

CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT | def check ( st ) :
INDENT n = len ( st )
digitSum = 0
for i in range ( 0, n ) :
INDENT digitSum = digitSum + ( int ) ( st [ i ] )
DEDENT return ( digitSum % 9 == 0 )
DEDENT

NUMBER_OF_BINARY_TREES_FOR_GIVEN_PREORDER_SEQUENCE_LENGTH | def countTrees ( n ) :
INDENT BT = [ 0 ] * ( n + 1 )
BT [ 0 ] = BT [ 1 ] = 1
for i in range ( 2, n + 1 ) :
INDENT for j in range ( i ) :
INDENT BT [ i ] += BT [ j ] * BT [ i - j - 1 ]
DEDENT DEDENT return BT [ n ]
DEDENT

PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_MATRIX | def swapUpperToLower ( arr ) :
INDENT n = 4;

for i in range ( 0, n ) :
INDENT for j in range ( i + 1, n ) :
INDENT temp = arr [ i ] [ j ];

arr [ i ] [ j ] = arr [ j ] [ i ];

arr [ j ] [ i ] = temp;

DEDENT DEDENT for i in range ( 0, n ) :
INDENT for j in range ( 0, n ) :
INDENT print ( arr [ i ] [ j ], end = " " );

DEDENT print ( " " );

DEDENT DEDENT

FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER_1 | def findSum ( N, K ) :
INDENT ans = 0;

y = N / K;

x = N % K;

ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 );

return int ( ans );

DEDENT

WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO | def xorZero ( str ) :
INDENT one_count = 0
zero_count = 0
n = len ( str )
for i in range ( 0, n, 1 ) :
INDENT if ( str [ i ] == '1' ) :
INDENT one_count += 1
DEDENT else :
INDENT zero_count += 1
DEDENT DEDENT if ( one_count % 2 == 0 ) :
INDENT return zero_count
DEDENT return one_count
DEDENT

DYNAMIC_PROGRAMMING_SET_7_COIN_CHANGE | def count ( S, m, n ) :
INDENT if ( n == 0 ) :
INDENT return 1
DEDENT if ( n < 0 ) :
INDENT return 0;

DEDENT if ( m <= 0 and n >= 1 ) :
INDENT return 0
DEDENT return count ( S, m - 1, n ) + count ( S, m, n - S [ m - 1 ] );

DEDENT

MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED | def minSum ( arr, n ) :
INDENT dp = [ 0 ] * n
if ( n == 1 ) :
INDENT return arr [ 0 ]
DEDENT if ( n == 2 ) :
INDENT return min ( arr [ 0 ], arr [ 1 ] )
DEDENT if ( n == 3 ) :
INDENT return min ( arr [ 0 ], min ( arr [ 1 ], arr [ 2 ] ) )
DEDENT if ( n == 4 ) :
INDENT return min ( min ( arr [ 0 ], arr [ 1 ] ), min ( arr [ 2 ], arr [ 3 ] ) )
DEDENT dp [ 0 ] = arr [ 0 ]
dp [ 1 ] = arr [ 1 ]
dp [ 2 ] = arr [ 2 ]
dp [ 3 ] = arr [ 3 ]
for i in range ( 4, n ) :
INDENT dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ], dp [ i - 2 ] ), min ( dp [ i - 3 ], dp [ i - 4 ] ) )
DEDENT return min ( min ( dp [ n - 1 ], dp [ n - 2 ] ), min ( dp [ n - 4 ], dp [ n - 3 ] ) )
DEDENT

MAXIMUM_PATH_SUM_TRIANGLE | def maxPathSum ( tri, m, n ) :
INDENT for i in range ( m - 1, - 1, - 1 ) :
INDENT for j in range ( i + 1 ) :
INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) :
INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ]
DEDENT else :
INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ]
DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ]
DEDENT

FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K | def findTriplet ( a1, a2, a3, n1, n2, n3, sum ) :
INDENT for i in range ( 0, n1 ) :
INDENT for j in range ( 0, n2 ) :
INDENT for k in range ( 0, n3 ) :
INDENT if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) :
INDENT return True
DEDENT DEDENT DEDENT DEDENT return False
DEDENT

TAIL_RECURSION_FIBONACCI | def fib ( n, a = 0, b = 1 ) :
INDENT if n == 0 :
INDENT return a
DEDENT if n == 1 :
INDENT return b
DEDENT return fib ( n - 1, b, a + b );

DEDENT

PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DIFFERENT | def isLucky ( n ) :
INDENT ar = [ 0 ] * 10
while ( n > 0 ) :
INDENT digit = math . floor ( n % 10 )
if ( ar [ digit ] ) :
INDENT return 0
DEDENT ar [ digit ] = 1
n = n / 10
DEDENT return 1
DEDENT

GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K_1 | def printSumTricky ( mat, k ) :
INDENT global n
if k > n :
INDENT return
DEDENT stripSum = [ [ None ] * n for i in range ( n ) ]
for j in range ( n ) :
INDENT Sum = 0
for i in range ( k ) :
INDENT Sum += mat [ i ] [ j ]
DEDENT stripSum [ 0 ] [ j ] = Sum
for i in range ( 1, n - k + 1 ) :
INDENT Sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] )
stripSum [ i ] [ j ] = Sum
DEDENT DEDENT for i in range ( n - k + 1 ) :
INDENT Sum = 0
for j in range ( k ) :
INDENT Sum += stripSum [ i ] [ j ]
DEDENT print ( Sum, end = " " )
for j in range ( 1, n - k + 1 ) :
INDENT Sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] )
print ( Sum, end = " " )
DEDENT print ( )
DEDENT DEDENT

SCHEDULE_ELEVATOR_TO_REDUCE_THE_TOTAL_TIME_TAKEN | def minTime ( n, k, a ) :
INDENT a . sort ( reverse = True );

minTime = 0;

for i in range ( 0, n, k ) :
INDENT minTime += ( 2 * a [ i ] );

DEDENT return minTime;

DEDENT

ODD_EVEN_SORT_BRICK_SORT | def oddEvenSort ( arr, n ) :
INDENT isSorted = 0
while isSorted == 0 :
INDENT isSorted = 1
temp = 0
for i in range ( 1, n - 1, 2 ) :
INDENT if arr [ i ] > arr [ i + 1 ] :
INDENT arr [ i ], arr [ i + 1 ] = arr [ i + 1 ], arr [ i ]
isSorted = 0
DEDENT DEDENT for i in range ( 0, n - 1, 2 ) :
INDENT if arr [ i ] > arr [ i + 1 ] :
INDENT arr [ i ], arr [ i + 1 ] = arr [ i + 1 ], arr [ i ]
isSorted = 0
DEDENT DEDENT DEDENT return
DEDENT

RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING | def getMaxOccuringChar ( str ) :
INDENT count = [ 0 ] * ASCII_SIZE
max = - 1
c = ''
for i in str :
INDENT count [ ord ( i ) ] += 1;

DEDENT for i in str :
INDENT if max < count [ ord ( i ) ] :
INDENT max = count [ ord ( i ) ]
c = i
DEDENT DEDENT return c
DEDENT

COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B | def CountPairs ( n ) :
INDENT k = n
imin = 1
ans = 0
while ( imin <= n ) :
INDENT imax = n / k
ans += k * ( imax - imin + 1 )
imin = imax + 1
k = n / imin
DEDENT return ans
DEDENT

K_TH_DISTINCT_OR_NON_REPEATING_ELEMENT_IN_AN_ARRAY_1 | def printKDistinct ( arr, size, KthIndex ) :
INDENT dict = {
}

vect = [ ]
for i in range ( size ) :
INDENT if ( arr [ i ] in dict ) :
INDENT dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1
DEDENT else :
INDENT dict [ arr [ i ] ] = 1
DEDENT DEDENT for i in range ( size ) :
INDENT if ( dict [ arr [ i ] ] > 1 ) :
INDENT continue
DEDENT else :
INDENT KthIndex = KthIndex - 1
DEDENT if ( KthIndex == 0 ) :
INDENT return arr [ i ]
DEDENT DEDENT return - 1
DEDENT

GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS | def generate ( ones, zeroes, str, len1 ) :
INDENT if ( len1 == len ( str ) ) :
INDENT print ( str, end = " " )
return
DEDENT generate ( ones + 1, zeroes, str + "1", len1 )
if ( ones > zeroes ) :
INDENT generate ( ones, zeroes + 1, str + "0", len1 )
DEDENT DEDENT

SEARCH_INSERT_AND_DELETE_IN_AN_UNSORTED_ARRAY | def findElement ( arr, n, key ) :
INDENT for i in range ( n ) :
INDENT if ( arr [ i ] == key ) :
INDENT return i
DEDENT DEDENT return - 1
DEDENT

LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS | def lcsOf3 ( X, Y, Z, m, n, o ) :
INDENT L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ]
for i in range ( m + 1 ) :
INDENT for j in range ( n + 1 ) :
INDENT for k in range ( o + 1 ) :
INDENT if ( i == 0 or j == 0 or k == 0 ) :
INDENT L [ i ] [ j ] [ k ] = 0
DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) :
INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1
DEDENT else :
INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ], L [ i ] [ j - 1 ] [ k ] ), L [ i ] [ j ] [ k - 1 ] )
DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ]
DEDENT

MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT | def maxSumSubarrayRemovingOneEle ( arr, n ) :
INDENT fw = [ 0 for k in range ( n ) ]
bw = [ 0 for k in range ( n ) ]
cur_max, max_so_far = arr [ 0 ], arr [ 0 ]
for i in range ( n ) :
INDENT cur_max = max ( arr [ i ], cur_max + arr [ i ] )
max_so_far = max ( max_so_far, cur_max )
fw [ i ] = cur_max
DEDENT cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ]
i = n - 2
while i >= 0 :
INDENT cur_max = max ( arr [ i ], cur_max + arr [ i ] )
max_so_far = max ( max_so_far, cur_max )
bw [ i ] = cur_max
i -= 1
DEDENT fans = max_so_far
for i in range ( 1, n - 1 ) :
INDENT fans = max ( fans, fw [ i - 1 ] + bw [ i + 1 ] )
DEDENT return fans
DEDENT

COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES | def countWays ( n, m ) :
INDENT count = [ ]
for i in range ( n + 2 ) :
INDENT count . append ( 0 )
DEDENT count [ 0 ] = 0
for i in range ( 1, n + 1 ) :
INDENT if ( i > m ) :
INDENT count [ i ] = count [ i - 1 ] + count [ i - m ]
DEDENT elif ( i < m ) :
INDENT count [ i ] = 1
DEDENT else :
INDENT count [ i ] = 2
DEDENT DEDENT return count [ n ]
DEDENT

MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS | def middleOfThree ( a, b, c ) :
INDENT if ( ( a < b and b < c ) or ( c < b and b < a ) ) :
INDENT return b;

DEDENT if ( ( b < a and a < c ) or ( c < a and a < b ) ) :
INDENT return a;

DEDENT else :
INDENT return c
DEDENT DEDENT

LONGEST_COMMON_INCREASING_SUBSEQUENCE_LCS_LIS | def LCIS ( arr1, n, arr2, m ) :
INDENT table = [ 0 ] * m
for j in range ( m ) :
INDENT table [ j ] = 0
DEDENT for i in range ( n ) :
INDENT current = 0
for j in range ( m ) :
INDENT if ( arr1 [ i ] == arr2 [ j ] ) :
INDENT if ( current + 1 > table [ j ] ) :
INDENT table [ j ] = current + 1
DEDENT DEDENT if ( arr1 [ i ] > arr2 [ j ] ) :
INDENT if ( table [ j ] > current ) :
INDENT current = table [ j ]
DEDENT DEDENT DEDENT DEDENT result = 0
for i in range ( m ) :
INDENT if ( table [ i ] > result ) :
INDENT result = table [ i ]
DEDENT DEDENT return result
DEDENT

MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE | def maxSumWO3Consec ( arr, n ) :
INDENT sum = [ 0 for k in range ( n ) ]
if n >= 1 :
INDENT sum [ 0 ] = arr [ 0 ]
DEDENT if n >= 2 :
INDENT sum [ 1 ] = arr [ 0 ] + arr [ 1 ]
DEDENT if n > 2 :
INDENT sum [ 2 ] = max ( sum [ 1 ], max ( arr [ 1 ] + arr [ 2 ], arr [ 0 ] + arr [ 2 ] ) )
DEDENT for i in range ( 3, n ) :
INDENT sum [ i ] = max ( max ( sum [ i - 1 ], sum [ i - 2 ] + arr [ i ] ), arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] )
DEDENT return sum [ n - 1 ]
DEDENT

EULERIAN_NUMBER_1 | def eulerian ( n, m ) :
INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]
for i in range ( 1, n + 1 ) :
INDENT for j in range ( 0, m + 1 ) :
INDENT if ( i > j ) :
INDENT if ( j == 0 ) :
INDENT dp [ i ] [ j ] = 1
DEDENT else :
INDENT dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) )
DEDENT DEDENT DEDENT DEDENT return dp [ n ] [ m ]
DEDENT

DOUBLE_FACTORIAL | def doublefactorial ( n ) :
INDENT if ( n == 0 or n == 1 ) :
INDENT return 1;

DEDENT return n * doublefactorial ( n - 2 );

DEDENT

REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH | def rearrange ( arr, n ) :
INDENT i = - 1
for j in range ( n ) :
INDENT if ( arr [ j ] < 0 ) :
INDENT i += 1
arr [ i ], arr [ j ] = arr [ j ], arr [ i ]
DEDENT DEDENT pos, neg = i + 1, 0
while ( pos < n and neg < pos and arr [ neg ] < 0 ) :
INDENT arr [ neg ], arr [ pos ] = arr [ pos ], arr [ neg ]
pos += 1
neg += 2
DEDENT DEDENT

MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS | def maximumSum ( arr, n, k ) :
INDENT for i in range ( 1, k + 1 ) :
INDENT min = + 2147483647
index = - 1
for j in range ( n ) :
INDENT if ( arr [ j ] < min ) :
INDENT min = arr [ j ]
index = j
DEDENT DEDENT if ( min == 0 ) :
INDENT break
DEDENT arr [ index ] = - arr [ index ]
DEDENT sum = 0
for i in range ( n ) :
INDENT sum += arr [ i ]
DEDENT return sum
DEDENT

MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ELEMENT_AFTER_PREFIX_IS_MUST | def pre_compute ( a, n, index, k ) :
INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]
for i in range ( n ) :
INDENT if a [ i ] > a [ 0 ] :
INDENT dp [ 0 ] [ i ] = a [ i ] + a [ 0 ]
DEDENT else :
INDENT dp [ 0 ] [ i ] = a [ i ]
DEDENT DEDENT for i in range ( 1, n ) :
INDENT for j in range ( n ) :
INDENT if a [ j ] > a [ i ] and j > i :
INDENT if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] :
INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ]
DEDENT else :
INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ]
DEDENT DEDENT else :
INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ]
DEDENT DEDENT DEDENT return dp [ index ] [ k ]
DEDENT

FUNCTION_COPY_STRING_ITERATIVE_RECURSIVE | def myCopy ( s1, s2 ) :
INDENT for i in range ( len ( s1 ) ) :
INDENT s2 [ i ] = s1 [ i ];

DEDENT DEDENT

GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND_1 | def isSubSequence ( str1, str2, m, n ) :
INDENT j = 0
i = 0
while j < m and i < n :
INDENT if str1 [ j ] == str2 [ i ] :
INDENT j = j + 1
DEDENT i = i + 1
DEDENT return j == m
DEDENT

FIND_UNIT_DIGIT_X_RAISED_POWER_Y_1 | def unitnumber ( x, y ) :
INDENT x = x % 10
if y != 0 :
INDENT y = y % 4 + 4
DEDENT return ( ( ( int ) ( math . pow ( x, y ) ) ) % 10 )
DEDENT

PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT | def NextFit ( blockSize, m, processSize, n ) :
INDENT allocation = [ - 1 ] * n
j = 0
for i in range ( n ) :
INDENT while j < m :
INDENT if blockSize [ j ] >= processSize [ i ] :
INDENT allocation [ i ] = j
blockSize [ j ] -= processSize [ i ]
break
DEDENT j = ( j + 1 ) % m
DEDENT DEDENT print ( "Process No. Process Size Block no." )
for i in range ( n ) :
INDENT print ( i + 1, "         ", processSize [ i ], end = "     " )
if allocation [ i ] != - 1 :
INDENT print ( allocation [ i ] + 1 )
DEDENT else :
INDENT print ( "Not Allocated" )
DEDENT DEDENT DEDENT

NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL_TO_VALUE | def nobleInteger ( arr, size ) :
INDENT for i in range ( 0, size ) :
INDENT count = 0
for j in range ( 0, size ) :
INDENT if ( arr [ i ] < arr [ j ] ) :
INDENT count += 1
DEDENT DEDENT if ( count == arr [ i ] ) :
INDENT return arr [ i ]
DEDENT DEDENT return - 1
DEDENT

MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC | def minimumflip ( mat, n ) :
INDENT transpose = [ [ 0 ] * n ] * n
for i in range ( n ) :
INDENT for j in range ( n ) :
INDENT transpose [ i ] [ j ] = mat [ j ] [ i ]
DEDENT DEDENT flip = 0
for i in range ( n ) :
INDENT for j in range ( n ) :
INDENT if transpose [ i ] [ j ] != mat [ i ] [ j ] :
INDENT flip += 1
DEDENT DEDENT DEDENT return int ( flip / 2 )
DEDENT

SEGREGATE_EVEN_ODD_NUMBERS_SET_3 | def arrayEvenAndOdd ( arr, n ) :
INDENT i = - 1
j = 0
while ( j != n ) :
INDENT if ( arr [ j ] % 2 == 0 ) :
INDENT i = i + 1
arr [ i ], arr [ j ] = arr [ j ], arr [ i ]
DEDENT j = j + 1
DEDENT for i in arr :
INDENT print ( str ( i ) + " ", end = '' )
DEDENT DEDENT

DFS_N_ARY_TREE_ACYCLIC_GRAPH_REPRESENTED_ADJACENCY_LIST | def dfs ( List, node, arrival ) :
INDENT print ( node )
for i in range ( len ( List [ node ] ) ) :
INDENT if ( List [ node ] [ i ] != arrival ) :
INDENT dfs ( List, List [ node ] [ i ], node )
DEDENT DEDENT DEDENT

HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER | def turnOffK ( n, k ) :
INDENT if ( k <= 0 ) :
INDENT return n
DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) )
DEDENT

NUMBER_SUBSTRINGS_DIVISIBLE_8_NOT_3 | def count ( s, Len ) :
INDENT global MAX
cur = 0
dig = 0
Sum = [ 0 ] * MAX
dp = [ [ 0, 0, 0 ] for i in range ( MAX ) ]
dp [ 0 ] [ 0 ] = 1
for i in range ( 1, Len + 1 ) :
INDENT dig = int ( s [ i - 1 ] ) - 48
cur += dig
cur %= 3
Sum [ i ] = cur
dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]
dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ]
dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ]
dp [ i ] [ Sum [ i ] ] += 1
DEDENT ans = 0
dprev = 0
value = 0
dprev2 = 0
for i in range ( 1, Len + 1 ) :
INDENT dig = int ( s [ i - 1 ] ) - 48
if dig == 8 :
INDENT ans += 1
DEDENT if i - 2 >= 0 :
INDENT dprev = int ( s [ i - 2 ] ) - 48
value = dprev * 10 + dig
if ( value % 8 == 0 ) and ( value % 3 != 0 ) :
INDENT ans += 1
DEDENT DEDENT if i - 3 >= 0 :
INDENT dprev2 = int ( s [ i - 3 ] ) - 48
dprev = int ( s [ i - 2 ] ) - 48
value = ( dprev2 * 100 + dprev * 10 + dig )
if value % 8 != 0 :
INDENT continue
DEDENT ans += ( i - 2 )
ans -= ( dp [ i - 3 ] [ Sum [ i ] ] )
DEDENT DEDENT return ans
DEDENT

ADD_1_TO_A_GIVEN_NUMBER_1 | def addOne ( x ) :
INDENT return ( - ( ~ x ) );

DEDENT

CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT | def isAnBn ( str ) :
INDENT n = len ( str )
for i in range ( n ) :
INDENT if ( str [ i ] != 'a' ) :
INDENT break
DEDENT DEDENT if ( i * 2 != n ) :
INDENT return False
DEDENT for j in range ( i, n ) :
INDENT if ( str [ j ] != 'b' ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS | def printFirstRepeating ( arr, n ) :
INDENT Min = - 1
myset = dict ( )
for i in range ( n - 1, - 1, - 1 ) :
INDENT if arr [ i ] in myset . keys ( ) :
INDENT Min = i
DEDENT else :
INDENT myset [ arr [ i ] ] = 1
DEDENT DEDENT if ( Min != - 1 ) :
INDENT print ( "The first repeating element is", arr [ Min ] )
DEDENT else :
INDENT print ( "There are no repeating elements" )
DEDENT DEDENT

COST_BALANCE_PARANTHESES | def costToBalance ( s ) :
INDENT if ( len ( s ) == 0 ) :
INDENT print ( 0 )
DEDENT ans = 0
o = 0
c = 0
for i in range ( len ( s ) ) :
INDENT if ( s [ i ] == '(' ) :
INDENT o += 1
DEDENT if ( s [ i ] == ')' ) :
INDENT c += 1
DEDENT DEDENT if ( o != c ) :
INDENT return - 1
DEDENT a = [ 0 for i in range ( len ( s ) ) ]
if ( s [ 0 ] == '(' ) :
INDENT a [ 0 ] = 1
DEDENT else :
INDENT a [ 0 ] = - 1
DEDENT if ( a [ 0 ] < 0 ) :
INDENT ans += abs ( a [ 0 ] )
DEDENT for i in range ( 1, len ( s ) ) :
INDENT if ( s [ i ] == '(' ) :
INDENT a [ i ] = a [ i - 1 ] + 1
DEDENT else :
INDENT a [ i ] = a [ i - 1 ] - 1
DEDENT if ( a [ i ] < 0 ) :
INDENT ans += abs ( a [ i ] )
DEDENT DEDENT return ans
DEDENT

COIN_GAME_WINNER_EVERY_PLAYER_THREE_CHOICES | def findWinner ( x, y, n ) :
INDENT dp = [ 0 for i in range ( n + 1 ) ]
dp [ 0 ] = False
dp [ 1 ] = True
for i in range ( 2, n + 1 ) :
INDENT if ( i - 1 >= 0 and not dp [ i - 1 ] ) :
INDENT dp [ i ] = True
DEDENT elif ( i - x >= 0 and not dp [ i - x ] ) :
INDENT dp [ i ] = True
DEDENT elif ( i - y >= 0 and not dp [ i - y ] ) :
INDENT dp [ i ] = True
DEDENT else :
INDENT dp [ i ] = False
DEDENT DEDENT return dp [ n ]
DEDENT

SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS | def getTotalNumberOfSequences ( m, n ) :
INDENT if m < n :
INDENT return 0
DEDENT if n == 0 :
INDENT return 1
DEDENT res = ( getTotalNumberOfSequences ( m - 1, n ) + getTotalNumberOfSequences ( m //2,n-1))
returnres
DEDENT


FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE | def printDuplicates ( arr ) :
INDENT dict = {
}

for ele in arr :
INDENT try :
INDENT dict [ ele ] += 1
DEDENT except :
INDENT dict [ ele ] = 1
DEDENT DEDENT for item in dict :
INDENT if ( dict [ item ] > 1 ) :
INDENT print ( item, end = " " )
DEDENT DEDENT print ( "\n" )
DEDENT

LONGEST_REPEATING_SUBSEQUENCE_1 | def findLongestRepeatingSubSeq ( X, m, n ) :
INDENT if ( dp [ m ] [ n ] != - 1 ) :
INDENT return dp [ m ] [ n ]
DEDENT if ( m == 0 or n == 0 ) :
INDENT dp [ m ] [ n ] = 0
return dp [ m ] [ n ]
DEDENT if ( X [ m - 1 ] == X [ n - 1 ] and m != n ) :
INDENT dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X, m - 1, n - 1 ) + 1
return dp [ m ] [ n ]
DEDENT dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X, m, n - 1 ), findLongestRepeatingSubSeq ( X, m - 1, n ) )
return dp [ m ] [ n ]
DEDENT

COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_SUM | def findCount ( n, sum ) :
INDENT start = math . pow ( 10, n - 1 );

end = math . pow ( 10, n ) - 1;

count = 0;

i = start;

while ( i <= end ) :
INDENT cur = 0;

temp = i;

while ( temp != 0 ) :
INDENT cur += temp % 10;

temp = temp //10;
DEDENTif(cur==sum):
INDENTcount=count+1;
i+=9;
DEDENTelse:
INDENTi=i+1;
DEDENTDEDENTprint(count);
DEDENT


MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY | def minimum_cost ( a, n ) :
INDENT mn = sys . maxsize
sum = 0
for i in range ( n ) :
INDENT mn = min ( a [ i ], mn )
sum += a [ i ]
DEDENT return mn * ( sum - mn )
DEDENT

FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2 | def printDivisors ( n ) :
INDENT list = [ ]
for i in range ( 1, int ( math . sqrt ( n ) + 1 ) ) :
INDENT if ( n % i == 0 ) :
INDENT if ( n / i == i ) :
INDENT print ( i, end = " " )
DEDENT else :
INDENT print ( i, end = " " )
list . append ( int ( n / i ) )
DEDENT DEDENT DEDENT for i in list [ : : - 1 ] :
INDENT print ( i, end = " " )
DEDENT DEDENT

SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1 | def diagonalsquare ( mat, row, column ) :
INDENT print ( "Diagonal one : ", end = "" )
for i in range ( 0, row ) :
INDENT print ( mat [ i ] [ i ] * mat [ i ] [ i ], end = " " )
DEDENT print ( "\n\nDiagonal two : ", end = "" )
for i in range ( 0, row ) :
INDENT print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ], end = " " )
DEDENT DEDENT

C_PROGRAM_FIND_AREA_TRIANGLE_1 | def polygonArea ( X, Y, n ) :
INDENT area = 0.0
j = n - 1
for i in range ( 0, n ) :
INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] )
j = i
DEDENT return abs ( area //2.0)
DEDENT


RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS | def findFrequency ( arr, n, left, right, element ) :
INDENT count = 0
for i in range ( left - 1, right ) :
INDENT if ( arr [ i ] == element ) :
INDENT count += 1
DEDENT DEDENT return count
DEDENT

SERIES_LARGEST_GCD_SUM_EQUALS_N | def print_sequence ( n, k ) :
INDENT b = int ( n / ( k * ( k + 1 ) / 2 ) );

if b == 0 :
INDENT print ( "-1" )
DEDENT else :
INDENT r = 1;

x = 1
while x * * 2 <= n :
INDENT if n % x != 0 :
INDENT continue;

DEDENT elif x <= b and x > r :
INDENT r = x
DEDENT elif n / x <= b and n / x > r :
INDENT r = n / x
DEDENT x = x + 1
DEDENT i = 1
while i < k :
INDENT print ( r * i, end = " " )
i = i + 1
DEDENT last_term = n - ( r * ( k * ( k - 1 ) / 2 ) )
print ( last_term )
DEDENT DEDENT

FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K_1 | def findTriplet ( a1, a2, a3, n1, n2, n3, sum ) :
INDENT s = set ( )
for i in range ( n1 ) :
INDENT s . add ( a1 [ i ] )
DEDENT for i in range ( n2 ) :
INDENT for j in range ( n3 ) :
INDENT if sum - a2 [ i ] - a3 [ j ] in s :
INDENT return True
DEDENT DEDENT DEDENT return False
DEDENT

FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASING_AND_THEN_DECREASING_1 | def findMaximum ( arr, low, high ) :
INDENT if low == high :
INDENT return arr [ low ]
DEDENT if high == low + 1 and arr [ low ] >= arr [ high ] :
INDENT return arr [ low ];

DEDENT if high == low + 1 and arr [ low ] < arr [ high ] :
INDENT return arr [ high ]
DEDENT mid = ( low + high ) //2
ifarr[mid]>arr[mid+1]andarr[mid]>arr[mid-1]:
INDENTreturnarr[mid]
DEDENTifarr[mid]>arr[mid+1]andarr[mid]<arr[mid-1]:
INDENTreturnfindMaximum(arr,low,mid-1)
DEDENTelse:
INDENTreturnfindMaximum(arr,mid+1,high)
DEDENTDEDENT


DYNAMIC_PROGRAMMING_SET_1 | def fib ( n, lookup ) :
INDENT if n == 0 or n == 1 :
INDENT lookup [ n ] = n
DEDENT if lookup [ n ] is None :
INDENT lookup [ n ] = fib ( n - 1, lookup ) + fib ( n - 2, lookup )
DEDENT return lookup [ n ]
DEDENT

MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC | def power ( x, y, p ) :
INDENT res = 1
x = x % p
while ( y > 0 ) :
INDENT if ( ( y & 1 ) == 1 ) :
INDENT res = ( res * x ) % p
DEDENT y = y >> 1
x = ( x * x ) % p
DEDENT return res
DEDENT

WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TWO_1 | def isPowerOfTwo ( x ) :
INDENT return ( x and ( not ( x & ( x - 1 ) ) ) )
DEDENT

LONGEST_COMMON_SUBSEQUENCE_WITH_PERMUTATIONS_ALLOWED | def longestString ( str1, str2 ) :
INDENT count1 = [ 0 ] * 26
count2 = [ 0 ] * 26
for i in range ( len ( str1 ) ) :
INDENT count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1
DEDENT for i in range ( len ( str2 ) ) :
INDENT count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1
DEDENT result = ""
for i in range ( 26 ) :
INDENT for j in range ( 1, min ( count1 [ i ], count2 [ i ] ) + 1 ) :
INDENT result = result + chr ( ord ( 'a' ) + i )
DEDENT DEDENT print ( result )
DEDENT

DIFFERENCE_MAXIMUM_SUM_MINIMUM_SUM_N_M_ELEMENTSIN_REVIEW | def find_difference ( arr, n, m ) :
INDENT max = 0;
min = 0
arr . sort ( );

j = n - 1
for i in range ( m ) :
INDENT min += arr [ i ]
max += arr [ j ]
j = j - 1
DEDENT return ( max - min )
DEDENT

PRINT_NUMBER_ASCENDING_ORDER_CONTAINS_1_2_3_DIGITS | def printNumbers ( numbers ) :
INDENT numbers = map ( str, numbers )
result = [ ]
for num in numbers :
INDENT if ( '1' in num and '2' in num and '3' in num ) :
INDENT result . append ( num )
DEDENT DEDENT if not result :
INDENT result = [ '-1' ]
DEDENT return sorted ( result );

DEDENT

DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE | def lis ( arr ) :
INDENT global maximum
n = len ( arr )
maximum = 1
_lis ( arr, n )
return maximum
DEDENT

MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET | def minRevolutions ( r, x1, y1, x2, y2 ) :
INDENT d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) )
return math . ceil ( d //(2*r))
DEDENT


CHECK_TWO_GIVEN_SETS_DISJOINT | def areDisjoint ( set1, set2, m, n ) :
INDENT for i in range ( 0, m ) :
INDENT for j in range ( 0, n ) :
INDENT if ( set1 [ i ] == set2 [ j ] ) :
INDENT return False
DEDENT DEDENT DEDENT return True
DEDENT

FIND_MINIMUM_SUM_FACTORS_NUMBER | def findMinSum ( num ) :
INDENT sum = 0
i = 2
while ( i * i <= num ) :
INDENT while ( num % i == 0 ) :
INDENT sum += i
num /= i
DEDENT i += 1
DEDENT sum += num
return sum
DEDENT

FREQUENT_ELEMENT_ARRAY | def mostFrequent ( arr, n ) :
INDENT arr . sort ( )
max_count = 1;
res = arr [ 0 ];
curr_count = 1
for i in range ( 1, n ) :
INDENT if ( arr [ i ] == arr [ i - 1 ] ) :
INDENT curr_count += 1
DEDENT else :
INDENT if ( curr_count > max_count ) :
INDENT max_count = curr_count
res = arr [ i - 1 ]
DEDENT curr_count = 1
DEDENT DEDENT if ( curr_count > max_count ) :
INDENT max_count = curr_count
res = arr [ n - 1 ]
DEDENT return res
DEDENT

MINIMUM_XOR_VALUE_PAIR_1 | def minXOR ( arr, n ) :
INDENT arr . sort ( )
minXor = int ( sys . float_info . max )
val = 0
for i in range ( 0, n - 1 ) :
INDENT val = arr [ i ] ^ arr [ i + 1 ];

minXor = min ( minXor, val );

DEDENT return minXor
DEDENT

MINIMUM_SUM_PRODUCT_TWO_ARRAYS | def minproduct ( a, b, n, k ) :
INDENT diff = 0
res = 0
for i in range ( n ) :
INDENT pro = a [ i ] * b [ i ]
res = res + pro
if ( pro < 0 and b [ i ] < 0 ) :
INDENT temp = ( a [ i ] + 2 * k ) * b [ i ]
DEDENT elif ( pro < 0 and a [ i ] < 0 ) :
INDENT temp = ( a [ i ] - 2 * k ) * b [ i ]
DEDENT elif ( pro > 0 and a [ i ] < 0 ) :
INDENT temp = ( a [ i ] + 2 * k ) * b [ i ]
DEDENT elif ( pro > 0 and a [ i ] > 0 ) :
INDENT temp = ( a [ i ] - 2 * k ) * b [ i ]
DEDENT d = abs ( pro - temp )
if ( d > diff ) :
INDENT diff = d
DEDENT DEDENT return res - diff
DEDENT

FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERATOR_RUSSIAN_PEASANTS_ALGORITHM | def russianPeasant ( a, b ) :
INDENT res = 0
while ( b > 0 ) :
INDENT if ( b & 1 ) :
INDENT res = res + a
DEDENT a = a << 1
b = b >> 1
DEDENT return res
DEDENT

DIVISIBILITY_9_USING_BITWISE_OPERATORS | def isDivBy9 ( n ) :
INDENT if ( n == 0 or n == 9 ) :
INDENT return True
DEDENT if ( n < 9 ) :
INDENT return False
DEDENT return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )
DEDENT

CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT | def isInorder ( arr, n ) :
INDENT if ( n == 0 or n == 1 ) :
INDENT return True
DEDENT for i in range ( 1, n, 1 ) :
INDENT if ( arr [ i - 1 ] > arr [ i ] ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

GIVEN_TWO_UNSORTED_ARRAYS_FIND_PAIRS_WHOSE_SUM_X | def findPairs ( arr1, arr2, n, m, x ) :
INDENT for i in range ( 0, n ) :
INDENT for j in range ( 0, m ) :
INDENT if ( arr1 [ i ] + arr2 [ j ] == x ) :
INDENT print ( arr1 [ i ], arr2 [ j ] )
DEDENT DEDENT DEDENT DEDENT

BINARY_REPRESENTATION_OF_NEXT_NUMBER | def nextGreater ( num1 ) :
INDENT l = len ( num1 );

num = list ( num1 );

i = l - 1;

while ( i >= 0 ) :
INDENT if ( num [ i ] == '0' ) :
INDENT num [ i ] = '1';

break;

DEDENT else :
INDENT num [ i ] = '0';

DEDENT i -= 1;

DEDENT num1 = '' . join ( num );

if ( i < 0 ) :
INDENT num1 = '1' + num1;

DEDENT return num1;

DEDENT

LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S | def findSubArray ( arr, n ) :
INDENT sum = 0
maxsize = - 1
for i in range ( 0, n - 1 ) :
INDENT sum = - 1 if ( arr [ i ] == 0 ) else 1
for j in range ( i + 1, n ) :
INDENT sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1
if ( sum == 0 and maxsize < j - i + 1 ) :
INDENT maxsize = j - i + 1
startindex = i
DEDENT DEDENT DEDENT if ( maxsize == - 1 ) :
INDENT print ( "No such subarray" );

DEDENT else :
INDENT print ( startindex, "to", startindex + maxsize - 1 );

DEDENT return maxsize
DEDENT

COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1 | def countPairs ( arr, n ) :
INDENT result = 0
Hash = set ( )
for i in range ( n ) :
INDENT Hash . add ( arr [ i ] )
DEDENT for i in range ( n ) :
INDENT for j in range ( i + 1, n ) :
INDENT product = arr [ i ] * arr [ j ]
if product in ( Hash ) :
INDENT result += 1
DEDENT DEDENT DEDENT return result
DEDENT

DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE | def lps ( str ) :
INDENT n = len ( str )
L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ]
for i in range ( n ) :
INDENT L [ i ] [ i ] = 1
DEDENT for cl in range ( 2, n + 1 ) :
INDENT for i in range ( n - cl + 1 ) :
INDENT j = i + cl - 1
if str [ i ] == str [ j ] and cl == 2 :
INDENT L [ i ] [ j ] = 2
DEDENT elif str [ i ] == str [ j ] :
INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2
DEDENT else :
INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ], L [ i + 1 ] [ j ] );

DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ]
DEDENT

COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1 | def getInvCount ( arr, n ) :
INDENT invcount = 0
for i in range ( 1, n - 1 ) :
INDENT small = 0
for j in range ( i + 1, n ) :
INDENT if ( arr [ i ] > arr [ j ] ) :
INDENT small += 1
DEDENT DEDENT great = 0;

for j in range ( i - 1, - 1, - 1 ) :
INDENT if ( arr [ i ] < arr [ j ] ) :
INDENT great += 1
DEDENT DEDENT invcount += great * small
DEDENT return invcount
DEDENT

DECIMAL_REPRESENTATION_GIVEN_BINARY_STRING_DIVISIBLE_10_NOT | def isDivisibleBy10 ( bin ) :
INDENT n = len ( bin )
if ( bin [ n - 1 ] == '1' ) :
INDENT return False
DEDENT sum = 0
i = n - 2
while i >= 0 :
INDENT if ( bin [ i ] == '1' ) :
INDENT posFromRight = n - i - 1
if ( posFromRight % 4 == 1 ) :
INDENT sum = sum + 2
DEDENT elif ( posFromRight % 4 == 2 ) :
INDENT sum = sum + 4
DEDENT elif ( posFromRight % 4 == 3 ) :
INDENT sum = sum + 8
DEDENT elif ( posFromRight % 4 == 0 ) :
INDENT sum = sum + 6
DEDENT DEDENT i = i - 1
DEDENT if ( sum % 10 == 0 ) :
INDENT return True
DEDENT return False
DEDENT

FIND_WHETHER_AN_ARRAY_IS_SUBSET_OF_ANOTHER_ARRAY_SET_1_1 | def isSubset ( arr1, arr2, m, n ) :
INDENT i = 0
j = 0
if m < n :
INDENT return 0
DEDENT arr1 . sort ( )
arr2 . sort ( )
while i < n and j < m :
INDENT if arr1 [ j ] < arr2 [ i ] :
INDENT j += 1
DEDENT elif arr1 [ j ] == arr2 [ i ] :
INDENT j += 1
i += 1
DEDENT elif arr1 [ j ] > arr2 [ i ] :
INDENT return 0
DEDENT DEDENT return False if i < n else True
DEDENT

DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1 | def isSubsetSum ( set, n, sum ) :
INDENT subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] )
for i in range ( n + 1 ) :
INDENT subset [ i ] [ 0 ] = True
for i in range ( 1, sum + 1 ) :
INDENT subset [ 0 ] [ i ] = False
DEDENT for i in range ( 1, n + 1 ) :
INDENT for j in range ( 1, sum + 1 ) :
INDENT if j < set [ i - 1 ] :
INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ]
DEDENT if j >= set [ i - 1 ] :
INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] )
DEDENT DEDENT DEDENT DEDENT return subset [ n ] [ sum ]
DEDENT

SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS_1 | def kthgroupsum ( k ) :
INDENT return k * k * k
DEDENT

THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS | def thirdLargest ( arr, arr_size ) :
INDENT if ( arr_size < 3 ) :
INDENT print ( " Invalid Input " )
return
DEDENT first = arr [ 0 ]
for i in range ( 1, arr_size ) :
INDENT if ( arr [ i ] > first ) :
INDENT first = arr [ i ]
DEDENT DEDENT second = - sys . maxsize
for i in range ( 0, arr_size ) :
INDENT if ( arr [ i ] > second and arr [ i ] < first ) :
INDENT second = arr [ i ]
DEDENT DEDENT third = - sys . maxsize
for i in range ( 0, arr_size ) :
INDENT if ( arr [ i ] > third and arr [ i ] < second ) :
INDENT third = arr [ i ]
DEDENT DEDENT print ( "The Third Largest", "element is", third )
DEDENT

FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1 | def sumNodes ( l ) :
INDENT leafNodeCount = math . pow ( 2, l - 1 );

sumLastLevel = 0;

sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 );

sum = sumLastLevel * l;

return int ( sum );

DEDENT

MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2 | def middleOfThree ( a, b, c ) :
INDENT x = a - b
y = b - c
z = a - c
if x * y > 0 :
INDENT return b
DEDENT elif ( x * z > 0 ) :
INDENT return
DEDENT else :
INDENT return a
DEDENT DEDENT

MAXIMUM_TRIPLET_SUM_ARRAY_2 | def maxTripletSum ( arr, n ) :
INDENT maxA = - 100000000
maxB = - 100000000
maxC = - 100000000
for i in range ( 0, n ) :
INDENT if ( arr [ i ] > maxA ) :
INDENT maxC = maxB
maxB = maxA
maxA = arr [ i ]
DEDENT elif ( arr [ i ] > maxB ) :
INDENT maxC = maxB
maxB = arr [ i ]
DEDENT elif ( arr [ i ] > maxC ) :
INDENT maxC = arr [ i ]
DEDENT DEDENT return ( maxA + maxB + maxC )
DEDENT

COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1 | def countPairs ( arr1, arr2, m, n, x ) :
INDENT count = 0
us = set ( )
for i in range ( m ) :
INDENT us . add ( arr1 [ i ] )
DEDENT for j in range ( n ) :
INDENT if x - arr2 [ j ] in us :
INDENT count += 1
DEDENT DEDENT return count
DEDENT

MINIMUM_STEPS_REACH_END_ARRAY_CONSTRAINTS | def getMinStepToReachEnd ( arr, N ) :
INDENT visit = [ False for i in range ( N ) ]
distance = [ 0 for i in range ( N ) ]
digit = [ [ 0 for i in range ( N ) ] for j in range ( 10 ) ]
for i in range ( 1, N ) :
INDENT digit [ arr [ i ] ] . append ( i )
DEDENT distance [ 0 ] = 0
visit [ 0 ] = True
q = [ ]
q . append ( 0 )
while ( len ( q ) > 0 ) :
INDENT idx = q [ 0 ]
q . remove ( q [ 0 ] )
if ( idx == N - 1 ) :
INDENT break
DEDENT d = arr [ idx ]
for i in range ( len ( digit [ d ] ) ) :
INDENT nextidx = digit [ d ] [ i ]
if ( visit [ nextidx ] == False ) :
INDENT visit [ nextidx ] = True
q . append ( nextidx )
distance [ nextidx ] = distance [ idx ] + 1
DEDENT DEDENT if ( idx - 1 >= 0 and visit [ idx - 1 ] == False ) :
INDENT visit [ idx - 1 ] = True
q . append ( idx - 1 )
distance [ idx - 1 ] = distance [ idx ] + 1
DEDENT if ( idx + 1 < N and visit [ idx + 1 ] == False ) :
INDENT visit [ idx + 1 ] = True
q . append ( idx + 1 )
distance [ idx + 1 ] = distance [ idx ] + 1
DEDENT DEDENT return distance [ N - 1 ]
DEDENT

LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS | def minimizeWithKSwaps ( arr, n, k ) :
INDENT for i in range ( n - 1 ) :
INDENT pos = i
for j in range ( i + 1, n ) :
INDENT if ( j - i > k ) :
INDENT break
DEDENT if ( arr [ j ] < arr [ pos ] ) :
INDENT pos = j
DEDENT DEDENT for j in range ( pos, i, - 1 ) :
INDENT arr [ j ], arr [ j - 1 ] = arr [ j - 1 ], arr [ j ]
DEDENT k -= pos - i
DEDENT DEDENT

CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE | def printSequence ( arr, input ) :
INDENT n = len ( input )
output = ""
for i in range ( n ) :
INDENT if ( input [ i ] == ' ' ) :
INDENT output = output + "0"
DEDENT else :
INDENT position = ord ( input [ i ] ) - ord ( 'A' )
output = output + arr [ position ]
DEDENT DEDENT return output
DEDENT

PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE | def arraySortedOrNot ( arr ) :
INDENT n = len ( arr )
if n == 1 or n == 0 :
INDENT return True
DEDENT return arr [ 0 ] <= arr [ 1 ] and arraySortedOrNot ( arr [ 1 : ] )
DEDENT

CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT | def circle ( x1, y1, x2, y2, r1, r2 ) :
INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 );

radSumSq = ( r1 + r2 ) * ( r1 + r2 );

if ( distSq == radSumSq ) :
INDENT return 1
DEDENT elif ( distSq > radSumSq ) :
INDENT return - 1
DEDENT else :
INDENT return 0
DEDENT DEDENT

SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2 | def nextPowerOf2 ( n ) :
INDENT n -= 1
n |= n >> 1
n |= n >> 2
n |= n >> 4
n |= n >> 8
n |= n >> 16
n += 1
return n
DEDENT

PADOVAN_SEQUENCE | def pad ( n ) :
INDENT pPrevPrev, pPrev, pCurr, pNext = 1, 1, 1, 1
for i in range ( 3, n + 1 ) :
INDENT pNext = pPrevPrev + pPrev
pPrevPrev = pPrev
pPrev = pCurr
pCurr = pNext
DEDENT return pNext;

DEDENT

CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS | def check ( s ) :
INDENT if ( len ( s ) >= 10 ) :
INDENT return True
DEDENT for i in range ( 1, len ( s ) ) :
INDENT for j in range ( i + 1, len ( s ) ) :
INDENT for k in range ( j + 1, len ( s ) ) :
INDENT s1 = s [ 0 : i ]
s2 = s [ i : j - i ]
s3 = s [ j : k - j ]
s4 = s [ k : len ( s ) - k ]
if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) :
INDENT return True
DEDENT DEDENT DEDENT DEDENT return False
DEDENT

PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K | def isPossible ( a, b, n, k ) :
INDENT a . sort ( reverse = True )
b . sort ( )
for i in range ( n ) :
INDENT if ( a [ i ] + b [ i ] < k ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES | def winner ( a, n, k ) :
INDENT if k >= n - 1 :
INDENT return n
DEDENT best = 0
times = 0
for i in range ( n ) :
INDENT if a [ i ] > best :
INDENT best = a [ i ]
if i == True :
INDENT times = 1
DEDENT DEDENT else :
INDENT times += 1
DEDENT if times >= k :
INDENT return best
DEDENT DEDENT return best
DEDENT

DIRECTION_LAST_SQUARE_BLOCK | def direction ( R, C ) :
INDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) :
INDENT print ( "Left" )
return
DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) :
INDENT print ( "Up" )
return
DEDENT if R == C and R % 2 != 0 and C % 2 != 0 :
INDENT print ( "Right" )
return
DEDENT if R == C and R % 2 == 0 and C % 2 == 0 :
INDENT print ( "Left" )
return
DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) :
INDENT print ( "Right" )
return
DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) :
INDENT print ( "Down" )
return
DEDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) :
INDENT print ( "Left" )
return
DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) :
INDENT print ( "Up" )
return
DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) :
INDENT print ( "Down" )
return
DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) :
INDENT print ( "Right" )
return
DEDENT DEDENT

NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N | def countIntegralSolutions ( n ) :
INDENT result = 0
for i in range ( n + 1 ) :
INDENT for j in range ( n + 1 ) :
INDENT for k in range ( n + 1 ) :
INDENT if i + j + k == n :
INDENT result += 1
DEDENT DEDENT DEDENT DEDENT return result
DEDENT

SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX | def swapDiagonal ( matrix ) :
INDENT for i in range ( N ) :
INDENT matrix [ i ] [ i ], matrix [ i ] [ N - i - 1 ] = \
INDENT matrix [ i ] [ N - i - 1 ], matrix [ i ] [ i ]
DEDENT DEDENT DEDENT

MINIMUM_OPERATIONS_MAKE_GCD_ARRAY_MULTIPLE_K | def MinOperation ( a, n, k ) :
INDENT result = 0
for i in range ( n ) :
INDENT if ( a [ i ] != 1 and a [ i ] > k ) :
INDENT result = ( result + min ( a [ i ] % k, k - a [ i ] % k ) )
DEDENT else :
INDENT result = result + k - a [ i ]
DEDENT DEDENT return result
DEDENT

MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX | def maxDecimalValue ( mat, i, j, p ) :
INDENT if i >= N or j >= N :
INDENT return 0
DEDENT result = max ( maxDecimalValue ( mat, i, j + 1, p + 1 ), maxDecimalValue ( mat, i + 1, j, p + 1 ) )
if mat [ i ] [ j ] == 1 :
INDENT return pow ( 2, p ) + result
DEDENT else :
INDENT return result
DEDENT DEDENT

SQUARE_ROOT_OF_A_PERFECT_SQUARE_1 | def squareRoot ( n ) :
INDENT x = n;

y = 1;

while ( x > y ) :
INDENT x = ( x + y ) / 2;

y = n / x;

DEDENT return x;

DEDENT

FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX | def KMP ( m, n, str2, str1 ) :
INDENT pos = 0
Len = 0
p = [ 0 for i in range ( m + 1 ) ]
k = 0
for i in range ( 2, n + 1 ) :
INDENT while ( k > 0 and str1 [ k ] != str1 [ i - 1 ] ) :
INDENT k = p [ k ]
DEDENT if ( str1 [ k ] == str1 [ i - 1 ] ) :
INDENT k += 1
DEDENT p [ i ] = k
DEDENT j = 0
for i in range ( m ) :
INDENT while ( j > 0 and j < n and str1 [ j ] != str2 [ i ] ) :
INDENT j = p [ j ]
DEDENT if ( j < n and str1 [ j ] == str2 [ i ] ) :
INDENT j += 1
DEDENT if ( j > Len ) :
INDENT Len = j
pos = i - j + 1
DEDENT DEDENT print ( "Shift = ", pos )
print ( "Prefix = ", str1 [ : Len ] )
DEDENT

SORTED_ORDER_PRINTING_OF_AN_ARRAY_THAT_REPRESENTS_A_BST | def printSorted ( arr, start, end ) :
INDENT if start > end :
INDENT return
DEDENT printSorted ( arr, start * 2 + 1, end )
print ( arr [ start ], end = " " )
printSorted ( arr, start * 2 + 2, end )
DEDENT

CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE | def check ( degree, n ) :
INDENT deg_sum = sum ( degree )
if ( 2 * ( n - 1 ) == deg_sum ) :
INDENT return True
DEDENT else :
INDENT return False
DEDENT DEDENT

MOVE_ZEROES_END_ARRAY | def pushZerosToEnd ( arr, n ) :
INDENT count = 0
for i in range ( n ) :
INDENT if arr [ i ] != 0 :
INDENT arr [ count ] = arr [ i ]
count += 1
DEDENT DEDENT while count < n :
INDENT arr [ count ] = 0
count += 1
DEDENT DEDENT

COUNT_ELEMENTS_WHICH_DIVIDE_ALL_NUMBERS_IN_RANGE_L_R | def answerQuery ( a, n, l, r ) :
INDENT count = 0
l = l - 1
for i in range ( l, r, 1 ) :
INDENT element = a [ i ]
divisors = 0
for j in range ( l, r, 1 ) :
INDENT if ( a [ j ] % a [ i ] == 0 ) :
INDENT divisors += 1
DEDENT else :
INDENT break
DEDENT DEDENT if ( divisors == ( r - l ) ) :
INDENT count += 1
DEDENT DEDENT return count
DEDENT

SUM_LARGEST_PRIME_FACTOR_NUMBER_LESS_EQUAL_N | def sumOfLargePrimeFactor ( n ) :
INDENT prime = [ 0 ] * ( n + 1 )
sum = 0
max = int ( n / 2 )
for p in range ( 2, max + 1 ) :
INDENT if prime [ p ] == 0 :
INDENT for i in range ( p * 2, n + 1, p ) :
INDENT prime [ i ] = p
DEDENT DEDENT DEDENT for p in range ( 2, n + 1 ) :
INDENT if prime [ p ] :
INDENT sum += prime [ p ]
DEDENT else :
INDENT sum += p
DEDENT DEDENT return sum
DEDENT

REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SUM | def arrangeString ( string ) :
INDENT char_count = [ 0 ] * MAX_CHAR
s = 0
for i in range ( len ( string ) ) :
INDENT if string [ i ] >= "A" and string [ i ] <= "Z" :
INDENT char_count [ ord ( string [ i ] ) - ord ( "A" ) ] += 1
DEDENT else :
INDENT s += ord ( string [ i ] ) - ord ( "0" )
DEDENT DEDENT res = ""
for i in range ( MAX_CHAR ) :
INDENT ch = chr ( ord ( "A" ) + i )
while char_count [ i ] :
INDENT res += ch
char_count [ i ] -= 1
DEDENT DEDENT if s > 0 :
INDENT res += str ( s )
DEDENT return res
DEDENT

COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1 | def numberOfPaths ( m, n ) :
INDENT count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ]
for i in range ( m ) :
INDENT count [ i ] [ 0 ] = 1;

DEDENT for j in range ( n ) :
INDENT count [ 0 ] [ j ] = 1;

DEDENT for i in range ( 1, m ) :
INDENT for j in range ( n ) :
INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ]
DEDENT DEDENT return count [ m - 1 ] [ n - 1 ]
DEDENT

DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1 | def editDistDP ( str1, str2, m, n ) :
INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ]
for i in range ( m + 1 ) :
INDENT for j in range ( n + 1 ) :
INDENT if i == 0 :
INDENT dp [ i ] [ j ] = j
DEDENT elif j == 0 :
INDENT dp [ i ] [ j ] = i
DEDENT elif str1 [ i - 1 ] == str2 [ j - 1 ] :
INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]
DEDENT else :
INDENT dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ], dp [ i - 1 ] [ j - 1 ] )
DEDENT DEDENT DEDENT return dp [ m ] [ n ]
DEDENT

FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES | def countSol ( coeff, start, end, rhs ) :
INDENT if ( rhs == 0 ) :
INDENT return 1
DEDENT result = 0
for i in range ( start, end + 1 ) :
INDENT if ( coeff [ i ] <= rhs ) :
INDENT result += countSol ( coeff, i, end, rhs - coeff [ i ] )
DEDENT DEDENT return result
DEDENT

SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1 | def minheapify ( a, index ) :
INDENT small = index
l = 2 * index + 1
r = 2 * index + 2
if ( l < n and a [ l ] < a [ small ] ) :
INDENT small = l
DEDENT if ( r < n and a [ r ] < a [ small ] ) :
INDENT small = r
DEDENT if ( small != index ) :
INDENT ( a [ small ], a [ index ] ) = ( a [ index ], a [ small ] )
minheapify ( a, small )
DEDENT DEDENT

SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM | def computeLPSArray ( pat, M, lps ) :
INDENT len = 0
lps [ 0 ]
i = 1
while i < M :
INDENT if pat [ i ] == pat [ len ] :
INDENT len += 1
lps [ i ] = len
i += 1
DEDENT else :
INDENT if len != 0 :
INDENT len = lps [ len - 1 ]
DEDENT else :
INDENT lps [ i ] = 0
i += 1
DEDENT DEDENT DEDENT DEDENT

FIND_MINIMUM_DIFFERENCE_PAIR | def findMinDiff ( arr, n ) :
INDENT diff = 10 * * 20
for i in range ( n - 1 ) :
INDENT for j in range ( i + 1, n ) :
INDENT if abs ( arr [ i ] - arr [ j ] ) < diff :
INDENT diff = abs ( arr [ i ] - arr [ j ] )
DEDENT DEDENT DEDENT return diff
DEDENT

PRINT_FIRST_K_DIGITS_1N_N_POSITIVE_INTEGER | def Print ( n, k ) :
INDENT rem = 1
for i in range ( 0, k ) :
INDENT print ( math . floor ( ( ( 10 * rem ) / n ) ), end = "" )
rem = ( 10 * rem ) % n
DEDENT DEDENT

GROUP_MULTIPLE_OCCURRENCE_OF_ARRAY_ELEMENTS_ORDERED_BY_FIRST_OCCURRENCE | def groupElements ( arr, n ) :
INDENT visited = [ False ] * n
for i in range ( 0, n ) :
INDENT visited [ i ] = False
DEDENT for i in range ( 0, n ) :
INDENT if ( visited [ i ] == False ) :
INDENT print ( arr [ i ], end = " " )
for j in range ( i + 1, n ) :
INDENT if ( arr [ i ] == arr [ j ] ) :
INDENT print ( arr [ i ], end = " " )
visited [ j ] = True
DEDENT DEDENT DEDENT DEDENT DEDENT

CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY | def checkIsAP ( arr, n ) :
INDENT if ( n == 1 ) : return True
arr . sort ( )
d = arr [ 1 ] - arr [ 0 ]
for i in range ( 2, n ) :
INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES | def findPosition ( k, n ) :
INDENT f1 = 0
f2 = 1
i = 2;

while i != 0 :
INDENT f3 = f1 + f2;

f1 = f2;

f2 = f3;

if f2 % k == 0 :
INDENT return n * i
DEDENT i += 1
DEDENT return
DEDENT

COUNT_PAIRS_DIFFERENCE_EQUAL_K_1 | def countPairsWithDiffK ( arr, n, k ) :
INDENT count = 0
arr . sort ( )
l = 0
r = 0
while r < n :
INDENT if arr [ r ] - arr [ l ] == k :
INDENT count += 1
l += 1
r += 1
DEDENT elif arr [ r ] - arr [ l ] > k :
INDENT l += 1
DEDENT else :
INDENT r += 1
DEDENT DEDENT return count
DEDENT

ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY | def countNum ( arr, n ) :
INDENT count = 0
arr . sort ( )
for i in range ( 0, n - 1 ) :
INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) :
INDENT count += arr [ i + 1 ] - arr [ i ] - 1;

DEDENT DEDENT return count
DEDENT

MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS | def maximumPalinUsingKChanges ( strr, k ) :
INDENT palin = strr
l = 0
r = len ( strr ) - 1
while ( l <= r ) :
INDENT if ( strr [ l ] != strr [ r ] ) :
INDENT palin [ l ] = palin [ r ] = max ( strr [ l ], strr [ r ] )
k -= 1
DEDENT l += 1
r -= 1
DEDENT if ( k < 0 ) :
INDENT return "Not possible"
DEDENT l = 0
r = len ( strr ) - 1
while ( l <= r ) :
INDENT if ( l == r ) :
INDENT if ( k > 0 ) :
INDENT palin [ l ] = '9'
DEDENT DEDENT if ( palin [ l ] < '9' ) :
INDENT if ( k >= 2 and palin [ l ] == strr [ l ] and palin [ r ] == strr [ r ] ) :
INDENT k -= 1
palin [ l ] = palin [ r ] = '9'
DEDENT elif ( k >= 1 and ( palin [ l ] != strr [ l ] or palin [ r ] != strr [ r ] ) ) :
INDENT k -= 1
palin [ l ] = palin [ r ] = '9'
DEDENT DEDENT l += 1
r -= 1
DEDENT return palin
DEDENT

SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THEM | def subArray ( arr, n ) :
INDENT for i in range ( 0, n ) :
INDENT for j in range ( i, n ) :
INDENT for k in range ( i, j + 1 ) :
INDENT print ( arr [ k ], end = " " )
DEDENT print ( "\n", end = "" )
DEDENT DEDENT DEDENT

MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS | def maximumSum ( a, n ) :
INDENT global M;

for i in range ( 0, n ) :
INDENT a [ i ] . sort ( );

DEDENT sum = a [ n - 1 ] [ M - 1 ];

prev = a [ n - 1 ] [ M - 1 ];

for i in range ( n - 2, - 1, - 1 ) :
INDENT for j in range ( M - 1, - 1, - 1 ) :
INDENT if ( a [ i ] [ j ] < prev ) :
INDENT prev = a [ i ] [ j ];

sum += prev;

break;

DEDENT DEDENT if ( j == - 1 ) :
INDENT return 0;

DEDENT DEDENT return sum;

DEDENT

C_PROGRAM_FACTORIAL_NUMBER | def factorial ( n ) :
INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 );

DEDENT

PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING | def printSquares ( n ) :
INDENT square = 0;
prev_x = 0;

for x in range ( 0, n ) :
INDENT square = ( square + x + prev_x )
print ( square, end = " " )
prev_x = x
DEDENT DEDENT

ROPES_DATA_STRUCTURE_FAST_STRING_CONCATENATION | def concatenate ( a, b, c, n1, n2 ) :
INDENT i = - 1
for i in range ( n1 ) :
INDENT c [ i ] = a [ i ]
DEDENT for j in range ( n2 ) :
INDENT c [ i ] = b [ j ]
i += 1
DEDENT DEDENT

GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_X | def printClosest ( ar1, ar2, m, n, x ) :
INDENT diff = sys . maxsize
l = 0
r = n - 1
while ( l < m and r >= 0 ) :
INDENT if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff :
INDENT res_l = l
res_r = r
diff = abs ( ar1 [ l ] + ar2 [ r ] - x )
DEDENT if ar1 [ l ] + ar2 [ r ] > x :
INDENT r = r - 1
DEDENT else :
INDENT l = l + 1
DEDENT DEDENT print ( "The closest pair is [", ar1 [ res_l ], ",", ar2 [ res_r ], "]" )
DEDENT

CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES | def minRemove ( arr, n ) :
INDENT LIS = [ 0 for i in range ( n ) ]
len = 0
for i in range ( n ) :
INDENT LIS [ i ] = 1
DEDENT for i in range ( 1, n ) :
INDENT for j in range ( i ) :
INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) :
INDENT LIS [ i ] = max ( LIS [ i ], LIS [ j ] + 1 )
DEDENT DEDENT len = max ( len, LIS [ i ] )
DEDENT return ( n - len )
DEDENT

TAIL_RECURSION | def fact ( n ) :
INDENT if ( n == 0 ) :
INDENT return 1
DEDENT return n * fact ( n - 1 )
DEDENT

RECURSIVE_FUNCTIONS | def tower ( n, sourcePole, destinationPole, auxiliaryPole ) :
INDENT if ( 0 == n ) :
INDENT return
DEDENT tower ( n - 1, sourcePole, auxiliaryPole, destinationPole )
print ( "Move the disk", sourcePole, "from", sourcePole, "to", destinationPole )
tower ( n - 1, auxiliaryPole, destinationPole, sourcePole )
DEDENT

FIND_X_Y_SATISFYING_AX_N | def solution ( a, b, n ) :
INDENT i = 0
while i * a <= n :
INDENT if ( n - ( i * a ) ) % b == 0 :
INDENT print ( "x = ", i, ", y = ", int ( ( n - ( i * a ) ) / b ) )
return 0
DEDENT i = i + 1
DEDENT print ( "No solution" )
DEDENT

EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1 | def exponentiation ( bas, exp ) :
INDENT t = 1;

while ( exp > 0 ) :
INDENT if ( exp % 2 != 0 ) :
INDENT t = ( t * bas ) % N;

DEDENT bas = ( bas * bas ) % N;

exp = int ( exp / 2 );

DEDENT return t % N;

DEDENT

CHECK_OCCURRENCES_CHARACTER_APPEAR_TOGETHER | def checkIfAllTogether ( s, c ) :
INDENT oneSeen = False
i = 0
n = len ( s )
while ( i < n ) :
INDENT if ( s [ i ] == c ) :
INDENT if ( oneSeen == True ) :
INDENT return False
DEDENT while ( i < n and s [ i ] == c ) :
INDENT i = i + 1
DEDENT oneSeen = True
DEDENT else :
INDENT i = i + 1
DEDENT DEDENT return True
DEDENT

MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY | def findArea ( arr, n ) :
INDENT arr . sort ( reverse = True )
dimension = [ 0, 0 ]
i = 0
j = 0
while ( i < n - 1 and j < 2 ) :
INDENT if ( arr [ i ] == arr [ i + 1 ] ) :
INDENT dimension [ j ] = arr [ i ]
j += 1
i += 1
DEDENT i += 1
DEDENT return ( dimension [ 0 ] * dimension [ 1 ] )
DEDENT

PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE | def Circumference ( a ) :
INDENT return ( 4 * a )
DEDENT

CYCLE_SORT | def cycleSort ( array ) :
INDENT writes = 0
for cycleStart in range ( 0, len ( array ) - 1 ) :
INDENT item = array [ cycleStart ]
pos = cycleStart
for i in range ( cycleStart + 1, len ( array ) ) :
INDENT if array [ i ] < item :
INDENT pos += 1
DEDENT DEDENT if pos == cycleStart :
INDENT continue
DEDENT while item == array [ pos ] :
INDENT pos += 1
DEDENT array [ pos ], item = item, array [ pos ]
writes += 1
while pos != cycleStart :
INDENT pos = cycleStart
for i in range ( cycleStart + 1, len ( array ) ) :
INDENT if array [ i ] < item :
INDENT pos += 1
DEDENT DEDENT while item == array [ pos ] :
INDENT pos += 1
DEDENT array [ pos ], item = item, array [ pos ]
writes += 1
DEDENT DEDENT return writes
DEDENT

SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE | def selectRandom ( x ) :
INDENT res = 0;

count = 0;

count += 1;

if ( count == 1 ) :
INDENT res = x;

DEDENT else :
INDENT i = random . randrange ( count );

if ( i == count - 1 ) :
INDENT res = x;

DEDENT DEDENT return res;

DEDENT

HOSOYAS_TRIANGLE | def printHosoya ( n ) :
INDENT dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ]
dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1
for i in range ( 2, n ) :
INDENT for j in range ( n ) :
INDENT if ( i > j ) :
INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] )
DEDENT else :
INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] )
DEDENT DEDENT DEDENT for i in range ( n ) :
INDENT for j in range ( i + 1 ) :
INDENT print ( dp [ i ] [ j ], end = ' ' )
DEDENT print ( )
DEDENT DEDENT

DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION | def lastPosition ( n, m, k ) :
INDENT if ( m <= n - k + 1 ) :
INDENT return m + k - 1
DEDENT m = m - ( n - k + 1 )
if ( m % n == 0 ) :
INDENT return n
DEDENT else :
INDENT return m % n
DEDENT DEDENT

PRINTING_LONGEST_INCREASING_CONSECUTIVE_SUBSEQUENCE | def longestSubsequence ( a, n ) :
INDENT mp = {
  i : 0 for i in range ( 13 ) }
  
  dp = [ 0 for i in range ( n ) ]
  maximum = - sys . maxsize - 1
  index = - 1
  for i in range ( n ) :
  INDENT if ( ( a [ i ] - 1 ) in mp ) :
  INDENT lastIndex = mp [ a [ i ] - 1 ] - 1
  dp [ i ] = 1 + dp [ lastIndex ]
  DEDENT else :
  INDENT dp [ i ] = 1
  DEDENT mp [ a [ i ] ] = i + 1
  if ( maximum < dp [ i ] ) :
  INDENT maximum = dp [ i ]
  index = i
  DEDENT DEDENT for curr in range ( a [ index ] - maximum + 1, a [ index ] + 1, 1 ) :
  INDENT print ( curr, end = " " )
  DEDENT DEDENT

NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS | def countTriangle ( g, isDirected ) :
INDENT nodes = len ( g )
count_Triangle = 0
for i in range ( nodes ) :
INDENT for j in range ( nodes ) :
INDENT for k in range ( nodes ) :
INDENT if ( i != j and i != k and j != k and g [ i ] [ j ] and g [ j ] [ k ] and g [ k ] [ i ] ) :
INDENT count_Triangle += 1
DEDENT DEDENT DEDENT DEDENT return count_Triangle / 3 if isDirected else count_Triangle / 6
DEDENT

CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTANCE | def checkDuplicatesWithinK ( arr, n, k ) :
INDENT myset = [ ]
for i in range ( n ) :
INDENT if arr [ i ] in myset :
INDENT return True
DEDENT myset . append ( arr [ i ] )
if ( i >= k ) :
INDENT myset . remove ( arr [ i - k ] )
DEDENT DEDENT return False
DEDENT

MINIMUM_INSERTIONS_SORT_ARRAY | def minInsertionStepToSortArray ( arr, N ) :
INDENT lis = [ 0 ] * N
for i in range ( N ) :
INDENT lis [ i ] = 1
DEDENT for i in range ( 1, N ) :
INDENT for j in range ( i ) :
INDENT if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) :
INDENT lis [ i ] = lis [ j ] + 1
DEDENT DEDENT DEDENT max = 0
for i in range ( N ) :
INDENT if ( max < lis [ i ] ) :
INDENT max = lis [ i ]
DEDENT DEDENT return ( N - max )
DEDENT

GENERATE_TWO_OUTPUT_STRINGS_DEPENDING_UPON_OCCURRENCE_CHARACTER_INPUT_STRING | def printDuo ( string ) :
INDENT countChar = [ 0 for i in range ( MAX_CHAR ) ]
n = len ( string )
for i in range ( n ) :
INDENT countChar [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1
DEDENT str1 = ""
str2 = ""
for i in range ( MAX_CHAR ) :
INDENT if ( countChar [ i ] > 1 ) :
INDENT str2 = str2 + chr ( i + ord ( 'a' ) )
DEDENT elif ( countChar [ i ] == 1 ) :
INDENT str1 = str1 + chr ( i + ord ( 'a' ) )
DEDENT DEDENT print ( "String with characters occurring once:", "\n", str1 )
print ( "String with characters occurring", "multiple times:", "\n", str2 )
DEDENT

NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1 | def countDigits ( a, b ) :
INDENT if ( a == 0 or b == 0 ) :
INDENT return 1
DEDENT return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1
DEDENT

TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1 | def countNonDecreasing ( n ) :
INDENT N = 10
count = 1
for i in range ( 1, n + 1 ) :
INDENT count = int ( count * ( N + i - 1 ) )
count = int ( count / i )
DEDENT return count
DEDENT

COUNT_STRINGS_ADJACENT_CHARACTERS_DIFFERENCE_ONE | def countStrs ( n ) :
INDENT dp = [ [ 0 for j in range ( 27 ) ] for i in range ( n + 1 ) ]
for i in range ( 0, 26 ) :
INDENT dp [ 1 ] [ i ] = 1
DEDENT for i in range ( 2, n + 1 ) :
INDENT for j in range ( 0, 26 ) :
INDENT if ( j == 0 ) :
INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ];

DEDENT else :
INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] )
DEDENT DEDENT DEDENT sum = 0
for i in range ( 0, 26 ) :
INDENT sum = sum + dp [ n ] [ i ]
DEDENT return sum
DEDENT

PROGRAM_TO_EFFICIENTLY_CALCULATE_EX | def exponential ( n, x ) :
INDENT sum = 1.0
for i in range ( n, 0, - 1 ) :
INDENT sum = 1 + x * sum / i
DEDENT print ( "e^x =", sum )
DEDENT

EFFICIENTLY_COMPUTE_SUMS_OF_DIAGONALS_OF_A_MATRIX_1 | def printDiagonalSums ( mat, n ) :
INDENT principal = 0
secondary = 0
for i in range ( 0, n ) :
INDENT principal += mat [ i ] [ i ]
secondary += mat [ i ] [ n - i - 1 ]
DEDENT print ( "Principal Diagonal:", principal )
print ( "Secondary Diagonal:", secondary )
DEDENT

PRINT_WAYS_BREAK_STRING_BRACKET_FORM | def findCombinations ( string, index, out ) :
INDENT if index == len ( string ) :
INDENT print ( out )
DEDENT for i in range ( index, len ( string ), 1 ) :
INDENT findCombinations ( string, i + 1, out + "(" + string [ index : i + 1 ] + ")" )
DEDENT DEDENT

LINEAR_SEARCH | def search ( arr, n, x ) :
INDENT for i in range ( 0, n ) :
INDENT if ( arr [ i ] == x ) :
INDENT return i;

DEDENT DEDENT return - 1;

DEDENT

FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2 | def singleNumber ( nums ) :
INDENT return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2
DEDENT

SEARCH_ALMOST_SORTED_ARRAY | def binarySearch ( arr, l, r, x ) :
INDENT if ( r >= l ) :
INDENT mid = int ( l + ( r - l ) / 2 )
if ( arr [ mid ] == x ) : return mid
if ( mid > l and arr [ mid - 1 ] == x ) :
INDENT return ( mid - 1 )
DEDENT if ( mid < r and arr [ mid + 1 ] == x ) :
INDENT return ( mid + 1 )
DEDENT if ( arr [ mid ] > x ) :
INDENT return binarySearch ( arr, l, mid - 2, x )
DEDENT return binarySearch ( arr, mid + 2, r, x )
DEDENT return - 1
DEDENT

EULERS_TOTIENT_FUNCTION_FOR_ALL_NUMBERS_SMALLER_THAN_OR_EQUAL_TO_N | def computeTotient ( n ) :
INDENT phi = [ ]
for i in range ( n + 2 ) :
INDENT phi . append ( 0 )
DEDENT for i in range ( 1, n + 1 ) :
INDENT phi [ i ] = i
DEDENT for p in range ( 2, n + 1 ) :
INDENT if ( phi [ p ] == p ) :
INDENT phi [ p ] = p - 1
for i in range ( 2 * p, n + 1, p ) :
INDENT phi [ i ] = ( phi [ i ] //p)*(p-1)
DEDENTDEDENTDEDENTforiinrange(1,n+1):
INDENTprint("Totient of ",i," is ",phi[i])
DEDENTDEDENT


FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE | def findMinNumber ( n ) :
INDENT count = 0
ans = 1
while n % 2 == 0 :
INDENT count += 1
n //=2
DEDENTifcount%2isnot0:
INDENTans*=2
DEDENTforiinrange(3,(int)(math.sqrt(n))+1,2):
INDENTcount=0
whilen%i==0:
INDENTcount+=1
n//=i
DEDENTifcount%2isnot0:
INDENTans*=i
DEDENTDEDENTifn>2:
INDENTans*=n
DEDENTreturnans
DEDENT


COUNT_NUMBER_WAYS_JUMP_REACH_END | def countWaysToJump ( arr, n ) :
INDENT count_jump = [ 0 for i in range ( n ) ]
for i in range ( n - 2, - 1, - 1 ) :
INDENT if ( arr [ i ] >= n - i - 1 ) :
INDENT count_jump [ i ] += 1
DEDENT j = i + 1
while ( j < n - 1 and j <= arr [ i ] + i ) :
INDENT if ( count_jump [ j ] != - 1 ) :
INDENT count_jump [ i ] += count_jump [ j ]
DEDENT j += 1
DEDENT if ( count_jump [ i ] == 0 ) :
INDENT count_jump [ i ] = - 1
DEDENT DEDENT for i in range ( n ) :
INDENT print ( count_jump [ i ], end = " " )
DEDENT DEDENT

CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1 | def substringConversions ( str1, k, b ) :
INDENT for i in range ( 0, len ( str1 ) - k + 1 ) :
INDENT sub = str1 [ i : k + i ]
Sum = 0
counter = 0
for i in range ( len ( sub ) - 1, - 1, - 1 ) :
INDENT Sum = ( Sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b, counter ) ) )
counter += 1
DEDENT print ( Sum, end = " " )
DEDENT DEDENT

TWO_ELEMENTS_WHOSE_SUM_IS_CLOSEST_TO_ZERO | def minAbsSumPair ( arr, arr_size ) :
INDENT inv_count = 0
if arr_size < 2 :
INDENT print ( "Invalid Input" )
return
DEDENT min_l = 0
min_r = 1
min_sum = arr [ 0 ] + arr [ 1 ]
for l in range ( 0, arr_size - 1 ) :
INDENT for r in range ( l + 1, arr_size ) :
INDENT sum = arr [ l ] + arr [ r ]
if abs ( min_sum ) > abs ( sum ) :
INDENT min_sum = sum
min_l = l
min_r = r
DEDENT DEDENT DEDENT print ( "The two elements whose sum is minimum are", arr [ min_l ], "and ", arr [ min_r ] )
DEDENT

HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS | def findoptimal ( N ) :
INDENT if ( N <= 6 ) :
INDENT return N
DEDENT screen = [ 0 ] * N
for n in range ( 1, 7 ) :
INDENT screen [ n - 1 ] = n
DEDENT for n in range ( 7, N + 1 ) :
INDENT screen [ n - 1 ] = max ( 2 * screen [ n - 4 ], max ( 3 * screen [ n - 5 ], 4 * screen [ n - 6 ] ) );

DEDENT return screen [ N - 1 ]
DEDENT

PROGRAM_DECIMAL_BINARY_CONVERSION_2 | def decimalToBinary ( N ) :
INDENT B_Number = 0
cnt = 0
while ( N != 0 ) :
INDENT rem = N % 2
c = pow ( 10, cnt )
B_Number += rem * c
N //=2
cnt+=1
DEDENTreturnB_Number
DEDENT


COUNTS_PATHS_POINT_REACH_ORIGIN_1 | def countPaths ( n, m ) :
INDENT if ( n == 0 or m == 0 ) :
INDENT return 1
DEDENT return ( countPaths ( n - 1, m ) + countPaths ( n, m - 1 ) )
DEDENT

SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS | def sumBetweenTwoKth ( arr, n, k1, k2 ) :
INDENT arr . sort ( )
result = 0
for i in range ( k1, k2 - 1 ) :
INDENT result += arr [ i ]
DEDENT return result
DEDENT

SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS | def minRange ( arr, n, k ) :
INDENT l = 0
r = n
for i in range ( n ) :
INDENT s = [ ]
for j in range ( i, n ) :
INDENT s . append ( arr [ j ] )
if ( len ( s ) == k ) :
INDENT if ( ( j - i ) < ( r - l ) ) :
INDENT r = j
l = i
DEDENT break
DEDENT DEDENT if ( j == n ) :
INDENT break
DEDENT DEDENT if ( l == 0 and r == n ) :
INDENT print ( "Invalid k" )
DEDENT else :
INDENT print ( l, r )
DEDENT DEDENT

AREA_OF_A_HEXAGON | def hexagonArea ( s ) :
INDENT return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2 );

DEDENT

NEXT_POWER_OF_2_2 | def nextPowerOf2 ( n ) :
INDENT n -= 1
n |= n >> 1
n |= n >> 2
n |= n >> 4
n |= n >> 8
n |= n >> 16
n += 1
return n
DEDENT

COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES | def countOfSubstringWithKOnes ( s, K ) :
INDENT N = len ( s )
res = 0
countOfOne = 0
freq = [ 0 for i in range ( N + 1 ) ]
freq [ 0 ] = 1
for i in range ( 0, N, 1 ) :
INDENT countOfOne += ord ( s [ i ] ) - ord ( '0' )
if ( countOfOne >= K ) :
INDENT res += freq [ countOfOne - K ]
DEDENT freq [ countOfOne ] += 1
DEDENT return res
DEDENT

NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE | def answer_query ( a, n, l, r ) :
INDENT count = 0
for i in range ( l, r ) :
INDENT if ( a [ i ] == a [ i + 1 ] ) :
INDENT count += 1
DEDENT DEDENT return count
DEDENT

CHECK_WHETHER_NUMBER_DUCK_NUMBER_NOT | def check_duck ( num ) :
INDENT l = len ( num )
count_zero = 0
i = 1
while i < l :
INDENT ch = num [ i ]
if ( ch == "0" ) :
INDENT count_zero = count_zero + 1
DEDENT i = i + 1
DEDENT return count_zero
DEDENT

NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N_1 | def countIntegralSolutions ( n ) :
INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) / 2 )
DEDENT

MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_K_TIMES_1 | def maxProfit ( price, n, k ) :
INDENT profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ]
for i in range ( 1, k + 1 ) :
INDENT prevDiff = float ( '-inf' )
for j in range ( 1, n ) :
INDENT prevDiff = max ( prevDiff, profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] )
profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ], price [ j ] + prevDiff )
DEDENT DEDENT return profit [ k ] [ n - 1 ]
DEDENT

COUNT_CHARACTERS_POSITION_ENGLISH_ALPHABETS | def findCount ( str ) :
INDENT result = 0
for i in range ( len ( str ) ) :
INDENT if ( ( i == ord ( str [ i ] ) - ord ( 'a' ) ) or ( i == ord ( str [ i ] ) - ord ( 'A' ) ) ) :
INDENT result += 1
DEDENT DEDENT return result
DEDENT

COUNT_GFG_SUBSEQUENCES_GIVEN_STRING | def countSubsequence ( s, n ) :
INDENT cntG = 0
cntF = 0
result = 0
C = 0
for i in range ( n ) :
INDENT if ( s [ i ] == 'G' ) :
INDENT cntG += 1
result += C
continue
DEDENT if ( s [ i ] == 'F' ) :
INDENT cntF += 1
C += cntG
continue
DEDENT else :
INDENT continue
DEDENT DEDENT print ( result )
DEDENT

FIND_SMALLEST_VALUE_REPRESENTED_SUM_SUBSET_GIVEN_ARRAY | def findSmallest ( arr, n ) :
INDENT res = 1
for i in range ( 0, n ) :
INDENT if arr [ i ] <= res :
INDENT res = res + arr [ i ]
DEDENT else :
INDENT break
DEDENT DEDENT return res
DEDENT

MAXIMUM_POINTS_COLLECTED_BY_TWO_PERSONS_ALLOWED_TO_MEET_ONCE | def findMaxPoints ( A ) :
INDENT P1S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ]
P1E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ]
P2S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ]
P2E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ]
for i in range ( 1, N + 1 ) :
INDENT for j in range ( 1, M + 1 ) :
INDENT P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ], P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ]
DEDENT DEDENT for i in range ( N, 0, - 1 ) :
INDENT for j in range ( M, 0, - 1 ) :
INDENT P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ], P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ]
DEDENT DEDENT for i in range ( N, 0, - 1 ) :
INDENT for j in range ( 1, M + 1 ) :
INDENT P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ], P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ]
DEDENT DEDENT for i in range ( 1, N + 1 ) :
INDENT for j in range ( M, 0, - 1 ) :
INDENT P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ], P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ]
DEDENT DEDENT ans = 0
for i in range ( 2, N ) :
INDENT for j in range ( 2, M ) :
INDENT op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + \
INDENT P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ]
DEDENT op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + \
INDENT P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ]
DEDENT ans = max ( ans, max ( op1, op2 ) )
DEDENT DEDENT return ans
DEDENT

PROGRAM_FIND_CIRCUMFERENCE_CIRCLE | def circumference ( r ) :
INDENT return ( 2 * PI * r )
DEDENT

QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY | def leftRotate ( arr, n, k ) :
INDENT for i in range ( k, k + n ) :
INDENT print ( str ( arr [ i % n ] ), end = " " )
DEDENT DEDENT

MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY | def minSum ( A ) :
INDENT min_val = min ( A );

return min_val * ( len ( A ) - 1 )
DEDENT

RECURSIVE_PROGRAM_PRIME_NUMBER | def isPrime ( n, i = 2 ) :
INDENT if ( n <= 2 ) :
INDENT return True if ( n == 2 ) else False
DEDENT if ( n % i == 0 ) :
INDENT return False
DEDENT if ( i * i > n ) :
INDENT return true
DEDENT return isPrime ( n, i + 1 )
DEDENT

SPARSE_SEARCH | def sparseSearch ( arr, key, low, high ) :
INDENT left = 0;
right = 0
while low <= high :
INDENT mid = ( low + high ) //2
ifarr[mid]=='':
INDENTleft=mid-1
right=mid+1
ifleft<lowandright>high:
INDENTreturn-1
DEDENTelifright<=highandarr[right]!='':
INDENTmid=right
DEDENTelifleft>=lowandarr[left]!='':
INDENTmid=left
DEDENTDEDENTifarr[mid]==key:
INDENTprint('Found string {} at index {}'.format(arr[mid],mid))
return
DEDENTelifarr[mid]>key:
INDENThigh=mid-1
DEDENTelifarr[mid]<key:
INDENTlow=mid+1
DEDENTleft-=1
right+=1
DEDENTreturn-1
DEDENT


FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING | def count ( a, b, m, n ) :
INDENT if ( ( m == 0 and n == 0 ) or n == 0 ) :
INDENT return 1
DEDENT if ( m == 0 ) :
INDENT return 0
DEDENT if ( a [ m - 1 ] == b [ n - 1 ] ) :
INDENT return ( count ( a, b, m - 1, n - 1 ) + count ( a, b, m - 1, n ) )
DEDENT else :
INDENT return count ( a, b, m - 1, n )
DEDENT DEDENT

PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1 | def arraySortedOrNot ( arr, n ) :
INDENT if ( n == 0 or n == 1 ) :
INDENT return True
DEDENT for i in range ( 1, n ) :
INDENT if ( arr [ i - 1 ] > arr [ i ] ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

FIND_INDEX_0_REPLACED_1_GET_LONGEST_CONTINUOUS_SEQUENCE_1S_BINARY_ARRAY | def maxOnesIndex ( arr, n ) :
INDENT max_count = 0
max_index = 0
prev_zero = - 1
prev_prev_zero = - 1
for curr in range ( n ) :
INDENT if ( arr [ curr ] == 0 ) :
INDENT if ( curr - prev_prev_zero > max_count ) :
INDENT max_count = curr - prev_prev_zero
max_index = prev_zero
DEDENT prev_prev_zero = prev_zero
prev_zero = curr
DEDENT DEDENT if ( n - prev_prev_zero > max_count ) :
INDENT max_index = prev_zero
DEDENT return max_index
DEDENT

FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1 | def maxProduct ( arr, n ) :
INDENT if n < 3 :
INDENT return - 1
DEDENT arr . sort ( )
return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ], arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] )
DEDENT

COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE | def printRect ( X, Y, n ) :
INDENT Xmax = max ( X )
Xmin = min ( X )
Ymax = max ( Y )
Ymin = min ( Y )
print ( "{", Xmin, ", ", Ymin, "}", sep = "" )
print ( "{", Xmin, ", ", Ymax, "}", sep = "" )
print ( "{", Xmax, ", ", Ymax, "}", sep = "" )
print ( "{", Xmax, ", ", Ymin, "}", sep = "" )
DEDENT

COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N | def countOfBinaryNumberLessThanN ( N ) :
INDENT q = deque ( )
q . append ( 1 )
cnt = 0
while ( q ) :
INDENT t = q . popleft ( )
if ( t <= N ) :
INDENT cnt = cnt + 1
q . append ( t * 10 )
q . append ( t * 10 + 1 )
DEDENT DEDENT return cnt
DEDENT

CONVERT_DECIMAL_FRACTION_BINARY_NUMBER | def decimalToBinary ( num, k_prec ) :
INDENT binary = ""
Integral = int ( num )
fractional = num - Integral
while ( Integral ) :
INDENT rem = Integral % 2
binary += str ( rem );

Integral //=2
DEDENTbinary=binary[::-1]
binary+='.'
while(k_prec):
INDENTfractional*=2
fract_bit=int(fractional)
if(fract_bit==1):
INDENTfractional-=fract_bit
binary+='1'
DEDENTelse:
INDENTbinary+='0'
DEDENTk_prec-=1
DEDENTreturnbinary
DEDENT


MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSETS_OF_SIZE_K | def maximumZeros ( arr, n, k ) :
INDENT global MAX5
subset = [ [ - 1 ] * ( MAX5 + 5 ) for _ in range ( k + 1 ) ]
subset [ 0 ] [ 0 ] = 0
for p in arr :
INDENT pw2, pw5 = 0, 0
while not p % 2 :
INDENT pw2 += 1
p //=2
DEDENTwhilenotp%5:
INDENTpw5+=1
p//=5
DEDENTforiinrange(k-1,-1,-1):
INDENTforjinrange(MAX5):
INDENTifsubset[i][j]!=-1:
INDENTsubset[i+1][j+pw5]=(max(subset[i+1][j+pw5],(subset[i][j]+pw2)))
DEDENTDEDENTDEDENTDEDENTans=0
foriinrange(MAX5):
INDENTans=max(ans,min(i,subset[k][i]))
DEDENTreturnans
DEDENT


SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY | def search ( arr, l, h, key ) :
INDENT if l > h :
INDENT return - 1
DEDENT mid = ( l + h ) //2
ifarr[mid]==key:
INDENTreturnmid
DEDENTifarr[l]<=arr[mid]:
INDENTifkey>=arr[l]andkey<=arr[mid]:
INDENTreturnsearch(arr,l,mid-1,key)
DEDENTreturnsearch(arr,mid+1,h,key)
DEDENTifkey>=arr[mid]andkey<=arr[h]:
INDENTreturnsearch(a,mid+1,h,key)
DEDENTreturnsearch(arr,l,mid-1,key)
DEDENT


PROGRAM_FIND_AREA_CIRCULAR_SEGMENT | def area_of_segment ( radius, angle ) :
INDENT area_of_sector = pi *
INDENT ( radius * radius )
* ( angle / 360 )
DEDENT area_of_triangle = 1 / 2 *
INDENT ( radius * radius ) *
math . sin ( ( angle * pi ) / 180 )
DEDENT return area_of_sector - area_of_triangle;

DEDENT

K_SMALLEST_ELEMENTS_ORDER_USING_O1_EXTRA_SPACE | def printSmall ( arr, n, k ) :
INDENT for i in range ( k, n ) :
INDENT max_var = arr [ k - 1 ]
pos = k - 1
for j in range ( k - 2, - 1, - 1 ) :
INDENT if ( arr [ j ] > max_var ) :
INDENT max_var = arr [ j ]
pos = j
DEDENT DEDENT if ( max_var > arr [ i ] ) :
INDENT j = pos
while ( j < k - 1 ) :
INDENT arr [ j ] = arr [ j + 1 ]
j += 1
DEDENT arr [ k - 1 ] = arr [ i ]
DEDENT DEDENT for i in range ( 0, k ) :
INDENT print ( arr [ i ], end = " " )
DEDENT DEDENT

NTH_NON_FIBONACCI_NUMBER | def nonFibonacci ( n ) :
INDENT prevPrev = 1
prev = 2
curr = 3
while n > 0 :
INDENT prevPrev = prev
prev = curr
curr = prevPrev + prev
n = n - ( curr - prev - 1 )
DEDENT n = n + ( curr - prev - 1 )
return prev + n
DEDENT

ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS | def search ( arr, n, x ) :
INDENT i = 0
for i in range ( i, n ) :
INDENT if ( arr [ i ] == x ) :
INDENT return i
DEDENT DEDENT return - 1
DEDENT

ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION | def nearestSmallerEqFib ( n ) :
INDENT if ( n == 0 or n == 1 ) :
INDENT return n
DEDENT f1, f2, f3 = 0, 1, 1
while ( f3 <= n ) :
INDENT f1 = f2;

f2 = f3;

f3 = f1 + f2;

DEDENT return f2;

DEDENT

PRINT_MAXIMUM_SHORTEST_DISTANCE | def find_maximum ( a, n, k ) :
INDENT b = dict ( )
for i in range ( n ) :
INDENT x = a [ i ]
d = min ( 1 + i, n - i )
if x not in b . keys ( ) :
INDENT b [ x ] = d
DEDENT else :
INDENT b [ x ] = min ( d, b [ x ] )
DEDENT DEDENT ans = 10 * * 9
for i in range ( n ) :
INDENT x = a [ i ]
if ( x != ( k - x ) and ( k - x ) in b . keys ( ) ) :
INDENT ans = min ( max ( b [ x ], b [ k - x ] ), ans )
DEDENT DEDENT return ans
DEDENT

GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOGRAPHIC_ORDER | def generate ( st, s ) :
INDENT if len ( s ) == 0 :
INDENT return
DEDENT if s not in st :
INDENT st . add ( s )
for i in range ( len ( s ) ) :
INDENT t = list ( s ) . copy ( )
t . remove ( s [ i ] )
t = '' . join ( t )
generate ( st, t )
DEDENT DEDENT return
DEDENT

WRITE_YOU_OWN_POWER_WITHOUT_USING_MULTIPLICATION_AND_DIVISION | def pow ( a, b ) :
INDENT if ( b == 0 ) :
INDENT return 1
DEDENT answer = a
increment = a
for i in range ( 1, b ) :
INDENT for j in range ( 1, a ) :
INDENT answer += increment
DEDENT increment = answer
DEDENT return answer
DEDENT

MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1 | def maxvolume ( s ) :
INDENT length = int ( s / 3 )
s -= length
breadth = s / 2
height = s - breadth
return int ( length * breadth * height )
DEDENT

HORNERS_METHOD_POLYNOMIAL_EVALUATION | def horner ( poly, n, x ) :
INDENT result = poly [ 0 ]
for i in range ( 1, n ) :
INDENT result = result * x + poly [ i ]
DEDENT return result
DEDENT

MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS | def minTime ( arr, n, m ) :
INDENT t = 0
while ( 1 ) :
INDENT items = 0
for i in range ( n ) :
INDENT items += ( t //arr[i])
DEDENTif(items>=m):
INDENTreturnt
DEDENTt+=1
DEDENTDEDENT


FIND_DIFFERENCE_BETWEEN_SUMS_OF_TWO_DIAGONALS | def difference ( arr, n ) :
INDENT d1 = 0
d2 = 0
for i in range ( 0, n ) :
INDENT for j in range ( 0, n ) :
INDENT if ( i == j ) :
INDENT d1 += arr [ i ] [ j ]
DEDENT if ( i == n - j - 1 ) :
INDENT d2 += arr [ i ] [ j ]
DEDENT DEDENT DEDENT return abs ( d1 - d2 );

DEDENT

SHORTEST_UNCOMMON_SUBSEQUENCE | def shortestSeq ( S : list, T : list ) :
INDENT m = len ( S )
n = len ( T )
dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ]
for i in range ( m + 1 ) :
INDENT dp [ i ] [ 0 ] = 1
DEDENT for i in range ( n + 1 ) :
INDENT dp [ 0 ] [ i ] = MAX
DEDENT for i in range ( 1, m + 1 ) :
INDENT for j in range ( 1, n + 1 ) :
INDENT ch = S [ i - 1 ]
k = j - 1
while k >= 0 :
INDENT if T [ k ] == ch :
INDENT break
DEDENT k -= 1
DEDENT if k == - 1 :
INDENT dp [ i ] [ j ] = 1
DEDENT else :
INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ], dp [ i - 1 ] [ k ] + 1 )
DEDENT DEDENT DEDENT ans = dp [ m ] [ n ]
if ans >= MAX :
INDENT ans = - 1
DEDENT return ans
DEDENT

MIN_FLIPS_OF_CONTINUOUS_CHARACTERS_TO_MAKE_ALL_CHARACTERS_SAME_IN_A_STRING | def findFlips ( str, n ) :
INDENT last = ' '
res = 0
for i in range ( n ) :
INDENT if ( last != str [ i ] ) :
INDENT res += 1
DEDENT last = str [ i ]
DEDENT return res //2
DEDENT


DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME | def findMinInsertions ( str, l, h ) :
INDENT if ( l > h ) :
INDENT return sys . maxsize
DEDENT if ( l == h ) :
INDENT return 0
DEDENT if ( l == h - 1 ) :
INDENT return 0 if ( str [ l ] == str [ h ] ) else 1
DEDENT if ( str [ l ] == str [ h ] ) :
INDENT return findMinInsertions ( str, l + 1, h - 1 )
DEDENT else :
INDENT return ( min ( findMinInsertions ( str, l, h - 1 ), findMinInsertions ( str, l + 1, h ) ) + 1 )
DEDENT DEDENT

COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS | def countPairs ( str1 ) :
INDENT result = 0;

n = len ( str1 )
for i in range ( 0, n ) :
INDENT for j in range ( i + 1, n ) :
INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) :
INDENT result += 1;

DEDENT DEDENT DEDENT return result;

DEDENT

MULTISTAGE_GRAPH_SHORTEST_PATH | def shortestDist ( graph ) :
INDENT global INF
dist = [ 0 ] * N
dist [ N - 1 ] = 0
for i in range ( N - 2, - 1, - 1 ) :
INDENT dist [ i ] = INF
for j in range ( N ) :
INDENT if graph [ i ] [ j ] == INF :
INDENT continue
DEDENT dist [ i ] = min ( dist [ i ], graph [ i ] [ j ] + dist [ j ] )
DEDENT DEDENT return dist [ 0 ]
DEDENT

MAXIMUM_SIZE_SUB_MATRIX_WITH_ALL_1S_IN_A_BINARY_MATRIX | def printMaxSubSquare ( M ) :
INDENT R = len ( M )
C = len ( M [ 0 ] )
S = [ [ 0 for k in range ( C ) ] for l in range ( R ) ]
for i in range ( 1, R ) :
INDENT for j in range ( 1, C ) :
INDENT if ( M [ i ] [ j ] == 1 ) :
INDENT S [ i ] [ j ] = min ( S [ i ] [ j - 1 ], S [ i - 1 ] [ j ], S [ i - 1 ] [ j - 1 ] ) + 1
DEDENT else :
INDENT S [ i ] [ j ] = 0
DEDENT DEDENT DEDENT max_of_s = S [ 0 ] [ 0 ]
max_i = 0
max_j = 0
for i in range ( R ) :
INDENT for j in range ( C ) :
INDENT if ( max_of_s < S [ i ] [ j ] ) :
INDENT max_of_s = S [ i ] [ j ]
max_i = i
max_j = j
DEDENT DEDENT DEDENT print ( "Maximum size sub-matrix is: " )
for i in range ( max_i, max_i - max_of_s, - 1 ) :
INDENT for j in range ( max_j, max_j - max_of_s, - 1 ) :
INDENT print ( M [ i ] [ j ], end = " " )
DEDENT print ( "" )
DEDENT DEDENT

GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST_X | def printClosest ( arr, n, x ) :
INDENT res_l, res_r = 0, 0
l, r, diff = 0, n - 1, MAX_VAL
while r > l :
INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff :
INDENT res_l = l
res_r = r
diff = abs ( arr [ l ] + arr [ r ] - x )
DEDENT if arr [ l ] + arr [ r ] > x :
INDENT r -= 1
DEDENT else :
INDENT l += 1
DEDENT DEDENT print ( 'The closest pair is {} and {}' . format ( arr [ res_l ], arr [ res_r ] ) )
DEDENT

SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1 | def sortedAfterSwap ( A, B, n ) :
INDENT for i in range ( 0, n - 1 ) :
INDENT if B [ i ] :
INDENT if A [ i ] != i + 1 :
INDENT A [ i ], A [ i + 1 ] = A [ i + 1 ], A [ i ]
DEDENT DEDENT DEDENT for i in range ( n ) :
INDENT if A [ i ] != i + 1 :
INDENT return False
DEDENT DEDENT return True
DEDENT

TILE_STACKING_PROBLEM | def possibleWays ( n, m, k ) :
INDENT dp = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ]
presum = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ]
for i in range ( 1, n + 1 ) :
INDENT dp [ 0 ] [ i ] = 0
presum [ 0 ] [ i ] = 1
DEDENT for i in range ( 0, m + 1 ) :
INDENT presum [ i ] [ 0 ] = 1
dp [ i ] [ 0 ] = 1
DEDENT for i in range ( 1, m + 1 ) :
INDENT for j in range ( 1, n + 1 ) :
INDENT dp [ i ] [ j ] = presum [ i - 1 ] [ j ]
if j > k :
INDENT dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ]
DEDENT DEDENT for j in range ( 1, n + 1 ) :
INDENT presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ]
DEDENT DEDENT return dp [ m ] [ n ]
DEDENT

NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT | def sumEqualProduct ( a, n ) :
INDENT zero = 0
two = 0
for i in range ( n ) :
INDENT if a [ i ] == 0 :
INDENT zero += 1
DEDENT if a [ i ] == 2 :
INDENT two += 1
DEDENT DEDENT cnt = ( zero * ( zero - 1 ) ) //2+\
INDENT(two*(two-1))//2
DEDENTreturncnt
DEDENT


DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING | def minPalPartion ( str ) :
INDENT n = len ( str )
C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]
P = [ [ False for i in range ( n ) ] for i in range ( n ) ]
j = 0
k = 0
L = 0
for i in range ( n ) :
INDENT P [ i ] [ i ] = True;

C [ i ] [ i ] = 0;

DEDENT for L in range ( 2, n + 1 ) :
INDENT for i in range ( n - L + 1 ) :
INDENT j = i + L - 1
if L == 2 :
INDENT P [ i ] [ j ] = ( str [ i ] == str [ j ] )
DEDENT else :
INDENT P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] )
DEDENT if P [ i ] [ j ] == True :
INDENT C [ i ] [ j ] = 0
DEDENT else :
INDENT C [ i ] [ j ] = 100000000
for k in range ( i, j ) :
INDENT C [ i ] [ j ] = min ( C [ i ] [ j ], C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 )
DEDENT DEDENT DEDENT DEDENT return C [ 0 ] [ n - 1 ]
DEDENT

FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY | def findRepeatingNumber ( arr, n ) :
INDENT sq = sqrt ( n )
range__ = int ( ( n / sq ) + 1 )
count = [ 0 for i in range ( range__ ) ]
for i in range ( 0, n + 1, 1 ) :
INDENT count [ int ( ( arr [ i ] - 1 ) / sq ) ] += 1
DEDENT selected_block = range__ - 1
for i in range ( 0, range__ - 1, 1 ) :
INDENT if ( count [ i ] > sq ) :
INDENT selected_block = i
break
DEDENT DEDENT m = {
  i : 0 for i in range ( n ) }
  
  for i in range ( 0, n + 1, 1 ) :
  INDENT if ( ( ( selected_block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) :
  INDENT m [ arr [ i ] ] += 1
  if ( m [ arr [ i ] ] > 1 ) :
  INDENT return arr [ i ]
  DEDENT DEDENT DEDENT return - 1
  DEDENT

MINIMUM_SUM_PATH_TRIANGLE | def minSumPath ( A ) :
INDENT memo = [ None ] * len ( A )
n = len ( A ) - 1
for i in range ( len ( A [ n ] ) ) :
INDENT memo [ i ] = A [ n ] [ i ]
DEDENT for i in range ( len ( A ) - 2, - 1, - 1 ) :
INDENT for j in range ( len ( A [ i ] ) ) :
INDENT memo [ j ] = A [ i ] [ j ] + min ( memo [ j ], memo [ j + 1 ] );

DEDENT DEDENT return memo [ 0 ]
DEDENT

HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT_1 | def getSum ( n ) :
INDENT sum = 0
while ( n > 0 ) :
INDENT sum += int ( n % 10 )
n = int ( n / 10 )
DEDENT return sum
DEDENT

RECURSION | def printFun ( test ) :
INDENT if ( test < 1 ) :
INDENT return
DEDENT else :
INDENT print ( test, end = " " )
printFun ( test - 1 )
print ( test, end = " " )
return
DEDENT DEDENT

MAXIMUM_TRIPLET_SUM_ARRAY | def maxTripletSum ( arr, n ) :
INDENT sm = - 1000000
for i in range ( 0, n ) :
INDENT for j in range ( i + 1, n ) :
INDENT for k in range ( j + 1, n ) :
INDENT if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) :
INDENT sm = arr [ i ] + arr [ j ] + arr [ k ]
DEDENT DEDENT DEDENT DEDENT return sm
DEDENT

MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1 | def minJumps ( arr, n ) :
INDENT jumps = [ 0 for i in range ( n ) ]
if ( n == 0 ) or ( arr [ 0 ] == 0 ) :
INDENT return float ( 'inf' )
DEDENT jumps [ 0 ] = 0
for i in range ( 1, n ) :
INDENT jumps [ i ] = float ( 'inf' )
for j in range ( i ) :
INDENT if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( 'inf' ) ) :
INDENT jumps [ i ] = min ( jumps [ i ], jumps [ j ] + 1 )
break
DEDENT DEDENT DEDENT return jumps [ n - 1 ]
DEDENT

MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER | def findMaxVal ( arr, n, num, maxLimit ) :
INDENT ind = - 1;

val = - 1;

dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in range ( n ) ];

for ind in range ( n ) :
INDENT for val in range ( maxLimit + 1 ) :
INDENT if ( ind == 0 ) :
INDENT if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) :
INDENT dp [ ind ] [ val ] = 1;

DEDENT else :
INDENT dp [ ind ] [ val ] = 0;

DEDENT DEDENT else :
INDENT if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) :
INDENT if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) :
INDENT dp [ ind ] [ val ] = 1;

DEDENT DEDENT elif ( val - arr [ ind ] >= 0 ) :
INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ];

DEDENT elif ( val + arr [ ind ] <= maxLimit ) :
INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ];

DEDENT else :
INDENT dp [ ind ] [ val ] = 0;

DEDENT DEDENT DEDENT DEDENT for val in range ( maxLimit, - 1, - 1 ) :
INDENT if ( dp [ n - 1 ] [ val ] == 1 ) :
INDENT return val;

DEDENT DEDENT return - 1;

DEDENT

PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM | def Resources ( process, need ) :
INDENT minResources = 0
minResources = process * ( need - 1 ) + 1
return minResources
DEDENT

NUMBER_DIGITS_PRODUCT_TWO_NUMBERS | def countDigits ( a, b ) :
INDENT count = 0
p = abs ( a * b )
if ( p == 0 ) :
INDENT return 1
DEDENT while ( p > 0 ) :
INDENT count = count + 1
p = p //10
DEDENTreturncount
DEDENT


FLOOR_IN_A_SORTED_ARRAY | def floorSearch ( arr, low, high, x ) :
INDENT if ( low > high ) :
INDENT return - 1
DEDENT if ( x >= arr [ high ] ) :
INDENT return high
DEDENT mid = int ( ( low + high ) / 2 )
if ( arr [ mid ] == x ) :
INDENT return mid
DEDENT if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) :
INDENT return mid - 1
DEDENT if ( x < arr [ mid ] ) :
INDENT return floorSearch ( arr, low, mid - 1, x )
DEDENT return floorSearch ( arr, mid + 1, high, x )
DEDENT

CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN | def checkValidity ( a, b, c ) :
INDENT if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) :
INDENT return False
DEDENT else :
INDENT return True
DEDENT DEDENT

PRINT_N_X_N_SPIRAL_MATRIX_USING_O1_EXTRA_SPACE | def printSpiral ( n ) :
INDENT for i in range ( 0, n ) :
INDENT for j in range ( 0, n ) :
INDENT x = min ( min ( i, j ), min ( n - 1 - i, n - 1 - j ) )
if ( i <= j ) :
INDENT print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ), end = "\t" )
DEDENT else :
INDENT print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ), end = "\t" )
DEDENT DEDENT print ( )
DEDENT DEDENT

POSITION_ELEMENT_STABLE_SORT | def getIndexInSortedArray ( arr, n, idx ) :
INDENT result = 0
for i in range ( n ) :
INDENT if ( arr [ i ] < arr [ idx ] ) :
INDENT result += 1
DEDENT if ( arr [ i ] == arr [ idx ] and i < idx ) :
INDENT result += 1
DEDENT DEDENT return result;

DEDENT

MAXIMUM_SEGMENT_VALUE_PUTTING_K_BREAKPOINTS_NUMBER | def findMaxSegment ( s, k ) :
INDENT seg_len = len ( s ) - k
res = 0
for i in range ( seg_len ) :
INDENT res = res * 10 + ( ord ( s [ i ] ) - ord ( '0' ) )
DEDENT seg_len_pow = pow ( 10, seg_len - 1 )
curr_val = res
for i in range ( 1, len ( s ) - seg_len ) :
INDENT curr_val = curr_val - ( ord ( s [ i - 1 ] ) - ord ( '0' ) ) * seg_len_pow
curr_val = ( curr_val * 10 + ( ord ( s [ i + seg_len - 1 ] ) - ord ( '0' ) ) )
res = max ( res, curr_val )
DEDENT return res
DEDENT

FINDING_POWER_PRIME_NUMBER_P_N_1 | def PowerOFPINnfactorial ( n, p ) :
INDENT ans = 0
temp = p
while ( temp <= n ) :
INDENT ans += n / temp
temp = temp * p
DEDENT return int ( ans )
DEDENT

PROGRAM_PRINT_IDENTITY_MATRIX | def Identity ( size ) :
INDENT for row in range ( 0, size ) :
INDENT for col in range ( 0, size ) :
INDENT if ( row == col ) :
INDENT print ( "1 ", end = " " )
DEDENT else :
INDENT print ( "0 ", end = " " )
DEDENT DEDENT print ( )
DEDENT DEDENT

SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN | def findSum ( N ) :
INDENT ans = 0
for i in range ( 1, N + 1 ) :
INDENT for j in range ( 1, N + 1 ) :
INDENT ans += i //j
DEDENTDEDENTreturnans
DEDENT


TILING_WITH_DOMINOES | def countWays ( n ) :
INDENT A = [ 0 ] * ( n + 1 )
B = [ 0 ] * ( n + 1 )
A [ 0 ] = 1
A [ 1 ] = 0
B [ 0 ] = 0
B [ 1 ] = 1
for i in range ( 2, n + 1 ) :
INDENT A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ]
B [ i ] = A [ i - 1 ] + B [ i - 2 ]
DEDENT return A [ n ]
DEDENT

COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION | def countDer ( n ) :
INDENT if ( n == 1 ) : return 0
if ( n == 0 ) : return 1
if ( n == 2 ) : return 1
return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) )
DEDENT

FREQUENCY_ELEMENT_UNSORTED_ARRAY_1 | def countFreq ( a, n ) :
INDENT hm = dict ( )
for i in range ( n ) :
INDENT hm [ a [ i ] ] = hm . get ( a [ i ], 0 ) + 1
DEDENT cumul = 0
for i in range ( n ) :
INDENT cumul += hm [ a [ i ] ]
if ( hm [ a [ i ] ] > 0 ) :
INDENT print ( a [ i ], "->", cumul )
DEDENT hm [ a [ i ] ] = 0
DEDENT DEDENT

MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N | def minSum ( n ) :
INDENT sum = 0;

while ( n > 0 ) :
INDENT sum += ( n % 10 );

n //=10;
DEDENTif(sum==1):
INDENTreturn10;
DEDENTreturnsum;
DEDENT


DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM | def maximizecube ( l, b, h ) :
INDENT side = gcd ( l, gcd ( b, h ) )
num = int ( l / side )
num = int ( num * b / side )
num = int ( num * h / side )
print ( side, num )
DEDENT

CHECK_NUMBER_POWER_K_USING_BASE_CHANGING_METHOD | def isPowerOfK ( n, k ) :
INDENT oneSeen = False
while ( n > 0 ) :
INDENT digit = n % k
if ( digit > 1 ) :
INDENT return False
DEDENT if ( digit == 1 ) :
INDENT if ( oneSeen ) :
INDENT return False
DEDENT oneSeen = True
DEDENT n //=k
DEDENTreturnTrue
DEDENT


POSITION_OF_RIGHTMOST_SET_BIT_1 | def PositionRightmostSetbit ( n ) :
INDENT position = 1
m = 1
while ( not ( n & m ) ) :
INDENT m = m << 1
position += 1
DEDENT return position
DEDENT

SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1 | def insertSorted ( arr, n, key, capacity ) :
INDENT if ( n >= capacity ) :
INDENT return n
DEDENT i = n - 1
while i >= 0 and arr [ i ] > key :
INDENT arr [ i + 1 ] = arr [ i ]
i -= 1
DEDENT arr [ i + 1 ] = key
return ( n + 1 )
DEDENT

FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN_ARRAY_1 | def printMaxOfMin ( arr, n ) :
INDENT s = [ ]
left = [ - 1 ] * ( n + 1 )
right = [ n ] * ( n + 1 )
for i in range ( n ) :
INDENT while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) :
INDENT s . pop ( )
DEDENT if ( len ( s ) != 0 ) :
INDENT left [ i ] = s [ - 1 ]
DEDENT s . append ( i )
DEDENT while ( len ( s ) != 0 ) :
INDENT s . pop ( )
DEDENT for i in range ( n - 1, - 1, - 1 ) :
INDENT while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) :
INDENT s . pop ( )
DEDENT if ( len ( s ) != 0 ) :
INDENT right [ i ] = s [ - 1 ]
DEDENT s . append ( i )
DEDENT ans = [ 0 ] * ( n + 1 )
for i in range ( n + 1 ) :
INDENT ans [ i ] = 0
DEDENT for i in range ( n ) :
INDENT Len = right [ i ] - left [ i ] - 1
ans [ Len ] = max ( ans [ Len ], arr [ i ] )
DEDENT for i in range ( n - 1, 0, - 1 ) :
INDENT ans [ i ] = max ( ans [ i ], ans [ i + 1 ] )
DEDENT for i in range ( 1, n + 1 ) :
INDENT print ( ans [ i ], end = " " )
DEDENT DEDENT

MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1 | def MaximumDecimalValue ( mat, n ) :
INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]
if ( mat [ 0 ] [ 0 ] == 1 ) :
INDENT dp [ 0 ] [ 0 ] = 1
DEDENT for i in range ( 1, n ) :
INDENT if ( mat [ 0 ] [ i ] == 1 ) :
INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 * * i
DEDENT else :
INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ]
DEDENT DEDENT for i in range ( 1, n ) :
INDENT if ( mat [ i ] [ 0 ] == 1 ) :
INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 * * i
DEDENT DEDENT else :
INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]
DEDENT for i in range ( 1, n ) :
INDENT for j in range ( 1, n ) :
INDENT if ( mat [ i ] [ j ] == 1 ) :
INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ] ) + ( 2 * * ( i + j ) )
DEDENT else :
INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ] )
DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ]
DEDENT

COUNT_NUMBER_OF_WAYS_TO_COVER_A_DISTANCE | def printCountRec ( dist ) :
INDENT if dist < 0 :
INDENT return 0
DEDENT if dist == 0 :
INDENT return 1
DEDENT return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) )
DEDENT

MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED | def segregateElements ( arr, n ) :
INDENT temp = [ 0 for k in range ( n ) ]
j = 0
for i in range ( n ) :
INDENT if ( arr [ i ] >= 0 ) :
INDENT temp [ j ] = arr [ i ]
j += 1
DEDENT DEDENT if ( j == n or j == 0 ) :
INDENT return
DEDENT for i in range ( n ) :
INDENT if ( arr [ i ] < 0 ) :
INDENT temp [ j ] = arr [ i ]
j += 1
DEDENT DEDENT for k in range ( n ) :
INDENT arr [ k ] = temp [ k ]
DEDENT DEDENT

MINIMUM_PERIMETER_N_BLOCKS | def minPerimeter ( n ) :
INDENT l = math . sqrt ( n )
sq = l * l
if ( sq == n ) :
INDENT return l * 4
DEDENT else :
INDENT row = n / l
perimeter = 2 * ( l + row )
if ( n % l != 0 ) :
INDENT perimeter += 2
DEDENT return perimeter
DEDENT DEDENT

DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT | def maxProd ( n ) :
INDENT if ( n == 0 or n == 1 ) :
INDENT return 0
DEDENT max_val = 0
for i in range ( 1, n - 1 ) :
INDENT max_val = max ( max_val, max ( i * ( n - i ), maxProd ( n - i ) * i ) )
DEDENT return max_val;

DEDENT

LONGEST_COMMON_SUBSTRING_SPACE_OPTIMIZED_DP_SOLUTION | def LCSubStr ( X, Y ) :
INDENT m = len ( X )
n = len ( Y )
result = 0
len_mat = np . zeros ( ( 2, n ) )
currRow = 0
for i in range ( m ) :
INDENT for j in range ( n ) :
INDENT if ( i == 0 | j == 0 ) :
INDENT len_mat [ currRow ] [ j ] = 0
DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) :
INDENT len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] + 1
result = max ( result, len_mat [ currRow ] [ j ] )
DEDENT else :
INDENT len_mat [ currRow ] [ j ] = 0
DEDENT DEDENT currRow = 1 - currRow
DEDENT return result
DEDENT

CHECK_GIVEN_STRING_ROTATION_PALINDROME | def isPalindrome ( string ) :
INDENT l = 0
h = len ( string ) - 1
while h > l :
INDENT l += 1
h -= 1
if string [ l - 1 ] != string [ h + 1 ] :
INDENT return False
DEDENT DEDENT return True
DEDENT

FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_1 | def countSol ( coeff, n, rhs ) :
INDENT dp = [ 0 for i in range ( rhs + 1 ) ]
dp [ 0 ] = 1
for i in range ( n ) :
INDENT for j in range ( coeff [ i ], rhs + 1 ) :
INDENT dp [ j ] += dp [ j - coeff [ i ] ]
DEDENT DEDENT return dp [ rhs ]
DEDENT

FIND_THE_LARGEST_PAIR_SUM_IN_AN_UNSORTED_ARRAY | def findLargestSumPair ( arr, n ) :
INDENT if arr [ 0 ] > arr [ 1 ] :
INDENT first = arr [ 0 ]
second = arr [ 1 ]
DEDENT else :
INDENT first = arr [ 1 ]
second = arr [ 0 ]
DEDENT for i in range ( 2, n ) :
INDENT if arr [ i ] > first :
INDENT second = first
first = arr [ i ]
DEDENT elif arr [ i ] > second and arr [ i ] != first :
INDENT second = arr [ i ]
DEDENT DEDENT return ( first + second )
DEDENT

FIND_BITONIC_POINT_GIVEN_BITONIC_SEQUENCE | def binarySearch ( arr, left, right ) :
INDENT if ( left <= right ) :
INDENT mid = ( left + right ) //2;
if(arr[mid-1]<arr[mid]andarr[mid]>arr[mid+1]):
INDENTreturnmid;
DEDENTif(arr[mid]<arr[mid+1]):
INDENTreturnbinarySearch(arr,mid+1,right);
DEDENTelse:
INDENTreturnbinarySearch(arr,left,mid-1);
DEDENTDEDENTreturn-1;
DEDENT


PRINT_ALL_DISTINCT_CHARACTERS_OF_A_STRING_IN_ORDER_3_METHODS_1 | def printDistinct ( Str ) :
INDENT n = len ( Str )
count = [ 0 for i in range ( MAX_CHAR ) ]
index = [ n for i in range ( MAX_CHAR ) ]
for i in range ( n ) :
INDENT x = ord ( Str [ i ] )
count [ x ] += 1
if ( count [ x ] == 1 and x != ' ' ) :
INDENT index [ x ] = i
DEDENT if ( count [ x ] == 2 ) :
INDENT index [ x ] = n
DEDENT DEDENT index = sorted ( index )
for i in range ( MAX_CHAR ) :
INDENT if index [ i ] == n :
INDENT break
DEDENT print ( Str [ index [ i ] ], end = "" )
DEDENT DEDENT

FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE | def printOtherSides ( n ) :
INDENT if ( n & 1 ) :
INDENT if ( n == 1 ) :
INDENT print ( - 1 )
DEDENT else :
INDENT b = ( n * n - 1 ) //2
c=(n*n+1)//2
print("b =",b,", c =",c)
DEDENTDEDENTelse:
INDENTif(n==2):
INDENTprint(-1)
DEDENTelse:
INDENTb=n*n//4-1
c=n*n//4+1
print("b =",b", c =",c)
DEDENTDEDENTDEDENT


COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINATION | def possibleStrings ( n, r, b, g ) :
INDENT fact = [ 0 for i in range ( n + 1 ) ]
fact [ 0 ] = 1
for i in range ( 1, n + 1, 1 ) :
INDENT fact [ i ] = fact [ i - 1 ] * i
DEDENT left = n - ( r + g + b )
sum = 0
for i in range ( 0, left + 1, 1 ) :
INDENT for j in range ( 0, left - i + 1, 1 ) :
INDENT k = left - ( i + j )
sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) )
DEDENT DEDENT return sum
DEDENT

REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_1 | def rearrange ( arr, n ) :
INDENT max_ele = arr [ n - 1 ]
min_ele = arr [ 0 ]
for i in range ( n ) :
INDENT if i % 2 == 0 :
INDENT arr [ i ] = max_ele
max_ele -= 1
DEDENT else :
INDENT arr [ i ] = min_ele
min_ele += 1
DEDENT DEDENT DEDENT

EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND | def calculateSum ( arr, n ) :
INDENT if ( n == 0 ) :
INDENT return 0
DEDENT s = arr [ 0 ]
value = int ( s )
sum = value
for i in range ( 2, n, 2 ) :
INDENT s = arr [ i ]
value = int ( s )
operation = arr [ i - 1 ] [ 0 ]
if ( operation == '+' ) :
INDENT sum += value
DEDENT else :
INDENT sum -= value
DEDENT DEDENT return sum
DEDENT

SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1 | def findSum ( n ) :
INDENT ans = 0;
temp = 0;

for i in range ( 1, n + 1 ) :
INDENT if temp < n :
INDENT temp = i - 1
num = 1
while temp < n :
INDENT if temp + i <= n :
INDENT ans += i * num
DEDENT else :
INDENT ans += ( n - temp ) * num
DEDENT temp += i
num += 1
DEDENT DEDENT DEDENT return ans
DEDENT

SHUFFLE_A_DECK_OF_CARDS_3 | def shuffle ( card, n ) :
INDENT for i in range ( n ) :
INDENT r = i + ( random . randint ( 0, 55 ) % ( 52 - i ) )
tmp = card [ i ]
card [ i ] = card [ r ]
card [ r ] = tmp
DEDENT DEDENT

DOOLITTLE_ALGORITHM_LU_DECOMPOSITION | def luDecomposition ( mat, n ) :
INDENT lower = [ [ 0 for x in range ( n ) ] for y in range ( n ) ];

upper = [ [ 0 for x in range ( n ) ] for y in range ( n ) ];

for i in range ( n ) :
INDENT for k in range ( i, n ) :
INDENT sum = 0;

for j in range ( i ) :
INDENT sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] );

DEDENT upper [ i ] [ k ] = mat [ i ] [ k ] - sum;

DEDENT for k in range ( i, n ) :
INDENT if ( i == k ) :
INDENT lower [ i ] [ i ] = 1;

DEDENT else :
INDENT sum = 0;

for j in range ( i ) :
INDENT sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] );

DEDENT lower [ k ] [ i ] = int ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] );

DEDENT DEDENT DEDENT print ( "Lower Triangular\t\tUpper Triangular" );

for i in range ( n ) :
INDENT for j in range ( n ) :
INDENT print ( lower [ i ] [ j ], end = "\t" );

DEDENT print ( "", end = "\t" );

for j in range ( n ) :
INDENT print ( upper [ i ] [ j ], end = "\t" );

DEDENT print ( "" );

DEDENT DEDENT

PROGRAM_NTH_CATALAN_NUMBER | def catalan ( n ) :
INDENT if n <= 1 :
INDENT return 1
DEDENT res = 0
for i in range ( n ) :
INDENT res += catalan ( i ) * catalan ( n - i - 1 )
DEDENT return res
DEDENT

NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3 | def divisible ( num ) :
INDENT n = len ( num );

sum = 0;

for i in range ( n ) :
INDENT sum += int ( num [ i ] );

DEDENT if ( sum % 3 == 0 ) :
INDENT return 0;

DEDENT if ( n == 1 ) :
INDENT return - 1;

DEDENT for i in range ( n ) :
INDENT if ( sum % 3 == int ( num [ i ] ) % 3 ) :
INDENT return 1;

DEDENT DEDENT if ( n == 2 ) :
INDENT return - 1;

DEDENT return 2;

DEDENT

CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1 | def isPower ( x, y ) :
INDENT res1 = math . log ( y ) / math . log ( x );

res2 = math . log ( y ) / math . log ( x );

return 1 if ( res1 == res2 ) else 0;

DEDENT

LARGEST_SUBSEQUENCE_GCD_GREATER_1 | def largestGCDSubsequence ( arr, n ) :
INDENT ans = 0
maxele = max ( arr )
for i in range ( 2, maxele + 1 ) :
INDENT count = 0
for j in range ( n ) :
INDENT if ( arr [ j ] % i == 0 ) :
INDENT count += 1
DEDENT DEDENT ans = max ( ans, count )
DEDENT return ans
DEDENT

FIND_COMMON_ELEMENT_ROWS_ROW_WISE_SORTED_MATRIX | def findCommon ( mat ) :
INDENT column = [ N - 1 ] * M
min_row = 0
while ( column [ min_row ] >= 0 ) :
INDENT for i in range ( M ) :
INDENT if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) :
INDENT min_row = i
DEDENT DEDENT eq_count = 0
for i in range ( M ) :
INDENT if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) :
INDENT if ( column [ i ] == 0 ) :
INDENT return - 1
DEDENT column [ i ] -= 1
DEDENT else :
INDENT eq_count += 1
DEDENT DEDENT if ( eq_count == M ) :
INDENT return mat [ min_row ] [ column [ min_row ] ]
DEDENT DEDENT return - 1
DEDENT

CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CONCENTRIC_CIRCLES | def checkcircle ( r, R, r1, x1, y1 ) :
INDENT dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) )
return ( dis - r1 >= R and dis + r1 <= r )
DEDENT

COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N | def countSetBits ( n ) :
INDENT i = 0
ans = 0
while ( ( 1 << i ) <= n ) :
INDENT k = 0
change = 1 << i
for j in range ( 0, n + 1 ) :
INDENT ans += k
if change == 1 :
INDENT k = not k
change = 1 << i
DEDENT else :
INDENT change -= 1
DEDENT DEDENT i += 1
DEDENT return ans
DEDENT

LONGEST_REPEATING_SUBSEQUENCE | def findLongestRepeatingSubSeq ( str ) :
INDENT n = len ( str )
dp = [ [ 0 ] * ( n + 1 ) ] * ( n + 1 )
for i in range ( 1, n + 1 ) :
INDENT for j in range ( 1, n + 1 ) :
INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) :
INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]
DEDENT else :
INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ] )
DEDENT DEDENT DEDENT return dp [ n ] [ n ]
DEDENT

FIND_THE_FIRST_MISSING_NUMBER | def findFirstMissing ( array, start, end ) :
INDENT if ( start > end ) :
INDENT return end + 1
DEDENT if ( start != array [ start ] ) :
INDENT return start;

DEDENT mid = int ( ( start + end ) / 2 )
if ( array [ mid ] == mid ) :
INDENT return findFirstMissing ( array, mid + 1, end )
DEDENT return findFirstMissing ( array, start, mid )
DEDENT

SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1 | def sortSquares ( arr, n ) :
INDENT K = 0
for K in range ( n ) :
INDENT if ( arr [ K ] >= 0 ) :
INDENT break
DEDENT DEDENT i = K - 1
j = K
ind = 0
temp = [ 0 ] * n
while ( i >= 0 and j < n ) :
INDENT if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) :
INDENT temp [ ind ] = arr [ i ] * arr [ i ]
i -= 1
DEDENT else :
INDENT temp [ ind ] = arr [ j ] * arr [ j ]
j += 1
DEDENT ind += 1
DEDENT while ( i >= 0 ) :
INDENT temp [ ind ] = arr [ i ] * arr [ i ]
i -= 1
ind += 1
DEDENT while ( j < n ) :
INDENT temp [ ind ] = arr [ j ] * arr [ j ]
j += 1
ind += 1
DEDENT for i in range ( n ) :
INDENT arr [ i ] = temp [ i ]
DEDENT DEDENT

PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR | def getRemainder ( num, divisor ) :
INDENT return ( num - divisor * ( num //divisor))
DEDENT


MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG | def MinimumCost ( cost, n, W ) :
INDENT val = list ( )
wt = list ( )
size = 0
for i in range ( n ) :
INDENT if ( cost [ i ] != - 1 ) :
INDENT val . append ( cost [ i ] )
wt . append ( i + 1 )
size += 1
DEDENT DEDENT n = size
min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ]
for i in range ( W + 1 ) :
INDENT min_cost [ 0 ] [ i ] = INF
DEDENT for i in range ( 1, n + 1 ) :
INDENT min_cost [ i ] [ 0 ] = 0
DEDENT for i in range ( 1, n + 1 ) :
INDENT for j in range ( 1, W + 1 ) :
INDENT if ( wt [ i - 1 ] > j ) :
INDENT min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ]
DEDENT else :
INDENT min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ], min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] )
DEDENT DEDENT DEDENT if ( min_cost [ n ] [ W ] == INF ) :
INDENT return - 1
DEDENT else :
INDENT return min_cost [ n ] [ W ]
DEDENT DEDENT

COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1 | def countPairs ( str1 ) :
INDENT result = 0;

n = len ( str1 )
for i in range ( 0, n ) :
INDENT for j in range ( 1, MAX_CHAR + 1 ) :
INDENT if ( ( i + j ) < n ) :
INDENT if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) :
INDENT result += 1;

DEDENT DEDENT DEDENT DEDENT return result
DEDENT

A_PRODUCT_ARRAY_PUZZLE | def productArray ( arr, n ) :
INDENT if ( n == 1 ) :
INDENT print ( 0 )
return
DEDENT left = [ 0 ] * n
right = [ 0 ] * n
prod = [ 0 ] * n
left [ 0 ] = 1
right [ n - 1 ] = 1
for i in range ( 1, n ) :
INDENT left [ i ] = arr [ i - 1 ] * left [ i - 1 ]
DEDENT for j in range ( n - 2, - 1, - 1 ) :
INDENT right [ j ] = arr [ j + 1 ] * right [ j + 1 ]
DEDENT for i in range ( n ) :
INDENT prod [ i ] = left [ i ] * right [ i ]
DEDENT for i in range ( n ) :
INDENT print ( prod [ i ], end = ' ' )
DEDENT DEDENT

FREQUENT_ELEMENT_ARRAY_1 | def mostFrequent ( arr, n ) :
INDENT Hash = dict ( )
for i in range ( n ) :
INDENT if arr [ i ] in Hash . keys ( ) :
INDENT Hash [ arr [ i ] ] += 1
DEDENT else :
INDENT Hash [ arr [ i ] ] = 1
DEDENT DEDENT max_count = 0
res = - 1
for i in Hash :
INDENT if ( max_count < Hash [ i ] ) :
INDENT res = i
max_count = Hash [ i ]
DEDENT DEDENT return res
DEDENT

PRINT_UNIQUE_ROWS | def printArray ( matrix ) :
INDENT rowCount = len ( matrix )
if rowCount == 0 :
INDENT return
DEDENT columnCount = len ( matrix [ 0 ] )
if columnCount == 0 :
INDENT return
DEDENT row_output_format = " " . join ( [ "%s" ] * columnCount )
printed = {
}

for row in matrix :
INDENT routput = row_output_format % tuple ( row )
if routput not in printed :
INDENT printed [ routput ] = True
print ( routput )
DEDENT DEDENT DEDENT

COUNT_1S_SORTED_BINARY_ARRAY | def countOnes ( arr, low, high ) :
INDENT if high >= low :
INDENT mid = low + ( high - low ) / 2
if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) :
INDENT return mid + 1
DEDENT if arr [ mid ] == 1 :
INDENT return countOnes ( arr, ( mid + 1 ), high )
DEDENT return countOnes ( arr, low, mid - 1 )
DEDENT return 0
DEDENT

POSSIBLE_MOVES_KNIGHT | def findPossibleMoves ( mat, p, q ) :
INDENT global n, m;

X = [ 2, 1, - 1, - 2, - 2, - 1, 1, 2 ];

Y = [ 1, 2, 2, 1, - 1, - 2, - 2, - 1 ];

count = 0;

for i in range ( 8 ) :
INDENT x = p + X [ i ];

y = q + Y [ i ];

if ( x >= 0 and y >= 0 and x < n and y < m and mat [ x ] [ y ] == 0 ) :
INDENT count += 1;

DEDENT DEDENT return count;

DEDENT

ROTATE_MATRIX_ELEMENTS | def rotateMatrix ( mat ) :
INDENT if not len ( mat ) :
INDENT return
DEDENT top = 0
bottom = len ( mat ) - 1
left = 0
right = len ( mat [ 0 ] ) - 1
while left < right and top < bottom :
INDENT prev = mat [ top + 1 ] [ left ]
for i in range ( left, right + 1 ) :
INDENT curr = mat [ top ] [ i ]
mat [ top ] [ i ] = prev
prev = curr
DEDENT top += 1
for i in range ( top, bottom + 1 ) :
INDENT curr = mat [ i ] [ right ]
mat [ i ] [ right ] = prev
prev = curr
DEDENT right -= 1
for i in range ( right, left - 1, - 1 ) :
INDENT curr = mat [ bottom ] [ i ]
mat [ bottom ] [ i ] = prev
prev = curr
DEDENT bottom -= 1
for i in range ( bottom, top - 1, - 1 ) :
INDENT curr = mat [ i ] [ left ]
mat [ i ] [ left ] = prev
prev = curr
DEDENT left += 1
DEDENT return mat
DEDENT

FIND_KTH_CHARACTER_OF_DECRYPTED_STRING | def encodedChar ( str, k ) :
INDENT expand = ""
freq = 0
i = 0
while ( i < len ( str ) ) :
INDENT temp = ""
freq = 0
while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( 'a' ) and ord ( str [ i ] ) <= ord ( 'z' ) ) :
INDENT temp += str [ i ]
i += 1
DEDENT while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '1' ) and ord ( str [ i ] ) <= ord ( '9' ) ) :
INDENT freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' )
i += 1
DEDENT for j in range ( 1, freq + 1, 1 ) :
INDENT expand += temp
DEDENT DEDENT if ( freq == 0 ) :
INDENT expand += temp
DEDENT return expand [ k - 1 ]
DEDENT

EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_IS_1 | def search ( arr, n, x ) :
INDENT i = 0
while ( i <= n - 1 ) :
INDENT if ( arr [ i ] == x ) :
INDENT return i
DEDENT i += abs ( arr [ i ] - x )
DEDENT return - 1
DEDENT

MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQUE | def returnMaxSum ( A, B, n ) :
INDENT mp = set ( )
result = 0
curr_sum = curr_begin = 0
for i in range ( 0, n ) :
INDENT while A [ i ] in mp :
INDENT mp . remove ( A [ curr_begin ] )
curr_sum -= B [ curr_begin ]
curr_begin += 1
DEDENT mp . add ( A [ i ] )
curr_sum += B [ i ]
result = max ( result, curr_sum )
DEDENT return result
DEDENT

WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF_3 | def isMultipleOf3 ( n ) :
INDENT odd_count = 0
even_count = 0
if ( n < 0 ) :
INDENT n = - n
DEDENT if ( n == 0 ) :
INDENT return 1
DEDENT if ( n == 1 ) :
INDENT return 0
DEDENT while ( n ) :
INDENT if ( n & 1 ) :
INDENT odd_count += 1
DEDENT if ( n & 2 ) :
INDENT even_count += 1
DEDENT n = n >> 2
DEDENT return isMultipleOf3 ( abs ( odd_count - even_count ) )
DEDENT

MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1 | def maxSum ( arr, n ) :
INDENT cum_sum = 0
for i in range ( 0, n ) :
INDENT cum_sum += arr [ i ]
DEDENT curr_val = 0
for i in range ( 0, n ) :
INDENT curr_val += i * arr [ i ]
DEDENT res = curr_val
for i in range ( 1, n ) :
INDENT next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) )
curr_val = next_val
res = max ( res, next_val )
DEDENT return res
DEDENT

DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING | def carAssembly ( a, t, e, x ) :
INDENT NUM_STATION = len ( a [ 0 ] )
T1 = [ 0 for i in range ( NUM_STATION ) ]
T2 = [ 0 for i in range ( NUM_STATION ) ]
T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ]
T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ]
for i in range ( 1, NUM_STATION ) :
INDENT T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ], T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] )
T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ], T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] )
DEDENT return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ], T2 [ NUM_STATION - 1 ] + x [ 1 ] )
DEDENT

PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT | def printSpiral ( mat, r, c ) :
INDENT a = 0
b = 2
low_row = 0 if ( 0 > a ) else a
low_column = 0 if ( 0 > b ) else b - 1
high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1
high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1
while ( ( low_row > 0 - r and low_column > 0 - c ) ) :
INDENT i = low_column + 1
while ( i <= high_column and i < c and low_row >= 0 ) :
INDENT print ( mat [ low_row ] [ i ], end = " " )
i += 1
DEDENT low_row -= 1
i = low_row + 2
while ( i <= high_row and i < r and high_column < c ) :
INDENT print ( mat [ i ] [ high_column ], end = " " )
i += 1
DEDENT high_column += 1
i = high_column - 2
while ( i >= low_column and i >= 0 and high_row < r ) :
INDENT print ( mat [ high_row ] [ i ], end = " " )
i -= 1
DEDENT high_row += 1
i = high_row - 2
while ( i > low_row and i >= 0 and low_column >= 0 ) :
INDENT print ( mat [ i ] [ low_column ], end = " " )
i -= 1
DEDENT low_column -= 1
DEDENT print ( )
DEDENT

MID_POINT_CIRCLE_DRAWING_ALGORITHM | def midPointCircleDraw ( x_centre, y_centre, r ) :
INDENT x = r
y = 0
print ( "(", x + x_centre, ", ", y + y_centre, ")", sep = "", end = "" )
if ( r > 0 ) :
INDENT print ( "(", x + x_centre, ", ", - y + y_centre, ")", sep = "", end = "" )
print ( "(", y + x_centre, ", ", x + y_centre, ")", sep = "", end = "" )
print ( "(", - y + x_centre, ", ", x + y_centre, ")", sep = "" )
DEDENT P = 1 - r
while ( x > y ) :
INDENT y += 1
if ( P <= 0 ) :
INDENT P = P + 2 * y + 1
DEDENT else :
INDENT x -= 1
P = P + 2 * y - 2 * x + 1
DEDENT if ( x < y ) :
INDENT break
DEDENT print ( "(", x + x_centre, ", ", y + y_centre, ")", sep = "", end = "" )
print ( "(", - x + x_centre, ", ", y + y_centre, ")", sep = "", end = "" )
print ( "(", x + x_centre, ", ", - y + y_centre, ")", sep = "", end = "" )
print ( "(", - x + x_centre, ", ", - y + y_centre, ")", sep = "" )
if ( x != y ) :
INDENT print ( "(", y + x_centre, ", ", x + y_centre, ")", sep = "", end = "" )
print ( "(", - y + x_centre, ", ", x + y_centre, ")", sep = "", end = "" )
print ( "(", y + x_centre, ", ", - x + y_centre, ")", sep = "", end = "" )
print ( "(", - y + x_centre, ", ", - x + y_centre, ")", sep = "" )
DEDENT DEDENT DEDENT

SMALLEST_ELEMENT_REPEATED_EXACTLY_K_TIMES_NOT_LIMITED_SMALL_RANGE | def smallestKFreq ( arr, n, k ) :
INDENT mp = defaultdict ( lambda : 0 )
for i in range ( n ) :
INDENT mp [ arr [ i ] ] += 1
DEDENT res = sys . maxsize
res1 = sys . maxsize
for key, values in mp . items ( ) :
INDENT if values == k :
INDENT res = min ( res, key )
DEDENT DEDENT return res if res != res1 else - 1
DEDENT

MINIMUM_XOR_VALUE_PAIR | def minXOR ( arr, n ) :
INDENT arr . sort ( );

min_xor = 999999
val = 0
for i in range ( 0, n - 1 ) :
INDENT for j in range ( i + 1, n - 1 ) :
INDENT val = arr [ i ] ^ arr [ j ]
min_xor = min ( min_xor, val )
DEDENT DEDENT return min_xor
DEDENT

MIRROR_CHARACTERS_STRING | def compute ( st, n ) :
INDENT reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba"
l = len ( st )
answer = ""
for i in range ( 0, n ) :
INDENT answer = answer + st [ i ];

DEDENT for i in range ( n, l ) :
INDENT answer = ( answer + reverseAlphabet [ ord ( st [ i ] ) - ord ( 'a' ) ] );

DEDENT return answer;

DEDENT

PROGRAM_CHECK_PLUS_PERFECT_NUMBER | def checkplusperfect ( x ) :
INDENT temp = x
n = 0
while ( x != 0 ) :
INDENT x = x //10
n=n+1
DEDENTx=temp
sm=0
while(x!=0):
INDENTsm=sm+(int)(math.pow(x%10,n))
x=x//10
DEDENTreturn(sm==temp)
DEDENT


ARC_LENGTH_ANGLE | def arcLength ( diameter, angle ) :
INDENT if angle >= 360 :
INDENT print ( "Angle cannot be formed" )
return 0
DEDENT else :
INDENT arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 )
return arc
DEDENT DEDENT

FIND_LAST_INDEX_CHARACTER_STRING | def findLastIndex ( str, x ) :
INDENT index = - 1
for i in range ( 0, len ( str ) ) :
INDENT if str [ i ] == x :
INDENT index = i
DEDENT DEDENT return index
DEDENT

COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER | def findTrailingZeros ( n ) :
INDENT count = 0
i = 5
while ( n / i >= 1 ) :
INDENT count += int ( n / i )
i *= 5
DEDENT return int ( count )
DEDENT

ROTATE_MATRIX_180_DEGREE | def rotateMatrix ( mat ) :
INDENT i = N - 1;

while ( i >= 0 ) :
INDENT j = N - 1;

while ( j >= 0 ) :
INDENT print ( mat [ i ] [ j ], end = " " );

j = j - 1;

DEDENT print ( );

i = i - 1;

DEDENT DEDENT

SUM_FIBONACCI_NUMBERS | def calculateSum ( n ) :
INDENT if ( n <= 0 ) :
INDENT return 0
DEDENT fibo = [ 0 ] * ( n + 1 )
fibo [ 1 ] = 1
sm = fibo [ 0 ] + fibo [ 1 ]
for i in range ( 2, n + 1 ) :
INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ]
sm = sm + fibo [ i ]
DEDENT return sm
DEDENT

LARGEST_LEXICOGRAPHIC_ARRAY_WITH_AT_MOST_K_CONSECUTIVE_SWAPS | def KSwapMaximum ( n, k ) :
INDENT global arr
for i in range ( 0, n - 1 ) :
INDENT if ( k > 0 ) :
INDENT indexPosition = i
for j in range ( i + 1, n ) :
INDENT if ( k <= j - i ) :
INDENT break
DEDENT if ( arr [ j ] > arr [ indexPosition ] ) :
INDENT indexPosition = j
DEDENT DEDENT for j in range ( indexPosition, i, - 1 ) :
INDENT t = arr [ j ]
arr [ j ] = arr [ j - 1 ]
arr [ j - 1 ] = t
DEDENT k = k - indexPosition - i
DEDENT DEDENT DEDENT

FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT | def check ( n ) :
INDENT return 1162261467 % n == 0
DEDENT

FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY | def printRepeating ( arr, size ) :
INDENT print ( "Repeating elements are ", end = '' )
for i in range ( 0, size ) :
INDENT for j in range ( i + 1, size ) :
INDENT if arr [ i ] == arr [ j ] :
INDENT print ( arr [ i ], end = ' ' )
DEDENT DEDENT DEDENT DEDENT

C_PROGRAM_FIND_AREA_TRIANGLE | def findArea ( a, b, c ) :
INDENT if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) ) :
INDENT print ( 'Not a valid trianglen' )
return
DEDENT s = ( a + b + c ) / 2
area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) * * 0.5
print ( 'Area of a traingle is %f' % area )
DEDENT

GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1 | def isSubSeqDivisible ( str ) :
INDENT n = len ( str )
dp = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 ) ]
arr = [ 0 for i in range ( n + 1 ) ]
for i in range ( 1, n + 1 ) :
INDENT arr [ i ] = int ( str [ i - 1 ] );

DEDENT for i in range ( 1, n + 1 ) :
INDENT dp [ i ] [ arr [ i ] % 8 ] = 1;

for j in range ( 8 ) :
INDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) :
INDENT dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ]
DEDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) :
INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ]
DEDENT DEDENT DEDENT for i in range ( 1, n + 1 ) :
INDENT if ( dp [ i ] [ 0 ] == 1 ) :
INDENT return True
DEDENT DEDENT return False
DEDENT

DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_SMALLER | def deleteElements ( arr, n, k ) :
INDENT st = [ ]
st . append ( arr [ 0 ] )
top = 0
count = 0
for i in range ( 1, n ) :
INDENT while ( len ( st ) != 0 and count < k and st [ top ] < arr [ i ] ) :
INDENT st . pop ( )
count += 1
top -= 1
DEDENT st . append ( arr [ i ] )
top += 1
DEDENT for i in range ( 0, len ( st ) ) :
INDENT print ( st [ i ], " ", end = "" )
DEDENT DEDENT

MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE | def smallestSubWithSum ( arr, n, x ) :
INDENT curr_sum = 0
min_len = n + 1
start = 0
end = 0
while ( end < n ) :
INDENT while ( curr_sum <= x and end < n ) :
INDENT curr_sum += arr [ end ]
end += 1
DEDENT while ( curr_sum > x and start < n ) :
INDENT if ( end - start < min_len ) :
INDENT min_len = end - start
DEDENT curr_sum -= arr [ start ]
start += 1
DEDENT DEDENT return min_len
DEDENT

FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1 | def findPair ( arr, n ) :
INDENT s = {
  i : 1 for i in arr }
  
  found = False
  for i in range ( n ) :
  INDENT for j in range ( i + 1, n ) :
  INDENT if arr [ i ] + arr [ j ] in s . keys ( ) :
  INDENT print ( arr [ i ], arr [ j ] )
  found = True
  DEDENT DEDENT DEDENT if found == False :
  INDENT print ( "Not exist" )
  DEDENT DEDENT

COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY | def numofAP ( a, n ) :
INDENT minarr = + 2147483647
maxarr = - 2147483648
for i in range ( n ) :
INDENT minarr = min ( minarr, a [ i ] )
maxarr = max ( maxarr, a [ i ] )
DEDENT dp = [ 0 for i in range ( n + 1 ) ]
ans = n + 1
for d in range ( ( minarr - maxarr ), ( maxarr - minarr ) + 1 ) :
INDENT sum = [ 0 for i in range ( MAX + 1 ) ]
for i in range ( n ) :
INDENT dp [ i ] = 1
if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 ) :
INDENT dp [ i ] += sum [ a [ i ] - d ]
DEDENT ans += dp [ i ] - 1
sum [ a [ i ] ] += dp [ i ]
DEDENT DEDENT return ans
DEDENT

COUNT_NUMBERS_THAT_DONT_CONTAIN_3 | def count ( n ) :
INDENT if n < 3 :
INDENT return n
DEDENT elif n >= 3 and n < 10 :
INDENT return n - 1
DEDENT po = 1
while n / po > 9 :
INDENT po = po * 10
DEDENT msd = n / po
if msd != 3 :
INDENT return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po )
DEDENT else :
INDENT return count ( msd * po - 1 )
DEDENT DEDENT

PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2 | def transpose ( A ) :
INDENT for i in range ( N ) :
INDENT for j in range ( i + 1, N ) :
INDENT A [ i ] [ j ], A [ j ] [ i ] = A [ j ] [ i ], A [ i ] [ j ]
DEDENT DEDENT DEDENT

SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX | def spiralDiaSum ( n ) :
INDENT if n == 1 :
INDENT return 1
DEDENT return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) )
DEDENT

COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY | def getInvCount ( arr ) :
INDENT n = len ( arr )
invcount = 0
for i in range ( 0, n - 1 ) :
INDENT for j in range ( i + 1, n ) :
INDENT if arr [ i ] > arr [ j ] :
INDENT for k in range ( j + 1, n ) :
INDENT if arr [ j ] > arr [ k ] :
INDENT invcount += 1
DEDENT DEDENT DEDENT DEDENT DEDENT return invcount
DEDENT

FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE | def SumNodes ( l ) :
INDENT leafNodeCount = pow ( 2, l - 1 )
vec = [ [ ] for i in range ( l ) ]
for i in range ( 1, leafNodeCount + 1 ) :
INDENT vec [ l - 1 ] . append ( i )
DEDENT for i in range ( l - 2, - 1, - 1 ) :
INDENT k = 0
while ( k < len ( vec [ i + 1 ] ) - 1 ) :
INDENT vec [ i ] . append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] )
k += 2
DEDENT DEDENT Sum = 0
for i in range ( l ) :
INDENT for j in range ( len ( vec [ i ] ) ) :
INDENT Sum += vec [ i ] [ j ]
DEDENT DEDENT return Sum
DEDENT

SUM_OF_ALL_PROPER_DIVISORS_OF_A_NATURAL_NUMBER | def divSum ( num ) :
INDENT result = 0
i = 2
while i <= ( math . sqrt ( num ) ) :
INDENT if ( num % i == 0 ) :
INDENT if ( i == ( num / i ) ) :
INDENT result = result + i;

DEDENT else :
INDENT result = result + ( i + num / i );

DEDENT DEDENT i = i + 1
DEDENT return ( result + 1 );

DEDENT

FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_2 | def find3Numbers ( A, arr_size, sum ) :
INDENT for i in range ( 0, arr_size - 1 ) :
INDENT s = set ( )
curr_sum = sum - A [ i ]
for j in range ( i + 1, arr_size ) :
INDENT if ( curr_sum - A [ j ] ) in s :
INDENT print ( "Triplet is", A [ i ], ", ", A [ j ], ", ", curr_sum - A [ j ] )
return True
DEDENT s . add ( A [ j ] )
DEDENT DEDENT return False
DEDENT

NTH_EVEN_LENGTH_PALINDROME | def evenlength ( n ) :
INDENT res = n
for j in range ( len ( n ) - 1, - 1, - 1 ) :
INDENT res += n [ j ]
DEDENT return res
DEDENT

FINDING_POWER_PRIME_NUMBER_P_N | def PowerOFPINnfactorial ( n, p ) :
INDENT ans = 0;

temp = p;

while ( temp <= n ) :
INDENT ans += n / temp;

temp = temp * p;

DEDENT return ans;

DEDENT

MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K | def solve ( X, Y, l, r, k, dp ) :
INDENT if k == 0 :
INDENT return 0
DEDENT if l < 0 or r < 0 :
INDENT return 1000000000
DEDENT if dp [ l ] [ r ] [ k ] != - 1 :
INDENT return dp [ l ] [ r ] [ k ]
DEDENT cost = ( ( ord ( X [ l ] ) - ord ( 'a' ) ) ^ ( ord ( Y [ r ] ) - ord ( 'a' ) ) )
dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X, Y, l - 1, r - 1, k - 1, dp ), solve ( X, Y, l - 1, r, k, dp ), solve ( X, Y, l, r - 1, k, dp ) ] )
return dp [ l ] [ r ] [ k ]
DEDENT

PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES | def printString ( str, ch, count ) :
INDENT occ, i = 0, 0
if ( count == 0 ) :
INDENT print ( str )
DEDENT for i in range ( len ( str ) ) :
INDENT if ( str [ i ] == ch ) :
INDENT occ += 1
DEDENT if ( occ == count ) :
INDENT break
DEDENT DEDENT if ( i < len ( str ) - 1 ) :
INDENT print ( str [ i + 1 : len ( str ) - i + 2 ] )
DEDENT else :
INDENT print ( "Empty string" )
DEDENT DEDENT

SORT_1_N_SWAPPING_ADJACENT_ELEMENTS | def sortedAfterSwap ( A, B, n ) :
INDENT for i in range ( 0, n - 1 ) :
INDENT if ( B [ i ] == 1 ) :
INDENT j = i
while ( B [ j ] == 1 ) :
INDENT j = j + 1
DEDENT A = A [ 0 : i ] + sorted ( A [ i : j + 1 ] ) + A [ j + 1 : ]
i = j
DEDENT DEDENT for i in range ( 0, n ) :
INDENT if ( A [ i ] != i + 1 ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

GENERATE_PYTHAGOREAN_TRIPLETS | def pythagoreanTriplets ( limits ) :
INDENT c, m = 0, 2
while c < limits :
INDENT for n in range ( 1, m ) :
INDENT a = m * m - n * n
b = 2 * m * n
c = m * m + n * n
if c > limits :
INDENT break
DEDENT print ( a, b, c )
DEDENT m = m + 1
DEDENT DEDENT

COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS | def countSeq ( n, diff ) :
INDENT if ( abs ( diff ) > n ) :
INDENT return 0
DEDENT if ( n == 1 and diff == 0 ) :
INDENT return 2
DEDENT if ( n == 1 and abs ( diff ) == 1 ) :
INDENT return 1
DEDENT res = ( countSeq ( n - 1, diff + 1 ) + 2 * countSeq ( n - 1, diff ) + countSeq ( n - 1, diff - 1 ) )
return res
DEDENT

POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES | def isPossibleTriangle ( arr, N ) :
INDENT if N < 3 :
INDENT return False
DEDENT arr . sort ( )
for i in range ( N - 2 ) :
INDENT if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] :
INDENT return True
DEDENT DEDENT DEDENT

PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_ANOTHER | def printInSortedOrder ( arr, n ) :
INDENT index = [ 0 ] * n
for i in range ( n ) :
INDENT index [ i ] = i
DEDENT for i in range ( n - 1 ) :
INDENT min = i
for j in range ( i + 1, n ) :
INDENT if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) :
INDENT min = j
DEDENT DEDENT if ( min != i ) :
INDENT index [ min ], index [ i ] = index [ i ], index [ min ]
DEDENT DEDENT for i in range ( n ) :
INDENT print ( arr [ index [ i ] ], end = " " )
DEDENT DEDENT

GAME_REPLACING_ARRAY_ELEMENTS | def playGame ( arr, n ) :
INDENT s = set ( )
for i in range ( n ) :
INDENT s . add ( arr [ i ] )
DEDENT return 1 if len ( s ) % 2 == 0 else 2
DEDENT

BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS | def gcd ( a, b ) :
INDENT if a == 0 :
INDENT return b
DEDENT return gcd ( b % a, a )
DEDENT

SORT_ARRAY_WAVE_FORM_2_1 | def sortInWave ( arr, n ) :
INDENT for i in range ( 0, n, 2 ) :
INDENT if ( i > 0 and arr [ i ] < arr [ i - 1 ] ) :
INDENT arr [ i ], arr [ i - 1 ] = arr [ i - 1 ], arr [ i ]
DEDENT if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) :
INDENT arr [ i ], arr [ i + 1 ] = arr [ i + 1 ], arr [ i ]
DEDENT DEDENT DEDENT

MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM | def maximumSumSubarray ( arr, n ) :
INDENT min_prefix_sum = 0
res = - math . inf
prefix_sum = [ ]
prefix_sum . append ( arr [ 0 ] )
for i in range ( 1, n ) :
INDENT prefix_sum . append ( prefix_sum [ i - 1 ] + arr [ i ] )
DEDENT for i in range ( n ) :
INDENT res = max ( res, prefix_sum [ i ] - min_prefix_sum )
min_prefix_sum = min ( min_prefix_sum, prefix_sum [ i ] )
DEDENT return res
DEDENT

STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES | def firstLetterWord ( str ) :
INDENT result = ""
v = True
for i in range ( len ( str ) ) :
INDENT if ( str [ i ] == ' ' ) :
INDENT v = True
DEDENT elif ( str [ i ] != ' ' and v == True ) :
INDENT result += ( str [ i ] )
v = False
DEDENT DEDENT return result
DEDENT

SUM_PAIRWISE_PRODUCTS_1 | def findSum ( n ) :
INDENT multiTerms = n * ( n + 1 ) //2
sm=multiTerms
foriinrange(2,n+1):
INDENTmultiTerms=multiTerms-(i-1)
sm=sm+multiTerms*i
DEDENTreturnsm
DEDENT


CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFERENCES_IS_MINIMUM_1 | def minCost ( a, n, k ) :
INDENT dp = [ [ inf for i in range ( k + 1 ) ] for j in range ( n + 1 ) ];

dp [ 0 ] [ 0 ] = 0;

for i in range ( 1, n + 1 ) :
INDENT for j in range ( 1, k + 1 ) :
INDENT for m in range ( i - 1, - 1, - 1 ) :
INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ], dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) );

DEDENT DEDENT DEDENT return dp [ n ] [ k ];

DEDENT

LEIBNIZ_HARMONIC_TRIANGLE | def LeibnizHarmonicTriangle ( n ) :
INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ];

for i in range ( 0, n + 1 ) :
INDENT for j in range ( 0, min ( i, n ) + 1 ) :
INDENT if ( j == 0 or j == i ) :
INDENT C [ i ] [ j ] = 1;

DEDENT else :
INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] );

DEDENT DEDENT DEDENT for i in range ( 1, n + 1 ) :
INDENT for j in range ( 1, i + 1 ) :
INDENT print ( "1/", end = "" );

print ( i * C [ i - 1 ] [ j - 1 ], end = " " );

DEDENT print ( );

DEDENT DEDENT

CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COUNT_ARRAY | def canMakeStr2 ( s1, s2 ) :
INDENT count = {
  s1 [ i ] : 0 for i in range ( len ( s1 ) ) }
  
  for i in range ( len ( s1 ) ) :
  INDENT count [ s1 [ i ] ] += 1
  DEDENT for i in range ( len ( s2 ) ) :
  INDENT if count [ s2 [ i ] ] == 0 :
  INDENT return False
  DEDENT count [ s2 [ i ] ] -= 1
  DEDENT return True
  DEDENT

SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K | def SumOfKsubArray ( arr, n, k ) :
INDENT Sum = 0
S = deque ( )
G = deque ( )
for i in range ( k ) :
INDENT while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) :
INDENT S . pop ( )
DEDENT while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) :
INDENT G . pop ( )
DEDENT G . append ( i )
S . append ( i )
DEDENT for i in range ( k, n ) :
INDENT Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ]
while ( len ( S ) > 0 and S [ 0 ] <= i - k ) :
INDENT S . popleft ( )
DEDENT while ( len ( G ) > 0 and G [ 0 ] <= i - k ) :
INDENT G . popleft ( )
DEDENT while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) :
INDENT S . pop ( )
DEDENT while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) :
INDENT G . pop ( )
DEDENT G . append ( i )
S . append ( i )
DEDENT Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ]
return Sum
DEDENT

LONGEST_COMMON_SUBSEQUENCE | def lcs ( X, Y, m, n ) :
INDENT if m == 0 or n == 0 :
INDENT return 0;

DEDENT elif X [ m - 1 ] == Y [ n - 1 ] :
INDENT return 1 + lcs ( X, Y, m - 1, n - 1 );

DEDENT else :
INDENT return max ( lcs ( X, Y, m, n - 1 ), lcs ( X, Y, m - 1, n ) );

DEDENT DEDENT

MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS | def findMinSum ( a, b, n ) :
INDENT a . sort ( )
b . sort ( )
sum = 0
for i in range ( n ) :
INDENT sum = sum + abs ( a [ i ] - b [ i ] )
DEDENT return sum
DEDENT

COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2 | def countSolutions ( n ) :
INDENT res = 0
x = 0
while ( x * x < n ) :
INDENT y = 0
while ( x * x + y * y < n ) :
INDENT res = res + 1
y = y + 1
DEDENT x = x + 1
DEDENT return res
DEDENT

FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL | def countOps ( A, B, m, n ) :
INDENT for i in range ( n ) :
INDENT for j in range ( m ) :
INDENT A [ i ] [ j ] -= B [ i ] [ j ];

DEDENT DEDENT for i in range ( 1, n ) :
INDENT for j in range ( 1, n ) :
INDENT if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) :
INDENT return - 1;

DEDENT DEDENT DEDENT result = 0;

for i in range ( n ) :
INDENT result += abs ( A [ i ] [ 0 ] );

DEDENT for j in range ( m ) :
INDENT result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] );

DEDENT return ( result );

DEDENT

EFFICIENTLY_FIND_FIRST_REPEATED_CHARACTER_STRING_WITHOUT_USING_ADDITIONAL_DATA_STRUCTURE_ONE_TRAVERSAL | def FirstRepeated ( string ) :
INDENT checker = 0
pos = 0
for i in string :
INDENT val = ord ( i ) - ord ( 'a' );

if ( ( checker & ( 1 << val ) ) > 0 ) :
INDENT return pos
DEDENT checker |= ( 1 << val )
pos += 1
DEDENT return - 1
DEDENT

MAXIMUM_UNIQUE_ELEMENT_EVERY_SUBARRAY_SIZE_K | def find_max ( A, N, K ) :
INDENT Count = dict ( )
for i in range ( K - 1 ) :
INDENT Count [ A [ i ] ] = Count . get ( A [ i ], 0 ) + 1
DEDENT Myset = dict ( )
for x in Count :
INDENT if ( Count [ x ] == 1 ) :
INDENT Myset [ x ] = 1
DEDENT DEDENT for i in range ( K - 1, N ) :
INDENT Count [ A [ i ] ] = Count . get ( A [ i ], 0 ) + 1
if ( Count [ A [ i ] ] == 1 ) :
INDENT Myset [ A [ i ] ] = 1
DEDENT else :
INDENT del Myset [ A [ i ] ]
DEDENT if ( len ( Myset ) == 0 ) :
INDENT print ( "Nothing" )
DEDENT else :
INDENT maxm = - 10 * * 9
for i in Myset :
INDENT maxm = max ( i, maxm )
DEDENT print ( maxm )
DEDENT x = A [ i - K + 1 ]
if x in Count . keys ( ) :
INDENT Count [ x ] -= 1
if ( Count [ x ] == 1 ) :
INDENT Myset [ x ] = 1
DEDENT if ( Count [ x ] == 0 ) :
INDENT del Myset [ x ]
DEDENT DEDENT DEDENT DEDENT

MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1 | def calculateEnergy ( mat, n ) :
INDENT tot_energy = 0
for i in range ( n ) :
INDENT for j in range ( n ) :
INDENT q = mat [ i ] [ j ] //n
i_des=q
j_des=mat[i][j]-(n*q)
tot_energy+=(abs(i_des-i)+abs(j_des-j))
DEDENTDEDENTreturntot_energy
DEDENT


LONGEST_COMMON_SUBSTRING | def LCSubStr ( X, Y, m, n ) :
INDENT LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ]
result = 0
for i in range ( m + 1 ) :
INDENT for j in range ( n + 1 ) :
INDENT if ( i == 0 or j == 0 ) :
INDENT LCSuff [ i ] [ j ] = 0
DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) :
INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1
result = max ( result, LCSuff [ i ] [ j ] )
DEDENT else :
INDENT LCSuff [ i ] [ j ] = 0
DEDENT DEDENT DEDENT return result
DEDENT

MAXIMUM_SUM_BITONIC_SUBARRAY | def maxSumBitonicSubArr ( arr, n ) :
INDENT msis = [ None ] * n
msds = [ None ] * n
max_sum = 0
msis [ 0 ] = arr [ 0 ]
for i in range ( 1, n ) :
INDENT if ( arr [ i ] > arr [ i - 1 ] ) :
INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ]
DEDENT else :
INDENT msis [ i ] = arr [ i ]
DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ]
for i in range ( n - 2, - 1, - 1 ) :
INDENT if ( arr [ i ] > arr [ i + 1 ] ) :
INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ]
DEDENT else :
INDENT msds [ i ] = arr [ i ]
DEDENT DEDENT for i in range ( n ) :
INDENT if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) :
INDENT max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] )
DEDENT DEDENT return max_sum
DEDENT

NEWMAN_CONWAY_SEQUENCE | def sequence ( n ) :
INDENT if n == 1 or n == 2 :
INDENT return 1
DEDENT else :
INDENT return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) );

DEDENT DEDENT

PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP | def printAllAPTriplets ( arr, n ) :
INDENT s = [ ];

for i in range ( 0, n - 1 ) :
INDENT for j in range ( i + 1, n ) :
INDENT diff = arr [ j ] - arr [ i ];

if ( ( arr [ i ] - diff ) in arr ) :
INDENT print ( "{} {} {}" . format ( ( arr [ i ] - diff ), arr [ i ], arr [ j ] ), end = "\n" );

DEDENT DEDENT DEDENT s . append ( arr [ i ] );

DEDENT

QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE | def countInRange ( arr, n, x, y ) :
INDENT count = 0;

for i in range ( n ) :
INDENT if ( arr [ i ] >= x and arr [ i ] <= y ) :
INDENT count += 1
DEDENT DEDENT return count
DEDENT

HIGHWAY_BILLBOARD_PROBLEM | def maxRevenue ( m, x, revenue, n, t ) :
INDENT maxRev = [ 0 ] * ( m + 1 )
nxtbb = 0;

for i in range ( 1, m + 1 ) :
INDENT if ( nxtbb < n ) :
INDENT if ( x [ nxtbb ] != i ) :
INDENT maxRev [ i ] = maxRev [ i - 1 ]
DEDENT else :
INDENT if ( i <= t ) :
INDENT maxRev [ i ] = max ( maxRev [ i - 1 ], revenue [ nxtbb ] )
DEDENT else :
INDENT maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ], maxRev [ i - 1 ] );

DEDENT nxtbb += 1
DEDENT DEDENT else :
INDENT maxRev [ i ] = maxRev [ i - 1 ]
DEDENT DEDENT return maxRev [ m ]
DEDENT

CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES | def printMat ( degseq, n ) :
INDENT mat = [ [ 0 ] * n for i in range ( n ) ]
for i in range ( n ) :
INDENT for j in range ( i + 1, n ) :
INDENT if ( degseq [ i ] > 0 and degseq [ j ] > 0 ) :
INDENT degseq [ i ] -= 1
degseq [ j ] -= 1
mat [ i ] [ j ] = 1
mat [ j ] [ i ] = 1
DEDENT DEDENT DEDENT print ( "      ", end = " " )
for i in range ( n ) :
INDENT print ( " ", "(", i, ")", end = "" )
DEDENT print ( )
print ( )
for i in range ( n ) :
INDENT print ( " ", "(", i, ")", end = "" )
for j in range ( n ) :
INDENT print ( "     ", mat [ i ] [ j ], end = "" )
DEDENT print ( )
DEDENT DEDENT

DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS | def oppositeSigns ( x, y ) :
INDENT return ( ( x ^ y ) < 0 );

DEDENT

TRIANGULAR_NUMBERS_1 | def isTriangular ( num ) :
INDENT if ( num < 0 ) :
INDENT return False
DEDENT c = ( - 2 * num )
b, a = 1, 1
d = ( b * b ) - ( 4 * a * c )
if ( d < 0 ) :
INDENT return False
DEDENT root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a )
root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a )
if ( root1 > 0 and math . floor ( root1 ) == root1 ) :
INDENT return True
DEDENT if ( root2 > 0 and math . floor ( root2 ) == root2 ) :
INDENT return True
DEDENT return False
DEDENT

FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT | def isPowerOfFour ( n ) :
INDENT if ( n == 0 ) :
INDENT return False
DEDENT while ( n != 1 ) :
INDENT if ( n % 4 != 0 ) :
INDENT return False
DEDENT n = n //4
DEDENTreturnTrue
DEDENT


LAST_NON_ZERO_DIGIT_FACTORIAL | def lastNon0Digit ( n ) :
INDENT if ( n < 10 ) :
INDENT return dig [ n ]
DEDENT if ( ( ( n //10)%10)%2==0):
INDENTreturn(6*lastNon0Digit(n//5)*dig[n%10])%10
DEDENTelse:
INDENTreturn(4*lastNon0Digit(n//5)*dig[n%10])%10
DEDENTreturn0
DEDENT


SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING | def sortByPattern ( str, pat ) :
INDENT global MAX_CHAR
count = [ 0 ] * MAX_CHAR
for i in range ( 0, len ( str ) ) :
INDENT count [ ord ( str [ i ] ) - 97 ] += 1
DEDENT index = 0;

str = ""
for i in range ( 0, len ( pat ) ) :
INDENT j = 0
while ( j < count [ ord ( pat [ i ] ) - ord ( 'a' ) ] ) :
INDENT str += pat [ i ]
j = j + 1
index += 1
DEDENT DEDENT return str
DEDENT

NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER | def minimumBox ( arr, n ) :
INDENT q = collections . deque ( [ ] )
arr . sort ( )
q . append ( arr [ 0 ] )
for i in range ( 1, n ) :
INDENT now = q [ 0 ]
if ( arr [ i ] >= 2 * now ) :
INDENT q . popleft ( )
DEDENT q . append ( arr [ i ] )
DEDENT return len ( q )
DEDENT

SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY | def binarySearch ( arr, low, high, key ) :
INDENT if ( high < low ) :
INDENT return - 1
DEDENT mid = ( low + high ) / 2
if ( key == arr [ int ( mid ) ] ) :
INDENT return mid
DEDENT if ( key > arr [ int ( mid ) ] ) :
INDENT return binarySearch ( arr, ( mid + 1 ), high, key )
DEDENT return ( binarySearch ( arr, low, ( mid - 1 ), key ) )
DEDENT

FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3 | def printRepeating ( arr, size ) :
INDENT print ( " The repeating elements are", end = " " )
for i in range ( 0, size ) :
INDENT if ( arr [ abs ( arr [ i ] ) ] > 0 ) :
INDENT arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ]
DEDENT else :
INDENT print ( abs ( arr [ i ] ), end = " " )
DEDENT DEDENT DEDENT

COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3 | def findgroups ( arr, n ) :
INDENT c = [ 0, 0, 0 ]
res = 0
for i in range ( 0, n ) :
INDENT c [ arr [ i ] % 3 ] += 1
DEDENT res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 )
res += c [ 1 ] * c [ 2 ]
res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6
res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6
res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 )
res += c [ 0 ] * c [ 1 ] * c [ 2 ]
return res
DEDENT

PRINT_STRING_IGNORING_ALTERNATE_OCCURRENCES_CHARACTER | def printStringAlternate ( string ) :
INDENT occ = {
}

for i in range ( 0, len ( string ) ) :
INDENT temp = string [ i ] . lower ( )
occ [ temp ] = occ . get ( temp, 0 ) + 1
if occ [ temp ] & 1 :
INDENT print ( string [ i ], end = "" )
DEDENT DEDENT print ( )
DEDENT

NUMBER_DAYS_TANK_WILL_BECOME_EMPTY | def minDaysToEmpty ( C, l ) :
INDENT if ( l >= C ) : return C
eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2
return math . ceil ( eq_root ) + l
DEDENT

REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE | def reversingString ( str, start, end ) :
INDENT while ( start < end ) :
INDENT str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] );

str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ end + 1 : ] );

str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] );

start += 1;

end -= 1;

DEDENT return str;

DEDENT

FREQUENCY_ELEMENT_UNSORTED_ARRAY | def countFreq ( a, n ) :
INDENT hm = {
}

for i in range ( 0, n ) :
INDENT hm [ a [ i ] ] = hm . get ( a [ i ], 0 ) + 1
DEDENT st = set ( )
for x in hm :
INDENT st . add ( ( x, hm [ x ] ) )
DEDENT cumul = 0
for x in sorted ( st ) :
INDENT cumul += x [ 1 ]
print ( x [ 0 ], cumul )
DEDENT DEDENT

FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY | def countRotations ( arr, n ) :
INDENT min = arr [ 0 ]
for i in range ( 0, n ) :
INDENT if ( min > arr [ i ] ) :
INDENT min = arr [ i ]
min_index = i
DEDENT DEDENT return min_index;

DEDENT

LONGEST_INCREASING_SUBSEQUENCE_1 | def lis ( arr ) :
INDENT n = len ( arr )
lis = [ 1 ] * n
for i in range ( 1, n ) :
INDENT for j in range ( 0, i ) :
INDENT if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 :
INDENT lis [ i ] = lis [ j ] + 1
DEDENT DEDENT DEDENT maximum = 0
for i in range ( n ) :
INDENT maximum = max ( maximum, lis [ i ] )
DEDENT return maximum
DEDENT

MEDIAN_OF_TWO_SORTED_ARRAYS | def getMedian ( ar1, ar2, n ) :
INDENT i = 0
j = 0
m1 = - 1
m2 = - 1
count = 0
while count < n + 1 :
INDENT count += 1
if i == n :
INDENT m1 = m2
m2 = ar2 [ 0 ]
break
DEDENT elif j == n :
INDENT m1 = m2
m2 = ar1 [ 0 ]
break
DEDENT if ar1 [ i ] < ar2 [ j ] :
INDENT m1 = m2
m2 = ar1 [ i ]
i += 1
DEDENT else :
INDENT m1 = m2
m2 = ar2 [ j ]
j += 1
DEDENT DEDENT return ( m1 + m2 ) / 2
DEDENT

LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION | def minLexRotation ( str_ ) :
INDENT n = len ( str_ )
arr = [ 0 ] * n
concat = str_ + str_
for i in range ( n ) :
INDENT arr [ i ] = concat [ i : n + i ]
DEDENT arr . sort ( )
return arr [ 0 ]
DEDENT

INTERPOLATION_SEARCH | def interpolationSearch ( arr, n, x ) :
INDENT lo = 0
hi = ( n - 1 )
while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] :
INDENT if lo == hi :
INDENT if arr [ lo ] == x :
INDENT return lo;

DEDENT return - 1;

DEDENT pos = lo + int ( ( ( float ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) )
if arr [ pos ] == x :
INDENT return pos
DEDENT if arr [ pos ] < x :
INDENT lo = pos + 1;

DEDENT else :
INDENT hi = pos - 1;

DEDENT DEDENT return - 1
DEDENT

COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_2 | def countPairs ( arr1, arr2, m, n, x ) :
INDENT count, l, r = 0, 0, n - 1
while ( l < m and r >= 0 ) :
INDENT if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) :
INDENT l += 1
r -= 1
count += 1
DEDENT elif ( ( arr1 [ l ] + arr2 [ r ] ) < x ) :
INDENT l += 1
DEDENT else :
INDENT r -= 1
DEDENT DEDENT return count
DEDENT

COUNT_SUBSETS_DISTINCT_EVEN_NUMBERS | def countSubSets ( arr, n ) :
INDENT us = set ( )
even_count = 0
for i in range ( n ) :
INDENT if arr [ i ] % 2 == 0 :
INDENT us . add ( arr [ i ] )
DEDENT DEDENT for i in us :
INDENT even_count += 1
DEDENT return pow ( 2, even_count ) - 1
DEDENT

COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY | def countOccurrences ( arr, n, x ) :
INDENT res = 0
for i in range ( n ) :
INDENT if x == arr [ i ] :
INDENT res += 1
DEDENT DEDENT return res
DEDENT

CONSTRUCT_THE_ROOTED_TREE_BY_USING_START_AND_FINISH_TIME_OF_ITS_DFS_TRAVERSAL | def Restore_Tree ( S, E ) :
INDENT Identity = N * [ 0 ]
for i in range ( N ) :
INDENT Identity [ Start [ i ] ] = i
DEDENT parent = N * [ - 1 ]
curr_parent = Identity [ 0 ]
for j in range ( 1, N ) :
INDENT child = Identity [ j ]
if End [ child ] - j > 1 :
INDENT parent [ child ] = curr_parent
curr_parent = child
DEDENT else :
INDENT parent [ child ] = curr_parent
while End [ child ] == End [ parent [ child ] ] :
INDENT child = parent [ child ]
curr_parent = parent [ child ]
if curr_parent == Identity [ 0 ] :
INDENT break
DEDENT DEDENT DEDENT DEDENT for i in range ( N ) :
INDENT parent [ i ] += 1
DEDENT return parent
DEDENT

NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES | def countOccurrences ( s, K ) :
INDENT n = len ( s )
c1 = 0
c2 = 0
C = 0
for i in range ( n ) :
INDENT if s [ i ] == 'a' :
INDENT c1 += 1
DEDENT if s [ i ] == 'b' :
INDENT c2 += 1
C += c1
DEDENT DEDENT return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2
DEDENT

NUMBER_SUBSTRINGS_STRING | def countNonEmptySubstr ( str ) :
INDENT n = len ( str );

return int ( n * ( n + 1 ) / 2 );

DEDENT

MAXIMUM_NUMBER_CHARACTERS_TWO_CHARACTER_STRING_1 | def maximumChars ( str1 ) :
INDENT n = len ( str1 )
res = - 1
firstInd = [ - 1 for i in range ( MAX_CHAR ) ]
for i in range ( n ) :
INDENT first_ind = firstInd [ ord ( str1 [ i ] ) ]
if ( first_ind == - 1 ) :
INDENT firstInd [ ord ( str1 [ i ] ) ] = i
DEDENT else :
INDENT res = max ( res, abs ( i - first_ind - 1 ) )
DEDENT DEDENT return res
DEDENT

SUM_SQUARES_BINOMIAL_COEFFICIENTS | def sumofsquare ( n ) :
INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]
for i in range ( 0, n + 1 ) :
INDENT for j in range ( 0, min ( i, n ) + 1 ) :
INDENT if ( j == 0 or j == i ) :
INDENT C [ i ] [ j ] = 1
DEDENT else :
INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] )
DEDENT DEDENT DEDENT sum = 0
for i in range ( 0, n + 1 ) :
INDENT sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] )
DEDENT return sum
DEDENT

PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2 | def printSubsequences ( str ) :
INDENT n = len ( str )
opsize = int ( pow ( 2, n - 1 ) )
for counter in range ( opsize ) :
INDENT for j in range ( n ) :
INDENT print ( str [ j ], end = "" )
if ( counter & ( 1 << j ) ) :
INDENT print ( " ", end = "" )
DEDENT DEDENT print ( "\n", end = "" )
DEDENT DEDENT

NON_REPEATING_ELEMENT | def firstNonRepeating ( arr, n ) :
INDENT for i in range ( n ) :
INDENT j = 0
while ( j < n ) :
INDENT if ( i != j and arr [ i ] == arr [ j ] ) :
INDENT break
DEDENT j += 1
DEDENT if ( j == n ) :
INDENT return arr [ i ]
DEDENT DEDENT return - 1
DEDENT

SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE | def calculateSum ( n ) :
INDENT sum = 0
for row in range ( n ) :
INDENT sum = sum + ( 1 << row )
DEDENT return sum
DEDENT

CHECK_TWO_STRINGS_K_ANAGRAMS_NOT | def arekAnagrams ( str1, str2, k ) :
INDENT n = len ( str1 )
if ( len ( str2 ) != n ) :
INDENT return False
DEDENT count1 = [ 0 ] * MAX_CHAR
count2 = [ 0 ] * MAX_CHAR
for i in range ( n ) :
INDENT count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1
DEDENT for i in range ( n ) :
INDENT count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1
DEDENT count = 0
for i in range ( MAX_CHAR ) :
INDENT if ( count1 [ i ] > count2 [ i ] ) :
INDENT count = count + abs ( count1 [ i ] - count2 [ i ] )
DEDENT DEDENT return ( count <= k )
DEDENT

LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS | def longestCommonSum ( arr1, arr2, n ) :
INDENT maxLen = 0
for i in range ( 0, n ) :
INDENT sum1 = 0
sum2 = 0
for j in range ( i, n ) :
INDENT sum1 += arr1 [ j ]
sum2 += arr2 [ j ]
if ( sum1 == sum2 ) :
INDENT len = j - i + 1
if ( len > maxLen ) :
INDENT maxLen = len
DEDENT DEDENT DEDENT DEDENT return maxLen
DEDENT

REMAINDER_7_LARGE_NUMBERS | def remainderWith7 ( num ) :
INDENT series = [ 1, 3, 2, - 1, - 3, - 2 ];

series_index = 0;

result = 0;

for i in range ( ( len ( num ) - 1 ), - 1, - 1 ) :
INDENT digit = ord ( num [ i ] ) - 48;

result += digit * series [ series_index ];

series_index = ( series_index + 1 ) % 6;

result %= 7;

DEDENT if ( result < 0 ) :
INDENT result = ( result + 7 ) % 7;

DEDENT return result;

DEDENT

LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C | def prevPermutation ( str ) :
INDENT n = len ( str ) - 1
i = n
while ( i > 0 and str [ i - 1 ] <= str [ i ] ) :
INDENT i -= 1
DEDENT if ( i <= 0 ) :
INDENT return False
DEDENT j = i - 1
while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) :
INDENT j += 1
DEDENT str = list ( str )
temp = str [ i - 1 ]
str [ i - 1 ] = str [ j ]
str [ j ] = temp
str = '' . join ( str )
str [ : : - 1 ]
return True, str
DEDENT

NUMBER_SUBSEQUENCES_FORM_AI_BJ_CK | def countSubsequences ( s ) :
INDENT aCount = 0
bCount = 0
cCount = 0
for i in range ( len ( s ) ) :
INDENT if ( s [ i ] == 'a' ) :
INDENT aCount = ( 1 + 2 * aCount )
DEDENT elif ( s [ i ] == 'b' ) :
INDENT bCount = ( aCount + 2 * bCount )
DEDENT elif ( s [ i ] == 'c' ) :
INDENT cCount = ( bCount + 2 * cCount )
DEDENT DEDENT return cCount
DEDENT

PROGRAM_PRINT_IDENTITY_MATRIX_1 | def isIdentity ( mat, N ) :
INDENT for row in range ( N ) :
INDENT for col in range ( N ) :
INDENT if ( row == col and mat [ row ] [ col ] != 1 ) :
INDENT return False;

DEDENT elif ( row != col and mat [ row ] [ col ] != 0 ) :
INDENT return False;

DEDENT DEDENT DEDENT return True;

DEDENT

MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1 | def maxDiff ( arr, n ) :
INDENT result = 0
arr . sort ( )
for i in range ( n - 1 ) :
INDENT if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) :
INDENT result += abs ( arr [ i ] )
DEDENT else :
INDENT pass
DEDENT DEDENT if ( arr [ n - 2 ] != arr [ n - 1 ] ) :
INDENT result += abs ( arr [ n - 1 ] )
DEDENT return result
DEDENT

PROGRAM_PRINT_SUM_GIVEN_NTH_TERM | def summingSeries ( n ) :
INDENT S = 0
for i in range ( 1, n + 1 ) :
INDENT S += i * i - ( i - 1 ) * ( i - 1 )
DEDENT return S
DEDENT

PREFIX_SUM_2D_ARRAY | def prefixSum2D ( a ) :
INDENT global C, R
psa = [ [ 0 for x in range ( C ) ] for y in range ( R ) ]
psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ]
for i in range ( 1, C ) :
INDENT psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] )
DEDENT for i in range ( 0, R ) :
INDENT psa [ i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] )
DEDENT for i in range ( 1, R ) :
INDENT for j in range ( 1, C ) :
INDENT psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] )
DEDENT DEDENT for i in range ( 0, R ) :
INDENT for j in range ( 0, C ) :
INDENT print ( psa [ i ] [ j ], end = " " )
DEDENT print ( )
DEDENT DEDENT

MAXIMUM_NUMBER_2X2_SQUARES_CAN_FIT_INSIDE_RIGHT_ISOSCELES_TRIANGLE | def numberOfSquares ( base ) :
INDENT base = ( base - 2 )
base = base / 2
return base * ( base + 1 ) / 2
DEDENT

GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1 | def countSubStr ( st, n ) :
INDENT m = 0
for i in range ( 0, n ) :
INDENT if ( st [ i ] == '1' ) :
INDENT m = m + 1
DEDENT DEDENT return m * ( m - 1 ) //2
DEDENT


CONVERTING_ONE_STRING_USING_APPEND_DELETE_LAST_OPERATIONS | def isConvertible ( str1, str2, k ) :
INDENT if ( ( len ( str1 ) + len ( str2 ) ) < k ) :
INDENT return True
DEDENT commonLength = 0
for i in range ( 0, min ( len ( str1 ), len ( str2 ) ), 1 ) :
INDENT if ( str1 [ i ] == str2 [ i ] ) :
INDENT commonLength += 1
DEDENT else :
INDENT break
DEDENT DEDENT if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) :
INDENT return True
DEDENT return False
DEDENT

FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2 | def getOddOccurrence ( arr ) :
INDENT res = 0
for element in arr :
INDENT res = res ^ element
DEDENT return res
DEDENT

SUM_MIDDLE_ROW_COLUMN_MATRIX | def middlesum ( mat, n ) :
INDENT row_sum = 0
col_sum = 0
for i in range ( n ) :
INDENT row_sum += mat [ n //2][i]
DEDENTprint("Sum of middle row = ",row_sum)
foriinrange(n):
INDENTcol_sum+=mat[i][n//2]
DEDENTprint("Sum of middle column = ",col_sum)
DEDENT


K_TH_DISTINCT_OR_NON_REPEATING_ELEMENT_IN_AN_ARRAY | def printKDistinct ( arr, n, k ) :
INDENT dist_count = 0
for i in range ( n ) :
INDENT j = 0
while j < n :
INDENT if ( i != j and arr [ j ] == arr [ i ] ) :
INDENT break
DEDENT j += 1
DEDENT if ( j == n ) :
INDENT dist_count += 1
DEDENT if ( dist_count == k ) :
INDENT return arr [ i ]
DEDENT DEDENT return - 1
DEDENT

MERGING_INTERVALS | def mergeIntervals ( arr ) :
INDENT arr . sort ( key = lambda x : x [ 0 ] )
m = [ ]
s = - 10000
max = - 100000
for i in range ( len ( arr ) ) :
INDENT a = arr [ i ]
if a [ 0 ] > max :
INDENT if i != 0 :
INDENT m . append ( [ s, max ] )
DEDENT max = a [ 1 ]
s = a [ 0 ]
DEDENT else :
INDENT if a [ 1 ] >= max :
INDENT max = a [ 1 ]
DEDENT DEDENT DEDENT if max != - 100000 and [ s, max ] not in m :
INDENT m . append ( [ s, max ] )
DEDENT print ( "The Merged Intervals are :", end = " " )
for i in range ( len ( m ) ) :
INDENT print ( m [ i ], end = " " )
DEDENT DEDENT

FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1 | def CountSquares ( a, b ) :
INDENT return ( math . floor ( math . sqrt ( b ) ) - math . ceil ( math . sqrt ( a ) ) + 1 )
DEDENT

LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS | def findFibSubset ( arr, n ) :
INDENT m = max ( arr )
a = 0
b = 1
hash = [ ]
hash . append ( a )
hash . append ( b )
while ( b < m ) :
INDENT c = a + b
a = b
b = c
hash . append ( b )
DEDENT for i in range ( n ) :
INDENT if arr [ i ] in hash :
INDENT print ( arr [ i ], end = " " )
DEDENT DEDENT DEDENT

LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING | def lexicographicSubConcat ( s ) :
INDENT n = len ( s );

sub_count = ( n * ( n + 1 ) ) //2;
arr=[0]*sub_count;
index=0;
foriinrange(n):
INDENTforjinrange(1,n-i+1):
INDENTarr[index]=s[i:i+j];
index+=1;
DEDENTDEDENTarr.sort();
res="";
foriinrange(sub_count):
INDENTres+=arr[i];
DEDENTreturnres;
DEDENT


COUNT_OPERATIONS_MAKE_STRINGAB_FREE | def abFree ( s ) :
INDENT b_count = 0
res = 0
for i in range ( len ( s ) ) :
INDENT if s [ ~ i ] == 'a' :
INDENT res = ( res + b_count )
b_count = ( b_count * 2 )
DEDENT else :
INDENT b_count += 1
DEDENT DEDENT return res
DEDENT

MAXIMUM_HEIGHT_OF_TRIANGULAR_ARRANGEMENT_OF_ARRAY_VALUES_1 | def MaximumHeight ( a, n ) :
INDENT return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ) //2
DEDENT


MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES | def maxvolume ( s ) :
INDENT maxvalue = 0
i = 1
for i in range ( s - 1 ) :
INDENT j = 1
for j in range ( s ) :
INDENT k = s - i - j
maxvalue = max ( maxvalue, i * j * k )
DEDENT DEDENT return maxvalue
DEDENT

PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION | def decToHexa ( n ) :
INDENT hexaDeciNum = [ '0' ] * 100;

i = 0;

while ( n != 0 ) :
INDENT temp = 0;

temp = n % 16;

if ( temp < 10 ) :
INDENT hexaDeciNum [ i ] = chr ( temp + 48 );

i = i + 1;

DEDENT else :
INDENT hexaDeciNum [ i ] = chr ( temp + 55 );

i = i + 1;

DEDENT n = int ( n / 16 );

DEDENT j = i - 1;

while ( j >= 0 ) :
INDENT print ( ( hexaDeciNum [ j ] ), end = "" );

j = j - 1;

DEDENT DEDENT

SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELEMENT | def smallestSubsegment ( a, n ) :
INDENT left = dict ( )
count = dict ( )
mx = 0
mn, strindex = 0, 0
for i in range ( n ) :
INDENT x = a [ i ]
if ( x not in count . keys ( ) ) :
INDENT left [ x ] = i
count [ x ] = 1
DEDENT else :
INDENT count [ x ] += 1
DEDENT if ( count [ x ] > mx ) :
INDENT mx = count [ x ]
mn = i - left [ x ] + 1
strindex = left [ x ]
DEDENT elif ( count [ x ] == mx and i - left [ x ] + 1 < mn ) :
INDENT mn = i - left [ x ] + 1
strindex = left [ x ]
DEDENT DEDENT for i in range ( strindex, strindex + mn ) :
INDENT print ( a [ i ], end = " " )
DEDENT DEDENT

FIND_LAST_INDEX_CHARACTER_STRING_1 | def findLastIndex ( str, x ) :
INDENT for i in range ( len ( str ) - 1, - 1, - 1 ) :
INDENT if ( str [ i ] == x ) :
INDENT return i
DEDENT DEDENT return - 1
DEDENT

RECAMANS_SEQUENCE | def recaman ( n ) :
INDENT arr = [ 0 ] * n
arr [ 0 ] = 0
print ( arr [ 0 ], end = ", " )
for i in range ( 1, n ) :
INDENT curr = arr [ i - 1 ] - i
for j in range ( 0, i ) :
INDENT if ( ( arr [ j ] == curr ) or curr < 0 ) :
INDENT curr = arr [ i - 1 ] + i
break
DEDENT DEDENT arr [ i ] = curr
print ( arr [ i ], end = ", " )
DEDENT DEDENT

C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER | def getSecondMostFreq ( str ) :
INDENT NO_OF_CHARS = 256
count = [ 0 ] * NO_OF_CHARS
for i in range ( len ( str ) ) :
INDENT count [ ord ( str [ i ] ) ] += 1
DEDENT first, second = 0, 0
for i in range ( NO_OF_CHARS ) :
INDENT if count [ i ] > count [ first ] :
INDENT second = first
first = i
DEDENT elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) :
INDENT second = i
DEDENT DEDENT return chr ( second )
DEDENT

FIND_MAXIMUM_HEIGHT_PYRAMID_FROM_THE_GIVEN_ARRAY_OF_OBJECTS | def maxLevel ( boxes, n ) :
INDENT boxes . sort ( )
ans = 1
prev_width = boxes [ 0 ]
prev_count = 1
curr_count = 0
curr_width = 0
for i in range ( 1, n ) :
INDENT curr_width += boxes [ i ]
curr_count += 1
if ( curr_width > prev_width and curr_count > prev_count ) :
INDENT prev_width = curr_width
prev_count = curr_count
curr_count = 0
curr_width = 0
ans += 1
DEDENT DEDENT return ans
DEDENT

COUNTING_INVERSIONS | def getInvCount ( arr, n ) :
INDENT inv_count = 0
for i in range ( n ) :
INDENT for j in range ( i + 1, n ) :
INDENT if ( arr [ i ] > arr [ j ] ) :
INDENT inv_count += 1
DEDENT DEDENT DEDENT return inv_count
DEDENT

SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS | def diagonalsquare ( mat, row, column ) :
INDENT print ( "Diagonal one : ", end = "" )
for i in range ( 0, row ) :
INDENT for j in range ( 0, column ) :
INDENT if ( i == j ) :
INDENT print ( "{} " . format ( mat [ i ] [ j ] * mat [ i ] [ j ] ), end = "" )
DEDENT DEDENT DEDENT print ( " \n\nDiagonal two : ", end = "" )
for i in range ( 0, row ) :
INDENT for j in range ( 0, column ) :
INDENT if ( i + j == column - 1 ) :
INDENT print ( "{} " . format ( mat [ i ] [ j ] * mat [ i ] [ j ] ), end = "" )
DEDENT DEDENT DEDENT DEDENT

ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX | def countCommon ( mat, n ) :
INDENT res = 0
for i in range ( n ) :
INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] :
INDENT res = res + 1
DEDENT DEDENT return res
DEDENT

EULERIAN_NUMBER | def eulerian ( n, m ) :
INDENT if ( m >= n or n == 0 ) :
INDENT return 0;

DEDENT if ( m == 0 ) :
INDENT return 1;

DEDENT return ( ( n - m ) * eulerian ( n - 1, m - 1 ) + ( m + 1 ) * eulerian ( n - 1, m ) )
DEDENT

EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS | def squareRootExists ( n, p ) :
INDENT n = n % p
for x in range ( 2, p, 1 ) :
INDENT if ( ( x * x ) % p == n ) :
INDENT return True
DEDENT DEDENT return False
DEDENT

COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3 | def numberOfPaths ( m, n ) :
INDENT for i in range ( n, ( m + n - 1 ) ) :
INDENT path *= i;

path //=(i-n+1);
DEDENTreturnpath;
DEDENT


MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES | def maximumDifferenceSum ( arr, N ) :
INDENT dp = [ [ 0, 0 ] for i in range ( N ) ]
for i in range ( N ) :
INDENT dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0
DEDENT for i in range ( N - 1 ) :
INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ], dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) )
dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ), dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) )
DEDENT return max ( dp [ N - 1 ] [ 0 ], dp [ N - 1 ] [ 1 ] )
DEDENT

STERN_BROCOT_SEQUENCE | def SternSequenceFunc ( BrocotSequence, n ) :
INDENT for i in range ( 1, n ) :
INDENT considered_element = BrocotSequence [ i ]
precedent = BrocotSequence [ i - 1 ]
BrocotSequence . append ( considered_element + precedent )
BrocotSequence . append ( considered_element )
DEDENT for i in range ( 0, 15 ) :
INDENT print ( BrocotSequence [ i ], end = " " )
DEDENT DEDENT

NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N | def countDivisibleSubseq ( str, n ) :
INDENT l = len ( str )
dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ]
dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1
for i in range ( 1, l ) :
INDENT dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1
for j in range ( n ) :
INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ]
dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ]
DEDENT DEDENT return dp [ l - 1 ] [ 0 ]
DEDENT

HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING | def search ( arr, x ) :
INDENT n = len ( arr )
for j in range ( 0, n ) :
INDENT if ( x == arr [ j ] ) :
INDENT return j
DEDENT DEDENT return - 1
DEDENT

COUNT_PAIRS_WITH_GIVEN_SUM_1 | def getPairsCount ( arr, n, sum ) :
INDENT m = [ 0 ] * 1000
for i in range ( 0, n ) :
INDENT m [ arr [ i ] ]
m [ arr [ i ] ] += 1
DEDENT twice_count = 0
for i in range ( 0, n ) :
INDENT twice_count += m [ sum - arr [ i ] ]
if ( sum - arr [ i ] == arr [ i ] ) :
INDENT twice_count -= 1
DEDENT DEDENT return int ( twice_count / 2 )
DEDENT

FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS | def minDist ( arr, n, x, y ) :
INDENT min_dist = 99999999
for i in range ( n ) :
INDENT for j in range ( i + 1, n ) :
INDENT if ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) :
INDENT min_dist = abs ( i - j )
DEDENT DEDENT return min_dist
DEDENT DEDENT

FIND_REPETITIVE_ELEMENT_1_N_1_2 | def findRepeating ( arr, n ) :
INDENT res = 0
for i in range ( 0, n - 1 ) :
INDENT res = res ^ ( i + 1 ) ^ arr [ i ]
DEDENT res = res ^ arr [ n - 1 ]
return res
DEDENT

SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH_1 | def shortestPath ( graph, u, v, k ) :
INDENT global V, INF
sp = [ [ None ] * V for i in range ( V ) ]
for i in range ( V ) :
INDENT for j in range ( V ) :
INDENT sp [ i ] [ j ] = [ None ] * ( k + 1 )
DEDENT DEDENT for e in range ( k + 1 ) :
INDENT for i in range ( V ) :
INDENT for j in range ( V ) :
INDENT sp [ i ] [ j ] [ e ] = INF
if ( e == 0 and i == j ) :
INDENT sp [ i ] [ j ] [ e ] = 0
DEDENT if ( e == 1 and graph [ i ] [ j ] != INF ) :
INDENT sp [ i ] [ j ] [ e ] = graph [ i ] [ j ]
DEDENT if ( e > 1 ) :
INDENT for a in range ( V ) :
INDENT if ( graph [ i ] [ a ] != INF and i != a and j != a and sp [ a ] [ j ] [ e - 1 ] != INF ) :
INDENT sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ], graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] )
DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return sp [ u ] [ v ] [ k ]
DEDENT

LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS | def longest ( a, n, k ) :
INDENT freq = [ 0 ] * n
start = 0
end = 0
now = 0
l = 0
for i in range ( n ) :
INDENT freq [ a [ i ] ] += 1
if ( freq [ a [ i ] ] == 1 ) :
INDENT now += 1
DEDENT while ( now > k ) :
INDENT freq [ a [ l ] ] -= 1
if ( freq [ a [ l ] ] == 0 ) :
INDENT now -= 1
DEDENT l += 1
DEDENT if ( i - l + 1 >= end - start + 1 ) :
INDENT end = i
start = l
DEDENT DEDENT for i in range ( start, end + 1 ) :
INDENT print ( a [ i ], end = " " )
DEDENT DEDENT

MAXIMUM_XOR_VALUE_MATRIX | def maxXOR ( mat, N ) :
INDENT max_xor = 0
for i in range ( N ) :
INDENT r_xor = 0
c_xor = 0
for j in range ( N ) :
INDENT r_xor = r_xor ^ mat [ i ] [ j ]
c_xor = c_xor ^ mat [ j ] [ i ]
DEDENT if ( max_xor < max ( r_xor, c_xor ) ) :
INDENT max_xor = max ( r_xor, c_xor )
DEDENT DEDENT return max_xor
DEDENT

LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED | def longestNull ( S ) :
INDENT arr = [ ]
arr . append ( [ '@', - 1 ] )
maxlen = 0
for i in range ( len ( S ) ) :
INDENT arr . append ( [ S [ i ], i ] )
while ( len ( arr ) >= 3 and arr [ len ( arr ) - 3 ] [ 0 ] == '1' and arr [ len ( arr ) - 2 ] [ 0 ] == '0' and arr [ len ( arr ) - 1 ] [ 0 ] == '0' ) :
INDENT arr . pop ( )
arr . pop ( )
arr . pop ( )
DEDENT tmp = arr [ - 1 ]
maxlen = max ( maxlen, i - tmp [ 1 ] )
DEDENT return maxlen
DEDENT

LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARRAY | def alternateSubarray ( arr, n ) :
INDENT len = [ ]
for i in range ( n + 1 ) :
INDENT len . append ( 0 )
DEDENT len [ n - 1 ] = 1
for i in range ( n - 2, - 1, - 1 ) :
INDENT if ( arr [ i ] ^ arr [ i + 1 ] == True ) :
INDENT len [ i ] = len [ i + 1 ] + 1
DEDENT else :
INDENT len [ i ] = 1
DEDENT DEDENT for i in range ( n ) :
INDENT print ( len [ i ], " ", end = "" )
DEDENT DEDENT

WILDCARD_CHARACTER_MATCHING | def match ( first, second ) :
INDENT if len ( first ) == 0 and len ( second ) == 0 :
INDENT return True
DEDENT if len ( first ) > 1 and first [ 0 ] == '*' and len ( second ) == 0 :
INDENT return False
DEDENT if ( len ( first ) > 1 and first [ 0 ] == '?' ) or ( len ( first ) != 0 and len ( second ) != 0 and first [ 0 ] == second [ 0 ] ) :
INDENT return match ( first [ 1 : ], second [ 1 : ] );

DEDENT if len ( first ) != 0 and first [ 0 ] == '*' :
INDENT return match ( first [ 1 : ], second ) or match ( first, second [ 1 : ] )
DEDENT return False
DEDENT

FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N | def printFactorialNums ( n ) :
INDENT fact = 1
x = 2
while fact <= n :
INDENT print ( fact, end = " " )
fact = fact * x
x += 1
DEDENT DEDENT

FRIENDS_PAIRING_PROBLEM_2 | def countFriendsPairings ( n ) :
INDENT a, b, c = 1, 2, 0;

if ( n <= 2 ) :
INDENT return n;

DEDENT for i in range ( 3, n + 1 ) :
INDENT c = b + ( i - 1 ) * a;

a = b;

b = c;

DEDENT return c;

DEDENT

FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALLOWED | def maxArea ( mat ) :
INDENT hist = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ]
for i in range ( 0, C, 1 ) :
INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ]
for j in range ( 1, R, 1 ) :
INDENT if ( ( mat [ j ] [ i ] == 0 ) ) :
INDENT hist [ j ] [ i ] = 0
DEDENT else :
INDENT hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1
DEDENT DEDENT DEDENT for i in range ( 0, R, 1 ) :
INDENT count = [ 0 for i in range ( R + 1 ) ]
for j in range ( 0, C, 1 ) :
INDENT count [ hist [ i ] [ j ] ] += 1
DEDENT col_no = 0
j = R
while ( j >= 0 ) :
INDENT if ( count [ j ] > 0 ) :
INDENT for k in range ( 0, count [ j ], 1 ) :
INDENT hist [ i ] [ col_no ] = j
col_no += 1
DEDENT DEDENT j -= 1
DEDENT DEDENT max_area = 0
for i in range ( 0, R, 1 ) :
INDENT for j in range ( 0, C, 1 ) :
INDENT curr_area = ( j + 1 ) * hist [ i ] [ j ]
if ( curr_area > max_area ) :
INDENT max_area = curr_area
DEDENT DEDENT DEDENT return max_area
DEDENT

SUM_SEQUENCE_2_22_222 | def sumOfSeries ( n ) :
INDENT return 0.0246 * ( math . pow ( 10, n ) - 1 - ( 9 * n ) )
DEDENT

PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT | def firstFit ( blockSize, m, processSize, n ) :
INDENT allocation = [ - 1 ] * n
for i in range ( n ) :
INDENT for j in range ( m ) :
INDENT if blockSize [ j ] >= processSize [ i ] :
INDENT allocation [ i ] = j
blockSize [ j ] -= processSize [ i ]
break
DEDENT DEDENT DEDENT print ( " Process No. Process Size      Block no." )
for i in range ( n ) :
INDENT print ( " ", i + 1, "         ", processSize [ i ], "         ", end = " " )
if allocation [ i ] != - 1 :
INDENT print ( allocation [ i ] + 1 )
DEDENT else :
INDENT print ( "Not Allocated" )
DEDENT DEDENT DEDENT

CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER | def isPower ( x, y ) :
INDENT if ( x == 1 ) :
INDENT return ( y == 1 )
DEDENT pow = 1
while ( pow < y ) :
INDENT pow = pow * x
DEDENT return ( pow == y )
DEDENT

DIVIDE_LARGE_NUMBER_REPRESENTED_STRING | def longDivision ( number, divisor ) :
INDENT ans = "";

idx = 0;

temp = ord ( number [ idx ] ) - ord ( '0' );

while ( temp < divisor ) :
INDENT temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) );

idx += 1;

DEDENT idx += 1;

while ( ( len ( number ) ) > idx ) :
INDENT ans += chr ( math . floor ( temp //divisor)+ord('0'));
temp=((temp%divisor)*10+ord(number[idx])-ord('0'));
idx+=1;
DEDENTans+=chr(math.floor(temp//divisor)+ord('0'));
if(len(ans)==0):
INDENTreturn"0";
DEDENTreturnans;
DEDENT


FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S | def findMax ( arr ) :
INDENT row = 0
j = N - 1
for i in range ( 0, N ) :
INDENT while ( arr [ i ] [ j ] == 1 and j >= 0 ) :
INDENT row = i
j -= 1
DEDENT DEDENT print ( "Row number = ", row + 1, ", MaxCount = ", N - 1 - j )
DEDENT

MINIMUM_ROTATIONS_REQUIRED_GET_STRING | def findRotations ( str ) :
INDENT tmp = str + str
n = len ( str )
for i in range ( 1, n + 1 ) :
INDENT substring = tmp [ i : n ]
if ( str == substring ) :
INDENT return i
DEDENT DEDENT return n
DEDENT

COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX | def numberOfPaths ( m, n ) :
INDENT if ( m == 1 or n == 1 ) :
INDENT return 1
DEDENT return numberOfPaths ( m - 1, n ) + numberOfPaths ( m, n - 1 )
DEDENT

N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_1 | def findNth ( n ) :
INDENT count = 0;

curr = 19;

while ( True ) :
INDENT sum = 0;

x = curr;

while ( x > 0 ) :
INDENT sum = sum + x % 10;

x = int ( x / 10 );

DEDENT if ( sum == 10 ) :
INDENT count += 1;

DEDENT if ( count == n ) :
INDENT return curr;

DEDENT curr += 9;

DEDENT return - 1;

DEDENT

SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1 | def sumAtKthLevel ( tree, k, i, level ) :
INDENT if ( tree [ i [ 0 ] ] == '(' ) :
INDENT i [ 0 ] += 1
if ( tree [ i [ 0 ] ] == ')' ) :
INDENT return 0
DEDENT sum = 0
if ( level == k ) :
INDENT sum = int ( tree [ i [ 0 ] ] )
DEDENT i [ 0 ] += 1
leftsum = sumAtKthLevel ( tree, k, i, level + 1 )
i [ 0 ] += 1
rightsum = sumAtKthLevel ( tree, k, i, level + 1 )
i [ 0 ] += 1
return sum + leftsum + rightsum
DEDENT DEDENT

COUNT_OFDIFFERENT_WAYS_EXPRESS_N_SUM_1_3_4 | def countWays ( n ) :
INDENT DP = [ 0 for i in range ( 0, n + 1 ) ]
DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1
DP [ 3 ] = 2
for i in range ( 4, n + 1 ) :
INDENT DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ]
DEDENT return DP [ n ]
DEDENT

MAXIMUM_EQULIBRIUM_SUM_ARRAY | def findMaxSum ( arr, n ) :
INDENT res = - sys . maxsize - 1
for i in range ( n ) :
INDENT prefix_sum = arr [ i ]
for j in range ( i ) :
INDENT prefix_sum += arr [ j ]
DEDENT suffix_sum = arr [ i ]
j = n - 1
while ( j > i ) :
INDENT suffix_sum += arr [ j ]
j -= 1
DEDENT if ( prefix_sum == suffix_sum ) :
INDENT res = max ( res, prefix_sum )
DEDENT DEDENT return res
DEDENT

STEINS_ALGORITHM_FOR_FINDING_GCD_1 | def gcd ( a, b ) :
INDENT if ( a == b ) :
INDENT return a
DEDENT if ( a == 0 ) :
INDENT return b
DEDENT if ( b == 0 ) :
INDENT return a
DEDENT if ( ( ~ a & 1 ) == 1 ) :
INDENT if ( ( b & 1 ) == 1 ) :
INDENT return gcd ( a >> 1, b )
DEDENT else :
INDENT return ( gcd ( a >> 1, b >> 1 ) << 1 )
DEDENT DEDENT if ( ( ~ b & 1 ) == 1 ) :
INDENT return gcd ( a, b >> 1 )
DEDENT if ( a > b ) :
INDENT return gcd ( ( a - b ) >> 1, b )
DEDENT return gcd ( ( b - a ) >> 1, a )
DEDENT

PROGRAM_TO_FIND_THE_VOLUME_OF_A_TRIANGULAR_PRISM | def findVolume ( l, b, h ) :
INDENT return ( ( l * b * h ) / 2 )
DEDENT

FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1 | def isRectangle ( m ) :
INDENT rows = len ( m )
if ( rows == 0 ) :
INDENT return False
DEDENT columns = len ( m [ 0 ] )
for y1 in range ( rows ) :
INDENT for x1 in range ( columns ) :
INDENT if ( m [ y1 ] [ x1 ] == 1 ) :
INDENT for y2 in range ( y1 + 1, rows ) :
INDENT for x2 in range ( x1 + 1, columns ) :
INDENT if ( m [ y1 ] [ x2 ] == 1 and m [ y2 ] [ x1 ] == 1 and m [ y2 ] [ x2 ] == 1 ) :
INDENT return True
DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return False
DEDENT

CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBER_OF_CHARACTERS | def isPossible ( str, n ) :
INDENT l = len ( str )
if ( l >= n ) :
INDENT return True
DEDENT return False
DEDENT

CHECK_STAR_GRAPH | def checkStar ( mat ) :
INDENT global size
vertexD1 = 0
vertexDn_1 = 0
if ( size == 1 ) :
INDENT return ( mat [ 0 ] [ 0 ] == 0 )
DEDENT if ( size == 2 ) :
INDENT return ( mat [ 0 ] [ 0 ] == 0 and mat [ 0 ] [ 1 ] == 1 and mat [ 1 ] [ 0 ] == 1 and mat [ 1 ] [ 1 ] == 0 )
DEDENT for i in range ( 0, size ) :
INDENT degreeI = 0
for j in range ( 0, size ) :
INDENT if ( mat [ i ] [ j ] ) :
INDENT degreeI = degreeI + 1
DEDENT DEDENT if ( degreeI == 1 ) :
INDENT vertexD1 = vertexD1 + 1
DEDENT elif ( degreeI == size - 1 ) :
INDENT vertexDn_1 = vertexDn_1 + 1
DEDENT DEDENT return ( vertexD1 == ( size - 1 ) and vertexDn_1 == 1 )
DEDENT

ROOTS_OF_UNITY | def printRoots ( n ) :
INDENT theta = math . pi * 2 / n
for k in range ( 0, n ) :
INDENT real = math . cos ( k * theta )
img = math . sin ( k * theta )
print ( real, end = " " )
if ( img >= 0 ) :
INDENT print ( " + i ", end = " " )
DEDENT else :
INDENT print ( " - i ", end = " " )
DEDENT print ( abs ( img ) )
DEDENT DEDENT

FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D | def findLargestd ( S, n ) :
INDENT found = False
S . sort ( )
for i in range ( n - 1, - 1, - 1 ) :
INDENT for j in range ( 0, n ) :
INDENT if ( i == j ) :
INDENT continue
DEDENT for k in range ( j + 1, n ) :
INDENT if ( i == k ) :
INDENT continue
DEDENT for l in range ( k + 1, n ) :
INDENT if ( i == l ) :
INDENT continue
DEDENT if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) :
INDENT found = True
return S [ i ]
DEDENT DEDENT DEDENT DEDENT DEDENT if ( found == False ) :
INDENT return - 1
DEDENT DEDENT

GIVEN_NUMBER_STRING_FIND_NUMBER_CONTIGUOUS_SUBSEQUENCES_RECURSIVELY_ADD_9_SET_2 | def count9s ( number ) :
INDENT n = len ( number )
d = [ 0 for i in range ( 9 ) ]
d [ 0 ] = 1
result = 0
mod_sum = 0
continuous_zero = 0
for i in range ( n ) :
INDENT if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) :
INDENT continuous_zero += 1
DEDENT else :
INDENT continuous_zero = 0
DEDENT mod_sum += ord ( number [ i ] ) - ord ( '0' )
mod_sum %= 9
result += d [ mod_sum ]
d [ mod_sum ] += 1
result -= continuous_zero
DEDENT return result
DEDENT

LEXICOGRAPHICAL_MAXIMUM_SUBSTRING_STRING | def LexicographicalMaxString ( str ) :
INDENT mx = ""
for i in range ( len ( str ) ) :
INDENT mx = max ( mx, str [ i : ] )
DEDENT return mx
DEDENT

CHECK_TWO_GIVEN_SETS_DISJOINT_1 | def areDisjoint ( set1, set2, m, n ) :
INDENT set1 . sort ( )
set2 . sort ( )
i = 0;
j = 0
while ( i < m and j < n ) :
INDENT if ( set1 [ i ] < set2 [ j ] ) :
INDENT i += 1
DEDENT elif ( set2 [ j ] < set1 [ i ] ) :
INDENT j += 1
DEDENT else :
INDENT return False
DEDENT DEDENT return True
DEDENT

EQUILIBRIUM_INDEX_OF_AN_ARRAY_1 | def equilibrium ( arr ) :
INDENT total_sum = sum ( arr )
leftsum = 0
for i, num in enumerate ( arr ) :
INDENT total_sum -= num
if leftsum == total_sum :
INDENT return i
DEDENT leftsum += num
DEDENT return - 1
DEDENT

AREA_CIRCUMSCRIBED_CIRCLE_SQUARE | def areacircumscribed ( a ) :
INDENT return ( a * a * ( PI / 2 ) )
DEDENT

LONGEST_REPEATING_AND_NON_OVERLAPPING_SUBSTRING | def longestRepeatedSubstring ( str ) :
INDENT n = len ( str )
LCSRe = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]
res = ""
res_length = 0
index = 0
for i in range ( 1, n + 1 ) :
INDENT for j in range ( i + 1, n + 1 ) :
INDENT if ( str [ i - 1 ] == str [ j - 1 ] and LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) :
INDENT LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1
if ( LCSRe [ i ] [ j ] > res_length ) :
INDENT res_length = LCSRe [ i ] [ j ]
index = max ( i, index )
DEDENT DEDENT else :
INDENT LCSRe [ i ] [ j ] = 0
DEDENT DEDENT DEDENT if ( res_length > 0 ) :
INDENT for i in range ( index - res_length + 1, index + 1 ) :
INDENT res = res + str [ i - 1 ]
DEDENT DEDENT return res
DEDENT

HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION | def mulmod ( a, b, mod ) :
INDENT res = 0;

a = a % mod;

while ( b > 0 ) :
INDENT if ( b % 2 == 1 ) :
INDENT res = ( res + a ) % mod;

DEDENT a = ( a * 2 ) % mod;

b //=2;
DEDENTreturnres%mod;
DEDENT


PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1 | def isProduct ( arr, n, x ) :
INDENT if n < 2 :
INDENT return False
DEDENT s = set ( )
for i in range ( 0, n ) :
INDENT if arr [ i ] == 0 :
INDENT if x == 0 :
INDENT return True
DEDENT else :
INDENT continue
DEDENT DEDENT if x % arr [ i ] == 0 :
INDENT if x //arr[i]ins:
INDENTreturnTrue
DEDENTs.add(arr[i])
DEDENTDEDENTreturnFalse
DEDENT


SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS | def kthgroupsum ( k ) :
INDENT cur = int ( ( k * ( k - 1 ) ) + 1 )
sum = 0
while k :
INDENT sum += cur
cur += 2
k = k - 1
DEDENT return sum
DEDENT

FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_1 | def findElements ( arr, n ) :
INDENT arr . sort ( )
for i in range ( 0, n - 2 ) :
INDENT print ( arr [ i ], end = " " )
DEDENT DEDENT

MINIMUM_STEPS_TO_DELETE_A_STRING_AFTER_REPEATED_DELETION_OF_PALINDROME_SUBSTRINGS | def minStepToDeleteString ( str ) :
INDENT N = len ( str )
dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ]
for l in range ( 1, N + 1 ) :
INDENT i = 0
j = l - 1
while j < N :
INDENT if ( l == 1 ) :
INDENT dp [ i ] [ j ] = 1
DEDENT else :
INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ]
if ( str [ i ] == str [ i + 1 ] ) :
INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ], dp [ i ] [ j ] )
DEDENT for K in range ( i + 2, j + 1 ) :
INDENT if ( str [ i ] == str [ K ] ) :
INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ], dp [ i ] [ j ] )
DEDENT DEDENT DEDENT i += 1
j += 1
DEDENT DEDENT return dp [ 0 ] [ N - 1 ]
DEDENT

CALCULATE_AREA_TETRAHEDRON | def vol_tetra ( side ) :
INDENT volume = ( side * * 3 / ( 6 * math . sqrt ( 2 ) ) )
return round ( volume, 2 )
DEDENT

SIEVE_OF_ATKIN | def SieveOfAtkin ( limit ) :
INDENT if ( limit > 2 ) :
INDENT print ( 2, end = " " )
DEDENT if ( limit > 3 ) :
INDENT print ( 3, end = " " )
DEDENT sieve = [ False ] * limit
for i in range ( 0, limit ) :
INDENT sieve [ i ] = False
DEDENT x = 1
while ( x * x < limit ) :
INDENT y = 1
while ( y * y < limit ) :
INDENT n = ( 4 * x * x ) + ( y * y )
if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) :
INDENT sieve [ n ] ^= True
DEDENT n = ( 3 * x * x ) + ( y * y )
if ( n <= limit and n % 12 == 7 ) :
INDENT sieve [ n ] ^= True
DEDENT n = ( 3 * x * x ) - ( y * y )
if ( x > y and n <= limit and n % 12 == 11 ) :
INDENT sieve [ n ] ^= True
DEDENT y += 1
DEDENT x += 1
DEDENT r = 5
while ( r * r < limit ) :
INDENT if ( sieve [ r ] ) :
INDENT for i in range ( r * r, limit, r * r ) :
INDENT sieve [ i ] = False
DEDENT DEDENT DEDENT for a in range ( 5, limit ) :
INDENT if ( sieve [ a ] ) :
INDENT print ( a, end = " " )
DEDENT DEDENT DEDENT

LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY | def lenghtOfLongestAP ( set, n ) :
INDENT if ( n <= 2 ) :
INDENT return n
DEDENT L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]
llap = 2
for i in range ( n ) :
INDENT L [ i ] [ n - 1 ] = 2
DEDENT for j in range ( n - 2, 0, - 1 ) :
INDENT i = j - 1
k = j + 1
while ( i >= 0 and k <= n - 1 ) :
INDENT if ( set [ i ] + set [ k ] < 2 * set [ j ] ) :
INDENT k += 1
DEDENT elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) :
INDENT L [ i ] [ j ] = 2
i -= 1
DEDENT else :
INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1
llap = max ( llap, L [ i ] [ j ] )
i -= 1
k += 1
while ( i >= 0 ) :
INDENT L [ i ] [ j ] = 2
i -= 1
DEDENT DEDENT DEDENT DEDENT return llap
DEDENT

COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS_IMMEDIATE_RIGHT_SUB_GROUP_1 | def countGroups ( position, previous_sum, length, num ) :
INDENT if ( position == length ) :
INDENT return 1
DEDENT if ( dp [ position ] [ previous_sum ] != - 1 ) :
INDENT return dp [ position ] [ previous_sum ]
DEDENT dp [ position ] [ previous_sum ] = 0
res = 0
sum = 0
for i in range ( position, length ) :
INDENT sum += ( ord ( num [ i ] ) - ord ( '0' ) )
if ( sum >= previous_sum ) :
INDENT res += countGroups ( i + 1, sum, length, num )
DEDENT DEDENT dp [ position ] [ previous_sum ] = res
return res
DEDENT

LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS_1 | def longestCommonSum ( arr1, arr2, n ) :
INDENT maxLen = 0
presum1 = presum2 = 0
diff = {
}

for i in range ( n ) :
INDENT presum1 += arr1 [ i ]
presum2 += arr2 [ i ]
curr_diff = presum1 - presum2
if curr_diff == 0 :
INDENT maxLen = i + 1
DEDENT elif curr_diff not in diff :
INDENT diff [ curr_diff ] = i
DEDENT else :
INDENT length = i - diff [ curr_diff ]
maxLen = max ( maxLen, length )
DEDENT DEDENT return maxLen
DEDENT

PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS | def printFibonacciNumbers ( n ) :
INDENT f1 = 0
f2 = 1
if ( n < 1 ) :
INDENT return
DEDENT for x in range ( 0, n ) :
INDENT print ( f2, end = " " )
next = f1 + f2
f1 = f2
f2 = next
DEDENT DEDENT

LARGEST_SUM_CONTIGUOUS_SUBARRAY_3 | def maxSubArraySum ( a, size ) :
INDENT max_so_far = - maxsize - 1
max_ending_here = 0
start = 0
end = 0
s = 0
for i in range ( 0, size ) :
INDENT max_ending_here += a [ i ]
if max_so_far < max_ending_here :
INDENT max_so_far = max_ending_here
start = s
end = i
DEDENT if max_ending_here < 0 :
INDENT max_ending_here = 0
s = i + 1
DEDENT DEDENT print ( "Maximum contiguous sum is %d" % ( max_so_far ) )
print ( "Starting Index %d" % ( start ) )
print ( "Ending Index %d" % ( end ) )
DEDENT

FIND_EQUAL_POINT_STRING_BRACKETS | def findIndex ( str ) :
INDENT l = len ( str )
open = [ None ] * ( l + 1 )
close = [ None ] * ( l + 1 )
index = - 1
open [ 0 ] = 0
close [ l ] = 0
if ( str [ 0 ] == '(' ) :
INDENT open [ 1 ] = 1
DEDENT if ( str [ l - 1 ] == ')' ) :
INDENT close [ l - 1 ] = 1
DEDENT for i in range ( 1, l ) :
INDENT if ( str [ i ] == '(' ) :
INDENT open [ i + 1 ] = open [ i ] + 1
DEDENT else :
INDENT open [ i + 1 ] = open [ i ]
DEDENT DEDENT for i in range ( l - 2, - 1, - 1 ) :
INDENT if ( str [ i ] == ')' ) :
INDENT close [ i ] = close [ i + 1 ] + 1
DEDENT else :
INDENT close [ i ] = close [ i + 1 ]
DEDENT DEDENT if ( open [ l ] == 0 ) :
INDENT return len
DEDENT if ( close [ 0 ] == 0 ) :
INDENT return 0
DEDENT for i in range ( l + 1 ) :
INDENT if ( open [ i ] == close [ i ] ) :
INDENT index = i
DEDENT DEDENT return index
DEDENT

COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1 | def countP ( n, k ) :
INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ]
for i in range ( n + 1 ) :
INDENT dp [ i ] [ 0 ] = 0
DEDENT for i in range ( k + 1 ) :
INDENT dp [ 0 ] [ k ] = 0
DEDENT for i in range ( 1, n + 1 ) :
INDENT for j in range ( 1, k + 1 ) :
INDENT if ( j == 1 or i == j ) :
INDENT dp [ i ] [ j ] = 1
DEDENT else :
INDENT dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] )
DEDENT DEDENT DEDENT return dp [ n ] [ k ]
DEDENT

LONGEST_INCREASING_SUBSEQUENCE | def lis ( arr ) :
INDENT global maximum
n = len ( arr )
maximum = 1
_lis ( arr, n )
return maximum
DEDENT

FIND_REPEATED_CHARACTER_PRESENT_FIRST_STRING | def findRepeatFirstN2 ( s ) :
INDENT p = - 1
for i in range ( len ( s ) ) :
INDENT for j in range ( i + 1, len ( s ) ) :
INDENT if ( s [ i ] == s [ j ] ) :
INDENT p = i
break
DEDENT DEDENT if ( p != - 1 ) :
INDENT break
DEDENT DEDENT return p
DEDENT

K_TH_SMALLEST_ELEMENT_REMOVING_INTEGERS_NATURAL_NUMBERS | def ksmallest ( arr, n, k ) :
INDENT b = [ 0 ] * MAX;

for i in range ( n ) :
INDENT b [ arr [ i ] ] = 1;

DEDENT for j in range ( 1, MAX ) :
INDENT if ( b [ j ] != 1 ) :
INDENT k -= 1;

DEDENT if ( k is not 1 ) :
INDENT return j;

DEDENT DEDENT DEDENT

CHECK_IF_STACK_ELEMENTS_ARE_PAIRWISE_CONSECUTIVE | def pairWiseConsecutive ( s ) :
INDENT aux = [ ]
while ( len ( s ) != 0 ) :
INDENT aux . append ( s [ - 1 ] )
s . pop ( )
DEDENT result = True
while ( len ( aux ) > 1 ) :
INDENT x = aux [ - 1 ]
aux . pop ( )
y = aux [ - 1 ]
aux . pop ( )
if ( abs ( x - y ) != 1 ) :
INDENT result = False
DEDENT s . append ( x )
s . append ( y )
DEDENT if ( len ( aux ) == 1 ) :
INDENT s . append ( aux [ - 1 ] )
DEDENT return result
DEDENT

BINARY_SEARCH_1 | def binarySearch ( arr, l, r, x ) :
INDENT while l <= r :
INDENT mid = l + ( r - l ) //2;
ifarr[mid]==x:
INDENTreturnmid
DEDENTelifarr[mid]<x:
INDENTl=mid+1
DEDENTelse:
INDENTr=mid-1
DEDENTDEDENTreturn-1
DEDENT


COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE | def findSubsequenceCount ( S, T ) :
INDENT m = len ( T )
n = len ( S )
if m > n :
INDENT return 0
DEDENT mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ]
for i in range ( 1, m + 1 ) :
INDENT mat [ i ] [ 0 ] = 0
DEDENT for j in range ( n + 1 ) :
INDENT mat [ 0 ] [ j ] = 1
DEDENT for i in range ( 1, m + 1 ) :
INDENT for j in range ( 1, n + 1 ) :
INDENT if T [ i - 1 ] != S [ j - 1 ] :
INDENT mat [ i ] [ j ] = mat [ i ] [ j - 1 ]
DEDENT else :
INDENT mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] )
DEDENT DEDENT DEDENT return mat [ m ] [ n ]
DEDENT

SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE | def swap ( xp, yp ) :
INDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]
yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]
xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]
DEDENT

POLICEMEN_CATCH_THIEVES | def policeThief ( arr, n, k ) :
INDENT i = 0
l = 0
r = 0
res = 0
thi = [ ]
pol = [ ]
while i < n :
INDENT if arr [ i ] == 'P' :
INDENT pol . append ( i )
DEDENT elif arr [ i ] == 'T' :
INDENT thi . append ( i )
DEDENT i += 1
DEDENT while l < len ( thi ) and r < len ( pol ) :
INDENT if ( abs ( thi [ l ] - pol [ r ] ) <= k ) :
INDENT res += 1
l += 1
r += 1
DEDENT elif thi [ l ] < pol [ r ] :
INDENT l += 1
DEDENT else :
INDENT r += 1
DEDENT DEDENT return res
DEDENT

LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1 | def maxLen ( arr, n ) :
INDENT hash_map = {
};

curr_sum = 0;

max_len = 0;

ending_index = - 1;

for i in range ( 0, n ) :
INDENT if ( arr [ i ] == 0 ) :
INDENT arr [ i ] = - 1;

DEDENT else :
INDENT arr [ i ] = 1;

DEDENT DEDENT for i in range ( 0, n ) :
INDENT curr_sum = curr_sum + arr [ i ];

if ( curr_sum == 0 ) :
INDENT max_len = i + 1;

ending_index = i;

DEDENT if ( curr_sum + n ) in hash_map :
INDENT max_len = max ( max_len, i - hash_map [ curr_sum + n ] )
DEDENT else :
INDENT hash_map [ curr_sum ] = i;

DEDENT DEDENT for i in range ( 0, n ) :
INDENT if ( arr [ i ] == - 1 ) :
INDENT arr [ i ] = 0;

DEDENT else :
INDENT arr [ i ] = 1;

DEDENT DEDENT print ( ending_index - max_len + 1, end = " " );

print ( "to", end = " " );

print ( ending_index );

return max_len;

DEDENT

MAXIMUM_DIFFERENCE_ZEROS_ONES_BINARY_STRING_SET_2_TIME | def findLength ( string, n ) :
INDENT current_sum = 0
max_sum = 0
for i in range ( n ) :
INDENT current_sum += ( 1 if string [ i ] == '0' else - 1 )
if current_sum < 0 :
INDENT current_sum = 0
DEDENT max_sum = max ( current_sum, max_sum )
DEDENT return max_sum if max_sum else 0
DEDENT

MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY | def findLongestConseqSubseq ( arr, n ) :
INDENT S = set ( );

for i in range ( n ) :
INDENT S . add ( arr [ i ] );

DEDENT ans = 0;

for i in range ( n ) :
INDENT if S . __contains__ ( arr [ i ] ) :
INDENT j = arr [ i ];

while ( S . __contains__ ( j ) ) :
INDENT j += 1;

DEDENT ans = max ( ans, j - arr [ i ] );

DEDENT DEDENT return ans;

DEDENT

LEXICOGRAPHICALLY_NEXT_STRING | def nextWord ( s ) :
INDENT if ( s == " " ) :
INDENT return "a"
DEDENT i = len ( s ) - 1
while ( s [ i ] == 'z' and i >= 0 ) :
INDENT i -= 1
DEDENT if ( i == - 1 ) :
INDENT s = s + 'a'
DEDENT else :
INDENT s = s . replace ( s [ i ], chr ( ord ( s [ i ] ) + 1 ), 1 )
DEDENT return s
DEDENT

SCHEDULE_JOBS_SERVER_GETS_EQUAL_LOAD | def solve ( a, b, n ) :
INDENT s = 0
for i in range ( 0, n ) :
INDENT s += a [ i ] + b [ i ]
DEDENT if n == 1 :
INDENT return a [ 0 ] + b [ 0 ]
DEDENT if s % n != 0 :
INDENT return - 1
DEDENT x = s //n
foriinrange(0,n):
INDENTifa[i]>x:
INDENTreturn-1
DEDENTifi>0:
INDENTa[i]+=b[i-1]
b[i-1]=0
DEDENTifa[i]==x:
INDENTcontinue
DEDENTy=a[i]+b[i]
ifi+1<n:
INDENTy+=b[i+1]
DEDENTify==x:
INDENTa[i]=y
b[i]=0
ifi+1<n:b[i+1]=0
continue
DEDENTifa[i]+b[i]==x:
INDENTa[i]+=b[i]
b[i]=0
continue
DEDENTifi+1<nanda[i]+b[i+1]==x:
INDENTa[i]+=b[i+1]
b[i+1]=0
continue
DEDENTreturn-1
DEDENTforiinrange(0,n):
INDENTifb[i]!=0:
INDENTreturn-1
DEDENTDEDENTreturnx
DEDENT


FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1 | def getMinNumberForPattern ( seq ) :
INDENT n = len ( seq )
if ( n >= 9 ) :
INDENT return "-1"
DEDENT result = [ None ] * ( n + 1 )
count = 1
for i in range ( n + 1 ) :
INDENT if ( i == n or seq [ i ] == 'I' ) :
INDENT for j in range ( i - 1, - 2, - 1 ) :
INDENT result [ j + 1 ] = int ( '0' + str ( count ) )
count += 1
if ( j >= 0 and seq [ j ] == 'I' ) :
INDENT break
DEDENT DEDENT DEDENT DEDENT return result
DEDENT

SHUFFLE_2N_INTEGERS_FORMAT_A1_B1_A2_B2_A3_B3_BN_WITHOUT_USING_EXTRA_SPACE | def shuffleArray ( a, n ) :
INDENT i, q, k = 0, 1, n
while ( i < n ) :
INDENT j = k
while ( j > i + q ) :
INDENT a [ j - 1 ], a [ j ] = a [ j ], a [ j - 1 ]
j -= 1
DEDENT i += 1
k += 1
q += 1
DEDENT DEDENT

FIND_REPETITIVE_ELEMENT_1_N_1_1 | def findRepeating ( arr, n ) :
INDENT s = set ( )
for i in range ( n ) :
INDENT if arr [ i ] in s :
INDENT return arr [ i ]
DEDENT s . add ( arr [ i ] )
DEDENT rteurn - 1
DEDENT

C_PROGRAM_SUBTRACTION_MATICES | def multiply ( A, B, C ) :
INDENT for i in range ( N ) :
INDENT for j in range ( N ) :
INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]
DEDENT DEDENT DEDENT

FIRST_NEGATIVE_INTEGER_EVERY_WINDOW_SIZE_K | def printFirstNegativeInteger ( arr, n, k ) :
INDENT for i in range ( 0, ( n - k + 1 ) ) :
INDENT flag = False
for j in range ( 0, k ) :
INDENT if ( arr [ i + j ] < 0 ) :
INDENT print ( arr [ i + j ], end = " " )
flag = True
break
DEDENT DEDENT if ( not ( flag ) ) :
INDENT print ( "0", end = " " )
DEDENT DEDENT DEDENT

NUMBER_FULL_BINARY_TREES_NODE_PRODUCT_CHILDREN | def numoffbt ( arr, n ) :
INDENT maxvalue = - 2147483647
minvalue = 2147483647
for i in range ( n ) :
INDENT maxvalue = max ( maxvalue, arr [ i ] )
minvalue = min ( minvalue, arr [ i ] )
DEDENT mark = [ 0 for i in range ( maxvalue + 2 ) ]
value = [ 0 for i in range ( maxvalue + 2 ) ]
for i in range ( n ) :
INDENT mark [ arr [ i ] ] = 1
value [ arr [ i ] ] = 1
DEDENT ans = 0
for i in range ( minvalue, maxvalue + 1 ) :
INDENT if ( mark [ i ] != 0 ) :
INDENT j = i + i
while ( j <= maxvalue and j //i<=i):
INDENTif(mark[j]==0):
INDENTcontinue
DEDENTvalue[j]=value[j]+(value[i]*value[j//i])
if(i!=j//i):
INDENTvalue[j]=value[j]+(value[i]*value[j//i])
DEDENTj+=i
DEDENTDEDENTans+=value[i]
DEDENTreturnans
DEDENT


TRIANGULAR_MATCHSTICK_NUMBER | def numberOfSticks ( x ) :
INDENT return ( 3 * x * ( x + 1 ) ) / 2
DEDENT

K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS | def KMaxCombinations ( A, B, N, K ) :
INDENT pq = PriorityQueue ( )
for i in range ( 0, N ) :
INDENT for j in range ( 0, N ) :
INDENT a = A [ i ] + B [ j ]
pq . put ( ( - a, a ) )
DEDENT DEDENT count = 0
while ( count < K ) :
INDENT print ( pq . get ( ) [ 1 ] )
count = count + 1
DEDENT DEDENT

CONSTRUCT_ARRAY_PAIR_SUM_ARRAY | def constructArr ( arr, pair, n ) :
INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) //2
foriinrange(1,n):
INDENTarr[i]=pair[i-1]-arr[0]
DEDENTDEDENT


CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER | def checkCorrectOrNot ( s ) :
INDENT global MAX_CHAR
count1 = [ 0 ] * MAX_CHAR
count2 = [ 0 ] * MAX_CHAR
n = len ( s )
if n == 1 :
INDENT return true
DEDENT i = 0;
j = n - 1
while ( i < j ) :
INDENT count1 [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1
count2 [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1
i += 1;
j -= 1
DEDENT for i in range ( MAX_CHAR ) :
INDENT if count1 [ i ] != count2 [ i ] :
INDENT return False
DEDENT DEDENT return True
DEDENT

MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS | def getMinDiff ( arr, n, k ) :
INDENT if ( n == 1 ) :
INDENT return 0
DEDENT arr . sort ( )
ans = arr [ n - 1 ] - arr [ 0 ]
small = arr [ 0 ] + k
big = arr [ n - 1 ] - k
if ( small > big ) :
INDENT small, big = big, small
DEDENT for i in range ( 1, n - 1 ) :
INDENT subtract = arr [ i ] - k
add = arr [ i ] + k
if ( subtract >= small or add <= big ) :
INDENT continue
DEDENT if ( big - subtract <= add - small ) :
INDENT small = subtract
DEDENT else :
INDENT big = add
DEDENT DEDENT return min ( ans, big - small )
DEDENT

MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K | def pairs ( arr, n, k ) :
INDENT smallest = 999999999999
count = 0
for i in range ( n ) :
INDENT for j in range ( i + 1, n ) :
INDENT if abs ( arr [ i ] + arr [ j ] - k ) < smallest :
INDENT smallest = abs ( arr [ i ] + arr [ j ] - k )
count = 1
DEDENT elif abs ( arr [ i ] + arr [ j ] - k ) == smallest :
INDENT count += 1
DEDENT DEDENT DEDENT print ( "Minimal Value = ", smallest )
print ( "Total Pairs = ", count )
DEDENT

SIZE_SUBARRAY_MAXIMUM_SUM | def maxSubArraySum ( a, size ) :
INDENT max_so_far = - maxsize - 1
max_ending_here = 0
start = 0
end = 0
s = 0
for i in range ( 0, size ) :
INDENT max_ending_here += a [ i ]
if max_so_far < max_ending_here :
INDENT max_so_far = max_ending_here
start = s
end = i
DEDENT if max_ending_here < 0 :
INDENT max_ending_here = 0
s = i + 1
DEDENT DEDENT return ( end - start + 1 )
DEDENT

MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1 | def getMinSquares ( n ) :
INDENT dp = [ 0, 1, 2, 3 ]
for i in range ( 4, n + 1 ) :
INDENT dp . append ( i )
for x in range ( 1, int ( ceil ( sqrt ( i ) ) ) + 1 ) :
INDENT temp = x * x;

if temp > i :
INDENT break
DEDENT else :
INDENT dp [ i ] = min ( dp [ i ], 1 + dp [ i - temp ] )
DEDENT DEDENT DEDENT return dp [ n ]
DEDENT

DIVISIBILITY_BY_7 | def isDivisibleBy7 ( num ) :
INDENT if num < 0 :
INDENT return isDivisibleBy7 ( - num )
DEDENT if ( num == 0 or num == 7 ) :
INDENT return True
DEDENT if ( num < 10 ) :
INDENT return False
DEDENT return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) )
DEDENT

POSITION_OF_RIGHTMOST_SET_BIT_2 | def Right_most_setbit ( num ) :
INDENT pos = 1
for i in range ( INT_SIZE ) :
INDENT if not ( num & ( 1 << i ) ) :
INDENT pos += 1
DEDENT else :
INDENT break
DEDENT DEDENT return pos
DEDENT

EFFICIENT_WAY_TO_MULTIPLY_WITH_7 | def multiplyBySeven ( n ) :
INDENT return ( ( n << 3 ) - n )
DEDENT

NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS | def snoob ( x ) :
INDENT next = 0
if ( x ) :
INDENT rightOne = x & - ( x )
nextHigherOneBit = x + int ( rightOne )
rightOnesPattern = x ^ int ( nextHigherOneBit )
rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) )
rightOnesPattern = int ( rightOnesPattern ) >> 2
next = nextHigherOneBit | rightOnesPattern
DEDENT return next
DEDENT

CHANGE_ARRAY_PERMUTATION_NUMBERS_1_N | def makePermutation ( a, n ) :
INDENT count = dict ( )
for i in range ( n ) :
INDENT if count . get ( a [ i ] ) :
INDENT count [ a [ i ] ] += 1
DEDENT else :
INDENT count [ a [ i ] ] = 1;

DEDENT DEDENT next_missing = 1
for i in range ( n ) :
INDENT if count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 :
INDENT count [ a [ i ] ] -= 1
while count . get ( next_missing ) :
INDENT next_missing += 1
DEDENT a [ i ] = next_missing
count [ next_missing ] = 1
DEDENT DEDENT DEDENT

MAXIMUM_AREA_QUADRILATERAL | def maxArea ( a, b, c, d ) :
INDENT semiperimeter = ( a + b + c + d ) / 2
return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) )
DEDENT

REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1 | def translate ( st ) :
INDENT l = len ( st )
if ( l < 2 ) :
INDENT return
DEDENT i = 0
j = 0
while ( j < l - 1 ) :
INDENT if ( st [ j ] == 'A' and st [ j + 1 ] == 'B' ) :
INDENT j += 2
st [ i ] = 'C'
i += 1
continue
DEDENT st [ i ] = st [ j ]
i += 1
j += 1
DEDENT if ( j == l - 1 ) :
INDENT st [ i ] = st [ j ]
i += 1
DEDENT st [ i ] = ' '
st [ l - 1 ] = ' '
DEDENT

FIND_POWER_POWER_MOD_PRIME | def calculate ( A, B, C, M ) :
INDENT res = pow ( B, C, M - 1 )
ans = pow ( A, res, M )
return ans
DEDENT

CHECK_EXIST_TWO_ELEMENTS_ARRAY_WHOSE_SUM_EQUAL_SUM_REST_ARRAY | def checkPair ( arr, n ) :
INDENT s = set ( )
sum = 0
for i in range ( n ) :
INDENT sum += arr [ i ]
DEDENT if sum % 2 != 0 :
INDENT return False
DEDENT sum = sum / 2
for i in range ( n ) :
INDENT val = sum - arr [ i ]
if arr [ i ] not in s :
INDENT s . add ( arr [ i ] )
DEDENT if val in s :
INDENT print ( "Pair elements are", arr [ i ], "and", int ( val ) )
DEDENT DEDENT DEDENT

PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON | def surface_area_octahedron ( side ) :
INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) )
DEDENT

FIND_A_SPECIFIC_PAIR_IN_MATRIX | def findMaxValue ( mat ) :
INDENT maxValue = 0
for a in range ( N - 1 ) :
INDENT for b in range ( N - 1 ) :
INDENT for d in range ( a + 1, N ) :
INDENT for e in range ( b + 1, N ) :
INDENT if maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) :
INDENT maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] );

DEDENT DEDENT DEDENT DEDENT DEDENT return maxValue;

DEDENT

MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_OPERATORS_AND_NO_LOOPS | def multiply ( x, y ) :
INDENT if ( y == 0 ) :
INDENT return 0
DEDENT if ( y > 0 ) :
INDENT return ( x + multiply ( x, y - 1 ) )
DEDENT if ( y < 0 ) :
INDENT return - multiply ( x, - y )
DEDENT DEDENT

FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1 | def findTriplets ( arr, n ) :
INDENT found = False
for i in range ( n - 1 ) :
INDENT s = set ( )
for j in range ( i + 1, n ) :
INDENT x = - ( arr [ i ] + arr [ j ] )
if x in s :
INDENT print ( x, arr [ i ], arr [ j ] )
found = True
DEDENT else :
INDENT s . add ( arr [ j ] )
DEDENT DEDENT DEDENT if found == False :
INDENT print ( "No Triplet Found" )
DEDENT DEDENT

FIND_MAXIMUM_VALUE_OF_SUM_IARRI_WITH_ONLY_ROTATIONS_ON_GIVEN_ARRAY_ALLOWED | def maxSum ( arr ) :
INDENT arrSum = 0
currVal = 0
n = len ( arr )
for i in range ( 0, n ) :
INDENT arrSum = arrSum + arr [ i ]
currVal = currVal + ( i * arr [ i ] )
DEDENT maxVal = currVal
for j in range ( 1, n ) :
INDENT currVal = currVal + arrSum - n * arr [ n - j ]
if currVal > maxVal :
INDENT maxVal = currVal
DEDENT DEDENT return maxVal
DEDENT

PROGRAM_FOR_SCALAR_MULTIPLICATION_OF_A_MATRIX | def scalarProductMat ( mat, k ) :
INDENT for i in range ( N ) :
INDENT for j in range ( N ) :
INDENT mat [ i ] [ j ] = mat [ i ] [ j ] * k
DEDENT DEDENT DEDENT

PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1 | def printSquares ( n ) :
INDENT square = 0
odd = 1
for x in range ( 0, n ) :
INDENT print ( square, end = " " )
square = square + odd
odd = odd + 2
DEDENT DEDENT

NTH_PENTAGONAL_NUMBER | def pentagonalNum ( n ) :
INDENT return ( 3 * n * n - n ) / 2
DEDENT

COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER | def numofArray ( n, m ) :
INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ]
di = [ [ ] for i in range ( MAX ) ]
mu = [ [ ] for i in range ( MAX ) ]
for i in range ( 1, m + 1 ) :
INDENT for j in range ( 2 * i, m + 1, i ) :
INDENT di [ j ] . append ( i )
mu [ i ] . append ( j )
DEDENT di [ i ] . append ( i )
DEDENT for i in range ( 1, m + 1 ) :
INDENT dp [ 1 ] [ i ] = 1
DEDENT for i in range ( 2, n + 1 ) :
INDENT for j in range ( 1, m + 1 ) :
INDENT dp [ i ] [ j ] = 0
for x in di [ j ] :
INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ]
DEDENT for x in mu [ j ] :
INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ]
DEDENT DEDENT DEDENT ans = 0
for i in range ( 1, m + 1 ) :
INDENT ans += dp [ n ] [ i ]
di [ i ] . clear ( )
mu [ i ] . clear ( )
DEDENT return ans
DEDENT

0_1_KNAPSACK_PROBLEM_DP_10 | def knapSack ( W, wt, val, n ) :
INDENT if n == 0 or W == 0 :
INDENT return 0
DEDENT if ( wt [ n - 1 ] > W ) :
INDENT return knapSack ( W, wt, val, n - 1 )
DEDENT else :
INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ], wt, val, n - 1 ), knapSack ( W, wt, val, n - 1 ) )
DEDENT DEDENT

FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO | def findTriplets ( arr, n ) :
INDENT found = True
for i in range ( 0, n - 2 ) :
INDENT for j in range ( i + 1, n - 1 ) :
INDENT for k in range ( j + 1, n ) :
INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) :
INDENT print ( arr [ i ], arr [ j ], arr [ k ] )
found = True
DEDENT DEDENT DEDENT DEDENT if ( found == False ) :
INDENT print ( " not exist " )
DEDENT DEDENT

COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME | def count ( n ) :
INDENT table = [ 0 for i in range ( n + 1 ) ]
table [ 0 ] = 1
for i in range ( 3, n + 1 ) :
INDENT table [ i ] += table [ i - 3 ]
DEDENT for i in range ( 5, n + 1 ) :
INDENT table [ i ] += table [ i - 5 ]
DEDENT for i in range ( 10, n + 1 ) :
INDENT table [ i ] += table [ i - 10 ]
DEDENT return table [ n ]
DEDENT

MAXIMUM_SUM_ABSOLUTE_DIFFERENCE_ARRAY | def MaxSumDifference ( a, n ) :
INDENT np . sort ( a );

j = 0
finalSequence = [ 0 for x in range ( n ) ]
for i in range ( 0, int ( n / 2 ) ) :
INDENT finalSequence [ j ] = a [ i ]
finalSequence [ j + 1 ] = a [ n - i - 1 ]
j = j + 2
DEDENT MaximumSum = 0
for i in range ( 0, n - 1 ) :
INDENT MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) )
DEDENT MaximumSum = ( MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) );

print ( MaximumSum )
DEDENT

PROGRAM_FIND_MID_POINT_LINE | def midpoint ( x1, x2, y1, y2 ) :
INDENT print ( ( x1 + x2 ) //2," , ",(y1+y2)//2)
DEDENT


ALTERNATIVE_SORTING | def alternateSort ( arr, n ) :
INDENT arr . sort ( )
i = 0
j = n - 1
while ( i < j ) :
INDENT print ( arr [ j ], end = " " )
j -= 1
print ( arr [ i ], end = " " )
i += 1
DEDENT if ( n % 2 != 0 ) :
INDENT print ( arr [ i ] )
DEDENT DEDENT

NUMBER_SUBARRAYS_SUM_EXACTLY_EQUAL_K | def findSubarraySum ( arr, n, Sum ) :
INDENT prevSum = defaultdict ( lambda : 0 )
res = 0
currsum = 0
for i in range ( 0, n ) :
INDENT currsum += arr [ i ]
if currsum == Sum :
INDENT res += 1
DEDENT if ( currsum - Sum ) in prevSum :
INDENT res += prevSum [ currsum - Sum ]
DEDENT prevSum [ currsum ] += 1
DEDENT return res
DEDENT

FIND_THE_ELEMENT_THAT_APPEARS_ONCE_IN_A_SORTED_ARRAY | def search ( arr, low, high ) :
INDENT if low > high :
INDENT return None
DEDENT if low == high :
INDENT return arr [ low ]
DEDENT mid = low + ( high - low ) / 2
if mid % 2 == 0 :
INDENT if arr [ mid ] == arr [ mid + 1 ] :
INDENT return search ( arr, mid + 2, high )
DEDENT else :
INDENT return search ( arr, low, mid )
DEDENT DEDENT else :
INDENT if arr [ mid ] == arr [ mid - 1 ] :
INDENT return search ( arr, mid + 1, high )
DEDENT else :
INDENT return search ( arr, low, mid - 1 )
DEDENT DEDENT DEDENT

FORM_SMALLEST_NUMBER_USING_ONE_SWAP_OPERATION | def smallestNumber ( num ) :
INDENT num = list ( num )
n = len ( num )
rightMin = [ 0 ] * n
right = 0
rightMin [ n - 1 ] = - 1;

right = n - 1;

for i in range ( n - 2, 0, - 1 ) :
INDENT if num [ i ] > num [ right ] :
INDENT rightMin [ i ] = right
DEDENT else :
INDENT rightMin [ i ] = - 1
right = i
DEDENT DEDENT small = - 1
for i in range ( 1, n ) :
INDENT if num [ i ] != '0' :
INDENT if small == - 1 :
INDENT if num [ i ] < num [ 0 ] :
INDENT small = i
DEDENT DEDENT elif num [ i ] < num [ small ] :
INDENT small = i
DEDENT DEDENT DEDENT if small != - 1 :
INDENT num [ 0 ], num [ small ] = num [ small ], num [ 0 ]
DEDENT else :
INDENT for i in range ( 1, n ) :
INDENT if rightMin [ i ] != - 1 :
INDENT num [ i ], num [ rightMin [ i ] ] = num [ rightMin [ i ] ], num [ i ]
break
DEDENT DEDENT DEDENT return '' . join ( num )
DEDENT

PROGRAM_AREA_SQUARE | def areaSquare ( side ) :
INDENT area = side * side
return area
DEDENT

FIND_DAY_OF_THE_WEEK_FOR_A_GIVEN_DATE | def dayofweek ( d, m, y ) :
INDENT t = [ 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 ]
y -= m < 3
return ( ( y + int ( y / 4 ) - int ( y / 100 ) + int ( y / 400 ) + t [ m - 1 ] + d ) % 7 )
DEDENT

CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK | def checkSorted ( n, q ) :
INDENT st = [ ]
expected = 1
fnt = None
while ( not q . empty ( ) ) :
INDENT fnt = q . queue [ 0 ]
q . get ( )
if ( fnt == expected ) :
INDENT expected += 1
DEDENT else :
INDENT if ( len ( st ) == 0 ) :
INDENT st . append ( fnt )
DEDENT elif ( len ( st ) != 0 and st [ - 1 ] < fnt ) :
INDENT return False
DEDENT else :
INDENT st . append ( fnt )
DEDENT DEDENT while ( len ( st ) != 0 and st [ - 1 ] == expected ) :
INDENT st . pop ( )
expected += 1
DEDENT DEDENT if ( expected - 1 == n and len ( st ) == 0 ) :
INDENT return True
DEDENT return False
DEDENT

SORT_ARRAY_CONTAIN_1_N_VALUES | def sortit ( arr, n ) :
INDENT for i in range ( n ) :
INDENT arr [ i ] = i + 1
DEDENT DEDENT

LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1 | def lcsOf3 ( i, j, k ) :
INDENT if ( i == - 1 or j == - 1 or k == - 1 ) :
INDENT return 0
DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) :
INDENT return dp [ i ] [ j ] [ k ]
DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) :
INDENT dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1, j - 1, k - 1 )
return dp [ i ] [ j ] [ k ]
DEDENT else :
INDENT dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1, j, k ), lcsOf3 ( i, j - 1, k ) ), lcsOf3 ( i, j, k - 1 ) )
return dp [ i ] [ j ] [ k ]
DEDENT DEDENT

LOWER_INSERTION_POINT | def LowerInsertionPoint ( arr, n, X ) :
INDENT if ( X < arr [ 0 ] ) :
INDENT return 0;

DEDENT elif ( X > arr [ n - 1 ] ) :
INDENT return n
DEDENT lowerPnt = 0
i = 1
while ( i < n and arr [ i ] < X ) :
INDENT lowerPnt = i
i = i * 2
DEDENT while ( lowerPnt < n and arr [ lowerPnt ] < X ) :
INDENT lowerPnt += 1
DEDENT return lowerPnt
DEDENT

CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME | def constructPalin ( string, l ) :
INDENT string = list ( string )
i = - 1
j = l
while i < j :
INDENT i += 1
j -= 1
if ( string [ i ] == string [ j ] and string [ i ] != '*' ) :
INDENT continue
DEDENT elif ( string [ i ] == string [ j ] and string [ i ] == '*' ) :
INDENT string [ i ] = 'a'
string [ j ] = 'a'
continue
DEDENT elif string [ i ] == '*' :
INDENT string [ i ] = string [ j ]
continue
DEDENT elif string [ j ] == '*' :
INDENT string [ j ] = string [ i ]
continue
DEDENT print ( "Not Possible" )
return ""
DEDENT return '' . join ( string )
DEDENT

SECTION_FORMULA_POINT_DIVIDES_LINE_GIVEN_RATIO | def section ( x1, x2, y1, y2, m, n ) :
INDENT x = ( float ) ( ( n * x1 ) + ( m * x2 ) ) / ( m + n )
y = ( float ) ( ( n * y1 ) + ( m * y2 ) ) / ( m + n )
print ( x, y )
DEDENT

SQUARE_ROOT_NUMBER_USING_LOG | def squareRoot ( n ) :
INDENT return pow ( 2, 0.5 * math . log2 ( n ) )
DEDENT

MAXIMIZE_SUM_ARRII | def maxSum ( arr, n ) :
INDENT arr . sort ( )
sum = 0
for i in range ( n ) :
INDENT sum += arr [ i ] * i
DEDENT return sum
DEDENT

STRING_K_DISTINCT_CHARACTERS_NO_CHARACTERS_ADJACENT | def findString ( n, k ) :
INDENT res = ""
for i in range ( k ) :
INDENT res = res + chr ( ord ( 'a' ) + i )
DEDENT count = 0
for i in range ( n - k ) :
INDENT res = res + chr ( ord ( 'a' ) + count )
count += 1
if ( count == k ) :
INDENT count = 0;

DEDENT DEDENT return res
DEDENT

COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD | def countWords ( str, l ) :
INDENT count = 1;

if ( l == 1 ) :
INDENT return count
DEDENT if ( str [ 0 ] == str [ 1 ] ) :
INDENT count *= 1
DEDENT else :
INDENT count *= 2
DEDENT for j in range ( 1, l - 1 ) :
INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) :
INDENT count *= 1
DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) :
INDENT count *= 2
DEDENT else :
INDENT count *= 3
DEDENT DEDENT if ( str [ l - 1 ] == str [ l - 2 ] ) :
INDENT count *= 1
DEDENT else :
INDENT count *= 2
DEDENT return count
DEDENT

NUMBER_JUMP_REQUIRED_GIVEN_LENGTH_REACH_POINT_FORM_D_0_ORIGIN_2D_PLANE | def minJumps ( a, b, d ) :
INDENT temp = a
a = min ( a, b )
b = max ( temp, b )
if ( d >= b ) :
INDENT return ( d + b - 1 ) / b
DEDENT if ( d == 0 ) :
INDENT return 0
DEDENT if ( d == a ) :
INDENT return 1
DEDENT return 2
DEDENT

SUM_FACTORS_NUMBER_1 | def sumofFactors ( n ) :
INDENT res = 1
for i in range ( 2, int ( m . sqrt ( n ) + 1 ) ) :
INDENT curr_sum = 1
curr_term = 1
while n % i == 0 :
INDENT n = n / i;

curr_term = curr_term * i;

curr_sum += curr_term;

DEDENT res = res * curr_sum
DEDENT if n > 2 :
INDENT res = res * ( 1 + n )
DEDENT return res;

DEDENT

DELETE_CONSECUTIVE_WORDS_SEQUENCE | def removeConsecutiveSame ( v ) :
INDENT n = len ( v )
i = 0
while ( i < n - 1 ) :
INDENT if ( ( i + 1 ) < len ( v ) ) and ( v [ i ] == v [ i + 1 ] ) :
INDENT v = v [ : i ]
v = v [ : i ]
if ( i > 0 ) :
INDENT i -= 1
DEDENT n = n - 2
DEDENT else :
INDENT i += 1
DEDENT DEDENT return len ( v [ : i - 1 ] )
DEDENT

COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S | def countStrings ( n ) :
INDENT a = [ 0 for i in range ( n ) ]
b = [ 0 for i in range ( n ) ]
a [ 0 ] = b [ 0 ] = 1
for i in range ( 1, n ) :
INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ]
b [ i ] = a [ i - 1 ]
DEDENT return a [ n - 1 ] + b [ n - 1 ]
DEDENT

FIND_THE_MISSING_NUMBER | def getMissingNo ( A ) :
INDENT n = len ( A )
total = ( n + 1 ) * ( n + 2 ) / 2
sum_of_A = sum ( A )
return total - sum_of_A
DEDENT

SQUARE_ROOT_OF_A_PERFECT_SQUARE | def squareRoot ( n ) :
INDENT x = n
y = 1
e = 0.000001
while ( x - y > e ) :
INDENT x = ( x + y ) / 2
y = n / x
DEDENT return x
DEDENT

SUBSET_SUM_PROBLEM_OSUM_SPACE | def isSubsetSum ( arr, n, sum ) :
INDENT subset = [ [ False for j in range ( sum + 1 ) ] for i in range ( 3 ) ]
for i in range ( n + 1 ) :
INDENT for j in range ( sum + 1 ) :
INDENT if ( j == 0 ) :
INDENT subset [ i % 2 ] [ j ] = True
DEDENT elif ( i == 0 ) :
INDENT subset [ i % 2 ] [ j ] = False
DEDENT elif ( arr [ i - 1 ] <= j ) :
INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ]
DEDENT else :
INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ]
DEDENT DEDENT DEDENT return subset [ n % 2 ] [ sum ]
DEDENT

MULTIPLICATIVE_INVERSE_UNDER_MODULO_M | def modInverse ( a, m ) :
INDENT a = a % m;

for x in range ( 1, m ) :
INDENT if ( ( a * x ) % m == 1 ) :
INDENT return x
DEDENT DEDENT return 1
DEDENT

COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW | def compute_average ( a, b ) :
INDENT return floor ( ( a + b ) / 2 )
DEDENT

REPRESENT_GIVEN_SET_POINTS_BEST_POSSIBLE_STRAIGHT_LINE | def bestApproximate ( x, y, n ) :
INDENT sum_x = 0
sum_y = 0
sum_xy = 0
sum_x2 = 0
for i in range ( 0, n ) :
INDENT sum_x += x [ i ]
sum_y += y [ i ]
sum_xy += x [ i ] * y [ i ]
sum_x2 += pow ( x [ i ], 2 )
DEDENT m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x, 2 ) ) );

c = ( float ) ( sum_y - m * sum_x ) / n;

print ( "m = ", m );

print ( "c = ", c );

DEDENT

SPLIT_ARRAY_ADD_FIRST_PART_END | def splitArr ( arr, n, k ) :
INDENT for i in range ( 0, k ) :
INDENT x = arr [ 0 ]
for j in range ( 0, n - 1 ) :
INDENT arr [ j ] = arr [ j + 1 ]
DEDENT arr [ n - 1 ] = x
DEDENT DEDENT

MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY | def maxDiff ( arr, n ) :
INDENT SubsetSum_1 = 0
SubsetSum_2 = 0
for i in range ( 0, n ) :
INDENT isSingleOccurance = True
for j in range ( i + 1, n ) :
INDENT if ( arr [ i ] == arr [ j ] ) :
INDENT isSingleOccurance = False
arr [ i ] = arr [ j ] = 0
break
DEDENT DEDENT if ( isSingleOccurance == True ) :
INDENT if ( arr [ i ] > 0 ) :
INDENT SubsetSum_1 += arr [ i ]
DEDENT else :
INDENT SubsetSum_2 += arr [ i ]
DEDENT DEDENT DEDENT return abs ( SubsetSum_1 - SubsetSum_2 )
DEDENT

LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2 | def longLenSub ( arr, n ) :
INDENT um = defaultdict ( lambda : 0 )
longLen = 0
for i in range ( n ) :
INDENT len1 = 0
if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) :
INDENT len1 = um [ arr [ i ] - 1 ]
DEDENT if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) :
INDENT len1 = um [ arr [ i ] + 1 ]
DEDENT um [ arr [ i ] ] = len1 + 1
if longLen < um [ arr [ i ] ] :
INDENT longLen = um [ arr [ i ] ]
DEDENT DEDENT return longLen
DEDENT

LONGEST_REPEATED_SUBSEQUENCE_1 | def longestRepeatedSubSeq ( str ) :
INDENT n = len ( str )
dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]
for i in range ( 1, n + 1 ) :
INDENT for j in range ( 1, n + 1 ) :
INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) :
INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]
DEDENT else :
INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ] )
DEDENT DEDENT DEDENT res = ''
i = n
j = n
while ( i > 0 and j > 0 ) :
INDENT if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) :
INDENT res += str [ i - 1 ]
i -= 1
j -= 1
DEDENT elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :
INDENT i -= 1
DEDENT else :
INDENT j -= 1
DEDENT DEDENT res = '' . join ( reversed ( res ) )
return res
DEDENT

FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY | def findRandomIndexOfMax ( arr, n ) :
INDENT mp = dict ( )
for i in range ( n ) :
INDENT if ( arr [ i ] in mp ) :
INDENT mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1
DEDENT else :
INDENT mp [ arr [ i ] ] = 1
DEDENT DEDENT max_element = - 323567
max_so_far = - 323567
for p in mp :
INDENT if ( mp [ p ] > max_so_far ) :
INDENT max_so_far = mp [ p ]
max_element = p
DEDENT DEDENT r = int ( ( ( random . randrange ( 1, max_so_far, 2 ) % max_so_far ) + 1 ) )
i = 0
count = 0
while ( i < n ) :
INDENT if ( arr [ i ] == max_element ) :
INDENT count = count + 1
DEDENT if ( count == r ) :
INDENT print ( "Element with maximum frequency present at index ", i )
break
DEDENT i = i + 1
DEDENT DEDENT

CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION | def isPerfectSquare ( n ) :
INDENT i = 1
the_sum = 0
while the_sum < n :
INDENT the_sum += i
if the_sum == n :
INDENT return True
DEDENT i += 2
DEDENT return False
DEDENT

N_BONACCI_NUMBERS_1 | def bonacciseries ( n, m ) :
INDENT a = [ 0 for i in range ( m ) ]
a [ n - 1 ] = 1
a [ n ] = 1
for i in range ( n + 1, m ) :
INDENT a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ]
DEDENT for i in range ( 0, m ) :
INDENT print ( a [ i ], end = " " )
DEDENT DEDENT

COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1 | def countPairs ( arr, n ) :
INDENT mp = dict ( )
for i in range ( n ) :
INDENT if arr [ i ] in mp . keys ( ) :
INDENT mp [ arr [ i ] ] += 1
DEDENT else :
INDENT mp [ arr [ i ] ] = 1
DEDENT DEDENT ans = 0
for it in mp :
INDENT count = mp [ it ]
ans += ( count * ( count - 1 ) ) //2
DEDENTreturnans
DEDENT


SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER | def bitonicGenerator ( arr, n ) :
INDENT evenArr = [ ]
oddArr = [ ]
for i in range ( n ) :
INDENT if ( ( i % 2 ) == 0 ) :
INDENT evenArr . append ( arr [ i ] )
DEDENT else :
INDENT oddArr . append ( arr [ i ] )
DEDENT DEDENT evenArr = sorted ( evenArr )
oddArr = sorted ( oddArr )
oddArr = oddArr [ : : - 1 ]
i = 0
for j in range ( len ( evenArr ) ) :
INDENT arr [ i ] = evenArr [ j ]
i += 1
DEDENT for j in range ( len ( oddArr ) ) :
INDENT arr [ i ] = oddArr [ j ]
i += 1
DEDENT DEDENT

DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT | def binomialCoeff ( n, k ) :
INDENT if k == 0 or k == n :
INDENT return 1
DEDENT return binomialCoeff ( n - 1, k - 1 ) + binomialCoeff ( n - 1, k )
DEDENT

WRITE_A_C_PROGRAM_TO_FIND_THE_PARITY_OF_AN_UNSIGNED_INTEGER | def getParity ( n ) :
INDENT parity = 0
while n :
INDENT parity = ~ parity
n = n & ( n - 1 )
DEDENT return parity
DEDENT

CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7 | def isdivisible7 ( num ) :
INDENT n = len ( num )
if ( n == 0 and num [ 0 ] == '\n' ) :
INDENT return 1
DEDENT if ( n % 3 == 1 ) :
INDENT num = str ( num ) + "00"
n += 2
DEDENT elif ( n % 3 == 2 ) :
INDENT num = str ( num ) + "0"
n += 1
DEDENT GSum = 0
p = 1
for i in range ( n - 1, - 1, - 1 ) :
INDENT group = 0
group += ord ( num [ i ] ) - ord ( '0' )
i -= 1
group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10
i -= 1
group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100
GSum = GSum + group * p
p *= ( - 1 )
DEDENT return ( GSum % 7 == 0 )
DEDENT

PRODUCT_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING | def productAtKthLevel ( tree, k ) :
INDENT level = - 1
product = 1
n = len ( tree )
for i in range ( 0, n ) :
INDENT if ( tree [ i ] == '(' ) :
INDENT level += 1
DEDENT elif ( tree [ i ] == ')' ) :
INDENT level -= 1
DEDENT else :
INDENT if ( level == k ) :
INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) )
DEDENT DEDENT DEDENT return product
DEDENT

CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD | def isEven ( n ) :
INDENT return ( n % 2 == 0 )
DEDENT

COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS_IMMEDIATE_RIGHT_SUB_GROUP | def countGroups ( position, previous_sum, length, num ) :
INDENT if ( position == length ) :
INDENT return 1
DEDENT res = 0
sum = 0
for i in range ( position, length ) :
INDENT sum = sum + int ( num [ i ] )
if ( sum >= previous_sum ) :
INDENT res = res + countGroups ( i + 1, sum, length, num )
DEDENT DEDENT return res
DEDENT

FIND_THE_ELEMENT_THAT_ODD_NUMBER_OF_TIMES_IN_OLOG_N_TIME | def search ( arr, low, high ) :
INDENT if low > high :
INDENT return None
DEDENT if low == high :
INDENT return arr [ low ]
DEDENT mid = ( low + high ) / 2;

if mid % 2 == 0 :
INDENT if arr [ mid ] == arr [ mid + 1 ] :
INDENT return search ( arr, mid + 2, high )
DEDENT else :
INDENT return search ( arr, low, mid )
DEDENT DEDENT else :
INDENT if arr [ mid ] == arr [ mid - 1 ] :
INDENT return search ( arr, mid + 1, high )
DEDENT else :
INDENT return search ( arr, low, mid - 1 )
DEDENT DEDENT DEDENT

DELETE_CONSECUTIVE_WORDS_SEQUENCE_1 | def removeConsecutiveSame ( v ) :
INDENT st = [ ]
for i in range ( len ( v ) ) :
INDENT if ( len ( st ) == 0 ) :
INDENT st . append ( v [ i ] )
DEDENT else :
INDENT Str = st [ - 1 ]
if ( Str == v [ i ] ) :
INDENT st . pop ( )
DEDENT else :
INDENT st . append ( v [ i ] )
DEDENT DEDENT DEDENT return len ( st )
DEDENT

MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2 | def minJumps ( arr, n ) :
INDENT jumps = [ 0 for i in range ( n ) ]
for i in range ( n - 2, - 1, - 1 ) :
INDENT if ( arr [ i ] == 0 ) :
INDENT jumps [ i ] = float ( 'inf' )
DEDENT elif ( arr [ i ] >= n - i - 1 ) :
INDENT jumps [ i ] = 1
DEDENT else :
INDENT min = float ( 'inf' )
for j in range ( i + 1, n ) :
INDENT if ( j <= arr [ i ] + i ) :
INDENT if ( min > jumps [ j ] ) :
INDENT min = jumps [ j ]
DEDENT DEDENT DEDENT if ( min != float ( 'inf' ) ) :
INDENT jumps [ i ] = min + 1
DEDENT else :
INDENT jumps [ i ] = min
DEDENT DEDENT DEDENT return jumps [ 0 ]
DEDENT

PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS | def gcd ( a, b ) :
INDENT if ( a < b ) :
INDENT return gcd ( b, a )
DEDENT if ( abs ( b ) < 0.001 ) :
INDENT return a
DEDENT else :
INDENT return ( gcd ( b, a - math . floor ( a / b ) * b ) )
DEDENT DEDENT

MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE | def maxProfit ( price, n ) :
INDENT profit = [ 0 ] * n
max_price = price [ n - 1 ]
for i in range ( n - 2, 0, - 1 ) :
INDENT if price [ i ] > max_price :
INDENT max_price = price [ i ]
DEDENT profit [ i ] = max ( profit [ i + 1 ], max_price - price [ i ] )
DEDENT min_price = price [ 0 ]
for i in range ( 1, n ) :
INDENT if price [ i ] < min_price :
INDENT min_price = price [ i ]
DEDENT profit [ i ] = max ( profit [ i - 1 ], profit [ i ] + ( price [ i ] - min_price ) )
DEDENT result = profit [ n - 1 ]
return result
DEDENT

COUNT_SET_BITS_IN_AN_INTEGER_1 | def countSetBits ( n ) :
INDENT if ( n == 0 ) :
INDENT return 0
DEDENT else :
INDENT return ( n & 1 ) + countSetBits ( n >> 1 )
DEDENT DEDENT

REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES | def reorder ( arr, index, n ) :
INDENT temp = [ 0 ] * n;

for i in range ( 0, n ) :
INDENT temp [ index [ i ] ] = arr [ i ]
DEDENT for i in range ( 0, n ) :
INDENT arr [ i ] = temp [ i ]
index [ i ] = i
DEDENT DEDENT

CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BINARY_SEARCH_TREE | def canRepresentBST ( pre ) :
INDENT s = [ ]
root = INT_MIN
for value in pre :
INDENT if value < root :
INDENT return False
DEDENT while ( len ( s ) > 0 and s [ - 1 ] < value ) :
INDENT root = s . pop ( )
DEDENT s . append ( value )
DEDENT return True
DEDENT

FIND_REPETITIVE_ELEMENT_1_N_1_3 | def findRepeating ( arr, n ) :
INDENT missingElement = 0
for i in range ( 0, n ) :
INDENT element = arr [ abs ( arr [ i ] ) ]
if ( element < 0 ) :
INDENT missingElement = arr [ i ]
break
DEDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ]
DEDENT return abs ( missingElement )
DEDENT

DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION_1 | def MatrixChainOrder ( p, n ) :
INDENT m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ]
for i in range ( 1, n ) :
INDENT m [ i ] [ i ] = 0
DEDENT for L in range ( 2, n ) :
INDENT for i in range ( 1, n - L + 1 ) :
INDENT j = i + L - 1
m [ i ] [ j ] = sys . maxint
for k in range ( i, j ) :
INDENT q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ]
if q < m [ i ] [ j ] :
INDENT m [ i ] [ j ] = q
DEDENT DEDENT DEDENT DEDENT return m [ 1 ] [ n - 1 ]
DEDENT

COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE | def countIslands ( mat ) :
INDENT count = 0;

for i in range ( 0, M ) :
INDENT for j in range ( 0, N ) :
INDENT if ( mat [ i ] [ j ] == 'X' ) :
INDENT if ( ( i == 0 or mat [ i - 1 ] [ j ] == 'O' ) and ( j == 0 or mat [ i ] [ j - 1 ] == 'O' ) ) :
INDENT count = count + 1
DEDENT DEDENT DEDENT DEDENT return count
DEDENT

MINIMIZE_MAXAI_BJ_CK_MINAI_BJ_CK_THREE_DIFFERENT_SORTED_ARRAYS | def solve ( A, B, C ) :
INDENT i = len ( A ) - 1
j = len ( B ) - 1
k = len ( C ) - 1
min_diff = abs ( max ( A [ i ], B [ j ], C [ k ] ) - min ( A [ i ], B [ j ], C [ k ] ) )
while i != - 1 and j != - 1 and k != - 1 :
INDENT current_diff = abs ( max ( A [ i ], B [ j ], C [ k ] ) - min ( A [ i ], B [ j ], C [ k ] ) )
if current_diff < min_diff :
INDENT min_diff = current_diff
DEDENT max_term = max ( A [ i ], B [ j ], C [ k ] )
if A [ i ] == max_term :
INDENT i -= 1
DEDENT elif B [ j ] == max_term :
INDENT j -= 1
DEDENT else :
INDENT k -= 1
DEDENT DEDENT return min_diff
DEDENT

ROOTS_QUADRATIC_EQUATION | def findRoots ( a, b, c ) :
INDENT if a == 0 :
INDENT print ( "Invalid" )
return - 1
DEDENT d = b * b - 4 * a * c
sqrt_val = math . sqrt ( abs ( d ) )
if d > 0 :
INDENT print ( "Roots are real and different " )
print ( ( - b + sqrt_val ) / ( 2 * a ) )
print ( ( - b - sqrt_val ) / ( 2 * a ) )
DEDENT elif d == 0 :
INDENT print ( "Roots are real and same" )
print ( - b / ( 2 * a ) )
DEDENT else :
INDENT print ( "Roots are complex" )
print ( - b / ( 2 * a ), " + i", sqrt_val )
print ( - b / ( 2 * a ), " - i", sqrt_val )
DEDENT DEDENT

GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP | def isMinHeap ( level, n ) :
INDENT for i in range ( int ( n / 2 ) - 1, - 1, - 1 ) :
INDENT if level [ i ] > level [ 2 * i + 1 ] :
INDENT return False
DEDENT if 2 * i + 2 < n :
INDENT if level [ i ] > level [ 2 * i + 2 ] :
INDENT return False
DEDENT DEDENT DEDENT return True
DEDENT

FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY | def findMin ( arr, low, high ) :
INDENT if high < low :
INDENT return arr [ 0 ]
DEDENT if high == low :
INDENT return arr [ low ]
DEDENT mid = int ( ( low + high ) / 2 )
if mid < high and arr [ mid + 1 ] < arr [ mid ] :
INDENT return arr [ mid + 1 ]
DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] :
INDENT return arr [ mid ]
DEDENT if arr [ high ] > arr [ mid ] :
INDENT return findMin ( arr, low, mid - 1 )
DEDENT return findMin ( arr, mid + 1, high )
DEDENT

SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTINCT_ADJACENT | def stringReduction ( str ) :
INDENT n = len ( str )
count = [ 0 ] * 3
for i in range ( n ) :
INDENT count [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1
DEDENT if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n ) :
INDENT return n
DEDENT if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) :
INDENT return 2
DEDENT return 1
DEDENT

CHECK_LARGE_NUMBER_DIVISIBLE_3_NOT | def check ( num ) :
INDENT digitSum = 0
while num > 0 :
INDENT rem = num % 10
digitSum = digitSum + rem
num = num / 10
DEDENT return ( digitSum % 3 == 0 )
DEDENT

COMPUTE_N_UNDER_MODULO_P | def modFact ( n, p ) :
INDENT if n >= p :
INDENT return 0
DEDENT result = 1
for i in range ( 1, n + 1 ) :
INDENT result = ( result * i ) % p
DEDENT return result
DEDENT

POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS | def isPresent ( s, q ) :
INDENT freq = [ 0 ] * MAX_CHAR
for i in range ( 0, len ( s ) ) :
INDENT freq [ ord ( s [ i ] ) ] += 1
DEDENT for i in range ( 0, len ( q ) ) :
INDENT freq [ ord ( q [ i ] ) ] -= 1
if ( freq [ ord ( q [ i ] ) ] < 0 ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

NEXT_POWER_OF_2_1 | def nextPowerOf2 ( n ) :
INDENT p = 1
if ( n and not ( n & ( n - 1 ) ) ) :
INDENT return n
DEDENT while ( p < n ) :
INDENT p <<= 1
DEDENT return p;

DEDENT

REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1 | def reorder ( arr, index, n ) :
INDENT for i in range ( 0, n ) :
INDENT while ( index [ i ] != i ) :
INDENT oldTargetI = index [ index [ i ] ]
oldTargetE = arr [ index [ i ] ]
arr [ index [ i ] ] = arr [ i ]
index [ index [ i ] ] = index [ i ]
index [ i ] = oldTargetI
arr [ i ] = oldTargetE
DEDENT DEDENT DEDENT

UNBOUNDED_KNAPSACK_REPETITION_ITEMS_ALLOWED | def unboundedKnapsack ( W, n, val, wt ) :
INDENT dp = [ 0 for i in range ( W + 1 ) ]
ans = 0
for i in range ( W + 1 ) :
INDENT for j in range ( n ) :
INDENT if ( wt [ j ] <= i ) :
INDENT dp [ i ] = max ( dp [ i ], dp [ i - wt [ j ] ] + val [ j ] )
DEDENT DEDENT DEDENT return dp [ W ]
DEDENT

PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX | def isDiagonalMatrix ( mat ) :
INDENT for i in range ( 0, N ) :
INDENT for j in range ( 0, N ) :
INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) :
INDENT return False
DEDENT DEDENT DEDENT return True
DEDENT

MAXIMUM_REMOVAL_FROM_ARRAY_WHEN_REMOVAL_TIME_WAITING_TIME | def maxRemoval ( arr, n ) :
INDENT count = 0
cummulative_sum = 0
arr . sort ( )
for i in range ( n ) :
INDENT if arr [ i ] >= cummulative_sum :
INDENT count += 1
cummulative_sum += arr [ i ]
DEDENT DEDENT return count
DEDENT

PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE | def censor ( text, word ) :
INDENT word_list = text . split ( )
result = ''
stars = '*' * len ( word )
count = 0
index = 0;

for i in word_list :
INDENT if i == word :
INDENT word_list [ index ] = stars
DEDENT index += 1
DEDENT result = ' ' . join ( word_list )
return result
DEDENT

COUNT_STRINGS_WITH_CONSECUTIVE_1S | def countStrings ( n ) :
INDENT a = [ 0 ] * n
b = [ 0 ] * n
a [ 0 ] = b [ 0 ] = 1
for i in range ( 1, n ) :
INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ]
b [ i ] = a [ i - 1 ]
DEDENT return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ]
DEDENT

LENGTH_LONGEST_BALANCED_SUBSEQUENCE | def maxLength ( s, n ) :
INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]
for i in range ( n - 1 ) :
INDENT if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) :
INDENT dp [ i ] [ i + 1 ] = 2
DEDENT DEDENT for l in range ( 2, n ) :
INDENT i = - 1
for j in range ( l, n ) :
INDENT i += 1
if ( s [ i ] == '(' and s [ j ] == ')' ) :
INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ]
DEDENT for k in range ( i, j ) :
INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ], dp [ i ] [ k ] + dp [ k + 1 ] [ j ] )
DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ]
DEDENT

FIND_THE_POINT_WHERE_MAXIMUM_INTERVALS_OVERLAP | def findMaxGuests ( arrl, exit, n ) :
INDENT arrl . sort ( );

exit . sort ( );

guests_in = 1;

max_guests = 1;

time = arrl [ 0 ];

i = 1;

j = 0;

while ( i < n and j < n ) :
INDENT if ( arrl [ i ] <= exit [ j ] ) :
INDENT guests_in = guests_in + 1;

if ( guests_in > max_guests ) :
INDENT max_guests = guests_in;

time = arrl [ i ];

DEDENT i = i + 1;

DEDENT else :
INDENT guests_in = guests_in - 1;

j = j + 1;

DEDENT DEDENT print ( "Maximum Number of Guests =", max_guests, "at time", time )
DEDENT

EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 | def isMultipleOf10 ( n ) :
INDENT return ( n % 15 == 0 )
DEDENT

MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE | def maxSumPairWithDifferenceLessThanK ( arr, N, K ) :
INDENT arr . sort ( )
dp = [ 0 ] * N
dp [ 0 ] = 0
for i in range ( 1, N ) :
INDENT dp [ i ] = dp [ i - 1 ]
if ( arr [ i ] - arr [ i - 1 ] < K ) :
INDENT if ( i >= 2 ) :
INDENT dp [ i ] = max ( dp [ i ], dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] );

DEDENT else :
INDENT dp [ i ] = max ( dp [ i ], arr [ i ] + arr [ i - 1 ] );

DEDENT DEDENT DEDENT return dp [ N - 1 ]
DEDENT

FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS | def kSmallestPair ( arr1, n1, arr2, n2, k ) :
INDENT if ( k > n1 * n2 ) :
INDENT print ( "k pairs don't exist" )
return
DEDENT index2 = [ 0 for i in range ( n1 ) ]
while ( k > 0 ) :
INDENT min_sum = sys . maxsize
min_index = 0
for i1 in range ( 0, n1, 1 ) :
INDENT if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) :
INDENT min_index = i1
min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ]
DEDENT DEDENT print ( "(", arr1 [ min_index ], ",", arr2 [ index2 [ min_index ] ], ")", end = " " )
index2 [ min_index ] += 1
k -= 1
DEDENT DEDENT

FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1 | def first ( str, i ) :
INDENT if ( str [ i ] == '\0' ) :
INDENT return 0
DEDENT if ( str [ i ] . isupper ( ) ) :
INDENT return str [ i ]
DEDENT return first ( str, i + 1 )
DEDENT

FIND_PAIRS_B_ARRAY_B_K | def printPairs ( arr, n, k ) :
INDENT isPairFound = True
for i in range ( 0, n ) :
INDENT for j in range ( 0, n ) :
INDENT if ( i != j and arr [ i ] % arr [ j ] == k ) :
INDENT print ( "(", arr [ i ], ", ", arr [ j ], ")", sep = "", end = " " )
isPairFound = True
DEDENT DEDENT DEDENT return isPairFound
DEDENT

FIND_ARRANGEMENT_QUEUE_GIVEN_TIME | def solve ( n, t, p ) :
INDENT s = list ( p )
for i in range ( 0, t ) :
INDENT for j in range ( 0, n - 1 ) :
INDENT if ( s [ j ] == 'B' and s [ j + 1 ] == 'G' ) :
INDENT temp = s [ j ];

s [ j ] = s [ j + 1 ];

s [ j + 1 ] = temp;

j = j + 1
DEDENT DEDENT DEDENT print ( '' . join ( s ) )
DEDENT

SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS | def printSuperSeq ( a, b ) :
INDENT m = len ( a )
n = len ( b )
dp = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ]
for i in range ( 0, m + 1 ) :
INDENT for j in range ( 0, n + 1 ) :
INDENT if not i :
INDENT dp [ i ] [ j ] = j;

DEDENT elif not j :
INDENT dp [ i ] [ j ] = i;

DEDENT elif ( a [ i - 1 ] == b [ j - 1 ] ) :
INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ];

DEDENT else :
INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] );

DEDENT DEDENT DEDENT index = dp [ m ] [ n ];

res = [ "" ] * ( index )
i = m
j = n;

while ( i > 0 and j > 0 ) :
INDENT if ( a [ i - 1 ] == b [ j - 1 ] ) :
INDENT res [ index - 1 ] = a [ i - 1 ];

i -= 1
j -= 1
index -= 1
DEDENT elif ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) :
INDENT res [ index - 1 ] = a [ i - 1 ]
i -= 1
index -= 1
DEDENT else :
INDENT res [ index - 1 ] = b [ j - 1 ]
j -= 1
index -= 1
DEDENT DEDENT while ( i > 0 ) :
INDENT res [ index - 1 ] = a [ i - 1 ]
i -= 1
index -= 1
DEDENT while ( j > 0 ) :
INDENT res [ index - 1 ] = b [ j - 1 ]
j -= 1
index -= 1
DEDENT print ( "" . join ( res ) )
DEDENT

COUNT_ROTATIONS_DIVISIBLE_8 | def countRotationsDivBy8 ( n ) :
INDENT l = len ( n )
count = 0
if ( l == 1 ) :
INDENT oneDigit = int ( n [ 0 ] )
if ( oneDigit % 8 == 0 ) :
INDENT return 1
DEDENT return 0
DEDENT if ( l == 2 ) :
INDENT first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] )
second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] )
if ( first % 8 == 0 ) :
INDENT count += 1
DEDENT if ( second % 8 == 0 ) :
INDENT count += 1
DEDENT return count
DEDENT threeDigit = 0
for i in range ( 0, ( l - 2 ) ) :
INDENT threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) )
if ( threeDigit % 8 == 0 ) :
INDENT count += 1
DEDENT DEDENT threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) )
if ( threeDigit % 8 == 0 ) :
INDENT count += 1
DEDENT threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) )
if ( threeDigit % 8 == 0 ) :
INDENT count += 1
DEDENT return count
DEDENT

LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED | def lcs ( dp, arr1, n, arr2, m, k ) :
INDENT if k < 0 :
INDENT return - ( 10 * * 7 )
DEDENT if n < 0 or m < 0 :
INDENT return 0
DEDENT ans = dp [ n ] [ m ] [ k ]
if ans != - 1 :
INDENT return ans
DEDENT ans = max ( lcs ( dp, arr1, n - 1, arr2, m, k ), lcs ( dp, arr1, n, arr2, m - 1, k ) )
if arr1 [ n - 1 ] == arr2 [ m - 1 ] :
INDENT ans = max ( ans, 1 + lcs ( dp, arr1, n - 1, arr2, m - 1, k ) )
DEDENT ans = max ( ans, lcs ( dp, arr1, n - 1, arr2, m - 1, k - 1 ) )
return ans
DEDENT

CHECK_LINE_TOUCHES_INTERSECTS_CIRCLE | def checkCollision ( a, b, c, x, y, radius ) :
INDENT dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) )
if ( radius == dist ) :
INDENT print ( "Touch" )
DEDENT elif ( radius > dist ) :
INDENT print ( "Intersect" )
DEDENT else :
INDENT print ( "Outside" )
DEDENT DEDENT

FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY | def maxSubarrayXOR ( arr, n ) :
INDENT ans = - 2147483648
for i in range ( n ) :
INDENT curr_xor = 0
for j in range ( i, n ) :
INDENT curr_xor = curr_xor ^ arr [ j ]
ans = max ( ans, curr_xor )
DEDENT DEDENT return ans
DEDENT

SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH | def shortestPath ( graph, u, v, k ) :
INDENT V = 4
INF = 999999999999
if k == 0 and u == v :
INDENT return 0
DEDENT if k == 1 and graph [ u ] [ v ] != INF :
INDENT return graph [ u ] [ v ]
DEDENT if k <= 0 :
INDENT return INF
DEDENT res = INF
for i in range ( V ) :
INDENT if graph [ u ] [ i ] != INF and u != i and v != i :
INDENT rec_res = shortestPath ( graph, i, v, k - 1 )
if rec_res != INF :
INDENT res = min ( res, graph [ u ] [ i ] + rec_res )
DEDENT DEDENT DEDENT return res
DEDENT

FIND_SUBARRAY_WITH_GIVEN_SUM | def subArraySum ( arr, n, sum ) :
INDENT for i in range ( n ) :
INDENT curr_sum = arr [ i ]
j = i + 1
while j <= n :
INDENT if curr_sum == sum :
INDENT print ( "Sum found between" )
print ( "indexes %d and %d" % ( i, j - 1 ) )
return 1
DEDENT if curr_sum > sum or j == n :
INDENT break
DEDENT curr_sum = curr_sum + arr [ j ]
j += 1
DEDENT DEDENT print ( "No subarray found" )
return 0
DEDENT

K_TH_PRIME_FACTOR_GIVEN_NUMBER | def kPrimeFactor ( n, k ) :
INDENT while ( n % 2 == 0 ) :
INDENT k = k - 1
n = n / 2
if ( k == 0 ) :
INDENT return 2
DEDENT DEDENT i = 3
while i <= math . sqrt ( n ) :
INDENT while ( n % i == 0 ) :
INDENT if ( k == 1 ) :
INDENT return i
DEDENT k = k - 1
n = n / i
DEDENT i = i + 2
DEDENT if ( n > 2 and k == 1 ) :
INDENT return n
DEDENT return - 1
DEDENT

FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1 | def countRotations ( arr, low, high ) :
INDENT if ( high < low ) :
INDENT return 0
DEDENT if ( high == low ) :
INDENT return low
DEDENT mid = low + ( high - low ) / 2;

mid = int ( mid )
if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) :
INDENT return ( mid + 1 )
DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) :
INDENT return mid
DEDENT if ( arr [ high ] > arr [ mid ] ) :
INDENT return countRotations ( arr, low, mid - 1 );

DEDENT return countRotations ( arr, mid + 1, high )
DEDENT

COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW_1 | def compute_average ( a, b ) :
INDENT return ( a //2)+(b//2)+((a%2+b%2)//2)
DEDENT


SORTING_USING_TRIVIAL_HASH_FUNCTION_1 | def sortUsingHash ( a, n ) :
INDENT Max = max ( a )
Min = abs ( min ( a ) )
hashpos = [ 0 ] * ( Max + 1 )
hashneg = [ 0 ] * ( Min + 1 )
for i in range ( 0, n ) :
INDENT if a [ i ] >= 0 :
INDENT hashpos [ a [ i ] ] += 1
DEDENT else :
INDENT hashneg [ abs ( a [ i ] ) ] += 1
DEDENT DEDENT for i in range ( Min, 0, - 1 ) :
INDENT if hashneg [ i ] != 0 :
INDENT for j in range ( 0, hashneg [ i ] ) :
INDENT print ( ( - 1 ) * i, end = " " )
DEDENT DEDENT DEDENT for i in range ( 0, Max + 1 ) :
INDENT if hashpos [ i ] != 0 :
INDENT for j in range ( 0, hashpos [ i ] ) :
INDENT print ( i, end = " " )
DEDENT DEDENT DEDENT DEDENT

FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1 | def printRepeating ( arr, size ) :
INDENT count = [ 0 ] * size
print ( " Repeating elements are ", end = "" )
for i in range ( 0, size ) :
INDENT if ( count [ arr [ i ] ] == 1 ) :
INDENT print ( arr [ i ], end = " " )
DEDENT else :
INDENT count [ arr [ i ] ] = count [ arr [ i ] ] + 1
DEDENT DEDENT DEDENT

MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION | def getMinSteps ( n ) :
INDENT table = [ 0 ] * ( n + 1 )
for i in range ( n + 1 ) :
INDENT table [ i ] = n - i
DEDENT for i in range ( n, 0, - 1 ) :
INDENT if ( not ( i % 2 ) ) :
INDENT table [ i //2]=min(table[i]+1,table[i//2])
DEDENTif(not(i%3)):
INDENTtable[i//3]=min(table[i]+1,table[i//3])
DEDENTDEDENTreturntable[1]



COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1 | def countDecodingDP ( digits, n ) :
INDENT count = [ 0 ] * ( n + 1 );

count [ 0 ] = 1;

count [ 1 ] = 1;

for i in range ( 2, n + 1 ) :
INDENT count [ i ] = 0;

if ( digits [ i - 1 ] > '0' ) :
INDENT count [ i ] = count [ i - 1 ];

DEDENT if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) :
INDENT count [ i ] += count [ i - 2 ];

DEDENT DEDENT return count [ n ];

DEDENT

EULERS_FOUR_SQUARE_IDENTITY_1 | def checkEulerFourSquareIdentity ( a, b ) :
INDENT ab = a * b
flag = False
i = 0
while i * i <= ab :
INDENT j = i
while i * i + j * j <= ab :
INDENT k = j
while i * i + j * j + k * k <= ab :
INDENT l = ( ab - ( i * i + j * j + k * k ) ) * * ( 0.5 )
if l == int ( l ) and l >= k :
INDENT flag = True
print ( "i = ", i )
print ( "j = ", j )
print ( "k = ", k )
print ( "l = ", l )
print ( "Product of", a, "and", b, "can be written as sum of squares of i, j, k, l" )
print ( ab, " = ", i, "*", i, "+", j, "*", j, "+", k, "*", k, "+", l, "*", l )
DEDENT k += 1
DEDENT j += 1
DEDENT i += 1
DEDENT if flag == False :
INDENT print ( "Solution doesn't exist!" )
return
DEDENT DEDENT

COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K | def numOfIncSubseqOfSizeK ( arr, n, k ) :
INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ]
for i in range ( n ) :
INDENT dp [ 0 ] [ i ] = 1
DEDENT for l in range ( 1, k ) :
INDENT for i in range ( l, n ) :
INDENT dp [ l ] [ i ] = 0
for j in range ( l - 1, i ) :
INDENT if ( arr [ j ] < arr [ i ] ) :
INDENT dp [ l ] [ i ] += dp [ l - 1 ] [ j ]
DEDENT DEDENT DEDENT DEDENT Sum = 0
for i in range ( k - 1, n ) :
INDENT Sum += dp [ k - 1 ] [ i ]
DEDENT return Sum
DEDENT

KNAPSACK_PROBLEM_1 | def knapSack ( W, wt, val, n ) :
INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ]
for i in range ( n + 1 ) :
INDENT for w in range ( W + 1 ) :
INDENT if i == 0 or w == 0 :
INDENT K [ i ] [ w ] = 0
DEDENT elif wt [ i - 1 ] <= w :
INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ], K [ i - 1 ] [ w ] )
DEDENT else :
INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ]
DEDENT DEDENT DEDENT return K [ n ] [ W ]
DEDENT

PROGRAM_TO_PRINT_DOUBLE_HEADED_ARROW_PATTERN | def drawPattern ( N ) :
INDENT n = N;

row = 1;

nst = 1;

nsp1 = n - 1;

nsp2 = - 1;

val1 = row;

val2 = 1;

while ( row <= n ) :
INDENT csp1 = 1;

while ( csp1 <= nsp1 ) :
INDENT print ( " ", end = " " );

csp1 = csp1 + 1;

DEDENT cst1 = 1;

while ( cst1 <= nst ) :
INDENT print ( val1, end = " " );

val1 = val1 - 1;

cst1 = cst1 + 1;

DEDENT csp2 = 1;

while ( csp2 <= nsp2 ) :
INDENT print ( " ", end = " " );

csp2 = csp2 + 1;

DEDENT if ( row != 1 and row != n ) :
INDENT cst2 = 1;

while ( cst2 <= nst ) :
INDENT print ( val2, end = " " );

val2 = val2 + 1;

cst2 = cst2 + 1;

DEDENT DEDENT print ( )
if ( row <= n //2):
INDENTnst=nst+1;
nsp1=nsp1-2;
nsp2=nsp2+2;
val1=row+1;
val2=1;
DEDENTelse:
INDENTnst=nst-1;
nsp1=nsp1+2;
nsp2=nsp2-2;
val1=n-row;
val2=1;
DEDENTrow=row+1;
DEDENTDEDENT


INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY | def findInteger ( arr, n ) :
INDENT hash = dict ( )
maximum = 0
for i in arr :
INDENT if ( i < 0 ) :
INDENT if abs ( i ) not in hash . keys ( ) :
INDENT hash [ abs ( i ) ] = - 1
DEDENT else :
INDENT hash [ abs ( i ) ] -= 1
DEDENT DEDENT else :
INDENT hash [ i ] = hash . get ( i, 0 ) + 1
DEDENT DEDENT for i in arr :
INDENT if i in hash . keys ( ) and hash [ i ] > 0 :
INDENT return i
DEDENT DEDENT return - 1
DEDENT

SPACE_OPTIMIZED_SOLUTION_LCS | def lcs ( X, Y ) :
INDENT m = len ( X )
n = len ( Y )
L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ]
bi = bool
for i in range ( m ) :
INDENT bi = i & 1
for j in range ( n + 1 ) :
INDENT if ( i == 0 or j == 0 ) :
INDENT L [ bi ] [ j ] = 0
DEDENT elif ( X [ i ] == Y [ j - 1 ] ) :
INDENT L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1
DEDENT else :
INDENT L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ], L [ bi ] [ j - 1 ] )
DEDENT DEDENT DEDENT return L [ bi ] [ n ]
DEDENT

REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS | def psuedoBinary ( n ) :
INDENT while ( n > 0 ) :
INDENT temp = n;

m = 0;

p = 1;

while ( temp ) :
INDENT rem = temp % 10;

temp = int ( temp / 10 );

if ( rem != 0 ) :
INDENT m += p;

DEDENT p *= 10;

DEDENT print ( m, end = " " );

n = n - m;

DEDENT DEDENT

FIND_NUMBER_CURRENCY_NOTES_SUM_UPTO_GIVEN_AMOUNT | def countCurrency ( amount ) :
INDENT notes = [ 2000, 500, 200, 100, 50, 20, 10, 5, 1 ]
noteCounter = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
print ( "Currency Count -> " )
for i, j in zip ( notes, noteCounter ) :
INDENT if amount >= i :
INDENT j = amount //i
amount=amount-j*i
print(i," : ",j)
DEDENTDEDENTDEDENT


POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS | def rearrange ( a, size ) :
INDENT positive = 0
negative = 1
while ( True ) :
INDENT while ( positive < size and a [ positive ] >= 0 ) :
INDENT positive = positive + 2
DEDENT while ( negative < size and a [ negative ] <= 0 ) :
INDENT negative = negative + 2
DEDENT if ( positive < size and negative < size ) :
INDENT temp = a [ positive ]
a [ positive ] = a [ negative ]
a [ negative ] = temp
DEDENT else :
INDENT break
DEDENT DEDENT DEDENT

FIND_WHETHER_AN_ARRAY_IS_SUBSET_OF_ANOTHER_ARRAY_SET_1 | def isSubset ( arr1, arr2, m, n ) :
INDENT i = 0
j = 0
for i in range ( n ) :
INDENT for j in range ( m ) :
INDENT if ( arr2 [ i ] == arr1 [ j ] ) :
INDENT break
DEDENT DEDENT if ( j == m ) :
INDENT return 0
DEDENT DEDENT return 1
DEDENT

GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM | def pairInSortedRotated ( arr, n, x ) :
INDENT for i in range ( 0, n - 1 ) :
INDENT if ( arr [ i ] > arr [ i + 1 ] ) :
INDENT break;

DEDENT DEDENT l = ( i + 1 ) % n
r = i
while ( l != r ) :
INDENT if ( arr [ l ] + arr [ r ] == x ) :
INDENT return True;

DEDENT if ( arr [ l ] + arr [ r ] < x ) :
INDENT l = ( l + 1 ) % n;

DEDENT else :
INDENT r = ( n + r - 1 ) % n;

DEDENT DEDENT return False;

DEDENT

PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR_1 | def getRemainder ( num, divisor ) :
INDENT if ( divisor == 0 ) :
INDENT return False
DEDENT if ( divisor < 0 ) :
INDENT divisor = - divisor
DEDENT if ( num < 0 ) :
INDENT num = - num
DEDENT i = 1
product = 0
while ( product <= num ) :
INDENT product = divisor * i
i += 1
DEDENT return num - ( product - divisor )
DEDENT

GNOME_SORT_A_STUPID_ONE | def gnomeSort ( arr, n ) :
INDENT index = 0
while index < n :
INDENT if index == 0 :
INDENT index = index + 1
DEDENT if arr [ index ] >= arr [ index - 1 ] :
INDENT index = index + 1
DEDENT else :
INDENT arr [ index ], arr [ index - 1 ] = arr [ index - 1 ], arr [ index ]
index = index - 1
DEDENT DEDENT return arr
DEDENT

NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE | def numberofways ( A, B, N, M ) :
INDENT pos = [ [ ] for _ in range ( MAX ) ]
for i in range ( M ) :
INDENT pos [ ord ( B [ i ] ) ] . append ( i + 1 )
DEDENT dpl = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ]
for i in range ( 1, N + 1 ) :
INDENT for j in range ( 1, M + 1 ) :
INDENT if A [ i - 1 ] == B [ j - 1 ] :
INDENT dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1
DEDENT else :
INDENT dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ], dpl [ i ] [ j - 1 ] )
DEDENT DEDENT DEDENT LCS = dpl [ N ] [ M ]
dpr = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ]
for i in range ( N, 0, - 1 ) :
INDENT for j in range ( M, 0, - 1 ) :
INDENT if A [ i - 1 ] == B [ j - 1 ] :
INDENT dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1
DEDENT else :
INDENT dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ], dpr [ i ] [ j + 1 ] )
DEDENT DEDENT DEDENT ans = 0
for i in range ( N + 1 ) :
INDENT for j in range ( MAX ) :
INDENT for x in pos [ j ] :
INDENT if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS :
INDENT ans += 1
break
DEDENT DEDENT DEDENT DEDENT return ans
DEDENT

MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS | def minProduct ( arr, n, k ) :
INDENT heapq . heapify ( arr )
count = 0
ans = 1
while ( arr ) and count < k :
INDENT x = heapq . heappop ( arr )
ans = ans * x
count = count + 1
DEDENT return ans;

DEDENT

FIND_UNIQUE_ELEMENTS_MATRIX | def unique ( mat, n, m ) :
INDENT maximum = 0;
flag = 0
for i in range ( 0, n ) :
INDENT for j in range ( 0, m ) :
INDENT if ( maximum < mat [ i ] [ j ] ) :
INDENT maximum = mat [ i ] [ j ];

DEDENT DEDENT DEDENT uniqueElementDict = [ 0 ] * ( maximum + 1 )
for i in range ( 0, n ) :
INDENT for j in range ( 0, m ) :
INDENT uniqueElementDict [ mat [ i ] [ j ] ] += 1
DEDENT DEDENT for key in range ( maximum + 1 ) :
INDENT if uniqueElementDict [ key ] == 1 :
INDENT print ( key, end = " " )
flag = 1
DEDENT DEDENT if ( flag == 0 ) :
INDENT print ( "No unique element in the matrix" )
DEDENT DEDENT

LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS_ONE | def longestSubseqWithDiffOne ( arr, n ) :
INDENT dp = [ 1 for i in range ( n ) ]
for i in range ( n ) :
INDENT for j in range ( i ) :
INDENT if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) :
INDENT dp [ i ] = max ( dp [ i ], dp [ j ] + 1 )
DEDENT DEDENT DEDENT result = 1
for i in range ( n ) :
INDENT if ( result < dp [ i ] ) :
INDENT result = dp [ i ]
DEDENT DEDENT return result
DEDENT

C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES | def repeat ( s, n ) :
INDENT s1 = s
for i in range ( 1, n ) :
INDENT s += s1
DEDENT return s
DEDENT

SEARCHING_FOR_PATTERNS_SET_1_NAIVE_PATTERN_SEARCHING | def search ( pat, txt ) :
INDENT M = len ( pat )
N = len ( txt )
for i in range ( N - M + 1 ) :
INDENT j = 0
while ( j < M ) :
INDENT if ( txt [ i + j ] != pat [ j ] ) :
INDENT break
DEDENT j += 1
DEDENT if ( j == M ) :
INDENT print ( "Pattern found at index ", i )
DEDENT DEDENT DEDENT

COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES | def countwalks ( graph, u, v, k ) :
INDENT if ( k == 0 and u == v ) :
INDENT return 1
DEDENT if ( k == 1 and graph [ u ] [ v ] ) :
INDENT return 1
DEDENT if ( k <= 0 ) :
INDENT return 0
DEDENT count = 0
for i in range ( 0, V ) :
INDENT if ( graph [ u ] [ i ] == 1 ) :
INDENT count += countwalks ( graph, i, v, k - 1 )
DEDENT DEDENT return count
DEDENT

COUNT_DIVISIBLE_PAIRS_ARRAY | def countDivisibles ( arr, n ) :
INDENT res = 0
for i in range ( 0, n ) :
INDENT for j in range ( i + 1, n ) :
INDENT if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) :
INDENT res += 1
DEDENT DEDENT DEDENT return res
DEDENT

PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC | def isSymmetric ( mat, N ) :
INDENT for i in range ( N ) :
INDENT for j in range ( N ) :
INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) :
INDENT return False
DEDENT DEDENT DEDENT return True
DEDENT

COUNT_PALINDROME_SUB_STRINGS_STRING | def CountPS ( str, n ) :
INDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]
P = [ [ False for x in range ( n ) ] for y in range ( n ) ]
for i in range ( n ) :
INDENT P [ i ] [ i ] = True
DEDENT for i in range ( n - 1 ) :
INDENT if ( str [ i ] == str [ i + 1 ] ) :
INDENT P [ i ] [ i + 1 ] = True
dp [ i ] [ i + 1 ] = 1
DEDENT DEDENT for gap in range ( 2, n ) :
INDENT for i in range ( n - gap ) :
INDENT j = gap + i;

if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) :
INDENT P [ i ] [ j ] = True
DEDENT if ( P [ i ] [ j ] == True ) :
INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] )
DEDENT else :
INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] )
DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ]
DEDENT

WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED | def countWays ( arr, m, N ) :
INDENT count = [ 0 for i in range ( N + 1 ) ]
count [ 0 ] = 1
for i in range ( 1, N + 1 ) :
INDENT for j in range ( m ) :
INDENT if ( i >= arr [ j ] ) :
INDENT count [ i ] += count [ i - arr [ j ] ]
DEDENT DEDENT DEDENT return count [ N ]
DEDENT

MINIMUM_NUMBER_OF_OPERATIONS_TO_MOVE_ALL_UPPERCASE_CHARACTERS_BEFORE_ALL_LOWER_CASE_CHARACTERS | def minOperations ( str, n ) :
INDENT lastUpper = - 1
firstLower = - 1
for i in range ( n - 1, - 1, - 1 ) :
INDENT if ( str [ i ] . isupper ( ) ) :
INDENT lastUpper = i
break
DEDENT DEDENT for i in range ( n ) :
INDENT if ( str [ i ] . islower ( ) ) :
INDENT firstLower = i
break
DEDENT DEDENT if ( lastUpper == - 1 or firstLower == - 1 ) :
INDENT return 0
DEDENT countUpper = 0
for i in range ( firstLower, n ) :
INDENT if ( str [ i ] . isupper ( ) ) :
INDENT countUpper += 1
DEDENT DEDENT countLower = 0
for i in range ( lastUpper ) :
INDENT if ( str [ i ] . islower ( ) ) :
INDENT countLower += 1
DEDENT DEDENT return min ( countLower, countUpper )
DEDENT

PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM | def spiralPrint ( m, n, a ) :
INDENT k = 0;
l = 0
while ( k < m and l < n ) :
INDENT for i in range ( l, n ) :
INDENT print ( a [ k ] [ i ], end = " " )
DEDENT k += 1
for i in range ( k, m ) :
INDENT print ( a [ i ] [ n - 1 ], end = " " )
DEDENT n -= 1
if ( k < m ) :
INDENT for i in range ( n - 1, ( l - 1 ), - 1 ) :
INDENT print ( a [ m - 1 ] [ i ], end = " " )
DEDENT m -= 1
DEDENT if ( l < n ) :
INDENT for i in range ( m - 1, k - 1, - 1 ) :
INDENT print ( a [ i ] [ l ], end = " " )
DEDENT l += 1
DEDENT DEDENT DEDENT

FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT | def findTriplets ( x ) :
INDENT fact = [ ];

factors = set ( );

for i in range ( 2, int ( sqrt ( x ) ) ) :
INDENT if ( x % i == 0 ) :
INDENT fact . append ( i );

if ( x / i != i ) :
INDENT fact . append ( x //i);
DEDENTfactors.add(i);
factors.add(x//i);
DEDENTDEDENTfound=False;
k=len(fact);
foriinrange(k):
INDENTa=fact[i];
forjinrange(k):
INDENTb=fact[j];
if((a!=b)and(x%(a*b)==0)and(x/(a*b)!=a)and(x/(a*b)!=b)and(x/(a*b)!=1)):
INDENTprint(a,b,x//(a*b));
found=True;
break;
DEDENTDEDENTif(found):
INDENTbreak;
DEDENTDEDENTif(notfound):
INDENTprint("-1");
DEDENTDEDENT


SUM_TWO_LARGE_NUMBERS_1 | def findSum ( str1, str2 ) :
INDENT if len ( str1 ) > len ( str2 ) :
INDENT temp = str1
str1 = str2
str2 = temp
DEDENT str3 = ""
n1 = len ( str1 )
n2 = len ( str2 )
diff = n2 - n1
carry = 0
for i in range ( n1 - 1, - 1, - 1 ) :
INDENT sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i + diff ] ) - ord ( '0' ) ) ) + carry )
str3 = str3 + str ( sum % 10 )
carry = sum //10
DEDENTforiinrange(n2-n1-1,-1,-1):
INDENTsum=((ord(str2[i])-ord('0'))+carry)
str3=str3+str(sum%10)
carry=sum//10
DEDENTif(carry):
INDENTstr3+str(carry+'0')
DEDENTstr3=str3[::-1]
returnstr3
DEDENT


COCKTAIL_SORT | def cocktailSort ( a ) :
INDENT n = len ( a )
swapped = True
start = 0
end = n - 1
while ( swapped == True ) :
INDENT swapped = False
for i in range ( start, end ) :
INDENT if ( a [ i ] > a [ i + 1 ] ) :
INDENT a [ i ], a [ i + 1 ] = a [ i + 1 ], a [ i ]
swapped = True
DEDENT DEDENT if ( swapped == False ) :
INDENT break
DEDENT swapped = False
end = end - 1
for i in range ( end - 1, start - 1, - 1 ) :
INDENT if ( a [ i ] > a [ i + 1 ] ) :
INDENT a [ i ], a [ i + 1 ] = a [ i + 1 ], a [ i ]
swapped = True
DEDENT DEDENT start = start + 1
DEDENT DEDENT

COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION_1 | def countDer ( n ) :
INDENT der = [ 0 for i in range ( n + 1 ) ]
der [ 0 ] = 1
der [ 1 ] = 0
der [ 2 ] = 1
for i in range ( 3, n + 1 ) :
INDENT der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] )
DEDENT return der [ n ]
DEDENT

MAXIMUM_PRODUCT_SUBARRAY_ADDED_NEGATIVE_PRODUCT_CASE | def findMaxProduct ( arr, n ) :
INDENT ans = - float ( 'inf' )
maxval = 1
minval = 1
for i in range ( 0, n ) :
INDENT if arr [ i ] > 0 :
INDENT maxval = maxval * arr [ i ]
minval = min ( 1, minval * arr [ i ] )
DEDENT elif arr [ i ] == 0 :
INDENT minval = 1
maxval = 0
DEDENT elif arr [ i ] < 0 :
INDENT prevMax = maxval
maxval = minval * arr [ i ]
minval = prevMax * arr [ i ]
DEDENT ans = max ( ans, maxval )
if maxval <= 0 :
INDENT maxval = 1
DEDENT DEDENT return ans
DEDENT

REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_ODD | def assign ( a, n ) :
INDENT a . sort ( )
ans = [ 0 ] * n
p = 0
q = n - 1
for i in range ( n ) :
INDENT if ( i + 1 ) % 2 == 0 :
INDENT ans [ i ] = a [ q ]
q = q - 1
DEDENT else :
INDENT ans [ i ] = a [ p ]
p = p + 1
DEDENT DEDENT for i in range ( n ) :
INDENT print ( ans [ i ], end = " " )
DEDENT DEDENT

FRIENDS_PAIRING_PROBLEM | def countFriendsPairings ( n ) :
INDENT dp = [ 0 for i in range ( n + 1 ) ]
for i in range ( n + 1 ) :
INDENT if ( i <= 2 ) :
INDENT dp [ i ] = i
DEDENT else :
INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ]
DEDENT DEDENT return dp [ n ]
DEDENT

PRIME_NUMBERS | def isPrime ( n ) :
INDENT if ( n <= 1 ) :
INDENT return False
DEDENT for i in range ( 2, n ) :
INDENT if ( n % i == 0 ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

PROBABILITY_REACHING_POINT_2_3_STEPS_TIME | def find_prob ( N, P ) :
INDENT dp = [ 0 ] * ( n + 1 )
dp [ 0 ] = 1
dp [ 1 ] = 0
dp [ 2 ] = P
dp [ 3 ] = 1 - P
for i in range ( 4, N + 1 ) :
INDENT dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ]
DEDENT return dp [ N ]
DEDENT

SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1 | def smallest ( x, y, z ) :
INDENT if ( not ( y / x ) ) :
INDENT return y if ( not ( y / z ) ) else z
DEDENT return x if ( not ( x / z ) ) else z
DEDENT

COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX | def printCommonElements ( mat ) :
INDENT mp = dict ( )
for j in range ( N ) :
INDENT mp [ mat [ 0 ] [ j ] ] = 1
DEDENT for i in range ( 1, M ) :
INDENT for j in range ( N ) :
INDENT if ( mat [ i ] [ j ] in mp . keys ( ) and mp [ mat [ i ] [ j ] ] == i ) :
INDENT mp [ mat [ i ] [ j ] ] = i + 1
if i == M - 1 :
INDENT print ( mat [ i ] [ j ], end = " " )
DEDENT DEDENT DEDENT DEDENT DEDENT

DETECTING_NEGATIVE_CYCLE_USING_FLOYD_WARSHALL | def negCyclefloydWarshall ( graph ) :
INDENT dist = [ [ 0 for i in range ( V + 1 ) ] for j in range ( V + 1 ) ]
for i in range ( V ) :
INDENT for j in range ( V ) :
INDENT dist [ i ] [ j ] = graph [ i ] [ j ]
DEDENT DEDENT for k in range ( V ) :
INDENT for i in range ( V ) :
INDENT for j in range ( V ) :
INDENT if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) :
INDENT dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ]
DEDENT DEDENT DEDENT DEDENT for i in range ( V ) :
INDENT if ( dist [ i ] [ i ] < 0 ) :
INDENT return True
DEDENT DEDENT return False
DEDENT

PROGRAM_SORT_STRING_DESCENDING_ORDER | def sortString ( str ) :
INDENT charCount = [ 0 ] * MAX_CHAR;

for i in range ( len ( str ) ) :
INDENT charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1;

DEDENT for i in range ( MAX_CHAR - 1, - 1, - 1 ) :
INDENT for j in range ( charCount [ i ] ) :
INDENT print ( chr ( 97 + i ), end = "" );

DEDENT DEDENT DEDENT

COUNT_PAIRS_WITH_GIVEN_SUM | def getPairsCount ( arr, n, sum ) :
INDENT count = 0
for i in range ( 0, n ) :
INDENT for j in range ( i + 1, n ) :
INDENT if arr [ i ] + arr [ j ] == sum :
INDENT count += 1
DEDENT DEDENT DEDENT return count
DEDENT

SUM_SERIES_12_32_52_2N_12_1 | def sumOfSeries ( n ) :
INDENT return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 )
DEDENT

MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER | def maxdiff ( arr, n ) :
INDENT freq = defaultdict ( lambda : 0 )
for i in range ( n ) :
INDENT freq [ arr [ i ] ] += 1
DEDENT ans = 0
for i in range ( n ) :
INDENT for j in range ( n ) :
INDENT if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] :
INDENT ans = max ( ans, freq [ arr [ i ] ] - freq [ arr [ j ] ] )
DEDENT elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] :
INDENT ans = max ( ans, freq [ arr [ j ] ] - freq [ arr [ i ] ] )
DEDENT DEDENT DEDENT return ans
DEDENT

SHIFT_MATRIX_ELEMENTS_K | def shiftMatrixByK ( mat, k ) :
INDENT if ( k > N ) :
INDENT print ( "shifting is" " not possible" )
return
DEDENT j = 0
while ( j < N ) :
INDENT for i in range ( k, N ) :
INDENT print ( "{} " . format ( mat [ j ] [ i ] ), end = "" )
DEDENT for i in range ( 0, k ) :
INDENT print ( "{} " . format ( mat [ j ] [ i ] ), end = "" )
DEDENT print ( "" )
j = j + 1
DEDENT DEDENT

MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX | def MAXMIN ( arr, n ) :
INDENT MIN = 10 * * 9
MAX = - 10 * * 9
for i in range ( n ) :
INDENT for j in range ( n //2+1):
INDENTif(arr[i][j]>arr[i][n-j-1]):
INDENTif(MIN>arr[i][n-j-1]):
INDENTMIN=arr[i][n-j-1]
DEDENTif(MAX<arr[i][j]):
INDENTMAX=arr[i][j]
DEDENTDEDENTelse:
INDENTif(MIN>arr[i][j]):
INDENTMIN=arr[i][j]
DEDENTif(MAX<arr[i][n-j-1]):
INDENTMAX=arr[i][n-j-1]
DEDENTDEDENTDEDENTDEDENTprint("MAXimum =",MAX,", MINimum =",MIN)
DEDENT


FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1 | def findGreatest ( arr, n ) :
INDENT m = dict ( )
for i in arr :
INDENT m [ i ] = m . get ( i, 0 ) + 1
DEDENT arr = sorted ( arr )
for i in range ( n - 1, 0, - 1 ) :
INDENT j = 0
while ( j < i and arr [ j ] <= sqrt ( arr [ i ] ) ) :
INDENT if ( arr [ i ] % arr [ j ] == 0 ) :
INDENT result = arr [ i ] //arr[j]
if(result!=arr[j]and(resultinm.keys())andm[result]>0):
INDENTreturnarr[i]
DEDENTelif(result==arr[j]and(resultinm.keys())andm[result]>1):
INDENTreturnarr[i]
DEDENTDEDENTj+=1
DEDENTDEDENTreturn-1
DEDENT


0_1_KNAPSACK_PROBLEM_DP_10_1 | def knapSack ( W, wt, val, n ) :
INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ]
for i in range ( n + 1 ) :
INDENT for w in range ( W + 1 ) :
INDENT if i == 0 or w == 0 :
INDENT K [ i ] [ w ] = 0
DEDENT elif wt [ i - 1 ] <= w :
INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ], K [ i - 1 ] [ w ] )
DEDENT else :
INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ]
DEDENT DEDENT DEDENT return K [ n ] [ W ]
DEDENT

PROGRAM_DECIMAL_OCTAL_CONVERSION | def decToOctal ( n ) :
INDENT octalNum = [ 0 ] * 100;

i = 0;

while ( n != 0 ) :
INDENT octalNum [ i ] = n % 8;

n = int ( n / 8 );

i += 1;

DEDENT for j in range ( i - 1, - 1, - 1 ) :
INDENT print ( octalNum [ j ], end = "" );

DEDENT DEDENT

SUBSEQUENCES_SIZE_THREE_ARRAY_WHOSE_SUM_DIVISIBLE_M_1 | def countSubSeq ( A, N, M ) :
INDENT ans = 0
h = [ 0 ] * M
for i in range ( 0, N ) :
INDENT A [ i ] = A [ i ] % M
h [ A [ i ] ] = h [ A [ i ] ] + 1
DEDENT for i in range ( 0, M ) :
INDENT for j in range ( i, M ) :
INDENT rem = ( M - ( i + j ) % M ) % M
if ( rem < j ) :
INDENT continue
DEDENT if ( i == j and rem == j ) :
INDENT ans = ans + h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6
DEDENT elif ( i == j ) :
INDENT ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 )
DEDENT elif ( i == rem ) :
INDENT ans = ans + h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2
DEDENT elif ( rem == j ) :
INDENT ans = ans + h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2
DEDENT else :
INDENT ans = ans + h [ i ] * h [ j ] * h [ rem ]
DEDENT DEDENT return ans
DEDENT DEDENT

COUNT_FIBONACCI_NUMBERS_GIVEN_RANGE_LOG_TIME | def countFibs ( low, high ) :
INDENT f1, f2, f3 = 0, 1, 1
result = 0
while ( f1 <= high ) :
INDENT if ( f1 >= low ) :
INDENT result += 1
DEDENT f1 = f2
f2 = f3
f3 = f1 + f2
DEDENT return result
DEDENT

FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1 | def isPowerOfFour ( n ) :
INDENT count = 0
if ( n and ( not ( n & ( n - 1 ) ) ) ) :
INDENT while ( n > 1 ) :
INDENT n >>= 1
count += 1
DEDENT if ( count % 2 == 0 ) :
INDENT return True
DEDENT else :
INDENT return False
DEDENT DEDENT DEDENT

FIND_SUM_EVEN_FACTORS_NUMBER | def sumofFactors ( n ) :
INDENT if ( n % 2 != 0 ) :
INDENT return 0
DEDENT res = 1
for i in range ( 2, ( int ) ( math . sqrt ( n ) ) + 1 ) :
INDENT count = 0
curr_sum = 1
curr_term = 1
while ( n % i == 0 ) :
INDENT count = count + 1
n = n //i
if(i==2andcount==1):
INDENTcurr_sum=0
DEDENTcurr_term=curr_term*i
curr_sum=curr_sum+curr_term
DEDENTres=res*curr_sum
DEDENTif(n>=2):
INDENTres=res*(1+n)
DEDENTreturnres
DEDENT


FIND_SUM_NON_REPEATING_DISTINCT_ELEMENTS_ARRAY | def findSum ( arr, n ) :
INDENT s = set ( )
sum = 0
for i in range ( n ) :
INDENT if arr [ i ] not in s :
INDENT s . add ( arr [ i ] )
DEDENT DEDENT for i in s :
INDENT sum = sum + i
DEDENT return sum
DEDENT

DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING_1 | def minPalPartion ( str1 ) :
INDENT n = len ( str1 );

C = [ 0 ] * ( n + 1 );

P = [ [ False for x in range ( n + 1 ) ] for y in range ( n + 1 ) ];

for i in range ( n ) :
INDENT P [ i ] [ i ] = True;

DEDENT for L in range ( 2, n + 1 ) :
INDENT for i in range ( n - L + 1 ) :
INDENT j = i + L - 1;

if ( L == 2 ) :
INDENT P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] );

DEDENT else :
INDENT P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] );

DEDENT DEDENT DEDENT for i in range ( n ) :
INDENT if ( P [ 0 ] [ i ] == True ) :
INDENT C [ i ] = 0;

DEDENT else :
INDENT C [ i ] = sys . maxsize;

for j in range ( i ) :
INDENT if ( P [ j + 1 ] [ i ] == True and 1 + C [ j ] < C [ i ] ) :
INDENT C [ i ] = 1 + C [ j ];

DEDENT DEDENT DEDENT DEDENT return C [ n - 1 ];

DEDENT

MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION | def minInitialPoints ( points ) :
INDENT dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R + 1 ) ]
m, n = R, C
if points [ m - 1 ] [ n - 1 ] > 0 :
INDENT dp [ m - 1 ] [ n - 1 ] = 1
DEDENT else :
INDENT dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1
DEDENT for i in range ( m - 2, - 1, - 1 ) :
INDENT dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ], 1 )
DEDENT for i in range ( 2, - 1, - 1 ) :
INDENT dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ], 1 )
DEDENT for i in range ( m - 2, - 1, - 1 ) :
INDENT for j in range ( n - 2, - 1, - 1 ) :
INDENT min_points_on_exit = min ( dp [ i + 1 ] [ j ], dp [ i ] [ j + 1 ] )
dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ], 1 )
DEDENT DEDENT return dp [ 0 ] [ 0 ]
DEDENT

COUNT_OF_PAIRS_SATISFYING_THE_GIVEN_CONDITION | def countPair ( a, b ) :
INDENT s = str ( b )
i = 0
while i < ( len ( s ) ) :
INDENT if ( s [ i ] != '9' ) :
INDENT break
DEDENT i += 1
DEDENT result = 0
if ( i == len ( s ) ) :
INDENT result = a * len ( s )
DEDENT else :
INDENT result = a * ( len ( s ) - 1 )
DEDENT return result
DEDENT

SURVIVAL | def survival ( S, N, M ) :
INDENT if ( ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N ) :
INDENT print ( "No" )
DEDENT else :
INDENT days = ( M * S ) / N
if ( ( ( M * S ) % N ) != 0 ) :
INDENT days += 1
DEDENT print ( "Yes " ),
print ( days )
DEDENT DEDENT

INTERLEAVE_FIRST_HALF_QUEUE_SECOND_HALF | def interLeaveQueue ( q ) :
INDENT if ( q . qsize ( ) % 2 != 0 ) :
INDENT print ( "Input even number of integers." )
DEDENT s = [ ]
halfSize = int ( q . qsize ( ) / 2 )
for i in range ( halfSize ) :
INDENT s . append ( q . queue [ 0 ] )
q . get ( )
DEDENT while len ( s ) != 0 :
INDENT q . put ( s [ - 1 ] )
s . pop ( )
DEDENT for i in range ( halfSize ) :
INDENT q . put ( q . queue [ 0 ] )
q . get ( )
DEDENT for i in range ( halfSize ) :
INDENT s . append ( q . queue [ 0 ] )
q . get ( )
DEDENT while len ( s ) != 0 :
INDENT q . put ( s [ - 1 ] )
s . pop ( )
q . put ( q . queue [ 0 ] )
q . get ( )
DEDENT DEDENT

INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_1 | def findInteger ( arr, n ) :
INDENT neg = 0
pos = 0
sum = 0
for i in range ( 0, n ) :
INDENT sum += arr [ i ]
if ( arr [ i ] < 0 ) :
INDENT neg += 1
DEDENT else :
INDENT pos += 1
DEDENT DEDENT return ( sum / abs ( neg - pos ) )
DEDENT

FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS | def evenSum ( n ) :
INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]
for i in range ( 0, n + 1 ) :
INDENT for j in range ( 0, min ( i, n + 1 ) ) :
INDENT if j == 0 or j == i :
INDENT C [ i ] [ j ] = 1
DEDENT else :
INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]
DEDENT DEDENT DEDENT sum = 0;

for i in range ( 0, n + 1 ) :
INDENT if n % 2 == 0 :
INDENT sum = sum + C [ n ] [ i ]
DEDENT DEDENT return sum
DEDENT

DELANNOY_NUMBER | def dealnnoy ( n, m ) :
INDENT if ( m == 0 or n == 0 ) :
INDENT return 1
DEDENT return dealnnoy ( m - 1, n ) + dealnnoy ( m - 1, n - 1 ) + dealnnoy ( m, n - 1 )
DEDENT

FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM | def maxLen ( arr ) :
INDENT max_len = 0
for i in range ( len ( arr ) ) :
INDENT curr_sum = 0
for j in range ( i, len ( arr ) ) :
INDENT curr_sum += arr [ j ]
if curr_sum == 0 :
INDENT max_len = max ( max_len, j - i + 1 )
DEDENT DEDENT DEDENT return max_len
DEDENT

NEXT_POWER_OF_2 | def nextPowerOf2 ( n ) :
INDENT count = 0;

if ( n and not ( n & ( n - 1 ) ) ) :
INDENT return n
DEDENT while ( n != 0 ) :
INDENT n >>= 1
count += 1
DEDENT return 1 << count;

DEDENT

LONGEST_GEOMETRIC_PROGRESSION | def lenOfLongestGP ( sett, n ) :
INDENT if n < 2 :
INDENT return n
DEDENT if n == 2 :
INDENT return ( sett [ 1 ] % sett [ 0 ] == 0 )
DEDENT sett . sort ( )
L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]
llgp = 1
for i in range ( 0, n ) :
INDENT if sett [ n - 1 ] % sett [ i ] == 0 :
INDENT L [ i ] [ n - 1 ] = 2
DEDENT else :
INDENT L [ i ] [ n - 1 ] = 1
DEDENT DEDENT for j in range ( n - 2, 0, - 1 ) :
INDENT i = j - 1
k = j + 1
while i >= 0 and k <= n - 1 :
INDENT if sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] :
INDENT k += 1
DEDENT elif sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] :
INDENT if sett [ j ] % sett [ i ] == 0 :
INDENT L [ i ] [ j ] = 2
DEDENT else :
INDENT L [ i ] [ j ] = 1
DEDENT i -= 1
DEDENT else :
INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1
if L [ i ] [ j ] > llgp :
INDENT llgp = L [ i ] [ j ]
DEDENT i -= 1
k + 1
DEDENT DEDENT while i >= 0 :
INDENT if sett [ j ] % sett [ i ] == 0 :
INDENT L [ i ] [ j ] = 2
DEDENT else :
INDENT L [ i ] [ j ] = 1
DEDENT i -= 1
DEDENT DEDENT return llgp
DEDENT

DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH | def minCost ( cost, m, n ) :
INDENT tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ]
tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ]
for i in range ( 1, m + 1 ) :
INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ]
DEDENT for j in range ( 1, n + 1 ) :
INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ]
DEDENT for i in range ( 1, m + 1 ) :
INDENT for j in range ( 1, n + 1 ) :
INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ], tc [ i - 1 ] [ j ], tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ]
DEDENT DEDENT return tc [ m ] [ n ]
DEDENT

PROGRAM_DISTANCE_TWO_POINTS_EARTH | def distance ( lat1, lat2, lon1, lon2 ) :
INDENT lon1 = radians ( lon1 )
lon2 = radians ( lon2 )
lat1 = radians ( lat1 )
lat2 = radians ( lat2 )
dlon = lon2 - lon1
dlat = lat2 - lat1
a = sin ( dlat / 2 ) * * 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) * * 2
c = 2 * asin ( sqrt ( a ) )
r = 6371
return ( c * r )
DEDENT

BIN_PACKING_PROBLEM_MINIMIZE_NUMBER_OF_USED_BINS | def nextfit ( weight, c ) :
INDENT res = 0
rem = c
for _ in range ( len ( weight ) ) :
INDENT if rem >= weight [ _ ] :
INDENT rem = rem - weight [ _ ]
DEDENT else :
INDENT res += 1
rem = c - weight [ _ ]
DEDENT DEDENT return res
DEDENT

FIND_SUBARRAY_WITH_GIVEN_SUM_1 | def subArraySum ( arr, n, sum ) :
INDENT curr_sum = arr [ 0 ]
start = 0
i = 1
while i <= n :
INDENT while curr_sum > sum and start < i - 1 :
INDENT curr_sum = curr_sum - arr [ start ]
start += 1
DEDENT if curr_sum == sum :
INDENT print ( "Sum found between indexes" )
print ( "%d and %d" % ( start, i - 1 ) )
return 1
DEDENT if i < n :
INDENT curr_sum = curr_sum + arr [ i ]
DEDENT i += 1
DEDENT print ( "No subarray found" )
return 0
DEDENT

SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1 | def KnapSack ( val, wt, n, W ) :
INDENT dp = [ 0 ] * ( W + 1 );

for i in range ( n ) :
INDENT for j in range ( W, wt [ i ], - 1 ) :
INDENT dp [ j ] = max ( dp [ j ], val [ i ] + dp [ j - wt [ i ] ] );

DEDENT DEDENT return dp [ W ];

DEDENT

FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X | def yMod ( y, x ) :
INDENT return ( y % pow ( 2, x ) )
DEDENT

SUM_SERIES_23_45_67_89_UPTO_N_TERMS | def seriesSum ( n ) :
INDENT i = 1;

res = 0.0;

sign = True;

while ( n > 0 ) :
INDENT n = n - 1;

if ( sign ) :
INDENT sign = False;

res = res + ( i + 1 ) / ( i + 2 );

i = i + 2;

DEDENT else :
INDENT sign = True;

res = res - ( i + 1 ) / ( i + 2 );

i = i + 2;

DEDENT DEDENT return res;

DEDENT

LENGTH_LONGEST_STRICT_BITONIC_SUBSEQUENCE | def longLenStrictBitonicSub ( arr, n ) :
INDENT inc, dcr = dict ( ), dict ( )
len_inc, len_dcr = [ 0 ] * n, [ 0 ] * n
longLen = 0
for i in range ( n ) :
INDENT len = 0
if inc . get ( arr [ i ] - 1 ) in inc . values ( ) :
INDENT len = inc . get ( arr [ i ] - 1 )
DEDENT inc [ arr [ i ] ] = len_inc [ i ] = len + 1
DEDENT for i in range ( n - 1, - 1, - 1 ) :
INDENT len = 0
if dcr . get ( arr [ i ] - 1 ) in dcr . values ( ) :
INDENT len = dcr . get ( arr [ i ] - 1 )
DEDENT dcr [ arr [ i ] ] = len_dcr [ i ] = len + 1
DEDENT for i in range ( n ) :
INDENT if longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) :
INDENT longLen = len_inc [ i ] + len_dcr [ i ] - 1
DEDENT DEDENT return longLen
DEDENT

MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY | def maxDistance ( arr, n ) :
INDENT mp = {
}

maxDict = 0
for i in range ( n ) :
INDENT if arr [ i ] not in mp . keys ( ) :
INDENT mp [ arr [ i ] ] = i
DEDENT else :
INDENT maxDict = max ( maxDict, i - mp [ arr [ i ] ] )
DEDENT DEDENT return maxDict
DEDENT

FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1 | def isRectangle ( matrix ) :
INDENT rows = len ( matrix )
if ( rows == 0 ) :
INDENT return False
DEDENT columns = len ( matrix [ 0 ] )
table = {
}

for i in range ( rows ) :
INDENT for j in range ( columns - 1 ) :
INDENT for k in range ( j + 1, columns ) :
INDENT if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) :
INDENT if ( j in table and k in table [ j ] ) :
INDENT return True
DEDENT if ( k in table and j in table [ k ] ) :
INDENT return True
DEDENT if j not in table :
INDENT table [ j ] = set ( )
DEDENT if k not in table :
INDENT table [ k ] = set ( )
DEDENT table [ j ] . add ( k )
table [ k ] . add ( j )
DEDENT DEDENT DEDENT DEDENT return False
DEDENT

COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS | def numofsubset ( arr, n ) :
INDENT x = sorted ( arr )
count = 1
for i in range ( 0, n - 1 ) :
INDENT if ( x [ i ] + 1 != x [ i + 1 ] ) :
INDENT count = count + 1
DEDENT DEDENT return count
DEDENT

LARGEST_SUM_CONTIGUOUS_SUBARRAY | def maxSubArraySum ( a, size ) :
INDENT max_so_far = - maxint - 1
max_ending_here = 0
for i in range ( 0, size ) :
INDENT max_ending_here = max_ending_here + a [ i ]
if ( max_so_far < max_ending_here ) :
INDENT max_so_far = max_ending_here
DEDENT if max_ending_here < 0 :
INDENT max_ending_here = 0
DEDENT DEDENT return max_so_far
DEDENT

PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR_2 | def getRemainder ( num, divisor ) :
INDENT while ( num >= divisor ) :
INDENT num -= divisor;

DEDENT return num;

DEDENT

CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT | def check ( st ) :
INDENT n = len ( st )
if ( n == 0 ) :
INDENT return False
DEDENT if ( n == 1 ) :
INDENT return ( ( st [ 0 ] - '0' ) % 4 == 0 )
DEDENT last = ( int ) ( st [ n - 1 ] )
second_last = ( int ) ( st [ n - 2 ] )
return ( ( second_last * 10 + last ) % 4 == 0 )
DEDENT

FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1 | def getSingle ( arr, n ) :
INDENT result = 0
for i in range ( 0, INT_SIZE ) :
INDENT sm = 0
x = ( 1 << i )
for j in range ( 0, n ) :
INDENT if ( arr [ j ] & x ) :
INDENT sm = sm + 1
DEDENT DEDENT if ( sm % 3 ) :
INDENT result = result | x
DEDENT DEDENT return result
DEDENT

NUMBER_RECTANGLES_NM_GRID | def rectCount ( n, m ) :
INDENT return ( m * n * ( n + 1 ) * ( m + 1 ) ) //4
DEDENT


MAXIMUM_POINTS_INTERSECTION_N_CIRCLES | def intersection ( n ) :
INDENT return n * ( n - 1 );

DEDENT

