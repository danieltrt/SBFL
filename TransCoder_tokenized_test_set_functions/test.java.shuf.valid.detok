PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2 | static void printDistinct ( int arr [ ] ) {
  HashSet < Integer > set = new HashSet < > ( );
  for ( int i = 0;
  i < arr . length;
  i ++ ) {
    if ( ! set . contains ( arr [ i ] ) ) {
      set . add ( arr [ i ] );
      System . out . print ( arr [ i ] + " " );
    }
  }
}


CHECK_ROWS_MATRIX_CIRCULAR_ROTATIONS | static boolean isPermutedMatrix ( int mat [ ] [ ], int n ) {
  String str_cat = "";
  for ( int i = 0;
  i < n;
  i ++ ) {
    str_cat = str_cat + "-" + String . valueOf ( mat [ 0 ] [ i ] );
  }
  str_cat = str_cat + str_cat;
  for ( int i = 1;
  i < n;
  i ++ ) {
    String curr_str = "";
    for ( int j = 0;
    j < n;
    j ++ ) {
      curr_str = curr_str + "-" + String . valueOf ( mat [ i ] [ j ] );
    }
    if ( str_cat . contentEquals ( curr_str ) ) {
      return false;
    }
  }
  return true;
}


SUM_PAIRWISE_PRODUCTS | static int findSum ( int n ) {
  int sum = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) for ( int j = i;
  j <= n;
  j ++ ) sum = sum + i * j;
  return sum;
}


SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION | static void printSorted ( int a, int b, int c ) {
  int get_max = Math . max ( a, Math . max ( b, c ) );
  int get_min = - Math . max ( - a, Math . max ( - b, - c ) );
  int get_mid = ( a + b + c ) - ( get_max + get_min );
  System . out . print ( get_min + " " + get_mid + " " + get_max );
}


PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_2 | int factorial ( int n ) {
  return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 );
}


FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2 | static int find_extra_element_index ( int [ ] arrA, int [ ] arrB ) {
  int extra_element = sum ( arrA ) - sum ( arrB );
  return indexOf ( arrA, extra_element );
}


SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THEM_1 | static void printSubsequences ( int n ) {
  int opsize = ( int ) Math . pow ( 2, n );
  for ( int counter = 1;
  counter < opsize;
  counter ++ ) {
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( BigInteger . valueOf ( counter ) . testBit ( j ) ) System . out . print ( arr [ j ] + " " );
    }
    System . out . println ( );
  }
}


N_BONACCI_NUMBERS | static void bonacciseries ( int n, int m ) {
  int [ ] a = new int [ m ];
  a [ n - 1 ] = 1;
  for ( int i = n;
  i < m;
  i ++ ) for ( int j = i - n;
  j < i;
  j ++ ) a [ i ] += a [ j ];
  for ( int i = 0;
  i < m;
  i ++ ) System . out . print ( a [ i ] + " " );
}


LOWER_CASE_UPPER_CASE_INTERESTING_FACT | static String to_upper ( char [ ] in ) {
  for ( int i = 0;
  i < in . length;
  i ++ ) {
    if ( 'a' <= in [ i ] & in [ i ] <= 'z' ) {
      in [ i ] = ( char ) ( in [ i ] - 'a' + 'A' );
    }
  }
  return String . valueOf ( in );
}


PRINT_BRACKET_NUMBER | static void printBracketNumber ( String exp, int n ) {
  int left_bnum = 1;
  Stack < Integer > right_bnum = new Stack < Integer > ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( exp . charAt ( i ) == '(' ) {
      System . out . print ( left_bnum + " " );
      right_bnum . push ( left_bnum );
      left_bnum ++;
    }
    else if ( exp . charAt ( i ) == ')' ) {
      System . out . print ( right_bnum . peek ( ) + " " );
      right_bnum . pop ( );
    }
  }
}


MAXIMUM_PRODUCT_OF_4_ADJACENT_ELEMENTS_IN_MATRIX | static int FindMaxProduct ( int arr [ ] [ ], int n ) {
  int max = 0, result;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( ( j - 3 ) >= 0 ) {
        result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ];
        if ( max < result ) max = result;
      }
      if ( ( i - 3 ) >= 0 ) {
        result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ];
        if ( max < result ) max = result;
      }
      if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) {
        result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ];
        if ( max < result ) max = result;
      }
    }
  }
  return max;
}


LONGEST_SUBARRAY_SUM_DIVISIBLE_K | static int longSubarrWthSumDivByK ( int arr [ ], int n, int k ) {
  HashMap < Integer, Integer > um = new HashMap < Integer, Integer > ( );
  int mod_arr [ ] = new int [ n ];
  int max = 0;
  int curr_sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    curr_sum += arr [ i ];
    mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k;
  }
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( mod_arr [ i ] == 0 ) max = i + 1;
    else if ( um . containsKey ( mod_arr [ i ] ) == false ) um . put ( mod_arr [ i ], i );
    else if ( max < ( i - um . get ( mod_arr [ i ] ) ) ) max = i - um . get ( mod_arr [ i ] );
  }
  return max;
}


CAESAR_CIPHER | public static StringBuffer encrypt ( String text, int s ) {
  StringBuffer result = new StringBuffer ( );
  for ( int i = 0;
  i < text . length ( );
  i ++ ) {
    if ( Character . isUpperCase ( text . charAt ( i ) ) ) {
      char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s - 65 ) % 26 + 65 );
      result . append ( ch );
    }
    else {
      char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s - 97 ) % 26 + 97 );
      result . append ( ch );
    }
  }
  return result;
}


SUBARRAYS_DISTINCT_ELEMENTS | public static int sumoflength ( int [ ] arr, int n ) {
  Set < Integer > s = new HashSet < > ( );
  int j = 0, ans = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    while ( j < n && ! s . contains ( arr [ j ] ) ) {
      s . add ( arr [ i ] );
      j ++;
    }
    ans += ( ( j - i ) * ( j - i + 1 ) ) / 2;
    s . remove ( arr [ i ] );
  }
  return ans;
}


K_TH_ELEMENT_TWO_SORTED_ARRAYS | static int kth ( int arr1 [ ], int arr2 [ ], int m, int n, int k ) {
  int [ ] sorted1 = new int [ m + n ];
  int i = 0, j = 0, d = 0;
  while ( i < m && j < n ) {
    if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ];
    else sorted1 [ d ++ ] = arr2 [ j ++ ];
  }
  while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ];
  while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ];
  return sorted1 [ k - 1 ];
}


REMOVE_CONSECUTIVE_DUPLICATES_STRING | static void removeDuplicates ( char [ ] S ) {
  int n = S . length;
  if ( n < 2 ) {
    return;
  }
  int j = 0;
  for ( int i = 1;
  i < n;
  i ++ ) {
    if ( S [ j ] != S [ i ] ) {
      j ++;
      S [ j ] = S [ i ];
    }
  }
  System . out . println ( Arrays . copyOfRange ( S, 0, j + 1 ) );
}


MAJORITY_ELEMENT | static void findMajority ( int arr [ ], int n ) {
  int maxCount = 0;
  int index = - 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int count = 0;
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( arr [ i ] == arr [ j ] ) count ++;
    }
    if ( count > maxCount ) {
      maxCount = count;
      index = i;
    }
  }
  if ( maxCount > n / 2 ) System . out . println ( arr [ index ] );
  else System . out . println ( "No Majority Element" );
}


FUNCTION_COPY_STRING_ITERATIVE_RECURSIVE_1 | static void myCopy ( char s1 [ ], char s2 [ ], int index ) {
  s2 [ index ] = s1 [ index ];
  if ( index == s1 . length - 1 ) {
    return;
  }
  myCopy ( s1, s2, index + 1 );
}


COUNT_NUMBER_OF_WAYS_TO_COVER_A_DISTANCE_1 | static int printCountDP ( int dist ) {
  int [ ] count = new int [ dist + 1 ];
  count [ 0 ] = 1;
  count [ 1 ] = 1;
  count [ 2 ] = 2;
  for ( int i = 3;
  i <= dist;
  i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ];
  return count [ dist ];
}


DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B | static int discreteLogarithm ( int a, int b, int m ) {
  int n = ( int ) ( Math . sqrt ( m ) + 1 );
  int an = 1;
  for ( int i = 0;
  i < n;
  ++ i ) an = ( an * a ) % m;
  int [ ] value = new int [ m ];
  for ( int i = 1, cur = an;
  i <= n;
  ++ i ) {
    if ( value [ cur ] == 0 ) value [ cur ] = i;
    cur = ( cur * an ) % m;
  }
  for ( int i = 0, cur = b;
  i <= n;
  ++ i ) {
    if ( value [ cur ] > 0 ) {
      int ans = value [ cur ] * n - i;
      if ( ans < m ) return ans;
    }
    cur = ( cur * a ) % m;
  }
  return - 1;
}


CHANGE_BITS_CAN_MADE_ONE_FLIP_1 | static boolean isOneFlip ( String str ) {
  int sum = 0;
  int n = str . length ( );
  for ( int i = 0;
  i < n;
  i ++ ) sum += str . charAt ( i ) - '0';
  return ( sum == n - 1 || sum == 1 );
}


FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY | static void findPair ( int [ ] arr, int n ) {
  boolean found = false;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = i + 1;
    j < n;
    j ++ ) {
      for ( int k = 0;
      k < n;
      k ++ ) {
        if ( arr [ i ] + arr [ j ] == arr [ k ] ) {
          System . out . println ( arr [ i ] + " " + arr [ j ] );
          found = true;
        }
      }
    }
  }
  if ( found == false ) System . out . println ( "Not exist" );
}


MODULAR_MULTIPLICATIVE_INVERSE_1_N | static void modularInverse ( int n, int prime ) {
  int dp [ ] = new int [ n + 1 ];
  dp [ 0 ] = dp [ 1 ] = 1;
  for ( int i = 2;
  i <= n;
  i ++ ) dp [ i ] = dp [ prime % i ] * ( prime - prime / i ) % prime;
  for ( int i = 1;
  i <= n;
  i ++ ) System . out . print ( dp [ i ] + " " );
}


SHUFFLE_2N_INTEGERS_FORMAT_A1_B1_A2_B2_A3_B3_BN_WITHOUT_USING_EXTRA_SPACE_1 | static void shufleArray ( int a [ ], int f, int l ) {
  if ( l > f ) return;
  if ( l - f == 1 ) return;
  int mid = ( f + l ) / 2;
  int temp = mid + 1;
  int mmid = ( f + mid ) / 2;
  for ( int i = mmid + 1;
  i <= mid;
  i ++ ) {
    int temp1 = a [ i ];
    a [ i ] = a [ temp ];
    a [ temp ++ ] = temp1;
  }
  shufleArray ( a, f, mid );
  shufleArray ( a, mid + 1, l );
}


N_TH_ROOT_NUMBER | static double nthRoot ( int A, int N ) {
  double xPre = Math . random ( ) % 10;
  double eps = 0.001;
  double delX = 2147483647;
  double xK = 0.0;
  while ( delX > eps ) {
    xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( xPre, N - 1 ) ) / ( double ) N;
    delX = Math . abs ( xK - xPre );
    xPre = xK;
  }
  return xK;
}


NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS | static int waysToArrange ( int N, int K, int [ ] k ) {
  int [ ] [ ] C = new int [ N + 1 ] [ N + 1 ];
  int i, j;
  for ( i = 0;
  i <= N;
  i ++ ) {
    for ( j = 0;
    j <= i;
    j ++ ) {
      if ( j == 0 || j == i ) {
        C [ i ] [ j ] = 1;
      }
      else {
        C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] );
      }
    }
  }
  int [ ] dp = new int [ K + 1 ];
  int count = 0;
  dp [ 0 ] = 1;
  for ( i = 0;
  i < K;
  i ++ ) {
    dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] );
    count += k [ i ];
  }
  return dp [ K ];
}


TEMPLE_OFFERINGS | static int offeringNumber ( int n, int templeHeight [ ] ) {
  int sum = 0;
  for ( int i = 0;
  i < n;
  ++ i ) {
    int left = 0, right = 0;
    for ( int j = i - 1;
    j >= 0;
    -- j ) {
      if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left;
      else break;
    }
    for ( int j = i + 1;
    j < n;
    ++ j ) {
      if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right;
      else break;
    }
    sum += Math . max ( right, left ) + 1;
  }
  return sum;
}


CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS | static boolean HalfDiagonalSums ( int mat [ ] [ ], int n ) {
  int diag1_left = 0, diag1_right = 0;
  int diag2_left = 0, diag2_right = 0;
  for ( int i = 0, j = n - 1;
  i < n;
  i ++, j -- ) {
    if ( i < n / 2 ) {
      diag1_left += mat [ i ] [ i ];
      diag2_left += mat [ j ] [ i ];
    }
    else if ( i > n / 2 ) {
      diag1_right += mat [ i ] [ i ];
      diag2_right += mat [ j ] [ i ];
    }
  }
  return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] );
}


COUNT_FACTORIAL_NUMBERS_IN_A_GIVEN_RANGE | static int countFact ( int low, int high ) {
  int fact = 1, x = 1;
  while ( fact < low ) {
    fact = fact * x;
    x ++;
  }
  int res = 0;
  while ( fact <= high ) {
    res ++;
    fact = fact * x;
    x ++;
  }
  return res;
}


PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1 | static void reverseStr ( String str ) {
  int n = str . length ( );
  char [ ] ch = str . toCharArray ( );
  char temp;
  for ( int i = 0, j = n - 1;
  i < j;
  i ++, j -- ) {
    temp = ch [ i ];
    ch [ i ] = ch [ j ];
    ch [ j ] = temp;
  }
  System . out . println ( ch );
}


FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY | static int minAdjustmentCost ( int A [ ], int n, int target ) {
  int [ ] [ ] dp = new int [ n ] [ M + 1 ];
  for ( int j = 0;
  j <= M;
  j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] );
  for ( int i = 1;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j <= M;
    j ++ ) {
      dp [ i ] [ j ] = Integer . MAX_VALUE;
      int k = Math . max ( j - target, 0 );
      for (;
      k <= Math . min ( M, j + target );
      k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ], dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) );
    }
  }
  int res = Integer . MAX_VALUE;
  for ( int j = 0;
  j <= M;
  j ++ ) res = Math . min ( res, dp [ n - 1 ] [ j ] );
  return res;
}


COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ | public static int find ( int n, int k ) {
  if ( n + 1 >= k ) return ( k - 1 );
  else return ( 2 * n + 1 - k );
}


MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1 | static int minimumflip ( int mat [ ] [ ], int n ) {
  int flip = 0;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 0;
  j < i;
  j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++;
  return flip;
}


NTH_PALINDROME_K_DIGITS | static void nthPalindrome ( int n, int k ) {
  int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 );
  int palindrome = ( int ) Math . pow ( 10, temp );
  palindrome += n - 1;
  System . out . print ( palindrome );
  if ( ( k & 1 ) > 0 ) palindrome /= 10;
  while ( palindrome > 0 ) {
    System . out . print ( palindrome % 10 );
    palindrome /= 10;
  }
  System . out . println ( "" );
}


DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1 | static int lis ( int arr [ ], int n ) {
  int lis [ ] = new int [ n ];
  int i, j, max = 0;
  for ( i = 0;
  i < n;
  i ++ ) lis [ i ] = 1;
  for ( i = 1;
  i < n;
  i ++ ) for ( j = 0;
  j < i;
  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1;
  for ( i = 0;
  i < n;
  i ++ ) if ( max < lis [ i ] ) max = lis [ i ];
  return max;
}


PATH_MAXIMUM_AVERAGE_VALUE | public static double maxAverageOfPath ( int cost [ ] [ ], int N ) {
  int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ];
  dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ];
  for ( int i = 1;
  i < N;
  i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ];
  for ( int j = 1;
  j < N;
  j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ];
  for ( int i = 1;
  i < N;
  i ++ ) for ( int j = 1;
  j < N;
  j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ];
  return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 );
}


PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING | public static int count ( String s, char c ) {
  int res = 0;
  for ( int i = 0;
  i < s . length ( );
  i ++ ) {
    if ( s . charAt ( i ) == c ) res ++;
  }
  return res;
}


KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY | public static int kthSmallest ( Integer [ ] arr, int k ) {
  Arrays . sort ( arr );
  return arr [ k - 1 ];
}


CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE | static void convertOpposite ( StringBuffer str ) {
  int ln = str . length ( );
  for ( int i = 0;
  i < ln;
  i ++ ) {
    Character c = str . charAt ( i );
    if ( Character . isLowerCase ( c ) ) str . replace ( i, i + 1, Character . toUpperCase ( c ) + "" );
    else str . replace ( i, i + 1, Character . toLowerCase ( c ) + "" );
  }
}


SUM_SERIES_555555_N_TERMS | static int sumOfSeries ( int n ) {
  return ( int ) ( 0.6172 * ( Math . pow ( 10, n ) - 1 ) - 0.55 * n );
}


DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION | static int MatrixChainOrder ( int p [ ], int i, int j ) {
  if ( i == j ) return 0;
  int min = Integer . MAX_VALUE;
  for ( int k = i;
  k < j;
  k ++ ) {
    int count = MatrixChainOrder ( p, i, k ) + MatrixChainOrder ( p, k + 1, j ) + p [ i - 1 ] * p [ k ] * p [ j ];
    if ( count < min ) min = count;
  }
  return min;
}


COUNT_SET_BITS_IN_AN_INTEGER_3 | public static int countSetBits ( int n ) {
  if ( n == 0 ) return 0;
  else return 1 + countSetBits ( n & ( n - 1 ) );
}


MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMPLETE_ARRAY_SORTED | static void printUnsorted ( int arr [ ], int n ) {
  int s = 0, e = n - 1, i, max, min;
  for ( s = 0;
  s < n - 1;
  s ++ ) {
    if ( arr [ s ] > arr [ s + 1 ] ) break;
  }
  if ( s == n - 1 ) {
    System . out . println ( "The complete array is sorted" );
    return;
  }
  for ( e = n - 1;
  e > 0;
  e -- ) {
    if ( arr [ e ] < arr [ e - 1 ] ) break;
  }
  max = arr [ s ];
  min = arr [ s ];
  for ( i = s + 1;
  i <= e;
  i ++ ) {
    if ( arr [ i ] > max ) max = arr [ i ];
    if ( arr [ i ] < min ) min = arr [ i ];
  }
  for ( i = 0;
  i < s;
  i ++ ) {
    if ( arr [ i ] > min ) {
      s = i;
      break;
    }
  }
  for ( i = n - 1;
  i >= e + 1;
  i -- ) {
    if ( arr [ i ] < max ) {
      e = i;
      break;
    }
  }
  System . out . println ( " The unsorted subarray which" + " makes the given array sorted lies" + "  between the indices " + s + " and " + e );
  return;
}


STEINS_ALGORITHM_FOR_FINDING_GCD | static int gcd ( int a, int b ) {
  if ( a == 0 ) return b;
  if ( b == 0 ) return a;
  int k;
  for ( k = 0;
  ( ( a | b ) & 1 ) == 0;
  ++ k ) {
    a >>= 1;
    b >>= 1;
  }
  while ( ( a & 1 ) == 0 ) a >>= 1;
  do {
    while ( ( b & 1 ) == 0 ) b >>= 1;
    if ( a > b ) {
      int temp = a;
      a = b;
      b = temp;
    }
    b = ( b - a );
  }
  while ( b != 0 );
  return a << k;
}


HEXAGONAL_NUMBER | int hexagonalNum ( int n ) {
  return n * ( 2 * n - 1 );
}


GOOGLE_CASE_GIVEN_SENTENCE | static String convert ( String s ) {
  int n = s . length ( );
  String s1 = "";
  s1 = s1 + Character . toLowerCase ( s . charAt ( 0 ) );
  for ( int i = 1;
  i < n;
  i ++ ) {
    if ( s . charAt ( i ) == ' ' && i < n ) {
      s1 = s1 + " " + Character . toLowerCase ( s . charAt ( i + 1 ) );
      i ++;
    }
    else s1 = s1 + Character . toUpperCase ( s . charAt ( i ) );
  }
  return s1;
}


FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE | static int maxHamming ( int arr [ ], int n ) {
  int brr [ ] = new int [ 2 * n + 1 ];
  for ( int i = 0;
  i < n;
  i ++ ) brr [ i ] = arr [ i ];
  for ( int i = 0;
  i < n;
  i ++ ) brr [ n + i ] = arr [ i ];
  int maxHam = 0;
  for ( int i = 1;
  i < n;
  i ++ ) {
    int currHam = 0;
    for ( int j = i, k = 0;
    j < ( i + n );
    j ++, k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++;
    if ( currHam == n ) return n;
    maxHam = Math . max ( maxHam, currHam );
  }
  return maxHam;
}


GIVEN_A_NUMBER_N_GENERATE_BIT_PATTERNS_FROM_0_TO_2N_1_SO_THAT_SUCCESSIVE_PATTERNS_DIFFER_BY_ONE_BIT | static void generateGrayarr ( int n ) {
  if ( n <= 0 ) return;
  ArrayList < String > arr = new ArrayList < String > ( );
  arr . add ( "0" );
  arr . add ( "1" );
  int i, j;
  for ( i = 2;
  i < ( 1 << n );
  i = i << 1 ) {
    for ( j = i - 1;
    j >= 0;
    j -- ) arr . add ( arr . get ( j ) );
    for ( j = 0;
    j < i;
    j ++ ) arr . set ( j, "0" + arr . get ( j ) );
    for ( j = i;
    j < 2 * i;
    j ++ ) arr . set ( j, "1" + arr . get ( j ) );
  }
  for ( i = 0;
  i < arr . size ( );
  i ++ ) System . out . println ( arr . get ( i ) );
}


MINIMUM_SWAPS_REQUIRED_BRING_ELEMENTS_LESS_EQUAL_K_TOGETHER | static int minSwap ( int arr [ ], int n, int k ) {
  int count = 0;
  for ( int i = 0;
  i < n;
  ++ i ) if ( arr [ i ] <= k ) ++ count;
  int bad = 0;
  for ( int i = 0;
  i < count;
  ++ i ) if ( arr [ i ] > k ) ++ bad;
  int ans = bad;
  for ( int i = 0, j = count;
  j < n;
  ++ i, ++ j ) {
    if ( arr [ i ] > k ) -- bad;
    if ( arr [ j ] > k ) ++ bad;
    ans = Math . min ( ans, bad );
  }
  return ans;
}


FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO | static int fib ( int n ) {
  if ( n < 6 ) return f [ n ];
  int t = 5;
  int fn = 5;
  while ( t < n ) {
    fn = ( int ) Math . round ( fn * PHI );
    t ++;
  }
  return fn;
}


SORTING_ARRAY_REVERSE_AROUND_MIDDLE | static boolean ifPossible ( int arr [ ], int n ) {
  int copy [ ] = Arrays . copyOf ( arr, arr . length );
  Arrays . sort ( copy );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false;
  }
  return true;
}


COUNT_ROTATIONS_DIVISIBLE_4 | static int countRotations ( String n ) {
  int len = n . length ( );
  if ( len == 1 ) {
    int oneDigit = n . charAt ( 0 ) - '0';
    if ( oneDigit % 4 == 0 ) return 1;
    return 0;
  }
  int twoDigit, count = 0;
  for ( int i = 0;
  i < ( len - 1 );
  i ++ ) {
    twoDigit = ( n . charAt ( i ) - '0' ) * 10 + ( n . charAt ( i + 1 ) - '0' );
    if ( twoDigit % 4 == 0 ) count ++;
  }
  twoDigit = ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' );
  if ( twoDigit % 4 == 0 ) count ++;
  return count;
}


N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2 | public static int findNth ( int n ) {
  int nthElement = 19 + ( n - 1 ) * 9;
  int outliersCount = ( int ) Math . log10 ( nthElement ) - 1;
  nthElement += 9 * outliersCount;
  return nthElement;
}


PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1 | static boolean isPrime ( int n ) {
  if ( n <= 1 ) return false;
  if ( n <= 3 ) return true;
  if ( n % 2 == 0 || n % 3 == 0 ) return false;
  for ( int i = 5;
  i * i <= n;
  i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false;
  return true;
}


MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1 | static int subset ( int arr [ ], int n ) {
  HashMap < Integer, Integer > mp = new HashMap < > ( );
  for ( int i = 0;
  i < n;
  i ++ ) mp . put ( arr [ i ], mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 );
  int res = 0;
  for ( Map . Entry < Integer, Integer > entry : mp . entrySet ( ) ) res = Math . max ( res, entry . getValue ( ) );
  return res;
}


RECAMANS_SEQUENCE_1 | static void recaman ( int n ) {
  if ( n <= 0 ) return;
  System . out . printf ( "%d, ", 0 );
  HashSet < Integer > s = new HashSet < Integer > ( );
  s . add ( 0 );
  int prev = 0;
  for ( int i = 1;
  i < n;
  i ++ ) {
    int curr = prev - i;
    if ( curr < 0 || s . contains ( curr ) ) curr = prev + i;
    s . add ( curr );
    System . out . printf ( "%d, ", curr );
    prev = curr;
  }
}


GENERATE_ROTATIONS_GIVEN_STRING_1 | static void printRotatedString ( String str ) {
  int n = str . length ( );
  StringBuffer sb = new StringBuffer ( str );
  sb . append ( str );
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j != n;
    j ++ ) System . out . print ( sb . charAt ( i + j ) );
    System . out . println ( );
  }
}


FITTING_SHELVES_PROBLEM | static void minSpacePreferLarge ( int wall, int m, int n ) {
  int num_m = 0, num_n = 0, min_empty = wall;
  int p = 0, q = 0, rem;
  while ( wall >= n ) {
    p = wall / m;
    rem = wall % m;
    if ( rem <= min_empty ) {
      num_m = p;
      num_n = q;
      min_empty = rem;
    }
    q += 1;
    wall = wall - n;
  }
  System . out . println ( num_m + " " + num_n + " " + min_empty );
}


COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1 | static int countStr ( int n ) {
  return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 );
}


DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER | static boolean isDvisibleBy12 ( String num ) {
  if ( num . length ( ) >= 3 ) {
    int d1 = ( int ) num . charAt ( num . length ( ) - 1 );
    if ( d1 % 2 != 0 ) return false;
    int d2 = ( int ) num . charAt ( num . length ( ) - 2 );
    int sum = 0;
    for ( int i = 0;
    i < num . length ( );
    i ++ ) sum += num . charAt ( i );
    return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 );
  }
  else {
    int number = Integer . parseInt ( num );
    return ( number % 12 == 0 );
  }
}


DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1 | static int maxProd ( int n ) {
  if ( n == 2 || n == 3 ) return ( n - 1 );
  int res = 1;
  while ( n > 4 ) {
    n -= 3;
    res *= 3;
  }
  return ( n * res );
}


RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS | static void maxProduct ( int arr [ ], int n ) {
  if ( n < 2 ) {
    System . out . println ( "No pairs exists" );
    return;
  }
  int a = arr [ 0 ], b = arr [ 1 ];
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) if ( arr [ i ] * arr [ j ] > a * b ) {
    a = arr [ i ];
    b = arr [ j ];
  }
  System . out . println ( "Max product pair is {" + a + ", " + b + "}" );
}


SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2 | static int findSum ( int n ) {
  n --;
  int sum = 0;
  sum += ( n * ( n + 1 ) ) / 2;
  sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6;
  return sum;
}


PRINT_MATRIX_ANTISPIRAL_FORM | public static void antiSpiralTraversal ( int m, int n, int a [ ] [ ] ) {
  int i, k = 0, l = 0;
  Stack < Integer > stk = new Stack < Integer > ( );
  while ( k <= m && l <= n ) {
    for ( i = l;
    i <= n;
    ++ i ) stk . push ( a [ k ] [ i ] );
    k ++;
    for ( i = k;
    i <= m;
    ++ i ) stk . push ( a [ i ] [ n ] );
    n --;
    if ( k <= m ) {
      for ( i = n;
      i >= l;
      -- i ) stk . push ( a [ m ] [ i ] );
      m --;
    }
    if ( l <= n ) {
      for ( i = m;
      i >= k;
      -- i ) stk . push ( a [ i ] [ l ] );
      l ++;
    }
  }
  while ( ! stk . empty ( ) ) {
    System . out . print ( stk . peek ( ) + " " );
    stk . pop ( );
  }
}


DICE_THROW_PROBLEM_1 | public static long findWays ( int f, int d, int s ) {
  long mem [ ] [ ] = new long [ d + 1 ] [ s + 1 ];
  mem [ 0 ] [ 0 ] = 1;
  for ( int i = 1;
  i <= d;
  i ++ ) {
    for ( int j = i;
    j <= s;
    j ++ ) {
      mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ];
      if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ];
    }
  }
  return mem [ d ] [ s ];
}


WRITE_A_C_PROGRAM_TO_CALCULATE_POWXN | static int power ( int x, int y ) {
  if ( y == 0 ) return 1;
  else if ( y % 2 == 0 ) return power ( x, y / 2 ) * power ( x, y / 2 );
  else return x * power ( x, y / 2 ) * power ( x, y / 2 );
}


SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING | static String findSubString ( String str ) {
  int n = str . length ( );
  int dist_count = 0;
  boolean [ ] visited = new boolean [ MAX_CHARS ];
  Arrays . fill ( visited, false );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( visited [ str . charAt ( i ) ] == false ) {
      visited [ str . charAt ( i ) ] = true;
      dist_count ++;
    }
  }
  int start = 0, start_index = - 1;
  int min_len = Integer . MAX_VALUE;
  int count = 0;
  int [ ] curr_count = new int [ MAX_CHARS ];
  for ( int j = 0;
  j < n;
  j ++ ) {
    curr_count [ str . charAt ( j ) ] ++;
    if ( curr_count [ str . charAt ( j ) ] == 1 ) count ++;
    if ( count == dist_count ) {
      while ( curr_count [ str . charAt ( start ) ] > 1 ) {
        if ( curr_count [ str . charAt ( start ) ] > 1 ) curr_count [ str . charAt ( start ) ] --;
        start ++;
      }
      int len_window = j - start + 1;
      if ( min_len > len_window ) {
        min_len = len_window;
        start_index = start;
      }
    }
  }
  return str . substring ( start_index, start_index + min_len );
}


CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFERENCES_IS_MINIMUM | static void solve ( int i, int par, int a [ ], int n, int k, int current_ans ) {
  if ( par > k ) return;
  if ( par == k && i == n - 1 ) {
    ans = Math . min ( ans, current_ans );
    return;
  }
  for ( int j = i + 1;
  j < n;
  j ++ ) solve ( j, par + 1, a, n, k, current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) );
}


PROGRAM_FIND_SMALLEST_LARGEST_WORD_STRING | static void minMaxLengthWords ( String input ) {
  int len = input . length ( );
  int si = 0, ei = 0;
  int min_length = len, min_start_index = 0, max_length = 0, max_start_index = 0;
  while ( ei <= len ) {
    if ( ei < len && input . charAt ( ei ) != ' ' ) {
      ei ++;
    }
    else {
      int curr_length = ei - si;
      if ( curr_length < min_length ) {
        min_length = curr_length;
        min_start_index = si;
      }
      if ( curr_length > max_length ) {
        max_length = curr_length;
        max_start_index = si;
      }
      ei ++;
      si = ei;
    }
  }
  minWord = input . substring ( min_start_index, min_start_index + min_length );
  maxWord = input . substring ( max_start_index, max_length );
}


CHECK_VALID_SEQUENCE_DIVISIBLE_M_1 | static int isPossible ( int n, int index, int modulo, int M, int arr [ ], int dp [ ] [ ] ) {
  modulo = ( ( modulo % M ) + M ) % M;
  if ( index == n ) {
    if ( modulo == 0 ) {
      return 1;
    }
    return 0;
  }
  if ( dp [ index ] [ modulo ] != - 1 ) {
    return dp [ index ] [ modulo ];
  }
  int placeAdd = isPossible ( n, index + 1, modulo + arr [ index ], M, arr, dp );
  int placeMinus = isPossible ( n, index + 1, modulo - arr [ index ], M, arr, dp );
  int res = placeAdd;
  dp [ index ] [ modulo ] = res;
  return res;
}


MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY | public static int minOperation ( int arr [ ], int n ) {
  HashMap < Integer, Integer > hash = new HashMap < Integer, Integer > ( );
  for ( int i = 0;
  i < n;
  i ++ ) if ( hash . containsKey ( arr [ i ] ) ) hash . put ( arr [ i ], hash . get ( arr [ i ] ) + 1 );
  else hash . put ( arr [ i ], 1 );
  int max_count = 0;
  Set < Integer > s = hash . keySet ( );
  for ( int i : s ) if ( max_count < hash . get ( i ) ) max_count = hash . get ( i );
  return ( n - max_count );
}


HYPERCUBE_GRAPH | static int power ( int n ) {
  if ( n == 1 ) return 2;
  return 2 * power ( n - 1 );
}


PROGRAM_FIND_CORRELATION_COEFFICIENT | static float correlationCoefficient ( int X [ ], int Y [ ], int n ) {
  int sum_X = 0, sum_Y = 0, sum_XY = 0;
  int squareSum_X = 0, squareSum_Y = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    sum_X = sum_X + X [ i ];
    sum_Y = sum_Y + Y [ i ];
    sum_XY = sum_XY + X [ i ] * Y [ i ];
    squareSum_X = squareSum_X + X [ i ] * X [ i ];
    squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ];
  }
  float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) );
  return corr;
}


COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING | static int countPS ( String str ) {
  int N = str . length ( );
  int [ ] [ ] cps = new int [ N + 1 ] [ N + 1 ];
  for ( int i = 0;
  i < N;
  i ++ ) cps [ i ] [ i ] = 1;
  for ( int L = 2;
  L <= N;
  L ++ ) {
    for ( int i = 0;
    i < N;
    i ++ ) {
      int k = L + i - 1;
      if ( k < N ) {
        if ( str . charAt ( i ) == str . charAt ( k ) ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1;
        else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ];
      }
    }
  }
  return cps [ 0 ] [ N - 1 ];
}


SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1 | static int nextPowerOf2 ( int n ) {
  int p = 1;
  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n;
  while ( p < n ) p <<= 1;
  return p;
}


FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B | static int computeLastDigit ( long A, long B ) {
  int variable = 1;
  if ( A == B ) return 1;
  else if ( ( B - A ) >= 5 ) return 0;
  else {
    for ( long i = A + 1;
    i <= B;
    i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10;
    return variable % 10;
  }
}


NUMBER_SUBSTRINGS_DIVISIBLE_4_STRING_INTEGERS | static int countDivisbleby4 ( String s ) {
  int n = s . length ( );
  int count = 0;
  for ( int i = 0;
  i < n;
  ++ i ) if ( s . charAt ( i ) == '4' || s . charAt ( i ) == '8' || s . charAt ( i ) == '0' ) count ++;
  for ( int i = 0;
  i < n - 1;
  ++ i ) {
    int h = ( s . charAt ( i ) - '0' ) * 10 + ( s . charAt ( i + 1 ) - '0' );
    if ( h % 4 == 0 ) count = count + i + 1;
  }
  return count;
}


DECODE_MEDIAN_STRING_ORIGINAL_STRING | static String decodeMedianString ( String s ) {
  int l = s . length ( );
  String s1 = "";
  boolean isEven = ( l % 2 == 0 ) ? true : false;
  for ( int i = 0;
  i < l;
  i += 2 ) {
    if ( isEven ) {
      s1 = s . charAt ( i ) + s1;
      s1 += s . charAt ( i + 1 );
    }
    else {
      if ( l - i > 1 ) {
        s1 += s . charAt ( i );
        s1 = s . charAt ( i + 1 ) + s1;
      }
      else {
        s1 += s . charAt ( i );
      }
    }
  }
  return s1;
}


NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS_IN_RANGE_M_TO_N | static int maximumNumberDistinctPrimeRange ( int m, int n ) {
  long factorCount [ ] = new long [ n + 1 ];
  boolean prime [ ] = new boolean [ n + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) {
    factorCount [ i ] = 0;
    prime [ i ] = true;
  }
  for ( int i = 2;
  i <= n;
  i ++ ) {
    if ( prime [ i ] == true ) {
      factorCount [ i ] = 1;
      for ( int j = i * 2;
      j <= n;
      j += i ) {
        factorCount [ j ] ++;
        prime [ j ] = false;
      }
    }
  }
  int max = ( int ) factorCount [ m ];
  int num = m;
  for ( int i = m;
  i <= n;
  i ++ ) {
    if ( factorCount [ i ] > max ) {
      max = ( int ) factorCount [ i ];
      num = i;
    }
  }
  return num;
}


NUMBER_EQUAL_PAIRS_STRING | static int countPairs ( String s ) {
  int cnt [ ] = new int [ MAX ];
  for ( int i = 0;
  i < s . length ( );
  i ++ ) cnt [ s . charAt ( i ) ] ++;
  int ans = 0;
  for ( int i = 0;
  i < MAX;
  i ++ ) ans += cnt [ i ] * cnt [ i ];
  return ans;
}


COUNT_NUMBER_WAYS_REACH_DESTINATION_MAZE | static int countPaths ( int maze [ ] [ ] ) {
  if ( maze [ 0 ] [ 0 ] == - 1 ) return 0;
  for ( int i = 0;
  i < R;
  i ++ ) {
    if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1;
    else break;
  }
  for ( int i = 1;
  i < C;
  i ++ ) {
    if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1;
    else break;
  }
  for ( int i = 1;
  i < R;
  i ++ ) {
    for ( int j = 1;
    j < C;
    j ++ ) {
      if ( maze [ i ] [ j ] == - 1 ) continue;
      if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] );
      if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] );
    }
  }
  return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0;
}


FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS | public static int maxSum ( int stack1 [ ], int stack2 [ ], int stack3 [ ], int n1, int n2, int n3 ) {
  int sum1 = 0, sum2 = 0, sum3 = 0;
  for ( int i = 0;
  i < n1;
  i ++ ) sum1 += stack1 [ i ];
  for ( int i = 0;
  i < n2;
  i ++ ) sum2 += stack2 [ i ];
  for ( int i = 0;
  i < n3;
  i ++ ) sum3 += stack3 [ i ];
  int top1 = 0, top2 = 0, top3 = 0;
  int ans = 0;
  while ( true ) {
    if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0;
    if ( sum1 == sum2 && sum2 == sum3 ) return sum1;
    if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1 ++ ];
    else if ( sum2 >= sum3 && sum2 >= sum3 ) sum2 -= stack2 [ top2 ++ ];
    else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ top3 ++ ];
  }
}


MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS | static int maxSum ( int arr [ ], int N, int k ) {
  int MS [ ] = new int [ N ];
  MS [ N - 1 ] = arr [ N - 1 ];
  for ( int i = N - 2;
  i >= 0;
  i -- ) {
    if ( i + k + 1 >= N ) MS [ i ] = Math . max ( arr [ i ], MS [ i + 1 ] );
    else MS [ i ] = Math . max ( arr [ i ] + MS [ i + k + 1 ], MS [ i + 1 ] );
  }
  return MS [ 0 ];
}


CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1 | public static boolean isEven ( int n ) {
  if ( ( n & 1 ) == 0 ) return true;
  else return false;
}


SORT_ARRAY_TWO_HALVES_SORTED | static void mergeTwoHalf ( int [ ] A, int n ) {
  Arrays . sort ( A );
}


PYTHAGOREAN_QUADRUPLE | static Boolean pythagorean_quadruple ( int a, int b, int c, int d ) {
  int sum = a * a + b * b + c * c;
  if ( d * d == sum ) return true;
  else return false;
}


FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN_ARRAY | static void printMaxOfMin ( int n ) {
  for ( int k = 1;
  k <= n;
  k ++ ) {
    int maxOfMin = Integer . MIN_VALUE;
    for ( int i = 0;
    i <= n - k;
    i ++ ) {
      int min = arr [ i ];
      for ( int j = 1;
      j < k;
      j ++ ) {
        if ( arr [ i + j ] < min ) min = arr [ i + j ];
      }
      if ( min > maxOfMin ) maxOfMin = min;
    }
    System . out . print ( maxOfMin + " " );
  }
}


COUNT_SUM_OF_DIGITS_IN_NUMBERS_FROM_1_TO_N | static int sumOfDigitsFrom1ToN ( int n ) {
  if ( n < 10 ) return ( n * ( n + 1 ) / 2 );
  int d = ( int ) ( Math . log10 ( n ) );
  int a [ ] = new int [ d + 1 ];
  a [ 0 ] = 0;
  a [ 1 ] = 45;
  for ( int i = 2;
  i <= d;
  i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10, i - 1 ) ) );
  int p = ( int ) ( Math . ceil ( Math . pow ( 10, d ) ) );
  int msd = n / p;
  return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) );
}


RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1 | static int breakSum ( int n ) {
  int dp [ ] = new int [ n + 1 ];
  dp [ 0 ] = 0;
  dp [ 1 ] = 1;
  for ( int i = 2;
  i <= n;
  i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ], i );
  return dp [ n ];
}


FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N | static int findRepeatingElement ( int arr [ ], int low, int high ) {
  if ( low > high ) return - 1;
  int mid = ( low + high ) / 2;
  if ( arr [ mid ] != mid + 1 ) {
    if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid;
    return findRepeatingElement ( arr, low, mid - 1 );
  }
  return findRepeatingElement ( arr, mid + 1, high );
}


COUNT_SUBARRAYS_EQUAL_NUMBER_1S_0S_1 | static int countSubarrWithEqualZeroAndOne ( int [ ] arr, int n ) {
  Map < Integer, Integer > myMap = new HashMap < > ( );
  int sum = 0;
  int count = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] == 0 ) arr [ i ] = - 1;
    sum += arr [ i ];
    if ( sum == 0 ) count ++;
    if ( myMap . containsKey ( sum ) ) count += myMap . get ( sum );
    if ( ! myMap . containsKey ( sum ) ) myMap . put ( sum, 1 );
    else myMap . put ( sum, myMap . get ( sum ) + 1 );
  }
  return count;
}


UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1 | static void printIntersection ( int arr1 [ ], int arr2 [ ], int m, int n ) {
  int i = 0, j = 0;
  while ( i < m && j < n ) {
    if ( arr1 [ i ] < arr2 [ j ] ) i ++;
    else if ( arr2 [ j ] < arr1 [ i ] ) j ++;
    else {
      System . out . print ( arr2 [ j ++ ] + " " );
      i ++;
    }
  }
}


COUNT_ALL_INCREASING_SUBSEQUENCES | static int countSub ( int arr [ ], int n ) {
  int count [ ] = new int [ 10 ];
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = arr [ i ] - 1;
    j >= 0;
    j -- ) count [ arr [ i ] ] += count [ j ];
    count [ arr [ i ] ] ++;
  }
  int result = 0;
  for ( int i = 0;
  i < 10;
  i ++ ) result += count [ i ];
  return result;
}


SMALLEST_NUMBER_SUM_DIGITS_N_DIVISIBLE_10N | static void digitsNum ( int N ) {
  if ( N == 0 ) System . out . println ( "0" );
  if ( N % 9 != 0 ) System . out . print ( ( N % 9 ) );
  for ( int i = 1;
  i <= ( N / 9 );
  ++ i ) System . out . print ( "9" );
  for ( int i = 1;
  i <= N;
  ++ i ) System . out . print ( "0" );
  System . out . print ( "" );
}


FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_1 | static int getOddOccurrence ( int arr [ ], int n ) {
  HashMap < Integer, Integer > hmap = new HashMap < > ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( hmap . containsKey ( arr [ i ] ) ) {
      int val = hmap . get ( arr [ i ] );
      hmap . put ( arr [ i ], val + 1 );
    }
    else hmap . put ( arr [ i ], 1 );
  }
  for ( Integer a : hmap . keySet ( ) ) {
    if ( hmap . get ( a ) % 2 != 0 ) return a;
  }
  return - 1;
}


CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE | static int isChangeable ( int notes [ ], int n ) {
  int fiveCount = 0;
  int tenCount = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( notes [ i ] == 5 ) fiveCount ++;
    else if ( notes [ i ] == 10 ) {
      if ( fiveCount > 0 ) {
        fiveCount --;
        tenCount ++;
      }
      else return 0;
    }
    else {
      if ( fiveCount > 0 && tenCount > 0 ) {
        fiveCount --;
        tenCount --;
      }
      else if ( fiveCount >= 3 ) {
        fiveCount -= 3;
      }
      else return 0;
    }
  }
  return 1;
}


MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION | static void minMaxValues ( int [ ] arr, int n, int m ) {
  int sum = 0;
  for ( int i = 0;
  i < ( n + m );
  i ++ ) {
    sum += arr [ i ];
    arr [ i ] += 50;
  }
  boolean dp [ ] [ ] = new boolean [ MAX + 1 ] [ MAX * MAX + 1 ];
  dp [ 0 ] [ 0 ] = true;
  for ( int i = 0;
  i < ( n + m );
  i ++ ) {
    for ( int k = Math . min ( n, i + 1 );
    k >= 1;
    k -- ) {
      for ( int j = 0;
      j < MAX * MAX + 1;
      j ++ ) {
        if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ] = true;
      }
    }
  }
  double max_value = - 1 * INF, min_value = INF;
  for ( int i = 0;
  i < MAX * MAX + 1;
  i ++ ) {
    if ( dp [ n ] [ i ] ) {
      int temp = i - 50 * n;
      max_value = Math . max ( max_value, temp * ( sum - temp ) );
      min_value = Math . min ( min_value, temp * ( sum - temp ) );
    }
  }
  System . out . print ( "Maximum Value: " + ( int ) max_value + "\n" + "Minimum Value: " + ( int ) min_value + "\n" );
}


MULTIPLY_AN_INTEGER_WITH_3_5 | static int multiplyWith3Point5 ( int x ) {
  return ( x << 1 ) + x + ( x > > 1 );
}


MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VALUES | static int minCells ( int mat [ ] [ ], int m, int n ) {
  int dp [ ] [ ] = new int [ m ] [ n ];
  for ( int i = 0;
  i < m;
  i ++ ) for ( int j = 0;
  j < n;
  j ++ ) dp [ i ] [ j ] = Integer . MAX_VALUE;
  dp [ 0 ] [ 0 ] = 1;
  for ( int i = 0;
  i < m;
  i ++ ) {
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1;
      if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1;
    }
  }
  if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ];
  return - 1;
}


FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY | static int findExtra ( int arr1 [ ], int arr2 [ ], int n ) {
  for ( int i = 0;
  i < n;
  i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i;
  return n;
}


CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING | static int findSum ( String str ) {
  String temp = "";
  int sum = 0;
  for ( int i = 0;
  i < str . length ( );
  i ++ ) {
    char ch = str . charAt ( i );
    if ( Character . isDigit ( ch ) ) temp += ch;
    else {
      sum += Integer . parseInt ( temp );
      temp = "0";
    }
  }
  return sum + Integer . parseInt ( temp );
}


CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED | static boolean checkReverse ( int arr [ ], int n ) {
  int temp [ ] = new int [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) {
    temp [ i ] = arr [ i ];
  }
  Arrays . sort ( temp );
  int front;
  for ( front = 0;
  front < n;
  front ++ ) {
    if ( temp [ front ] != arr [ front ] ) {
      break;
    }
  }
  int back;
  for ( back = n - 1;
  back >= 0;
  back -- ) {
    if ( temp [ back ] != arr [ back ] ) {
      break;
    }
  }
  if ( front >= back ) {
    return true;
  }
  do {
    front ++;
    if ( arr [ front - 1 ] < arr [ front ] ) {
      return false;
    }
  }
  while ( front != back );
  return true;
}


GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER | static void evaluate ( int n ) {
  if ( n == 1 || n == 2 ) System . out . println ( "No Pythagoras " + "Triplet exists" );
  else if ( n % 2 == 0 ) {
    int var = 1 * n * n / 4;
    System . out . print ( "Pythagoras Triplets " + "exist i.e. " );
    System . out . print ( n + " " );
    System . out . print ( var - 1 + " " );
    System . out . println ( var + 1 + " " );
  }
  else if ( n % 2 != 0 ) {
    int var = 1 * n * n + 1;
    System . out . print ( "Pythagoras Triplets " + "exist i.e. " );
    System . out . print ( n + " " );
    System . out . print ( var / 2 - 1 + " " );
    System . out . println ( var / 2 + " " );
  }
}


PETERSON_GRAPH | static boolean findthepath ( char [ ] S, int v ) {
  result [ 0 ] = ( char ) ( v + '0' );
  for ( int i = 1;
  i < ( int ) S . length;
  i ++ ) {
    if ( adj [ v ] [ S [ i ] - 'A' ] || adj [ S [ i ] - 'A' ] [ v ] ) {
      v = S [ i ] - 'A';
    }
    else if ( adj [ v ] [ S [ i ] - 'A' + 5 ] || adj [ S [ i ] - 'A' + 5 ] [ v ] ) {
      v = S [ i ] - 'A' + 5;
    }
    else return false;
    result [ i ] = ( char ) ( v + '0' );
  }
  return true;
}


COUNT_NUMBER_OF_SOLUTIONS_OF_X2_1_MOD_P_IN_GIVEN_RANGE | static int findCountOfSolutions ( int n, int p ) {
  int ans = 0;
  for ( int x = 1;
  x < p;
  x ++ ) {
    if ( ( x * x ) % p == 1 ) {
      int last = x + p * ( n / p );
      if ( last > n ) last -= p;
      ans += ( ( last - x ) / p + 1 );
    }
  }
  return ans;
}


JUMP_SEARCH | public static int jumpSearch ( int [ ] arr, int x ) {
  int n = arr . length;
  int step = ( int ) Math . floor ( Math . sqrt ( n ) );
  int prev = 0;
  while ( arr [ Math . min ( step, n ) - 1 ] < x ) {
    prev = step;
    step += ( int ) Math . floor ( Math . sqrt ( n ) );
    if ( prev >= n ) return - 1;
  }
  while ( arr [ prev ] < x ) {
    prev ++;
    if ( prev == Math . min ( step, n ) ) return - 1;
  }
  if ( arr [ prev ] == x ) return prev;
  return - 1;
}


FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE | static void PrintMinNumberForPattern ( String arr ) {
  int curr_max = 0;
  int last_entry = 0;
  int j;
  for ( int i = 0;
  i < arr . length ( );
  i ++ ) {
    int noOfNextD = 0;
    switch ( arr . charAt ( i ) ) {
      case 'I' : j = i + 1;
      while ( j < arr . length ( ) && arr . charAt ( j ) == 'D' ) {
        noOfNextD ++;
        j ++;
      }
      if ( i == 0 ) {
        curr_max = noOfNextD + 2;
        System . out . print ( " " + ++ last_entry );
        System . out . print ( " " + curr_max );
        last_entry = curr_max;
      }
      else {
        curr_max = curr_max + noOfNextD + 1;
        last_entry = curr_max;
        System . out . print ( " " + last_entry );
      }
      for ( int k = 0;
      k < noOfNextD;
      k ++ ) {
        System . out . print ( " " + -- last_entry );
        i ++;
      }
      break;
      case 'D' : if ( i == 0 ) {
        j = i + 1;
        while ( j < arr . length ( ) && arr . charAt ( j ) == 'D' ) {
          noOfNextD ++;
          j ++;
        }
        curr_max = noOfNextD + 2;
        System . out . print ( " " + curr_max + " " + ( curr_max - 1 ) );
        last_entry = curr_max - 1;
      }
      else {
        System . out . print ( " " + ( last_entry - 1 ) );
        last_entry --;
      }
      break;
    }
  }
  System . out . println ( );
}


GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8 | static boolean isSubSeqDivisible ( String str ) {
  int i, j, k, l = str . length ( );
  int arr [ ] = new int [ l ];
  for ( i = 0;
  i < l;
  i ++ ) {
    for ( j = i;
    j < l;
    j ++ ) {
      for ( k = j;
      k < l;
      k ++ ) {
        if ( arr [ i ] % 8 == 0 ) return true;
        else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true;
        else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true;
      }
    }
  }
  return false;
}


PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES | static void fib ( int n ) {
  int a = 0, b = 1, c;
  if ( n >= 0 ) System . out . print ( a + " " );
  if ( n >= 1 ) System . out . print ( b + " " );
  for ( int i = 2;
  i <= n;
  i ++ ) {
    c = a + b;
    System . out . print ( c + " " );
    a = b;
    b = c;
  }
}


INTERCHANGE_ELEMENTS_OF_FIRST_AND_LAST_ROWS_IN_MATRIX | static void interchangeFirstLast ( int m [ ] [ ] ) {
  int rows = m . length;
  for ( int i = 0;
  i < m [ 0 ] . length;
  i ++ ) {
    int t = m [ 0 ] [ i ];
    m [ 0 ] [ i ] = m [ rows - 1 ] [ i ];
    m [ rows - 1 ] [ i ] = t;
  }
}


SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS | static int findSum ( int n ) {
  int [ ] [ ] arr = new int [ n ] [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 0;
  j < n;
  j ++ ) arr [ i ] [ j ] = Math . abs ( i - j );
  int sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 0;
  j < n;
  j ++ ) sum += arr [ i ] [ j ];
  return sum;
}


FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASING_AND_THEN_DECREASING | static int findMaximum ( int arr [ ], int low, int high ) {
  int max = arr [ low ];
  int i;
  for ( i = low;
  i <= high;
  i ++ ) {
    if ( arr [ i ] > max ) max = arr [ i ];
  }
  return max;
}


PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1 | static boolean isScalarMatrix ( int mat [ ] [ ] ) {
  for ( int i = 0;
  i < N;
  i ++ ) for ( int j = 0;
  j < N;
  j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false;
  for ( int i = 0;
  i < N - 1;
  i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false;
  return true;
}


STOOGE_SORT | static void stoogesort ( int arr [ ], int l, int h ) {
  if ( l >= h ) return;
  if ( arr [ l ] > arr [ h ] ) {
    int t = arr [ l ];
    arr [ l ] = arr [ h ];
    arr [ h ] = t;
  }
  if ( h - l + 1 > 2 ) {
    int t = ( h - l + 1 ) / 3;
    stoogesort ( arr, l, h - t );
    stoogesort ( arr, l + t, h );
    stoogesort ( arr, l, h - t );
  }
}


DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE | static int eggDrop ( int n, int k ) {
  if ( k == 1 || k == 0 ) return k;
  if ( n == 1 ) return k;
  int min = Integer . MAX_VALUE;
  int x, res;
  for ( x = 1;
  x <= k;
  x ++ ) {
    res = Math . max ( eggDrop ( n - 1, x - 1 ), eggDrop ( n, k - x ) );
    if ( res < min ) min = res;
  }
  return min + 1;
}


DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M | static int numberofways ( int n, int m ) {
  int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ];
  dp [ 0 ] [ n + 1 ] = 1;
  for ( int k = n;
  k >= m;
  k -- ) {
    for ( int i = 0;
    i <= n;
    i ++ ) {
      dp [ i ] [ k ] = dp [ i ] [ k + 1 ];
      if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] );
    }
  }
  return dp [ n ] [ m ];
}


BUBBLE_SORT | void bubbleSort ( int arr [ ] ) {
  int n = arr . length;
  for ( int i = 0;
  i < n - 1;
  i ++ ) for ( int j = 0;
  j < n - i - 1;
  j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) {
    int temp = arr [ j ];
    arr [ j ] = arr [ j + 1 ];
    arr [ j + 1 ] = temp;
  }
}


GENERATE_ROTATIONS_GIVEN_STRING | static void printRotatedString ( String str ) {
  int len = str . length ( );
  StringBuffer sb;
  for ( int i = 0;
  i < len;
  i ++ ) {
    sb = new StringBuffer ( );
    int j = i;
    int k = 0;
    for ( int k2 = j;
    k2 < str . length ( );
    k2 ++ ) {
      sb . insert ( k, str . charAt ( j ) );
      k ++;
      j ++;
    }
    j = 0;
    while ( j < i ) {
      sb . insert ( k, str . charAt ( j ) );
      j ++;
      k ++;
    }
    System . out . println ( sb );
  }
}


MID_POINT_LINE_GENERATION_ALGORITHM | static void midPoint ( int X1, int Y1, int X2, int Y2 ) {
  int dx = X2 - X1;
  int dy = Y2 - Y1;
  int d = dy - ( dx / 2 );
  int x = X1, y = Y1;
  System . out . print ( x + "," + y + "\n" );
  while ( x < X2 ) {
    x ++;
    if ( d < 0 ) d = d + dy;
    else {
      d += ( dy - dx );
      y ++;
    }
    System . out . print ( x + "," + y + "\n" );
  }
}


FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA | static void parabola ( float a, float b, float c ) {
  System . out . println ( "Vertex: (" + ( - b / ( 2 * a ) ) + ", " + ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) + ")" );
  System . out . println ( "Focus: (" + ( - b / ( 2 * a ) ) + ", " + ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) + ")" );
  System . out . println ( "Directrix:" + " y=" + ( int ) ( c - ( ( b * b ) + 1 ) * 4 * a ) );
}


TRIANGULAR_NUMBERS | static boolean isTriangular ( int num ) {
  if ( num < 0 ) return false;
  int sum = 0;
  for ( int n = 1;
  sum <= num;
  n ++ ) {
    sum = sum + n;
    if ( sum == num ) return true;
  }
  return false;
}


PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES | static int findMaximumPieces ( int n ) {
  return 1 + n * ( n + 1 ) / 2;
}


MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION | static int minTimeForWritingChars ( int N, int insert, int remove, int copy ) {
  if ( N == 0 ) return 0;
  if ( N == 1 ) return insert;
  int dp [ ] = new int [ N + 1 ];
  for ( int i = 1;
  i <= N;
  i ++ ) {
    if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert, dp [ i / 2 ] + copy );
    else dp [ i ] = Math . min ( dp [ i - 1 ] + insert, dp [ ( i + 1 ) / 2 ] + copy + remove );
  }
  return dp [ N ];
}


SEARCHING_ARRAY_ADJACENT_DIFFER_K | static int search ( int arr [ ], int n, int x, int k ) {
  int i = 0;
  while ( i < n ) {
    if ( arr [ i ] == x ) return i;
    i = i + Math . max ( 1, Math . abs ( arr [ i ] - x ) / k );
  }
  System . out . println ( "number is " + "not present!" );
  return - 1;
}


FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY | static int maxProduct ( int [ ] arr, int n ) {
  if ( n < 3 ) return - 1;
  int max_product = Integer . MIN_VALUE;
  for ( int i = 0;
  i < n - 2;
  i ++ ) for ( int j = i + 1;
  j < n - 1;
  j ++ ) for ( int k = j + 1;
  k < n;
  k ++ ) max_product = Math . max ( max_product, arr [ i ] * arr [ j ] * arr [ k ] );
  return max_product;
}


LONGEST_PALINDROME_SUBSEQUENCE_SPACE | static int lps ( String s ) {
  int n = s . length ( );
  int a [ ] = new int [ n ];
  for ( int i = n - 1;
  i >= 0;
  i -- ) {
    int back_up = 0;
    for ( int j = i;
    j < n;
    j ++ ) {
      if ( j == i ) a [ j ] = 1;
      else if ( s . charAt ( i ) == s . charAt ( j ) ) {
        int temp = a [ j ];
        a [ j ] = back_up + 2;
        back_up = temp;
      }
      else {
        back_up = a [ j ];
        a [ j ] = Math . max ( a [ j - 1 ], a [ j ] );
      }
    }
  }
  return a [ n - 1 ];
}


CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1 | static boolean checkCorrectOrNot ( String s ) {
  int [ ] count = new int [ MAX_CHAR ];
  int n = s . length ( );
  if ( n == 1 ) return true;
  for ( int i = 0, j = n - 1;
  i < j;
  i ++, j -- ) {
    count [ s . charAt ( i ) - 'a' ] ++;
    count [ s . charAt ( j ) - 'a' ] --;
  }
  for ( int i = 0;
  i < MAX_CHAR;
  i ++ ) if ( count [ i ] != 0 ) return false;
  return true;
}


EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION | static long exponentiation ( long base, long exp ) {
  if ( exp == 0 ) return 1;
  if ( exp == 1 ) return base % N;
  long t = exponentiation ( base, exp / 2 );
  t = ( t * t ) % N;
  if ( exp % 2 == 0 ) return t;
  else return ( ( base % N ) * t ) % N;
}


REMOVE_MINIMUM_NUMBER_ELEMENTS_NO_COMMON_ELEMENT_EXIST_ARRAY | public static int minRemove ( int a [ ], int b [ ], int n, int m ) {
  HashMap < Integer, Integer > countA = new HashMap < Integer, Integer > ( );
  HashMap < Integer, Integer > countB = new HashMap < Integer, Integer > ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( countA . containsKey ( a [ i ] ) ) countA . put ( a [ i ], countA . get ( a [ i ] ) + 1 );
    else countA . put ( a [ i ], 1 );
  }
  for ( int i = 0;
  i < m;
  i ++ ) {
    if ( countB . containsKey ( b [ i ] ) ) countB . put ( b [ i ], countB . get ( b [ i ] ) + 1 );
    else countB . put ( b [ i ], 1 );
  }
  int res = 0;
  Set < Integer > s = countA . keySet ( );
  for ( int x : s ) if ( countB . containsKey ( x ) ) res += Math . min ( countB . get ( x ), countA . get ( x ) );
  return res;
}


FIND_A_FIXED_POINT_IN_A_GIVEN_ARRAY | static int linearSearch ( int arr [ ], int n ) {
  int i;
  for ( i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] == i ) return i;
  }
  return - 1;
}


ADD_1_TO_A_GIVEN_NUMBER | static int addOne ( int x ) {
  int m = 1;
  while ( ( int ) ( x & m ) >= 1 ) {
    x = x ^ m;
    m <<= 1;
  }
  x = x ^ m;
  return x;
}


HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES | static int height ( int N ) {
  return ( int ) Math . ceil ( Math . log ( N + 1 ) / Math . log ( 2 ) ) - 1;
}


MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY | static int minJumps ( int arr [ ], int l, int h ) {
  if ( h == l ) return 0;
  if ( arr [ l ] == 0 ) return Integer . MAX_VALUE;
  int min = Integer . MAX_VALUE;
  for ( int i = l + 1;
  i <= h && i <= l + arr [ l ];
  i ++ ) {
    int jumps = minJumps ( arr, i, h );
    if ( jumps != Integer . MAX_VALUE && jumps + 1 < min ) min = jumps + 1;
  }
  return min;
}


PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2 | public static int fib ( int n ) {
  if ( n == 0 ) return 0;
  if ( n == 1 || n == 2 ) return ( f [ n ] = 1 );
  if ( f [ n ] != 0 ) return f [ n ];
  int k = ( n & 1 ) == 1 ? ( n + 1 ) / 2 : n / 2;
  f [ n ] = ( n & 1 ) == 1 ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k );
  return f [ n ];
}


DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING | static String decode ( String str ) {
  Stack < Integer > integerstack = new Stack < > ( );
  Stack < Character > stringstack = new Stack < > ( );
  String temp = "", result = "";
  for ( int i = 0;
  i < str . length ( );
  i ++ ) {
    int count = 0;
    if ( Character . isDigit ( str . charAt ( i ) ) ) {
      while ( Character . isDigit ( str . charAt ( i ) ) ) {
        count = count * 10 + str . charAt ( i ) - '0';
        i ++;
      }
      i --;
      integerstack . push ( count );
    }
    else if ( str . charAt ( i ) == ']' ) {
      temp = "";
      count = 0;
      if ( ! integerstack . isEmpty ( ) ) {
        count = integerstack . peek ( );
        integerstack . pop ( );
      }
      while ( ! stringstack . isEmpty ( ) && stringstack . peek ( ) != '[' ) {
        temp = stringstack . peek ( ) + temp;
        stringstack . pop ( );
      }
      if ( ! stringstack . empty ( ) && stringstack . peek ( ) == '[' ) stringstack . pop ( );
      for ( int j = 0;
      j < count;
      j ++ ) result = result + temp;
      for ( int j = 0;
      j < result . length ( );
      j ++ ) stringstack . push ( result . charAt ( j ) );
      result = "";
    }
    else if ( str . charAt ( i ) == '[' ) {
      if ( Character . isDigit ( str . charAt ( i - 1 ) ) ) stringstack . push ( str . charAt ( i ) );
      else {
        stringstack . push ( str . charAt ( i ) );
        integerstack . push ( 1 );
      }
    }
    else stringstack . push ( str . charAt ( i ) );
  }
  while ( ! stringstack . isEmpty ( ) ) {
    result = stringstack . peek ( ) + result;
    stringstack . pop ( );
  }
  return result;
}


HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP | static boolean isHeap ( int arr [ ], int i, int n ) {
  if ( i > ( n - 2 ) / 2 ) {
    return true;
  }
  if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr, 2 * i + 1, n ) && isHeap ( arr, 2 * i + 2, n ) ) {
    return true;
  }
  return false;
}


HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1 | static boolean isHeap ( int arr [ ], int n ) {
  for ( int i = 0;
  i <= ( n - 2 ) / 2;
  i ++ ) {
    if ( arr [ 2 * i + 1 ] > arr [ i ] ) {
      return false;
    }
    if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) {
      return false;
    }
  }
  return true;
}


CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND | static int calcAngle ( double h, double m ) {
  if ( h < 0 || m < 0 || h > 12 || m > 60 ) System . out . println ( "Wrong input" );
  if ( h == 12 ) h = 0;
  if ( m == 60 ) m = 0;
  int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) );
  int minute_angle = ( int ) ( 6 * m );
  int angle = Math . abs ( hour_angle - minute_angle );
  angle = Math . min ( 360 - angle, angle );
  return angle;
}


CONVERTING_DECIMAL_NUMBER_LYING_BETWEEN_1_TO_3999_TO_ROMAN_NUMERALS | static void printRoman ( int number ) {
  char c [ ] = new char [ 10001 ];
  int i = 0;
  if ( number <= 0 ) {
    System . out . printf ( "Invalid number" );
    return;
  }
  while ( number != 0 ) {
    if ( number >= 1000 ) {
      i = digit ( 'M', number / 1000, i, c );
      number = number % 1000;
    }
    else if ( number >= 500 ) {
      if ( number < 900 ) {
        i = digit ( 'D', number / 500, i, c );
        number = number % 500;
      }
      else {
        i = sub_digit ( 'C', 'M', i, c );
        number = number % 100;
      }
    }
    else if ( number >= 100 ) {
      if ( number < 400 ) {
        i = digit ( 'C', number / 100, i, c );
        number = number % 100;
      }
      else {
        i = sub_digit ( 'C', 'D', i, c );
        number = number % 100;
      }
    }
    else if ( number >= 50 ) {
      if ( number < 90 ) {
        i = digit ( 'L', number / 50, i, c );
        number = number % 50;
      }
      else {
        i = sub_digit ( 'X', 'C', i, c );
        number = number % 10;
      }
    }
    else if ( number >= 10 ) {
      if ( number < 40 ) {
        i = digit ( 'X', number / 10, i, c );
        number = number % 10;
      }
      else {
        i = sub_digit ( 'X', 'L', i, c );
        number = number % 10;
      }
    }
    else if ( number >= 5 ) {
      if ( number < 9 ) {
        i = digit ( 'V', number / 5, i, c );
        number = number % 5;
      }
      else {
        i = sub_digit ( 'I', 'X', i, c );
        number = 0;
      }
    }
    else if ( number >= 1 ) {
      if ( number < 4 ) {
        i = digit ( 'I', number, i, c );
        number = 0;
      }
      else {
        i = sub_digit ( 'I', 'V', i, c );
        number = 0;
      }
    }
  }
  System . out . printf ( "Roman numeral is: " );
  for ( int j = 0;
  j < i;
  j ++ ) {
    System . out . printf ( "%c", c [ j ] );
  }
}


SORTING_USING_TRIVIAL_HASH_FUNCTION | static void sortUsingHash ( int a [ ], int n ) {
  int max = Arrays . stream ( a ) . max ( ) . getAsInt ( );
  int hash [ ] = new int [ max + 1 ];
  for ( int i = 0;
  i < n;
  i ++ ) hash [ a [ i ] ] += 1;
  for ( int i = 0;
  i <= max;
  i ++ ) {
    if ( hash [ i ] != 0 ) {
      for ( int j = 0;
      j < hash [ i ];
      j ++ ) {
        System . out . print ( i + " " );
      }
    }
  }
}


SUM_PAIRWISE_PRODUCTS_2 | static int findSum ( int n ) {
  return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24;
}


ENTRINGER_NUMBER | static int zigzag ( int n, int k ) {
  if ( n == 0 && k == 0 ) return 1;
  if ( k == 0 ) return 0;
  return zigzag ( n, k - 1 ) + zigzag ( n - 1, n - k );
}


MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY_2 | static int minSum ( int a [ ], int n ) {
  Arrays . sort ( a );
  int num1 = 0;
  int num2 = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ];
    else num2 = num2 * 10 + a [ i ];
  }
  return num2 + num1;
}


SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K | static void subarrayDivisibleByK ( int [ ] arr, int n, int k ) {
  int [ ] mp = new int [ 1000 ];
  int s = 0, e = 0, maxs = 0, maxe = 0;
  mp [ arr [ 0 ] % k ] ++;
  for ( int i = 1;
  i < n;
  i ++ ) {
    int mod = arr [ i ] % k;
    while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] != 0 ) ) {
      mp [ arr [ s ] % k ] --;
      s ++;
    }
    mp [ mod ] ++;
    e ++;
    if ( ( e - s ) > ( maxe - maxs ) ) {
      maxe = e;
      maxs = s;
    }
  }
  System . out . print ( "The maximum size is " + ( maxe - maxs + 1 ) + " and the subarray is as follows\n" );
  for ( int i = maxs;
  i <= maxe;
  i ++ ) System . out . print ( arr [ i ] + " " );
}


MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_K_TIMES | static int maxProfit ( int [ ] price, int n, int k ) {
  int [ ] [ ] profit = new int [ k + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= k;
  i ++ ) profit [ i ] [ 0 ] = 0;
  for ( int j = 0;
  j <= n;
  j ++ ) profit [ 0 ] [ j ] = 0;
  for ( int i = 1;
  i <= k;
  i ++ ) {
    for ( int j = 1;
    j < n;
    j ++ ) {
      int max_so_far = 0;
      for ( int m = 0;
      m < j;
      m ++ ) max_so_far = Math . max ( max_so_far, price [ j ] - price [ m ] + profit [ i - 1 ] [ m ] );
      profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ], max_so_far );
    }
  }
  return profit [ k ] [ n - 1 ];
}


MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED | static int minValue ( int A [ ], int B [ ], int n ) {
  Arrays . sort ( A );
  Arrays . sort ( B );
  int result = 0;
  for ( int i = 0;
  i < n;
  i ++ ) result += ( A [ i ] * B [ n - i - 1 ] );
  return result;
}


FIND_MAXIMUM_ELEMENT_ROW_MATRIX | public static void maxelement ( int no_of_rows, int [ ] [ ] arr ) {
  int i = 0;
  int max = 0;
  int [ ] result = new int [ no_of_rows ];
  while ( i < no_of_rows ) {
    for ( int j = 0;
    j < arr [ i ] . length;
    j ++ ) {
      if ( arr [ i ] [ j ] > max ) {
        max = arr [ i ] [ j ];
      }
    }
    result [ i ] = max;
    max = 0;
    i ++;
  }
  printArray ( result );
}


ROUND_OFF_NUMBER_GIVEN_NUMBER_SIGNIFICANT_DIGITS | static void Round_off ( double N, double n ) {
  int h;
  double l, a, b, c, d, e, i, j, m, f, g;
  b = N;
  c = floor ( N );
  for ( i = 0;
  b >= 1;
  ++ i ) b = b / 10;
  d = n - i;
  b = N;
  b = b * pow ( 10, d );
  e = b + 0.5;
  if ( ( float ) e == ( float ) ceil ( b ) ) {
    f = ( ceil ( b ) );
    h = ( int ) ( f - 2 );
    if ( h % 2 != 0 ) {
      e = e - 1;
    }
  }
  j = floor ( e );
  m = pow ( 10, d );
  j = j / m;
  System . out . println ( "The number after rounding-off is " + j );
}


CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT | static void checkPoint ( int radius, int x, int y, float percent, float startAngle ) {
  float endAngle = 360 / percent + startAngle;
  double polarradius = Math . sqrt ( x * x + y * y );
  double Angle = Math . atan ( y / x );
  if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) System . out . print ( "Point" + "(" + x + "," + y + ")" + " exist in the circle sector\n" );
  else System . out . print ( "Point" + "(" + x + "," + y + ")" + " exist in the circle sector\n" );
}


NUMBER_IS_DIVISIBLE_BY_29_OR_NOT | static boolean isDivisible ( long n ) {
  while ( n / 100 > 0 ) {
    int last_digit = ( int ) n % 10;
    n /= 10;
    n += last_digit * 3;
  }
  return ( n % 29 == 0 );
}


PRINT_ALL_DISTINCT_CHARACTERS_OF_A_STRING_IN_ORDER_3_METHODS | static void printDistinct ( String str ) {
  int [ ] count = new int [ NO_OF_CHARS ];
  int i;
  for ( i = 0;
  i < str . length ( );
  i ++ ) if ( str . charAt ( i ) != ' ' ) count [ ( int ) str . charAt ( i ) ] ++;
  int n = i;
  for ( i = 0;
  i < n;
  i ++ ) if ( count [ ( int ) str . charAt ( i ) ] == 1 ) System . out . print ( str . charAt ( i ) );
}


PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE | public static String recursiveReverse ( char [ ] str ) {
  Stack < Character > st = new Stack < > ( );
  for ( int i = 0;
  i < str . length;
  i ++ ) st . push ( str [ i ] );
  for ( int i = 0;
  i < str . length;
  i ++ ) {
    str [ i ] = st . peek ( );
    st . pop ( );
  }
  return String . valueOf ( str );
}


PAINTING_FENCE_ALGORITHM | static long countWays ( int n, int k ) {
  long total = k;
  int mod = 1000000007;
  int same = 0, diff = k;
  for ( int i = 2;
  i <= n;
  i ++ ) {
    same = diff;
    diff = ( int ) total * ( k - 1 );
    diff = diff % mod;
    total = ( same + diff ) % mod;
  }
  return total;
}


COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME | static int CountSubstring ( char str [ ], int n ) {
  int ans = ( n * ( n + 1 ) ) / 2;
  int a_index = 0;
  int b_index = 0;
  int c_index = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( str [ i ] == 'a' ) {
      a_index = i + 1;
      ans -= Math . min ( b_index, c_index );
    }
    else if ( str [ i ] == 'b' ) {
      b_index = i + 1;
      ans -= Math . min ( a_index, c_index );
    }
    else {
      c_index = i + 1;
      ans -= Math . min ( a_index, b_index );
    }
  }
  return ans;
}


CALCULATING_FACTORIALS_USING_STIRLING_APPROXIMATION | public static int stirlingFactorial ( double n ) {
  if ( n == 1 ) return 1;
  double z;
  double e = 2.71;
  z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ), n );
  return ( int ) ( z );
}


LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRAY | static String lexsmallest ( String a [ ], int n ) {
  sort ( a, n );
  String answer = "";
  for ( int i = 0;
  i < n;
  i ++ ) answer += a [ i ];
  return answer;
}


PRODUCT_MAXIMUM_FIRST_ARRAY_MINIMUM_SECOND | public static int minMaxProduct ( int arr1 [ ], int arr2 [ ], int n1, int n2 ) {
  Arrays . sort ( arr1 );
  Arrays . sort ( arr2 );
  return arr1 [ n1 - 1 ] * arr2 [ 0 ];
}


FIND_IF_THERE_IS_A_SUBARRAY_WITH_0_SUM | static Boolean subArrayExists ( int arr [ ] ) {
  HashMap < Integer, Integer > hM = new HashMap < Integer, Integer > ( );
  int sum = 0;
  for ( int i = 0;
  i < arr . length;
  i ++ ) {
    sum += arr [ i ];
    if ( arr [ i ] == 0 || sum == 0 || hM . get ( sum ) != null ) return true;
    hM . put ( sum, i );
  }
  return false;
}


MINIMUM_PRODUCT_SUBSET_ARRAY | static int minProductSubset ( int a [ ], int n ) {
  if ( n == 1 ) return a [ 0 ];
  int negmax = Integer . MIN_VALUE;
  int posmin = Integer . MAX_VALUE;
  int count_neg = 0, count_zero = 0;
  int product = 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( a [ i ] == 0 ) {
      count_zero ++;
      continue;
    }
    if ( a [ i ] < 0 ) {
      count_neg ++;
      negmax = Math . max ( negmax, a [ i ] );
    }
    if ( a [ i ] > 0 && a [ i ] < posmin ) posmin = a [ i ];
    product *= a [ i ];
  }
  if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0;
  if ( count_neg == 0 ) return posmin;
  if ( count_neg % 2 == 0 && count_neg != 0 ) {
    product = product / negmax;
  }
  return product;
}


NUMBER_NODES_TWO_VERTICES_ACYCLIC_GRAPH_DISJOINT_UNION_METHOD | static int totalNodes ( Vector < Integer > adjac [ ], int n, int x, int y ) {
  Boolean visited [ ] = new Boolean [ n + 1 ];
  Arrays . fill ( visited, false );
  int p [ ] = new int [ n ];
  Queue < Integer > q = new LinkedList < > ( );
  q . add ( x );
  visited [ x ] = true;
  int m;
  while ( ! q . isEmpty ( ) ) {
    m = q . peek ( );
    q . poll ( );
    for ( int i = 0;
    i < adjac [ m ] . size ( );
    ++ i ) {
      int h = adjac [ m ] . get ( i );
      if ( visited [ h ] != true ) {
        visited [ h ] = true;
        p [ h ] = m;
        q . add ( h );
      }
    }
  }
  int count = 0;
  int i = p [ y ];
  while ( i != x ) {
    count ++;
    i = p [ i ];
  }
  return count;
}


PRINTING_STRING_PLUS_PATTERN_MATRIX | static void carveCross ( String str ) {
  int n = str . length ( );
  if ( n % 2 == 0 ) {
    System . out . print ( "Not possible. Please enter " + "odd length string.\n" );
  }
  else {
    char arr [ ] [ ] = new char [ max ] [ max ];
    int m = n / 2;
    for ( int i = 0;
    i < n;
    i ++ ) {
      for ( int j = 0;
      j < n;
      j ++ ) {
        arr [ i ] [ j ] = 'X';
      }
    }
    for ( int i = 0;
    i < n;
    i ++ ) {
      arr [ i ] [ m ] = str . charAt ( i );
    }
    for ( int i = 0;
    i < n;
    i ++ ) {
      arr [ m ] [ i ] = str . charAt ( i );
    }
    for ( int i = 0;
    i < n;
    i ++ ) {
      for ( int j = 0;
      j < n;
      j ++ ) {
        System . out . print ( arr [ i ] [ j ] + " " );
      }
      System . out . print ( "\n" );
    }
  }
}


NEXT_GREATER_FREQUENCY_ELEMENT | static void NFG ( int a [ ], int n, int freq [ ] ) {
  Stack < Integer > s = new Stack < Integer > ( );
  s . push ( 0 );
  int res [ ] = new int [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) res [ i ] = 0;
  for ( int i = 1;
  i < n;
  i ++ ) {
    if ( freq [ a [ s . peek ( ) ] ] > freq [ a [ i ] ] ) s . push ( i );
    else {
      while ( freq [ a [ s . peek ( ) ] ] < freq [ a [ i ] ] && s . size ( ) > 0 ) {
        res [ s . peek ( ) ] = a [ i ];
        s . pop ( );
      }
      s . push ( i );
    }
  }
  while ( s . size ( ) > 0 ) {
    res [ s . peek ( ) ] = - 1;
    s . pop ( );
  }
  for ( int i = 0;
  i < n;
  i ++ ) {
    System . out . print ( res [ i ] + " " );
  }
}


CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1 | static boolean checkReverse ( int arr [ ], int n ) {
  if ( n == 1 ) {
    return true;
  }
  int i;
  for ( i = 1;
  arr [ i - 1 ] < arr [ i ] && i < n;
  i ++ );
  if ( i == n ) {
    return true;
  }
  int j = i ++;
  while ( arr [ j ] < arr [ j - 1 ] ) {
    if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) {
      return false;
    }
    j ++;
  }
  if ( j == n ) {
    return true;
  }
  int k = j;
  if ( arr [ k ] < arr [ i - 1 ] ) {
    return false;
  }
  while ( k > 1 && k < n ) {
    if ( arr [ k ] < arr [ k - 1 ] ) {
      return false;
    }
    k ++;
  }
  return true;
}


FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2 | static void findTriplets ( int arr [ ], int n ) {
  boolean found = false;
  Arrays . sort ( arr );
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    int l = i + 1;
    int r = n - 1;
    int x = arr [ i ];
    while ( l < r ) {
      if ( x + arr [ l ] + arr [ r ] == 0 ) {
        System . out . print ( x + " " );
        System . out . print ( arr [ l ] + " " );
        System . out . println ( arr [ r ] + " " );
        l ++;
        r --;
        found = true;
      }
      else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++;
      else r --;
    }
  }
  if ( found == false ) System . out . println ( " No Triplet Found" );
}


FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS | static void findElements ( int arr [ ], int n ) {
  for ( int i = 0;
  i < n;
  i ++ ) {
    int count = 0;
    for ( int j = 0;
    j < n;
    j ++ ) if ( arr [ j ] > arr [ i ] ) count ++;
    if ( count >= 2 ) System . out . print ( arr [ i ] + " " );
  }
}


POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1 | static void printArray ( int [ ] a, int n ) {
  for ( int i = 0;
  i < n;
  i ++ ) System . out . print ( a [ i ] + " " );
  System . out . println ( );
}


FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE | static int minRadius ( int k, int [ ] x, int [ ] y, int n ) {
  int [ ] dis = new int [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ];
  Arrays . sort ( dis );
  return dis [ k - 1 ];
}


COUNT_SUBARRAYS_EQUAL_NUMBER_1S_0S | static int countSubarrWithEqualZeroAndOne ( int arr [ ], int n ) {
  Map < Integer, Integer > um = new HashMap < > ( );
  int curr_sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    curr_sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ];
    um . put ( curr_sum, um . get ( curr_sum ) == null ? 1 : um . get ( curr_sum ) + 1 );
  }
  int count = 0;
  for ( Map . Entry < Integer, Integer > itr : um . entrySet ( ) ) {
    if ( itr . getValue ( ) > 1 ) count += ( ( itr . getValue ( ) * ( itr . getValue ( ) - 1 ) ) / 2 );
  }
  if ( um . containsKey ( 0 ) ) count += um . get ( 0 );
  return count;
}


MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS | static void find ( Vector < String > list1, Vector < String > list2 ) {
  Vector < String > res = new Vector < > ( );
  int max_possible_sum = list1 . size ( ) + list2 . size ( ) - 2;
  for ( int sum = 0;
  sum <= max_possible_sum;
  sum ++ ) {
    for ( int i = 0;
    i <= sum;
    i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . size ( ) && list1 . get ( i ) == list2 . get ( sum - i ) ) res . add ( list1 . get ( i ) );
    if ( res . size ( ) > 0 ) break;
  }
  for ( int i = 0;
  i < res . size ( );
  i ++ ) System . out . print ( res . get ( i ) + " " );
}


CHECK_IF_A_NUMBER_IS_JUMBLED_OR_NOT | static boolean checkJumbled ( int num ) {
  if ( num / 10 == 0 ) return true;
  while ( num != 0 ) {
    if ( num / 10 == 0 ) return true;
    int digit1 = num % 10;
    int digit2 = ( num / 10 ) % 10;
    if ( Math . abs ( digit2 - digit1 ) > 1 ) return false;
    num = num / 10;
  }
  return true;
}


CEILING_IN_A_SORTED_ARRAY_1 | static int ceilSearch ( int arr [ ], int low, int high, int x ) {
  int mid;
  if ( x <= arr [ low ] ) return low;
  if ( x > arr [ high ] ) return - 1;
  mid = ( low + high ) / 2;
  if ( arr [ mid ] == x ) return mid;
  else if ( arr [ mid ] < x ) {
    if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1;
    else return ceilSearch ( arr, mid + 1, high, x );
  }
  else {
    if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid;
    else return ceilSearch ( arr, low, mid - 1, x );
  }
}


GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2 | static int Largestpower ( int n, int p ) {
  int ans = 0;
  while ( n > 0 ) {
    n /= p;
    ans += n;
  }
  return ans;
}


MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY | static int maxSum ( int arr [ ], int n ) {
  int res = Integer . MIN_VALUE;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int curr_sum = 0;
    for ( int j = 0;
    j < n;
    j ++ ) {
      int index = ( i + j ) % n;
      curr_sum += j * arr [ index ];
    }
    res = Math . max ( res, curr_sum );
  }
  return res;
}


MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1 | static int smallestSubWithSum ( int arr [ ], int n, int x ) {
  int curr_sum = 0, min_len = n + 1;
  int start = 0, end = 0;
  while ( end < n ) {
    while ( curr_sum <= x && end < n ) {
      if ( curr_sum <= 0 && x > 0 ) {
        start = end;
        curr_sum = 0;
      }
      curr_sum += arr [ end ++ ];
    }
    while ( curr_sum > x && start < n ) {
      if ( end - start < min_len ) min_len = end - start;
      curr_sum -= arr [ start ++ ];
    }
  }
  return min_len;
}


LEXICOGRAPHICALLY_SMALLEST_STRING_WHOSE_HAMMING_DISTANCE_GIVEN_STRING_EXACTLY_K | static void findString ( String str, int n, int k ) {
  if ( k == 0 ) {
    System . out . println ( str );
    ;
    return;
  }
  String str2 = str;
  int p = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( str2 . charAt ( i ) != 'a' ) {
      str2 = str2 . substring ( 0, i ) + 'a' + str2 . substring ( i + 1 );
      p ++;
      if ( p == k ) break;
    }
  }
  if ( p < k ) {
    for ( int i = n - 1;
    i >= 0;
    i -- ) if ( str . charAt ( i ) == 'a' ) {
      str2 = str2 . substring ( 0, i ) + 'b' + str2 . substring ( i + 1 );
      p ++;
      if ( p == k ) break;
    }
  }
  System . out . println ( str2 );
}


SUBSET_SUM_DIVISIBLE_M | static boolean modularSum ( int arr [ ], int n, int m ) {
  if ( n > m ) return true;
  boolean DP [ ] = new boolean [ m ];
  Arrays . fill ( DP, false );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( DP [ 0 ] ) return true;
    boolean temp [ ] = new boolean [ m ];
    Arrays . fill ( temp, false );
    for ( int j = 0;
    j < m;
    j ++ ) {
      if ( DP [ j ] == true ) {
        if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true;
      }
    }
    for ( int j = 0;
    j < m;
    j ++ ) if ( temp [ j ] ) DP [ j ] = true;
    DP [ arr [ i ] % m ] = true;
  }
  return DP [ 0 ];
}


FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1 | static int evenbinomialCoeffSum ( int n ) {
  return ( 1 << ( n - 1 ) );
}


EVEN_FIBONACCI_NUMBERS_SUM | static int evenFibSum ( int limit ) {
  if ( limit < 2 ) return 0;
  long ef1 = 0, ef2 = 2;
  long sum = ef1 + ef2;
  while ( ef2 <= limit ) {
    long ef3 = 4 * ef2 + ef1;
    if ( ef3 > limit ) break;
    ef1 = ef2;
    ef2 = ef3;
    sum += ef2;
  }
  return ( int ) sum;
}


MAKING_ELEMENTS_OF_TWO_ARRAYS_SAME_WITH_MINIMUM_INCREMENTDECREMENT | static int MinOperation ( int a [ ], int b [ ], int n ) {
  Arrays . sort ( a );
  Arrays . sort ( b );
  int result = 0;
  for ( int i = 0;
  i < n;
  ++ i ) {
    if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] );
    else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] );
  }
  return result;
}


REQUIRED_MINIMUM_DIGITS_REMOVE_NUMBER_MAKE_PERFECT_SQUARE | static int perfectSquare ( String s ) {
  int n = s . length ( );
  int ans = - 1;
  String num = "";
  for ( int i = 1;
  i < ( 1 << n );
  i ++ ) {
    String str = "";
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( ( ( i > > j ) & 1 ) == 1 ) {
        str += s . charAt ( j );
      }
    }
    if ( str . charAt ( 0 ) != '0' ) {
      int temp = 0;
      for ( int j = 0;
      j < str . length ( );
      j ++ ) temp = temp * 10 + ( int ) ( str . charAt ( j ) - '0' );
      int k = ( int ) Math . sqrt ( temp );
      if ( k * k == temp ) {
        if ( ans < ( int ) str . length ( ) ) {
          ans = ( int ) str . length ( );
          num = str;
        }
      }
    }
  }
  if ( ans == - 1 ) return ans;
  else {
    System . out . print ( num + " " );
    return n - ans;
  }
}


COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS | static int countWords ( String str [ ], int n ) {
  HashMap < String, Integer > m = new HashMap < > ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( m . containsKey ( str [ i ] ) ) {
      int get = m . get ( str [ i ] );
      m . put ( str [ i ], get + 1 );
    }
    else {
      m . put ( str [ i ], 1 );
    }
  }
  int res = 0;
  for ( Map . Entry < String, Integer > it : m . entrySet ( ) ) {
    if ( it . getValue ( ) == 2 ) res ++;
  }
  return res;
}


COUNT_SET_BITS_IN_AN_INTEGER_4 | static int countSetBitsRec ( int num ) {
  int nibble = 0;
  if ( 0 == num ) return num_to_bits [ 0 ];
  nibble = num & 0xf;
  return num_to_bits [ nibble ] + countSetBitsRec ( num > > 4 );
}


MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX | public static int maxCost ( int mat [ ] [ ], int N ) {
  int dp [ ] [ ] = new int [ N ] [ N ];
  dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ];
  for ( int i = 1;
  i < N;
  i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ];
  for ( int i = 1;
  i < N;
  i ++ ) for ( int j = 1;
  j < i + 1 && j < N;
  j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ], dp [ i - 1 ] [ j ] );
  int result = 0;
  for ( int i = 0;
  i < N;
  i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ];
  return result;
}


PERFECT_REVERSIBLE_STRING | static boolean isReversible ( String str ) {
  int i = 0, j = str . length ( ) - 1;
  while ( i < j ) {
    if ( str . charAt ( i ) != str . charAt ( j ) ) return false;
    i ++;
    j --;
  }
  return true;
}


FIND_SUM_ODD_FACTORS_NUMBER | static int sumofoddFactors ( int n ) {
  int res = 1;
  while ( n % 2 == 0 ) n = n / 2;
  for ( int i = 3;
  i <= Math . sqrt ( n );
  i ++ ) {
    int count = 0, curr_sum = 1;
    int curr_term = 1;
    while ( n % i == 0 ) {
      count ++;
      n = n / i;
      curr_term *= i;
      curr_sum += curr_term;
    }
    res *= curr_sum;
  }
  if ( n >= 2 ) res *= ( 1 + n );
  return res;
}


MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM | static int maxSum ( int [ ] [ ] mat, int n ) {
  if ( n == 1 ) return mat [ 0 ] [ 0 ];
  int dp [ ] [ ] = new int [ n ] [ n ];
  int maxSum = Integer . MIN_VALUE, max;
  for ( int j = 0;
  j < n;
  j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ];
  for ( int i = n - 2;
  i >= 0;
  i -- ) {
    for ( int j = 0;
    j < n;
    j ++ ) {
      max = Integer . MIN_VALUE;
      if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ];
      if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ];
      dp [ i ] [ j ] = mat [ i ] [ j ] + max;
    }
  }
  for ( int j = 0;
  j < n;
  j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ];
  return maxSum;
}


COUNT_DIGITS_FACTORIAL_SET_1 | static int findDigits ( int n ) {
  if ( n < 0 ) return 0;
  if ( n <= 1 ) return 1;
  double digits = 0;
  for ( int i = 2;
  i <= n;
  i ++ ) digits += Math . log10 ( i );
  return ( int ) ( Math . floor ( digits ) ) + 1;
}


FIND_UNCOMMON_CHARACTERS_TWO_STRINGS | static void findAndPrintUncommonChars ( String str1, String str2 ) {
  int present [ ] = new int [ MAX_CHAR ];
  for ( int i = 0;
  i < MAX_CHAR;
  i ++ ) {
    present [ i ] = 0;
  }
  int l1 = str1 . length ( );
  int l2 = str2 . length ( );
  for ( int i = 0;
  i < l1;
  i ++ ) {
    present [ str1 . charAt ( i ) - 'a' ] = 1;
  }
  for ( int i = 0;
  i < l2;
  i ++ ) {
    if ( present [ str2 . charAt ( i ) - 'a' ] == 1 || present [ str2 . charAt ( i ) - 'a' ] == - 1 ) {
      present [ str2 . charAt ( i ) - 'a' ] = - 1;
    }
    else {
      present [ str2 . charAt ( i ) - 'a' ] = 2;
    }
  }
  for ( int i = 0;
  i < MAX_CHAR;
  i ++ ) {
    if ( present [ i ] == 1 || present [ i ] == 2 ) {
      System . out . print ( ( char ) ( i + 'a' ) + " " );
    }
  }
}


SQUARE_ROOT_OF_AN_INTEGER_1 | public static int floorSqrt ( int x ) {
  if ( x == 0 || x == 1 ) return x;
  int start = 1, end = x, ans = 0;
  while ( start <= end ) {
    int mid = ( start + end ) / 2;
    if ( mid * mid == x ) return mid;
    if ( mid * mid < x ) {
      start = mid + 1;
      ans = mid;
    }
    else end = mid - 1;
  }
  return ans;
}


CHECK_POSSIBLE_PATH_2D_MATRIX | static boolean isPath ( int arr [ ] [ ] ) {
  arr [ 0 ] [ 0 ] = 1;
  for ( int i = 1;
  i < 5;
  i ++ ) if ( arr [ 0 ] [ i ] != - 1 ) arr [ 0 ] [ i ] = arr [ 0 ] [ i - 1 ];
  for ( int j = 1;
  j < 5;
  j ++ ) if ( arr [ j ] [ 0 ] != - 1 ) arr [ j ] [ 0 ] = arr [ j - 1 ] [ 0 ];
  for ( int i = 1;
  i < 5;
  i ++ ) for ( int j = 1;
  j < 5;
  j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ], arr [ i - 1 ] [ j ] );
  return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 );
}


NEWMAN_CONWAY_SEQUENCE_1 | static int sequence ( int n ) {
  int f [ ] = new int [ n + 1 ];
  f [ 0 ] = 0;
  f [ 1 ] = 1;
  f [ 2 ] = 1;
  int i;
  for ( i = 3;
  i <= n;
  i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ];
  return f [ n ];
}


PRINT_WORDS_STRING_REVERSE_ORDER | static String wordReverse ( String str ) {
  int i = str . length ( ) - 1;
  int start, end = i + 1;
  String result = "";
  while ( i >= 0 ) {
    if ( str . charAt ( i ) == ' ' ) {
      start = i + 1;
      while ( start != end ) result += str . charAt ( start ++ );
      result += ' ';
      end = i;
    }
    i --;
  }
  start = 0;
  while ( start != end ) result += str . charAt ( start ++ );
  return result;
}


FIND_NUMBER_ENDLESS_POINTS | static int countEndless ( boolean input [ ] [ ], int n ) {
  boolean row [ ] [ ] = new boolean [ n ] [ n ];
  boolean col [ ] [ ] = new boolean [ n ] [ n ];
  for ( int j = 0;
  j < n;
  j ++ ) {
    boolean isEndless = true;
    for ( int i = n - 1;
    i >= 0;
    i -- ) {
      if ( input [ i ] [ j ] == false ) isEndless = false;
      col [ i ] [ j ] = isEndless;
    }
  }
  for ( int i = 0;
  i < n;
  i ++ ) {
    boolean isEndless = true;
    for ( int j = n - 1;
    j >= 0;
    j -- ) {
      if ( input [ i ] [ j ] == false ) isEndless = false;
      row [ i ] [ j ] = isEndless;
    }
  }
  int ans = 0;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 1;
  j < n;
  j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++;
  return ans;
}


CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER | static boolean check ( String s1, String s2 ) {
  int n = s1 . length ( );
  int m = s2 . length ( );
  boolean dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) {
    for ( int j = 0;
    j <= m;
    j ++ ) {
      dp [ i ] [ j ] = false;
    }
  }
  dp [ 0 ] [ 0 ] = true;
  for ( int i = 0;
  i < s1 . length ( );
  i ++ ) {
    for ( int j = 0;
    j <= s2 . length ( );
    j ++ ) {
      if ( dp [ i ] [ j ] ) {
        if ( j < s2 . length ( ) && ( Character . toUpperCase ( s1 . charAt ( i ) ) == s2 . charAt ( j ) ) ) dp [ i + 1 ] [ j + 1 ] = true;
        if ( ! Character . isUpperCase ( s1 . charAt ( i ) ) ) dp [ i + 1 ] [ j ] = true;
      }
    }
  }
  return ( dp [ n ] [ m ] );
}


CALCULATE_VOLUME_DODECAHEDRON | static double vol_of_dodecahedron ( int side ) {
  return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side, 3 ) ) );
}


PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11 | static int remainder ( String str ) {
  int len = str . length ( );
  int num, rem = 0;
  for ( int i = 0;
  i < len;
  i ++ ) {
    num = rem * 10 + ( str . charAt ( i ) - '0' );
    rem = num % 11;
  }
  return rem;
}


SORT_STRING_CHARACTERS | static void sortString ( String str ) {
  char [ ] arr = str . toCharArray ( );
  Arrays . sort ( arr );
  System . out . print ( String . valueOf ( arr ) );
}


BIRTHDAY_PARADOX | static double find ( double p ) {
  return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) );
}


CHECK_LINE_PASSES_ORIGIN | static boolean checkOrigin ( int x1, int y1, int x2, int y2 ) {
  return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) );
}


FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2 | static void findElements ( int arr [ ], int n ) {
  int first = Integer . MIN_VALUE;
  int second = Integer . MAX_VALUE;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] > first ) {
      second = first;
      first = arr [ i ];
    }
    else if ( arr [ i ] > second ) second = arr [ i ];
  }
  for ( int i = 0;
  i < n;
  i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + " " );
}


MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED_1 | static int minSum ( int ar [ ], int n ) {
  if ( n <= 4 ) return Arrays . stream ( ar ) . min ( ) . getAsInt ( );
  int [ ] sum = new int [ n ];
  sum [ 0 ] = ar [ 0 ];
  sum [ 1 ] = ar [ 1 ];
  sum [ 2 ] = ar [ 2 ];
  sum [ 3 ] = ar [ 3 ];
  for ( int i = 4;
  i < n;
  i ++ ) sum [ i ] = ar [ i ] + Arrays . stream ( Arrays . copyOfRange ( sum, i - 4, i ) ) . min ( ) . getAsInt ( );
  return Arrays . stream ( Arrays . copyOfRange ( sum, n - 4, n ) ) . min ( ) . getAsInt ( );
}


CEILING_IN_A_SORTED_ARRAY | static int ceilSearch ( int arr [ ], int low, int high, int x ) {
  int i;
  if ( x <= arr [ low ] ) return low;
  for ( i = low;
  i < high;
  i ++ ) {
    if ( arr [ i ] == x ) return i;
    if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1;
  }
  return - 1;
}


SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE_1 | static void swap ( int xp, int yp ) {
  if ( xp == yp ) return;
  xp = xp + yp;
  yp = xp - yp;
  xp = xp - yp;
}


MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_ANAGRAM_WITHOUT_DELETION_OF_CHARACTER | static int countManipulations ( String s1, String s2 ) {
  int count = 0;
  int char_count [ ] = new int [ 26 ];
  for ( int i = 0;
  i < s1 . length ( );
  i ++ ) char_count [ s1 . charAt ( i ) - 'a' ] ++;
  for ( int i = 0;
  i < s2 . length ( );
  i ++ ) if ( char_count [ s2 . charAt ( i ) - 'a' ] -- <= 0 ) count ++;
  return count;
}


CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS | static boolean flipsPossible ( int [ ] a, int n ) {
  int count_odd = 0, count_even = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( ( a [ i ] & 1 ) == 1 ) count_odd ++;
    else count_even ++;
  }
  if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false;
  else return true;
}


CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL | static void substringConversions ( String str, int k, int b ) {
  for ( int i = 0;
  i + k <= str . length ( );
  i ++ ) {
    String sub = str . substring ( i, i + k );
    int sum = 0, counter = 0;
    for ( int j = sub . length ( ) - 1;
    j >= 0;
    j -- ) {
      sum = ( int ) ( sum + ( ( sub . charAt ( j ) - '0' ) * Math . pow ( b, counter ) ) );
      counter ++;
    }
    System . out . print ( sum + " " );
  }
}


FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN_ARE_1_IN_A_BOOLEAN_MATRIX | static int find ( boolean arr [ ] [ ] ) {
  int i = 0, j = n - 1;
  int res = - 1;
  while ( i < n && j >= 0 ) {
    if ( arr [ i ] [ j ] == false ) {
      while ( j >= 0 && ( arr [ i ] [ j ] == false || i == j ) ) {
        j --;
      }
      if ( j == - 1 ) {
        res = i;
        break;
      }
      else {
        i ++;
      }
    }
    else {
      while ( i < n && ( arr [ i ] [ j ] == true || i == j ) ) {
        i ++;
      }
      if ( i == n ) {
        res = j;
        break;
      }
      else {
        j --;
      }
    }
  }
  if ( res == - 1 ) {
    return res;
  }
  for ( int k = 0;
  k < n;
  k ++ ) {
    if ( res != k && arr [ k ] [ res ] != true ) {
      return - 1;
    }
  }
  for ( int l = 0;
  l < n;
  l ++ ) {
    if ( res != l && arr [ res ] [ l ] != false ) {
      return - 1;
    }
  }
  return res;
}


NUMBER_ORDERED_PAIRS_AI_AJ_0 | static int countPairs ( int a [ ], int n ) {
  int count = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = i + 1;
    j < n;
    j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2;
  }
  return count;
}


CIRCLE_LATTICE_POINTS | static int countLattice ( int r ) {
  if ( r <= 0 ) return 0;
  int result = 4;
  for ( int x = 1;
  x < r;
  x ++ ) {
    int ySquare = r * r - x * x;
    int y = ( int ) Math . sqrt ( ySquare );
    if ( y * y == ySquare ) result += 4;
  }
  return result;
}


MINIMUM_CHARACTERS_ADDED_FRONT_MAKE_STRING_PALINDROME | static boolean ispalindrome ( String s ) {
  int l = s . length ( );
  for ( int i = 0, j = l - 1;
  i <= j;
  i ++, j -- ) {
    if ( s . charAt ( i ) != s . charAt ( j ) ) {
      return false;
    }
  }
  return true;
}


K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SEQUENCE | static int find ( int a [ ], int b [ ], int k, int n1, int n2 ) {
  LinkedHashSet < Integer > s = new LinkedHashSet < > ( );
  for ( int i = 0;
  i < n2;
  i ++ ) s . add ( b [ i ] );
  int missing = 0;
  for ( int i = 0;
  i < n1;
  i ++ ) {
    if ( ! s . contains ( a [ i ] ) ) missing ++;
    if ( missing == k ) return a [ i ];
  }
  return - 1;
}


PROGRAM_CHECK_ISBN | static boolean isValidISBN ( String isbn ) {
  int n = isbn . length ( );
  if ( n != 10 ) return false;
  int sum = 0;
  for ( int i = 0;
  i < 9;
  i ++ ) {
    int digit = isbn . charAt ( i ) - '0';
    if ( 0 > digit || 9 < digit ) return false;
    sum += ( digit * ( 10 - i ) );
  }
  char last = isbn . charAt ( 9 );
  if ( last != 'X' && ( last < '0' || last > '9' ) ) return false;
  sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) );
  return ( sum % 11 == 0 );
}


COUNT_WAYS_INCREASE_LCS_LENGTH_TWO_STRINGS_ONE | static int waysToIncreaseLCSBy1 ( String str1, String str2 ) {
  int m = str1 . length ( ), n = str2 . length ( );
  Vector < Integer > [ ] position = new Vector [ M ];
  for ( int i = 0;
  i < M;
  i ++ ) position [ i ] = new Vector < > ( );
  for ( int i = 1;
  i <= n;
  i ++ ) position [ str2 . charAt ( i - 1 ) - 'a' ] . add ( i );
  int [ ] [ ] lcsl = new int [ m + 2 ] [ n + 2 ];
  int [ ] [ ] lcsr = new int [ m + 2 ] [ n + 2 ];
  for ( int i = 0;
  i <= m + 1;
  i ++ ) for ( int j = 0;
  j <= n + 1;
  j ++ ) lcsl [ i ] [ j ] = lcsr [ i ] [ j ] = 0;
  for ( int i = 1;
  i <= m;
  i ++ ) {
    for ( int j = 1;
    j <= n;
    j ++ ) {
      if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ];
      else lcsl [ i ] [ j ] = Math . max ( lcsl [ i - 1 ] [ j ], lcsl [ i ] [ j - 1 ] );
    }
  }
  for ( int i = m;
  i >= 1;
  i -- ) {
    for ( int j = n;
    j >= 1;
    j -- ) {
      if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ];
      else lcsr [ i ] [ j ] = Math . max ( lcsr [ i + 1 ] [ j ], lcsr [ i ] [ j + 1 ] );
    }
  }
  int ways = 0;
  for ( int i = 0;
  i <= m;
  i ++ ) {
    for ( char d = 0;
    d < 26;
    d ++ ) {
      for ( int j = 0;
      j < position [ d ] . size ( );
      j ++ ) {
        int p = position [ d ] . elementAt ( j );
        if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) ways ++;
      }
    }
  }
  return ways;
}


DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1 | static int eggDrop ( int n, int k ) {
  int eggFloor [ ] [ ] = new int [ n + 1 ] [ k + 1 ];
  int res;
  int i, j, x;
  for ( i = 1;
  i <= n;
  i ++ ) {
    eggFloor [ i ] [ 1 ] = 1;
    eggFloor [ i ] [ 0 ] = 0;
  }
  for ( j = 1;
  j <= k;
  j ++ ) eggFloor [ 1 ] [ j ] = j;
  for ( i = 2;
  i <= n;
  i ++ ) {
    for ( j = 2;
    j <= k;
    j ++ ) {
      eggFloor [ i ] [ j ] = Integer . MAX_VALUE;
      for ( x = 1;
      x <= j;
      x ++ ) {
        res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ], eggFloor [ i ] [ j - x ] );
        if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res;
      }
    }
  }
  return eggFloor [ n ] [ k ];
}


WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS | static int countWays ( int n ) {
  int table [ ] = new int [ n + 1 ];
  Arrays . fill ( table, 0 );
  table [ 0 ] = 1;
  for ( int i = 1;
  i < n;
  i ++ ) for ( int j = i;
  j <= n;
  j ++ ) table [ j ] += table [ j - i ];
  return table [ n ];
}


PROGRAM_SUM_COSX_SERIES | static double cosXSertiesSum ( double x, int n ) {
  x = x * ( PI / 180.0 );
  double res = 1;
  double sign = 1, fact = 1, pow = 1;
  for ( int i = 1;
  i < 5;
  i ++ ) {
    sign = sign * - 1;
    fact = fact * ( 2 * i - 1 ) * ( 2 * i );
    pow = pow * x * x;
    res = res + sign * pow / fact;
  }
  return res;
}


UNIQUE_CELLS_BINARY_MATRIX | static int countUnique ( int mat [ ] [ ], int n, int m ) {
  int [ ] rowsum = new int [ n ];
  int [ ] colsum = new int [ m ];
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 0;
  j < m;
  j ++ ) if ( mat [ i ] [ j ] != 0 ) {
    rowsum [ i ] ++;
    colsum [ j ] ++;
  }
  int uniquecount = 0;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 0;
  j < m;
  j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++;
  return uniquecount;
}


GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS | static void findMin ( int V ) {
  Vector < Integer > ans = new Vector < > ( );
  for ( int i = n - 1;
  i >= 0;
  i -- ) {
    while ( V >= deno [ i ] ) {
      V -= deno [ i ];
      ans . add ( deno [ i ] );
    }
  }
  for ( int i = 0;
  i < ans . size ( );
  i ++ ) {
    System . out . print ( " " + ans . elementAt ( i ) );
  }
}


CHECK_INTEGER_OVERFLOW_MULTIPLICATION | static Boolean isOverflow ( long a, long b ) {
  if ( a == 0 || b == 0 ) return false;
  long result = a * b;
  if ( a == result / b ) return false;
  else return true;
}


DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_1 | static int findDiff ( int arr [ ], int n ) {
  Map < Integer, Integer > mp = new HashMap < > ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( mp . containsKey ( arr [ i ] ) ) {
      mp . put ( arr [ i ], mp . get ( arr [ i ] ) + 1 );
    }
    else {
      mp . put ( arr [ i ], 1 );
    }
  }
  int max_count = 0, min_count = n;
  for ( Map . Entry < Integer, Integer > x : mp . entrySet ( ) ) {
    max_count = Math . max ( max_count, x . getValue ( ) );
    min_count = Math . min ( min_count, x . getValue ( ) );
  }
  return ( max_count - min_count );
}


COMPOSITE_NUMBER | static boolean isComposite ( int n ) {
  if ( n <= 1 ) System . out . println ( "False" );
  if ( n <= 3 ) System . out . println ( "False" );
  if ( n % 2 == 0 || n % 3 == 0 ) return true;
  for ( int i = 5;
  i * i <= n;
  i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true;
  return false;
}


LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS | static void findLIS ( int A [ ], int n ) {
  Map < Integer, Integer > hash = new HashMap < Integer, Integer > ( );
  int LIS_size = 1;
  int LIS_index = 0;
  hash . put ( A [ 0 ], 1 );
  for ( int i = 1;
  i < n;
  i ++ ) {
    hash . put ( A [ i ], hash . get ( A [ i ] - 1 ) == null ? 1 : hash . get ( A [ i ] - 1 ) + 1 );
    if ( LIS_size < hash . get ( A [ i ] ) ) {
      LIS_size = hash . get ( A [ i ] );
      LIS_index = A [ i ];
    }
  }
  System . out . println ( "LIS_size = " + LIS_size );
  System . out . print ( "LIS : " );
  int start = LIS_index - LIS_size + 1;
  while ( start <= LIS_index ) {
    System . out . print ( start + " " );
    start ++;
  }
}


COUNT_SET_BITS_IN_AN_INTEGER_2 | static int countSetBits ( int n ) {
  int count = 0;
  while ( n > 0 ) {
    n &= ( n - 1 );
    count ++;
  }
  return count;
}


FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD | boolean findPairs ( int arr [ ] ) {
  HashMap < Integer, pair > map = new HashMap < Integer, pair > ( );
  int n = arr . length;
  for ( int i = 0;
  i < n;
  ++ i ) {
    for ( int j = i + 1;
    j < n;
    ++ j ) {
      int sum = arr [ i ] + arr [ j ];
      if ( ! map . containsKey ( sum ) ) map . put ( sum, new pair ( i, j ) );
      else {
        pair p = map . get ( sum );
        System . out . println ( "(" + arr [ p . first ] + ", " + arr [ p . second ] + ") and (" + arr [ i ] + ", " + arr [ j ] + ")" );
        return true;
      }
    }
  }
  return false;
}


COUNT_OBTUSE_ANGLES_CIRCLE_K_EQUIDISTANT_POINTS_2_GIVEN_POINTS | static int countObtuseAngles ( int a, int b, int k ) {
  int c1 = ( b - a ) - 1;
  int c2 = ( k - b ) + ( a - 1 );
  if ( c1 == c2 ) return 0;
  return min ( c1, c2 );
}


NUMBER_TRIANGLES_N_MOVES_1 | public static double numberOfTriangles ( int n ) {
  double ans = 2 * ( pow ( 3, n ) ) - 1;
  return ans;
}


FIND_A_REPEATING_AND_A_MISSING_NUMBER | static void printTwoElements ( int arr [ ], int size ) {
  int i;
  System . out . print ( "The repeating element is " );
  for ( i = 0;
  i < size;
  i ++ ) {
    int abs_val = Math . abs ( arr [ i ] );
    if ( arr [ abs_val - 1 ] > 0 ) arr [ abs_val - 1 ] = - arr [ abs_val - 1 ];
    else System . out . println ( abs_val );
  }
  System . out . print ( "And the missing element is " );
  for ( i = 0;
  i < size;
  i ++ ) {
    if ( arr [ i ] > 0 ) System . out . println ( i + 1 );
  }
}


MINIMUM_DIFFERENCE_BETWEEN_GROUPS_OF_SIZE_TWO | static long calculate ( long a [ ], int n ) {
  Arrays . sort ( a );
  int i, j;
  Vector < Long > s = new Vector < > ( );
  for ( i = 0, j = n - 1;
  i < j;
  i ++, j -- ) s . add ( ( a [ i ] + a [ j ] ) );
  long mini = Collections . min ( s );
  long maxi = Collections . max ( s );
  return Math . abs ( maxi - mini );
}


FIND_PERIMETER_CYLINDER | static int perimeter ( int diameter, int height ) {
  return 2 * ( diameter + height );
}


MAGICAL_INDICES_ARRAY | static int solve ( int [ ] A, int n ) {
  int i, cnt = 0, j;
  int [ ] parent = new int [ n + 1 ];
  int [ ] vis = new int [ n + 1 ];
  for ( i = 0;
  i < n + 1;
  i ++ ) {
    parent [ i ] = - 1;
    vis [ i ] = 0;
  }
  for ( i = 0;
  i < n;
  i ++ ) {
    j = i;
    if ( parent [ j ] == - 1 ) {
      while ( parent [ j ] == - 1 ) {
        parent [ j ] = i;
        j = ( j + A [ j ] + 1 ) % n;
      }
      if ( parent [ j ] == i ) {
        while ( vis [ j ] == 0 ) {
          vis [ j ] = 1;
          cnt ++;
          j = ( j + A [ j ] + 1 ) % n;
        }
      }
    }
  }
  return cnt;
}


FIND_A_FIXED_POINT_IN_A_GIVEN_ARRAY_1 | static int binarySearch ( int arr [ ], int low, int high ) {
  if ( high >= low ) {
    int mid = ( low + high ) / 2;
    if ( mid == arr [ mid ] ) return mid;
    if ( mid > arr [ mid ] ) return binarySearch ( arr, ( mid + 1 ), high );
    else return binarySearch ( arr, low, ( mid - 1 ) );
  }
  return - 1;
}


FIND_SIZE_OF_THE_LARGEST_FORMED_BY_ALL_ONES_IN_A_BINARY_MATRIX | static int findLargestPlus ( int mat [ ] [ ] ) {
  int left [ ] [ ] = new int [ N ] [ N ];
  int right [ ] [ ] = new int [ N ] [ N ];
  int top [ ] [ ] = new int [ N ] [ N ];
  int bottom [ ] [ ] = new int [ N ] [ N ];
  for ( int i = 0;
  i < N;
  i ++ ) {
    top [ 0 ] [ i ] = mat [ 0 ] [ i ];
    bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ];
    left [ i ] [ 0 ] = mat [ i ] [ 0 ];
    right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ];
  }
  for ( int i = 0;
  i < N;
  i ++ ) {
    for ( int j = 1;
    j < N;
    j ++ ) {
      if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1;
      else left [ i ] [ j ] = 0;
      if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1;
      else top [ j ] [ i ] = 0;
      j = N - 1 - j;
      if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1;
      else bottom [ j ] [ i ] = 0;
      if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1;
      else right [ i ] [ j ] = 0;
      j = N - 1 - j;
    }
  }
  int n = 0;
  for ( int i = 0;
  i < N;
  i ++ ) {
    for ( int j = 0;
    j < N;
    j ++ ) {
      int len = Math . min ( Math . min ( top [ i ] [ j ], bottom [ i ] [ j ] ), Math . min ( left [ i ] [ j ], right [ i ] [ j ] ) );
      if ( len > n ) n = len;
    }
  }
  if ( n > 0 ) return 4 * ( n - 1 ) + 1;
  return 0;
}


LEVEL_NODE_TREE_SOURCE_NODE_USING_BFS | static void printLevels ( Vector < Vector < Integer > > graph, int V, int x ) {
  int level [ ] = new int [ V ];
  boolean marked [ ] = new boolean [ V ];
  Queue < Integer > que = new LinkedList < Integer > ( );
  que . add ( x );
  level [ x ] = 0;
  marked [ x ] = true;
  while ( que . size ( ) > 0 ) {
    x = que . peek ( );
    que . remove ( );
    for ( int i = 0;
    i < graph . get ( x ) . size ( );
    i ++ ) {
      int b = graph . get ( x ) . get ( i );
      if ( ! marked [ b ] ) {
        que . add ( b );
        level [ b ] = level [ x ] + 1;
        marked [ b ] = true;
      }
    }
  }
  System . out . println ( "Nodes" + " " + "Level" );
  for ( int i = 0;
  i < V;
  i ++ ) System . out . println ( " " + i + " --> " + level [ i ] );
}


FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I_3 | static void squareRoot ( int n, int p ) {
  n = n % p;
  for ( int x = 2;
  x < p;
  x ++ ) {
    if ( ( x * x ) % p == n ) {
      System . out . println ( "Square " + "root is " + x );
      return;
    }
  }
  System . out . println ( "Square root " + "doesn't exist" );
}


CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE | boolean areConsecutive ( int arr [ ], int n ) {
  if ( n < 1 ) return false;
  int min = getMin ( arr, n );
  int max = getMax ( arr, n );
  if ( max - min + 1 == n ) {
    boolean visited [ ] = new boolean [ n ];
    int i;
    for ( i = 0;
    i < n;
    i ++ ) {
      if ( visited [ arr [ i ] - min ] != false ) return false;
      visited [ arr [ i ] - min ] = true;
    }
    return true;
  }
  return false;
}


SMALLEST_SUBSET_SUM_GREATER_ELEMENTS | static int minElements ( int arr [ ], int n ) {
  int halfSum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) halfSum = halfSum + arr [ i ];
  halfSum = halfSum / 2;
  Arrays . sort ( arr );
  int res = 0, curr_sum = 0;
  for ( int i = n - 1;
  i >= 0;
  i -- ) {
    curr_sum += arr [ i ];
    res ++;
    if ( curr_sum > halfSum ) return res;
  }
  return res;
}


SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1 | static long calculateSum ( int n ) {
  long sum = 0;
  sum = 1 << n;
  return ( sum - 1 );
}


SWAP_TWO_NIBBLES_BYTE | static int swapNibbles ( int x ) {
  return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) > > 4 );
}


CHECK_CHARACTERS_GIVEN_STRING_CAN_REARRANGED_FORM_PALINDROME_1 | static boolean canFormPalindrome ( String str ) {
  List < Character > list = new ArrayList < Character > ( );
  for ( int i = 0;
  i < str . length ( );
  i ++ ) {
    if ( list . contains ( str . charAt ( i ) ) ) list . remove ( ( Character ) str . charAt ( i ) );
    else list . add ( str . charAt ( i ) );
  }
  if ( str . length ( ) % 2 == 0 && list . isEmpty ( ) || ( str . length ( ) % 2 == 1 && list . size ( ) == 1 ) ) return true;
  else return false;
}


WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER | static int countWays ( String s ) {
  int count [ ] = new int [ 26 ];
  for ( int i = 0;
  i < s . length ( );
  i ++ ) count [ s . charAt ( i ) - 'a' ] ++;
  count [ s . charAt ( 0 ) - 'a' ] = 1;
  int ans = 1;
  for ( int i = 0;
  i < 26;
  ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ];
  return ans;
}


ENTRINGER_NUMBER_1 | static int zigzag ( int n, int k ) {
  int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ];
  dp [ 0 ] [ 0 ] = 1;
  for ( int i = 1;
  i <= n;
  i ++ ) dp [ i ] [ 0 ] = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) {
    for ( int j = 1;
    j <= Math . min ( i, k );
    j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ];
  }
  return dp [ n ] [ k ];
}


COUNT_PAIRS_DIFFERENCE_EQUAL_K | static int countPairsWithDiffK ( int arr [ ], int n, int k ) {
  int count = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = i + 1;
    j < n;
    j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) count ++;
  }
  return count;
}


EXPECTATION_EXPECTED_VALUE_ARRAY | static float calc_Expectation ( float a [ ], float n ) {
  float prb = ( 1 / n );
  float sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) sum += a [ i ] * prb;
  return sum;
}


GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE | static void printGrouped ( String str ) {
  int n = str . length ( );
  int count [ ] = new int [ MAX_CHAR ];
  for ( int i = 0;
  i < n;
  i ++ ) count [ str . charAt ( i ) - 'a' ] ++;
  for ( int i = 0;
  i < n;
  i ++ ) {
    while ( count [ str . charAt ( i ) - 'a' ] != 0 ) {
      System . out . print ( str . charAt ( i ) );
      count [ str . charAt ( i ) - 'a' ] --;
    }
    count [ str . charAt ( i ) - 'a' ] = 0;
  }
}


MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION | static void printMaxSum ( int arr [ ], int n ) {
  int dp [ ] = new int [ n ];
  Arrays . fill ( dp, 0 );
  for ( int i = 0;
  i < n;
  i ++ ) {
    dp [ i ] = arr [ i ];
    int maxi = 0;
    for ( int j = 1;
    j <= Math . sqrt ( i + 1 );
    j ++ ) {
      if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) {
        if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ];
        if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ];
      }
    }
    dp [ i ] += maxi;
  }
  for ( int i = 0;
  i < n;
  i ++ ) System . out . print ( dp [ i ] + " " );
}


PROGRAM_CIRCUMFERENCE_PARALLELOGRAM | static float circumferenceparallelogram ( float a, float b ) {
  return ( ( 2 * a ) + ( 2 * b ) );
}


COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2 | static int numberOfPaths ( int m, int n ) {
  int [ ] dp = new int [ n ];
  dp [ 0 ] = 1;
  for ( int i = 0;
  i < m;
  i ++ ) {
    for ( int j = 1;
    j < n;
    j ++ ) {
      dp [ j ] += dp [ j - 1 ];
    }
  }
  return dp [ n - 1 ];
}


REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM | static int remAnagram ( String str1, String str2 ) {
  int count1 [ ] = new int [ 26 ];
  int count2 [ ] = new int [ 26 ];
  for ( int i = 0;
  i < str1 . length ( );
  i ++ ) count1 [ str1 . charAt ( i ) - 'a' ] ++;
  for ( int i = 0;
  i < str2 . length ( );
  i ++ ) count2 [ str2 . charAt ( i ) - 'a' ] ++;
  int result = 0;
  for ( int i = 0;
  i < 26;
  i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] );
  return result;
}


SUM_DIVISORS_1_N_1 | static int divisorSum ( int n ) {
  int sum = 0;
  for ( int i = 1;
  i <= n;
  ++ i ) sum += ( n / i ) * i;
  return sum;
}


FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_STRING | static int maxSubsequenceSubstring ( char x [ ], char y [ ], int n, int m ) {
  int dp [ ] [ ] = new int [ MAX ] [ MAX ];
  for ( int i = 0;
  i <= m;
  i ++ ) for ( int j = 0;
  j <= n;
  j ++ ) dp [ i ] [ j ] = 0;
  for ( int i = 1;
  i <= m;
  i ++ ) {
    for ( int j = 1;
    j <= n;
    j ++ ) {
      if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ];
      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ];
    }
  }
  int ans = 0;
  for ( int i = 1;
  i <= m;
  i ++ ) ans = Math . max ( ans, dp [ i ] [ n ] );
  return ans;
}


SUM_FAI_AJ_PAIRS_ARRAY_N_INTEGERS | public static int sum ( int a [ ], int n ) {
  Map < Integer, Integer > cnt = new HashMap < Integer, Integer > ( );
  int ans = 0, pre_sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    ans += ( i * a [ i ] ) - pre_sum;
    pre_sum += a [ i ];
    if ( cnt . containsKey ( a [ i ] - 1 ) ) ans -= cnt . get ( a [ i ] - 1 );
    if ( cnt . containsKey ( a [ i ] + 1 ) ) ans += cnt . get ( a [ i ] + 1 );
    if ( cnt . containsKey ( a [ i ] ) ) {
      cnt . put ( a [ i ], cnt . get ( a [ i ] ) + 1 );
    }
    else {
      cnt . put ( a [ i ], 1 );
    }
  }
  return ans;
}


BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER | static void bin ( int n ) {
  if ( n > 1 ) bin ( n / 2 );
  System . out . print ( n % 2 );
}


KNAPSACK_PROBLEM | static int knapSack ( int W, int wt [ ], int val [ ], int n ) {
  if ( n == 0 || W == 0 ) return 0;
  if ( wt [ n - 1 ] > W ) return knapSack ( W, wt, val, n - 1 );
  else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ], wt, val, n - 1 ), knapSack ( W, wt, val, n - 1 ) );
}


DOUBLE_FACTORIAL_1 | static int doublefactorial ( int n ) {
  int res = 1;
  for ( int i = n;
  i >= 0;
  i = i - 2 ) {
    if ( i == 0 || i == 1 ) return res;
    else res *= i;
  }
  return res;
}


COUNT_DIGITS_FACTORIAL_SET_2 | static long findDigits ( int n ) {
  if ( n < 0 ) return 0;
  if ( n <= 1 ) return 1;
  double x = ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 );
  return ( long ) Math . floor ( x ) + 1;
}


DELANNOY_NUMBER_1 | static int dealnnoy ( int n, int m ) {
  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= m;
  i ++ ) dp [ i ] [ 0 ] = 1;
  for ( int i = 0;
  i < m;
  i ++ ) dp [ 0 ] [ i ] = 1;
  for ( int i = 1;
  i <= m;
  i ++ ) for ( int j = 1;
  j <= n;
  j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ];
  return dp [ m ] [ n ];
}


FIND_THE_MISSING_NUMBER_2 | static int getMissingNo ( int a [ ], int n ) {
  int x1 = a [ 0 ];
  int x2 = 1;
  for ( int i = 1;
  i < n;
  i ++ ) x1 = x1 ^ a [ i ];
  for ( int i = 2;
  i <= n + 1;
  i ++ ) x2 = x2 ^ i;
  return ( x1 ^ x2 );
}


FIND_NUMBER_OF_TRIANGLES_POSSIBLE | static int findNumberOfTriangles ( int arr [ ] ) {
  int n = arr . length;
  Arrays . sort ( arr );
  int count = 0;
  for ( int i = 0;
  i < n - 2;
  ++ i ) {
    int k = i + 2;
    for ( int j = i + 1;
    j < n;
    ++ j ) {
      while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k;
      if ( k > j ) count += k - j - 1;
    }
  }
  return count;
}


NUMBER_TRIANGLES_N_MOVES | public static int numberOfTriangles ( int n ) {
  int [ ] answer = new int [ n + 1 ];
  answer [ 0 ] = 1;
  for ( int i = 1;
  i <= n;
  i ++ ) answer [ i ] = answer [ i - 1 ] * 3 + 2;
  return answer [ n ];
}


CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX | static boolean areSumSame ( int a [ ] [ ], int n, int m ) {
  int sum1 = 0, sum2 = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    sum1 = 0;
    sum2 = 0;
    for ( int j = 0;
    j < m;
    j ++ ) {
      sum1 += a [ i ] [ j ];
      sum2 += a [ j ] [ i ];
    }
    if ( sum1 == sum2 ) return true;
  }
  return false;
}


WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TWO | static boolean isPowerOfTwo ( int n ) {
  if ( n == 0 ) return false;
  while ( n != 1 ) {
    if ( n % 2 != 0 ) return false;
    n = n / 2;
  }
  return true;
}


PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS | public static void amendSentence ( String sstr ) {
  char [ ] str = sstr . toCharArray ( );
  for ( int i = 0;
  i < str . length;
  i ++ ) {
    if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) {
      str [ i ] = ( char ) ( str [ i ] + 32 );
      if ( i != 0 ) System . out . print ( " " );
      System . out . print ( str [ i ] );
    }
    else System . out . print ( str [ i ] );
  }
}


CHECK_DIVISIBILITY_BINARY_STRING_2K | static boolean isDivisible ( String str, int k ) {
  int n = str . length ( );
  int c = 0;
  for ( int i = 0;
  i < k;
  i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++;
  return ( c == k );
}


SUBSEQUENCES_SIZE_THREE_ARRAY_WHOSE_SUM_DIVISIBLE_M | static int coutSubSeq ( int A [ ], int N, int M ) {
  int sum = 0;
  int ans = 0;
  for ( int i = 0;
  i < N;
  i ++ ) {
    for ( int j = i + 1;
    j < N;
    j ++ ) {
      for ( int k = j + 1;
      k < N;
      k ++ ) {
        sum = A [ i ] + A [ j ] + A [ k ];
        if ( sum % M == 0 ) ans ++;
      }
    }
  }
  return ans;
}


LONGEST_CONSECUTIVE_SUBSEQUENCE | static int findLongestConseqSubseq ( int arr [ ], int n ) {
  HashSet < Integer > S = new HashSet < Integer > ( );
  int ans = 0;
  for ( int i = 0;
  i < n;
  ++ i ) S . add ( arr [ i ] );
  for ( int i = 0;
  i < n;
  ++ i ) {
    if ( ! S . contains ( arr [ i ] - 1 ) ) {
      int j = arr [ i ];
      while ( S . contains ( j ) ) j ++;
      if ( ans < j - arr [ i ] ) ans = j - arr [ i ];
    }
  }
  return ans;
}


FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME_1 | static int findIndex ( int n ) {
  float fibo = 2.078087F * ( float ) Math . log ( n ) + 1.672276F;
  return Math . round ( fibo );
}


LARGEST_DIVISIBLE_PAIRS_SUBSET | static int largestSubset ( int [ ] a, int n ) {
  Arrays . sort ( a );
  int [ ] dp = new int [ n ];
  dp [ n - 1 ] = 1;
  for ( int i = n - 2;
  i >= 0;
  i -- ) {
    int mxm = 0;
    for ( int j = i + 1;
    j < n;
    j ++ ) {
      if ( a [ j ] % a [ i ] == 0 ) {
        mxm = Math . max ( mxm, dp [ j ] );
      }
    }
    dp [ i ] = 1 + mxm;
  }
  return Arrays . stream ( dp ) . max ( ) . getAsInt ( );
}


FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2 | static boolean isPowerOfFour ( int n ) {
  return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0xAAAAAAAA ) == 0;
}


COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLUTION | static int nCrModp ( int n, int r, int p ) {
  int C [ ] = new int [ r + 1 ];
  Arrays . fill ( C, 0 );
  C [ 0 ] = 1;
  for ( int i = 1;
  i <= n;
  i ++ ) {
    for ( int j = Math . min ( i, r );
    j > 0;
    j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p;
  }
  return C [ r ];
}


ROUND_THE_GIVEN_NUMBER_TO_NEAREST_MULTIPLE_OF_10 | static int round ( int n ) {
  int a = ( n / 10 ) * 10;
  int b = a + 10;
  return ( n - a > b - n ) ? b : a;
}


SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING_ORDER_1 | static void twoWaySort ( int arr [ ], int n ) {
  for ( int i = 0;
  i < n;
  i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1;
  Arrays . sort ( arr );
  for ( int i = 0;
  i < n;
  i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1;
}


POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS | static void pointClip ( int XY [ ] [ ], int n, int Xmin, int Ymin, int Xmax, int Ymax ) {
  System . out . printf ( "Point inside the viewing pane:\n" );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xmax ) ) {
      if ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] <= Ymax ) ) System . out . printf ( "[%d, %d] ", XY [ i ] [ 0 ], XY [ i ] [ 1 ] );
    }
  }
  System . out . printf ( "\nPoint outside the viewing pane:\n" );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax ) ) System . out . printf ( "[%d, %d] ", XY [ i ] [ 0 ], XY [ i ] [ 1 ] );
    if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax ) ) System . out . printf ( "[%d, %d] ", XY [ i ] [ 0 ], XY [ i ] [ 1 ] );
  }
}


WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS | static int countTransformation ( String a, String b ) {
  int n = a . length ( ), m = b . length ( );
  if ( m == 0 ) {
    return 1;
  }
  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ];
  for ( int i = 0;
  i < m;
  i ++ ) {
    for ( int j = i;
    j < n;
    j ++ ) {
      if ( i == 0 ) {
        if ( j == 0 ) {
          dp [ i ] [ j ] = ( a . charAt ( j ) == b . charAt ( i ) ) ? 1 : 0;
        }
        else if ( a . charAt ( j ) == b . charAt ( i ) ) {
          dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1;
        }
        else {
          dp [ i ] [ j ] = dp [ i ] [ j - 1 ];
        }
      }
      else if ( a . charAt ( j ) == b . charAt ( i ) ) {
        dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ];
      }
      else {
        dp [ i ] [ j ] = dp [ i ] [ j - 1 ];
      }
    }
  }
  return dp [ m - 1 ] [ n - 1 ];
}


FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS | static void relativeComplement ( int arr1 [ ], int arr2 [ ], int n, int m ) {
  int i = 0, j = 0;
  while ( i < n && j < m ) {
    if ( arr1 [ i ] < arr2 [ j ] ) {
      System . out . print ( arr1 [ i ] + " " );
      i ++;
    }
    else if ( arr1 [ i ] > arr2 [ j ] ) {
      j ++;
    }
    else if ( arr1 [ i ] == arr2 [ j ] ) {
      i ++;
      j ++;
    }
  }
  while ( i < n ) System . out . print ( arr1 [ i ] + " " );
}


COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY | static int countPairs ( int arr [ ], int n ) {
  int ans = 0;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++;
  return ans;
}


GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT | static void findSymPairs ( int arr [ ] [ ] ) {
  HashMap < Integer, Integer > hM = new HashMap < Integer, Integer > ( );
  for ( int i = 0;
  i < arr . length;
  i ++ ) {
    int first = arr [ i ] [ 0 ];
    int sec = arr [ i ] [ 1 ];
    Integer val = hM . get ( sec );
    if ( val != null && val == first ) System . out . println ( "(" + sec + ", " + first + ")" );
    else hM . put ( first, sec );
  }
}


COUNT_SUBSEQUENCES_PRODUCT_LESS_K | public static int productSubSeqCount ( ArrayList < Integer > arr, int k ) {
  int n = arr . size ( );
  int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ];
  for ( int i = 1;
  i <= k;
  i ++ ) {
    for ( int j = 1;
    j <= n;
    j ++ ) {
      dp [ i ] [ j ] = dp [ i ] [ j - 1 ];
      if ( arr . get ( j - 1 ) <= i && arr . get ( j - 1 ) > 0 ) dp [ i ] [ j ] += dp [ i / arr . get ( j - 1 ) ] [ j - 1 ] + 1;
    }
  }
  return dp [ k ] [ n ];
}


REARRANGE_ARRAY_ARRI_ARRJ_EVEN_ARRI | public static void rearrangeArr ( int arr [ ], int n ) {
  int evenPos = n / 2;
  int oddPos = n - evenPos;
  int [ ] tempArr = new int [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) tempArr [ i ] = arr [ i ];
  Arrays . sort ( tempArr );
  int j = oddPos - 1;
  for ( int i = 0;
  i < n;
  i += 2 ) {
    arr [ i ] = tempArr [ j ];
    j --;
  }
  j = oddPos;
  for ( int i = 1;
  i < n;
  i += 2 ) {
    arr [ i ] = tempArr [ j ];
    j ++;
  }
  for ( int i = 0;
  i < n;
  i ++ ) System . out . print ( arr [ i ] + " " );
}


MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK | static int minRotation ( int input, int unlock_code ) {
  int rotation = 0;
  int input_digit, code_digit;
  while ( input > 0 || unlock_code > 0 ) {
    input_digit = input % 10;
    code_digit = unlock_code % 10;
    rotation += Math . min ( Math . abs ( input_digit - code_digit ), 10 - Math . abs ( input_digit - code_digit ) );
    input /= 10;
    unlock_code /= 10;
  }
  return rotation;
}


REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES | static void arrangeString ( String str, int x, int y ) {
  int count_0 = 0;
  int count_1 = 0;
  int len = str . length ( );
  for ( int i = 0;
  i < len;
  i ++ ) {
    if ( str . charAt ( i ) == '0' ) count_0 ++;
    else count_1 ++;
  }
  while ( count_0 > 0 || count_1 > 0 ) {
    for ( int j = 0;
    j < x && count_0 > 0;
    j ++ ) {
      if ( count_0 > 0 ) {
        System . out . print ( "0" );
        count_0 --;
      }
    }
    for ( int j = 0;
    j < y && count_1 > 0;
    j ++ ) {
      if ( count_1 > 0 ) {
        System . out . print ( "1" );
        count_1 --;
      }
    }
  }
}


DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE | static int maxSumIS ( int arr [ ], int n ) {
  int i, j, max = 0;
  int msis [ ] = new int [ n ];
  for ( i = 0;
  i < n;
  i ++ ) msis [ i ] = arr [ i ];
  for ( i = 1;
  i < n;
  i ++ ) for ( j = 0;
  j < i;
  j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ];
  for ( i = 0;
  i < n;
  i ++ ) if ( max < msis [ i ] ) max = msis [ i ];
  return max;
}


NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES | static int countRect ( int n ) {
  int ans = 0;
  for ( int length = 1;
  length <= Math . sqrt ( n );
  ++ length ) for ( int height = length;
  height * length <= n;
  ++ height ) ans ++;
  return ans;
}


PROGRAM_TO_PRINT_TETRAHEDRAL_NUMBERS_UPTO_NTH_TERM | static void printSeries ( int n ) {
  for ( int i = 1;
  i <= n;
  i ++ ) {
    int num = i * ( i + 1 ) * ( i + 2 ) / 6;
    System . out . print ( num + " " );
  }
}


PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX | static void transpose ( int A [ ] [ ], int B [ ] [ ] ) {
  int i, j;
  for ( i = 0;
  i < N;
  i ++ ) for ( j = 0;
  j < N;
  j ++ ) B [ i ] [ j ] = A [ j ] [ i ];
}


PROGRAM_DECIMAL_BINARY_CONVERSION_1 | public void decToBinary ( int n ) {
  for ( int i = 31;
  i >= 0;
  i -- ) {
    int k = n > > i;
    if ( ( k & 1 ) > 0 ) System . out . print ( "1" );
    else System . out . print ( "0" );
  }
}


REARRANGE_ARRAY_ORDER_SMALLEST_LARGEST_2ND_SMALLEST_2ND_LARGEST | static void rearrangeArray ( int arr [ ], int n ) {
  Arrays . sort ( arr );
  int [ ] tempArr = new int [ n ];
  int ArrIndex = 0;
  for ( int i = 0, j = n - 1;
  i <= n / 2 || j > n / 2;
  i ++, j -- ) {
    if ( ArrIndex < n ) {
      tempArr [ ArrIndex ] = arr [ i ];
      ArrIndex ++;
    }
    if ( ArrIndex < n ) {
      tempArr [ ArrIndex ] = arr [ j ];
      ArrIndex ++;
    }
  }
  for ( int i = 0;
  i < n;
  i ++ ) arr [ i ] = tempArr [ i ];
}


SUM_AREA_RECTANGLES_POSSIBLE_ARRAY | static int MaxTotalRectangleArea ( int [ ] a, int n ) {
  Arrays . sort ( a );
  int sum = 0;
  boolean flag = false;
  int len = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ! flag ) {
      flag = true;
      len = a [ i + 1 ];
      i ++;
    }
    else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) {
      sum = sum + a [ i + 1 ] * len;
      flag = false;
      i ++;
    }
  }
  return sum;
}


GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1 | int countSubStr ( char str [ ], int n ) {
  int res = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( str [ i ] == '1' ) {
      for ( int j = i + 1;
      j < n;
      j ++ ) {
        if ( str [ j ] == '1' ) res ++;
      }
    }
  }
  return res;
}


DYNAMIC_PROGRAMMING_SET_31_OPTIMAL_STRATEGY_FOR_A_GAME | static int optimalStrategyOfGame ( int arr [ ], int n ) {
  int table [ ] [ ] = new int [ n ] [ n ];
  int gap, i, j, x, y, z;
  for ( gap = 0;
  gap < n;
  ++ gap ) {
    for ( i = 0, j = gap;
    j < n;
    ++ i, ++ j ) {
      x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0;
      y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0;
      z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0;
      table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x, y ), arr [ j ] + Math . min ( y, z ) );
    }
  }
  return table [ 0 ] [ n - 1 ];
}


REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S | static String replace ( String s, char c1, char c2 ) {
  int l = s . length ( );
  char [ ] arr = s . toCharArray ( );
  for ( int i = 0;
  i < l;
  i ++ ) {
    if ( arr [ i ] == c1 ) arr [ i ] = c2;
    else if ( arr [ i ] == c2 ) arr [ i ] = c1;
  }
  return String . valueOf ( arr );
}


FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1 | static int maxLen ( int arr [ ] ) {
  HashMap < Integer, Integer > hM = new HashMap < Integer, Integer > ( );
  int sum = 0;
  int max_len = 0;
  for ( int i = 0;
  i < arr . length;
  i ++ ) {
    sum += arr [ i ];
    if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1;
    if ( sum == 0 ) max_len = i + 1;
    Integer prev_i = hM . get ( sum );
    if ( prev_i != null ) max_len = Math . max ( max_len, i - prev_i );
    else hM . put ( sum, i );
  }
  return max_len;
}


PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1 | static int summingSeries ( long n ) {
  return ( int ) Math . pow ( n, 2 );
}


RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY | static int recSearch ( int arr [ ], int l, int r, int x ) {
  if ( r < l ) return - 1;
  if ( arr [ l ] == x ) return l;
  if ( arr [ r ] == x ) return r;
  return recSearch ( arr, l + 1, r - 1, x );
}


PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN | static void printPath ( String str ) {
  int i = 0;
  int curX = 0, curY = 0;
  while ( i < str . length ( ) ) {
    int nextX = ( str . charAt ( i ) - 'A' ) / 5;
    int nextY = ( str . charAt ( i ) - 'B' + 1 ) % 5;
    while ( curX > nextX ) {
      System . out . println ( "Move Up" );
      curX --;
    }
    while ( curY > nextY ) {
      System . out . println ( "Move Left" );
      curY --;
    }
    while ( curX < nextX ) {
      System . out . println ( "Move Down" );
      curX ++;
    }
    while ( curY < nextY ) {
      System . out . println ( "Move Right" );
      curY ++;
    }
    System . out . println ( "Press OK" );
    i ++;
  }
}


COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX | static int count ( int n, int x ) {
  int count = 0;
  for ( int i = 1;
  i <= n && i <= x;
  i ++ ) {
    if ( x / i <= n && x % i == 0 ) count ++;
  }
  return count;
}


PROGRAM_FIND_LINE_PASSING_2_POINTS | static void lineFromPoints ( Pair P, Pair Q ) {
  int a = Q . second - P . second;
  int b = P . first - Q . first;
  int c = a * ( P . first ) + b * ( P . second );
  if ( b < 0 ) {
    System . out . println ( "The line passing through points P and Q is: " + a + "x " + b + "y = " + c );
  }
  else {
    System . out . println ( "The line passing through points P and Q is: " + a + "x + " + b + "y = " + c );
  }
}


REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT | static int solve ( int dp [ ] [ ], int a [ ], int low, int high, int turn ) {
  if ( low == high ) {
    return a [ low ] * turn;
  }
  if ( dp [ low ] [ high ] != 0 ) {
    return dp [ low ] [ high ];
  }
  dp [ low ] [ high ] = Math . max ( a [ low ] * turn + solve ( dp, a, low + 1, high, turn + 1 ), a [ high ] * turn + solve ( dp, a, low, high - 1, turn + 1 ) );
  return dp [ low ] [ high ];
}


CHECK_GRAPHS_CYCLE_ODD_LENGTH | public static boolean containsOdd ( int G [ ] [ ], int src ) {
  int colorArr [ ] = new int [ V ];
  for ( int i = 0;
  i < V;
  ++ i ) colorArr [ i ] = - 1;
  colorArr [ src ] = 1;
  LinkedList < Integer > q = new LinkedList < Integer > ( );
  q . add ( src );
  while ( ! q . isEmpty ( ) ) {
    int u = q . peek ( );
    q . pop ( );
    if ( G [ u ] [ u ] == 1 ) return true;
    for ( int v = 0;
    v < V;
    ++ v ) {
      if ( G [ u ] [ v ] == 1 && colorArr [ v ] == - 1 ) {
        colorArr [ v ] = 1 - colorArr [ u ];
        q . push ( v );
      }
      else if ( G [ u ] [ v ] == 1 && colorArr [ v ] == colorArr [ u ] ) return true;
    }
  }
  return false;
}


SUM_SERIES_ALTERNATE_SIGNED_SQUARES_AP | static int seiresSum ( int n, int [ ] a ) {
  int res = 0, i;
  for ( i = 0;
  i < 2 * n;
  i ++ ) {
    if ( i % 2 == 0 ) res += a [ i ] * a [ i ];
    else res -= a [ i ] * a [ i ];
  }
  return res;
}


PROGRAM_DECIMAL_BINARY_CONVERSION | static void decToBinary ( int n ) {
  int [ ] binaryNum = new int [ 32 ];
  int i = 0;
  while ( n > 0 ) {
    binaryNum [ i ] = n % 2;
    n = n / 2;
    i ++;
  }
  for ( int j = i - 1;
  j >= 0;
  j -- ) System . out . print ( binaryNum [ j ] );
}


LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY_INDEX | public static void longestAlternating ( int arr [ ], int n ) {
  int [ ] count = new int [ n ];
  count [ n - 1 ] = 1;
  for ( int i = n - 2;
  i >= 0;
  i -- ) {
    if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1;
    else count [ i ] = 1;
  }
  for ( int i = 0;
  i < n;
  i ++ ) System . out . print ( count [ i ] + " " );
}


FIND_STRING_LEXICOGRAPHIC_ORDER_GIVEN_TWO_STRINGS | static String lexNext ( String str, int n ) {
  char [ ] s = str . toCharArray ( );
  for ( int i = n - 1;
  i >= 0;
  i -- ) {
    if ( s [ i ] != 'z' ) {
      s [ i ] ++;
      return String . valueOf ( s );
    }
    s [ i ] = 'a';
  }
  return null;
}


NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE | static int getNumStrictMonotone ( int len ) {
  int [ ] [ ] DP = new int [ len ] [ DP_s ];
  for ( int i = 0;
  i < DP_s;
  ++ i ) DP [ 0 ] [ i ] = i + 1;
  for ( int i = 1;
  i < len;
  ++ i ) for ( int j = 1;
  j < DP_s;
  ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ];
  return DP [ len - 1 ] [ DP_s - 1 ];
}


PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES | static void constructTree ( int n, int d, int h ) {
  if ( d == 1 ) {
    if ( n == 2 && h == 1 ) {
      System . out . println ( "1 2" );
      return;
    }
    System . out . println ( "-1" );
    return;
  }
  if ( d > 2 * h ) {
    System . out . println ( "-1" );
    return;
  }
  for ( int i = 1;
  i <= h;
  i ++ ) System . out . println ( i + " " + ( i + 1 ) );
  if ( d > h ) {
    System . out . println ( "1" + " " + ( h + 2 ) );
    for ( int i = h + 2;
    i <= d;
    i ++ ) {
      System . out . println ( i + " " + ( i + 1 ) );
    }
  }
  for ( int i = d + 1;
  i < n;
  i ++ ) {
    int k = 1;
    if ( d == h ) k = 2;
    System . out . println ( k + " " + ( i + 1 ) );
  }
}


MINIMAL_OPERATIONS_MAKE_NUMBER_MAGICAL | static int calculate ( String s ) {
  int ans = 6;
  for ( int i = 0;
  i < 10;
  ++ i ) {
    for ( int j = 0;
    j < 10;
    ++ j ) {
      for ( int k = 0;
      k < 10;
      ++ k ) {
        for ( int l = 0;
        l < 10;
        ++ l ) {
          for ( int m = 0;
          m < 10;
          ++ m ) {
            for ( int n = 0;
            n < 10;
            ++ n ) {
              if ( i + j + k == l + m + n ) {
                int c = 0;
                if ( i != s . charAt ( 0 ) - '0' ) c ++;
                if ( j != s . charAt ( 1 ) - '0' ) c ++;
                if ( k != s . charAt ( 2 ) - '0' ) c ++;
                if ( l != s . charAt ( 3 ) - '0' ) c ++;
                if ( m != s . charAt ( 4 ) - '0' ) c ++;
                if ( n != s . charAt ( 5 ) - '0' ) c ++;
                if ( c < ans ) ans = c;
              }
            }
          }
        }
      }
    }
  }
  return ans;
}


FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE | boolean find3Numbers ( int A [ ], int arr_size, int sum ) {
  int l, r;
  for ( int i = 0;
  i < arr_size - 2;
  i ++ ) {
    for ( int j = i + 1;
    j < arr_size - 1;
    j ++ ) {
      for ( int k = j + 1;
      k < arr_size;
      k ++ ) {
        if ( A [ i ] + A [ j ] + A [ k ] == sum ) {
          System . out . print ( "Triplet is " + A [ i ] + ", " + A [ j ] + ", " + A [ k ] );
          return true;
        }
      }
    }
  }
  return false;
}


AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_IN_IT | static float getArea ( int a ) {
  float area = ( float ) ( Math . PI * a * a ) / 4;
  return area;
}


GIVEN_TWO_UNSORTED_ARRAYS_FIND_PAIRS_WHOSE_SUM_X_1 | public static void findPairs ( int arr1 [ ], int arr2 [ ], int n, int m, int x ) {
  HashMap < Integer, Integer > s = new HashMap < Integer, Integer > ( );
  for ( int i = 0;
  i < n;
  i ++ ) s . put ( arr1 [ i ], 0 );
  for ( int j = 0;
  j < m;
  j ++ ) if ( s . containsKey ( x - arr2 [ j ] ) ) System . out . println ( x - arr2 [ j ] + " " + arr2 [ j ] );
}


QUICK_WAY_CHECK_CHARACTERS_STRING | static boolean allCharactersSame ( String s ) {
  int n = s . length ( );
  for ( int i = 1;
  i < n;
  i ++ ) if ( s . charAt ( i ) != s . charAt ( 0 ) ) return false;
  return true;
}


REARRANGE_ARRAY_ARRI | public static int [ ] fix ( int [ ] A ) {
  for ( int i = 0;
  i < A . length;
  i ++ ) {
    if ( A [ i ] != - 1 && A [ i ] != i ) {
      int x = A [ i ];
      while ( A [ x ] != - 1 && A [ x ] != x ) {
        int y = A [ x ];
        A [ x ] = x;
        x = y;
      }
      A [ x ] = x;
      if ( A [ i ] != i ) {
        A [ i ] = - 1;
      }
    }
  }
  return A;
}


PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS | boolean isProduct ( int arr [ ], int n, int x ) {
  for ( int i = 0;
  i < n - 1;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true;
  return false;
}


SORT_GIVEN_STRING_USING_CHARACTER_SEARCH | static String sortString ( String str, int n ) {
  String new_str = "";
  for ( int i = 'a';
  i <= 'z';
  i ++ ) for ( int j = 0;
  j < n;
  j ++ ) if ( str . charAt ( j ) == i ) new_str += str . charAt ( j );
  return new_str;
}


COUNT_OF_OCCURRENCES_OF_A_101_PATTERN_IN_A_STRING | static int countPattern ( String str ) {
  int len = str . length ( );
  boolean oneSeen = false;
  int count = 0;
  for ( int i = 0;
  i < len;
  i ++ ) {
    char getChar = str . charAt ( i );
    if ( getChar == '1' && oneSeen == true ) {
      if ( str . charAt ( i - 1 ) == '0' ) count ++;
    }
    if ( getChar == '1' && oneSeen == false ) oneSeen = true;
    if ( getChar != '0' && str . charAt ( i ) != '1' ) oneSeen = false;
  }
  return count;
}


C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE | static void rotate ( ) {
  int x = arr [ arr . length - 1 ], i;
  for ( i = arr . length - 1;
  i > 0;
  i -- ) arr [ i ] = arr [ i - 1 ];
  arr [ 0 ] = x;
}


QUEUE_BASED_APPROACH_FOR_FIRST_NON_REPEATING_CHARACTER_IN_A_STREAM | static void firstNonRepeating ( String str ) {
  int [ ] charCount = new int [ MAX_CHAR ];
  Queue < Character > q = new LinkedList < Character > ( );
  for ( int i = 0;
  i < str . length ( );
  i ++ ) {
    char ch = str . charAt ( i );
    q . add ( ch );
    charCount [ ch - 'a' ] ++;
    while ( ! q . isEmpty ( ) ) {
      if ( charCount [ q . peek ( ) - 'a' ] > 1 ) q . remove ( );
      else {
        System . out . print ( q . peek ( ) + " " );
        break;
      }
    }
    if ( q . isEmpty ( ) ) System . out . print ( - 1 + " " );
  }
  System . out . println ( );
}


CHECK_LARGE_NUMBER_DIVISIBLE_6_NOT | static boolean check ( String str ) {
  int n = str . length ( );
  if ( ( str . charAt ( n - 1 ) - '0' ) % 2 != 0 ) return false;
  int digitSum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) digitSum += ( str . charAt ( i ) - '0' );
  return ( digitSum % 3 == 0 );
}


MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N | static int getMinSquares ( int n ) {
  if ( n <= 3 ) return n;
  int res = n;
  for ( int x = 1;
  x <= n;
  x ++ ) {
    int temp = x * x;
    if ( temp > n ) break;
    else res = Math . min ( res, 1 + getMinSquares ( n - temp ) );
  }
  return res;
}


OVERLAPPING_SUM_TWO_ARRAY | static int findSum ( int [ ] A, int [ ] B, int n ) {
  HashMap < Integer, Integer > hash = new HashMap < > ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( hash . containsKey ( A [ i ] ) ) hash . put ( A [ i ], 1 + hash . get ( A [ i ] ) );
    else hash . put ( A [ i ], 1 );
    if ( hash . containsKey ( B [ i ] ) ) hash . put ( B [ i ], 1 + hash . get ( B [ i ] ) );
    else hash . put ( B [ i ], 1 );
  }
  int sum = 0;
  for ( Map . Entry entry : hash . entrySet ( ) ) {
    if ( Integer . parseInt ( ( entry . getValue ( ) ) . toString ( ) ) == 1 ) sum += Integer . parseInt ( ( entry . getKey ( ) ) . toString ( ) );
  }
  return sum;
}


MOBILE_NUMERIC_KEYPAD_PROBLEM | static int getCount ( char keypad [ ] [ ], int n ) {
  if ( keypad == null || n <= 0 ) return 0;
  if ( n == 1 ) return 10;
  int [ ] odd = new int [ 10 ];
  int [ ] even = new int [ 10 ];
  int i = 0, j = 0, useOdd = 0, totalCount = 0;
  for ( i = 0;
  i <= 9;
  i ++ ) odd [ i ] = 1;
  for ( j = 2;
  j <= n;
  j ++ ) {
    useOdd = 1 - useOdd;
    if ( useOdd == 1 ) {
      even [ 0 ] = odd [ 0 ] + odd [ 8 ];
      even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ];
      even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ];
      even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ];
      even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ];
      even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ];
      even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ];
      even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ];
      even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ];
      even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ];
    }
    else {
      odd [ 0 ] = even [ 0 ] + even [ 8 ];
      odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ];
      odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ];
      odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ];
      odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ];
      odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ];
      odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ];
      odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ];
      odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ];
      odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ];
    }
  }
  totalCount = 0;
  if ( useOdd == 1 ) {
    for ( i = 0;
    i <= 9;
    i ++ ) totalCount += even [ i ];
  }
  else {
    for ( i = 0;
    i <= 9;
    i ++ ) totalCount += odd [ i ];
  }
  return totalCount;
}


FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY | static void findLarger ( int arr [ ], int n ) {
  Arrays . sort ( arr );
  for ( int i = n - 1;
  i >= n / 2;
  i -- ) System . out . print ( arr [ i ] + " " );
}


SUM_BINOMIAL_COEFFICIENTS | static int binomialCoeffSum ( int n ) {
  int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) {
    for ( int j = 0;
    j <= Math . min ( i, n );
    j ++ ) {
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1;
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ];
    }
  }
  int sum = 0;
  for ( int i = 0;
  i <= n;
  i ++ ) sum += C [ n ] [ i ];
  return sum;
}


FIND_COMMON_ELEMENT_ROWS_ROW_WISE_SORTED_MATRIX_1 | static int findCommon ( int mat [ ] [ ] ) {
  HashMap < Integer, Integer > cnt = new HashMap < Integer, Integer > ( );
  int i, j;
  for ( i = 0;
  i < M;
  i ++ ) {
    if ( cnt . containsKey ( mat [ i ] [ 0 ] ) ) {
      cnt . put ( mat [ i ] [ 0 ], cnt . get ( mat [ i ] [ 0 ] ) + 1 );
    }
    else {
      cnt . put ( mat [ i ] [ 0 ], 1 );
    }
    for ( j = 1;
    j < N;
    j ++ ) {
      if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) if ( cnt . containsKey ( mat [ i ] [ j ] ) ) {
        cnt . put ( mat [ i ] [ j ], cnt . get ( mat [ i ] [ j ] ) + 1 );
      }
      else {
        cnt . put ( mat [ i ] [ j ], 1 );
      }
    }
  }
  for ( Map . Entry < Integer, Integer > ele : cnt . entrySet ( ) ) {
    if ( ele . getValue ( ) == M ) return ele . getKey ( );
  }
  return - 1;
}


SIEVE_ERATOSTHENES_0N_TIME_COMPLEXITY | static void manipulated_seive ( int N ) {
  isprime . set ( 0, false );
  isprime . set ( 1, false );
  for ( int i = 2;
  i < N;
  i ++ ) {
    if ( isprime . get ( i ) ) {
      prime . add ( i );
      SPF . set ( i, i );
    }
    for ( int j = 0;
    j < prime . size ( ) && i * prime . get ( j ) < N && prime . get ( j ) <= SPF . get ( i );
    j ++ ) {
      isprime . set ( i * prime . get ( j ), false );
      SPF . set ( i * prime . get ( j ), prime . get ( j ) );
    }
  }
}


COUNT_SORTED_ROWS_MATRIX | static int sortedCount ( int mat [ ] [ ], int r, int c ) {
  int result = 0;
  for ( int i = 0;
  i < r;
  i ++ ) {
    int j;
    for ( j = 0;
    j < c - 1;
    j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break;
    if ( j == c - 1 ) result ++;
  }
  for ( int i = 0;
  i < r;
  i ++ ) {
    int j;
    for ( j = c - 1;
    j > 0;
    j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break;
    if ( c > 1 && j == 0 ) result ++;
  }
  return result;
}


NUMBER_WAYS_NODE_MAKE_LOOP_SIZE_K_UNDIRECTED_COMPLETE_CONNECTED_GRAPH_N_NODES | static int numOfways ( int n, int k ) {
  int p = 1;
  if ( k % 2 != 0 ) p = - 1;
  return ( int ) ( Math . pow ( n - 1, k ) + p * ( n - 1 ) ) / n;
}


DICE_THROW_PROBLEM | public static long findWays ( int m, int n, int x ) {
  long [ ] [ ] table = new long [ n + 1 ] [ x + 1 ];
  for ( int j = 1;
  j <= m && j <= x;
  j ++ ) table [ 1 ] [ j ] = 1;
  for ( int i = 2;
  i <= n;
  i ++ ) {
    for ( int j = 1;
    j <= x;
    j ++ ) {
      for ( int k = 1;
      k < j && k <= m;
      k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ];
    }
  }
  return table [ n ] [ x ];
}


MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2 | static int getLevenstein ( StringBuilder input ) {
  StringBuilder revInput = new StringBuilder ( input );
  revInput = revInput . reverse ( );
  int n = input . length ( );
  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= n;
  ++ i ) {
    dp [ 0 ] [ i ] = i;
    dp [ i ] [ 0 ] = i;
  }
  for ( int i = 1;
  i <= n;
  ++ i ) {
    for ( int j = 1;
    j <= n;
    ++ j ) {
      if ( input . charAt ( i - 1 ) == revInput . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ];
      else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] );
    }
  }
  int res = Integer . MAX_VALUE;
  for ( int i = n, j = 0;
  i >= 0;
  i --, j ++ ) {
    res = Math . min ( res, dp [ i ] [ j ] );
    if ( i < n ) res = Math . min ( res, dp [ i + 1 ] [ j ] );
    if ( i > 0 ) res = Math . min ( res, dp [ i - 1 ] [ j ] );
  }
  return res;
}


DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM | static int countParenth ( char symb [ ], char oper [ ], int n ) {
  int F [ ] [ ] = new int [ n ] [ n ];
  int T [ ] [ ] = new int [ n ] [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) {
    F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0;
    T [ i ] [ i ] = ( symb [ i ] == 'T' ) ? 1 : 0;
  }
  for ( int gap = 1;
  gap < n;
  ++ gap ) {
    for ( int i = 0, j = gap;
    j < n;
    ++ i, ++ j ) {
      T [ i ] [ j ] = F [ i ] [ j ] = 0;
      for ( int g = 0;
      g < gap;
      g ++ ) {
        int k = i + g;
        int tik = T [ i ] [ k ] + F [ i ] [ k ];
        int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ];
        if ( oper [ k ] == '&' ) {
          T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ];
          F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] );
        }
        if ( oper [ k ] == '|' ) {
          F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ];
          T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] );
        }
        if ( oper [ k ] == '^' ) {
          T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ];
          F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ];
        }
      }
    }
  }
  return T [ 0 ] [ n - 1 ];
}


PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE_1 | static int Circumference ( int l, int w ) {
  return ( 2 * ( l + w ) );
}


THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1 | static void thirdLargest ( int arr [ ], int arr_size ) {
  if ( arr_size < 3 ) {
    System . out . printf ( " Invalid Input " );
    return;
  }
  int first = arr [ 0 ], second = Integer . MIN_VALUE, third = Integer . MIN_VALUE;
  for ( int i = 1;
  i < arr_size;
  i ++ ) {
    if ( arr [ i ] > first ) {
      third = second;
      second = first;
      first = arr [ i ];
    }
    else if ( arr [ i ] > second ) {
      third = second;
      second = arr [ i ];
    }
    else if ( arr [ i ] > third ) {
      third = arr [ i ];
    }
  }
  System . out . printf ( "The third Largest element is %d\n", third );
}


MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE | static int findMinRooms ( String slots [ ], int n, int m ) {
  int counts [ ] = new int [ m ];
  for ( int i = 0;
  i < m;
  i ++ ) counts [ i ] = 0;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 0;
  j < m;
  j ++ ) if ( slots [ i ] . charAt ( j ) == '1' ) counts [ j ] ++;
  int max = - 1;
  for ( int i = 0;
  i < m;
  i ++ ) if ( max < counts [ i ] ) max = counts [ i ];
  return max;
}


DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM | static boolean isSubsetSum ( int set [ ], int n, int sum ) {
  if ( sum == 0 ) return true;
  if ( n == 0 && sum != 0 ) return false;
  if ( set [ n - 1 ] > sum ) return isSubsetSum ( set, n - 1, sum );
  return isSubsetSum ( set, n - 1, sum ) || isSubsetSum ( set, n - 1, sum - set [ n - 1 ] );
}


COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS | static int chordCnt ( int A ) {
  int n = 2 * A;
  int [ ] dpArray = new int [ n + 1 ];
  dpArray [ 0 ] = 1;
  dpArray [ 2 ] = 1;
  for ( int i = 4;
  i <= n;
  i += 2 ) {
    for ( int j = 0;
    j < i - 1;
    j += 2 ) {
      dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] );
    }
  }
  return dpArray [ n ];
}


BREAK_NUMBER_THREE_PARTS_1 | static long count_of_ways ( long n ) {
  long count = 0;
  count = ( n + 1 ) * ( n + 2 ) / 2;
  return count;
}


PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6 | static void greatest ( String s ) {
  int n = s . length ( );
  int [ ] a = new int [ n ];
  int sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    a [ i ] = s . charAt ( i ) - '0';
    sum += a [ i ];
  }
  if ( a [ n - 1 ] % 2 != 0 ) {
    if ( a [ n - 2 ] % 2 != 0 || ( sum - a [ n - 1 ] ) % 3 != 0 ) {
      System . out . println ( "-1" );
    }
    else {
      System . out . println ( n );
    }
  }
  else {
    int re = sum % 3;
    int del = - 1;
    int flag = 0;
    for ( int i = 0;
    i < n - 1;
    i ++ ) {
      if ( ( a [ i ] ) % 3 == re ) {
        if ( a [ i + 1 ] > a [ i ] ) {
          del = i;
          flag = 1;
          break;
        }
        else {
          del = i;
        }
      }
    }
    if ( flag == 0 ) {
      if ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) del = n - 1;
    }
    if ( del == - 1 ) System . out . println ( - 1 );
    else {
      System . out . println ( del + 1 );
    }
  }
}


MAXIMUM_HEIGHT_OF_TRIANGULAR_ARRANGEMENT_OF_ARRAY_VALUES | static int MaximumHeight ( int [ ] a, int n ) {
  int result = 1;
  for ( int i = 1;
  i <= n;
  ++ i ) {
    int y = ( i * ( i + 1 ) ) / 2;
    if ( y < n ) result = i;
    else break;
  }
  return result;
}


SQUARED_TRIANGULAR_NUMBER_SUM_CUBES | static int findS ( int s ) {
  int sum = 0;
  for ( int n = 1;
  sum < s;
  n ++ ) {
    sum += n * n * n;
    if ( sum == s ) return n;
  }
  return - 1;
}


EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING | static int evaluateBoolExpr ( StringBuffer s ) {
  int n = s . length ( );
  for ( int i = 0;
  i < n;
  i += 2 ) {
    if ( i + 1 < n && i + 2 < n ) {
      if ( s . charAt ( i + 1 ) == 'A' ) {
        if ( s . charAt ( i + 2 ) == '0' || s . charAt ( i ) == 0 ) s . setCharAt ( i + 2, '0' );
        else s . setCharAt ( i + 2, '1' );
      }
      else if ( ( i + 1 ) < n && s . charAt ( i + 1 ) == 'B' ) {
        if ( s . charAt ( i + 2 ) == '1' || s . charAt ( i ) == '1' ) s . setCharAt ( i + 2, '1' );
        else s . setCharAt ( i + 2, '0' );
      }
      else {
        if ( s . charAt ( i + 2 ) == s . charAt ( i ) ) s . setCharAt ( i + 2, '0' );
        else s . setCharAt ( i + 2, '1' );
      }
    }
  }
  return s . charAt ( n - 1 ) - '0';
}


PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT | static int assignValue ( int a, int b, int x ) {
  int arr [ ] = {
    a, b };
    return ( arr [ x ] );
  }
  

MINIMUM_SUM_SQUARES_CHARACTERS_COUNTS_GIVEN_STRING_REMOVING_K_CHARACTERS | static int minStringValue ( String str, int k ) {
  int l = str . length ( );
  if ( k >= l ) return 0;
  int [ ] frequency = new int [ MAX_CHAR ];
  for ( int i = 0;
  i < l;
  i ++ ) frequency [ str . charAt ( i ) - 'a' ] ++;
  Comparator < Integer > c = new IntCompare ( );
  PriorityQueue < Integer > q = new PriorityQueue < > ( c );
  for ( int i = 0;
  i < MAX_CHAR;
  i ++ ) {
    if ( frequency [ i ] != 0 ) q . add ( frequency [ i ] );
  }
  while ( k != 0 ) {
    int temp = q . peek ( );
    q . poll ( );
    temp = temp - 1;
    q . add ( temp );
    k --;
  }
  int result = 0;
  while ( ! q . isEmpty ( ) ) {
    int temp = q . peek ( );
    result += temp * temp;
    q . poll ( );
  }
  return result;
}


MAJORITY_ELEMENT_1 | private static void findMajority ( int [ ] arr ) {
  HashMap < Integer, Integer > map = new HashMap < Integer, Integer > ( );
  for ( int i = 0;
  i < arr . length;
  i ++ ) {
    if ( map . containsKey ( arr [ i ] ) ) {
      int count = map . get ( arr [ i ] ) + 1;
      if ( count > arr . length / 2 ) {
        System . out . println ( "Majority found :- " + arr [ i ] );
        return;
      }
      else map . put ( arr [ i ], count );
    }
    else map . put ( arr [ i ], 1 );
  }
  System . out . println ( " No Majority element" );
}


LARGEST_SUBSET_GRAPH_VERTICES_EDGES_2_COLORS | static int subsetGraph ( int C [ ] [ ] ) {
  HashSet < Integer > vertices = new HashSet < > ( );
  for ( int i = 0;
  i < N;
  ++ i ) {
    vertices . add ( i );
  }
  while ( ! vertices . isEmpty ( ) ) {
    if ( vertices . size ( ) == 1 ) {
      return 1;
    }
    boolean someone_removed = false;
    for ( int x : vertices ) {
      HashSet < Integer > values = new HashSet < > ( );
      for ( int y : vertices ) {
        if ( y != x ) {
          values . add ( C [ x ] [ y ] );
        }
      }
      if ( values . size ( ) == 1 ) {
        vertices . remove ( x );
        someone_removed = true;
        break;
      }
    }
    if ( ! someone_removed ) {
      break;
    }
  }
  return ( vertices . size ( ) );
}


FLOOR_IN_A_SORTED_ARRAY_1 | static int floorSearch ( int arr [ ], int low, int high, int x ) {
  if ( low > high ) return - 1;
  if ( x >= arr [ high ] ) return high;
  int mid = ( low + high ) / 2;
  if ( arr [ mid ] == x ) return mid;
  if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1;
  if ( x < arr [ mid ] ) return floorSearch ( arr, low, mid - 1, x );
  return floorSearch ( arr, mid + 1, high, x );
}


LONGEST_PREFIX_ALSO_SUFFIX_1 | static int longestPrefixSuffix ( String s ) {
  int n = s . length ( );
  int lps [ ] = new int [ n ];
  lps [ 0 ] = 0;
  int len = 0;
  int i = 1;
  while ( i < n ) {
    if ( s . charAt ( i ) == s . charAt ( len ) ) {
      len ++;
      lps [ i ] = len;
      i ++;
    }
    else {
      if ( len != 0 ) {
        len = lps [ len - 1 ];
      }
      else {
        lps [ i ] = 0;
        i ++;
      }
    }
  }
  int res = lps [ n - 1 ];
  return ( res > n / 2 ) ? n / 2 : res;
}


COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS | public static int countP ( int n, int k ) {
  if ( n == 0 || k == 0 || k > n ) return 0;
  if ( k == 1 || k == n ) return 1;
  return ( k * countP ( n - 1, k ) + countP ( n - 1, k - 1 ) );
}


C_PROGRAM_FACTORIAL_NUMBER_2 | int factorial ( int n ) {
  return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 );
}


FIND_REPEATED_CHARACTER_PRESENT_FIRST_STRING_1 | public static int findRepeatFirst ( String s ) {
  int p = - 1, i, k;
  int MAX_CHAR = 256;
  int hash [ ] = new int [ MAX_CHAR ];
  int pos [ ] = new int [ MAX_CHAR ];
  for ( i = 0;
  i < s . length ( );
  i ++ ) {
    k = ( int ) s . charAt ( i );
    if ( hash [ k ] == 0 ) {
      hash [ k ] ++;
      pos [ k ] = i;
    }
    else if ( hash [ k ] == 1 ) hash [ k ] ++;
  }
  for ( i = 0;
  i < MAX_CHAR;
  i ++ ) {
    if ( hash [ i ] == 2 ) {
      if ( p == - 1 ) p = pos [ i ];
      else if ( p > pos [ i ] ) p = pos [ i ];
    }
  }
  return p;
}


NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS | static int numberOfPermWithKInversion ( int N, int K ) {
  if ( N == 0 ) return 0;
  if ( K == 0 ) return 1;
  if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ];
  int sum = 0;
  for ( int i = 0;
  i <= K;
  i ++ ) {
    if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1, K - i );
  }
  memo [ N ] [ K ] = sum;
  return sum;
}


K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY | static int kthLargestSum ( int arr [ ], int n, int k ) {
  int sum [ ] = new int [ n + 1 ];
  sum [ 0 ] = 0;
  sum [ 1 ] = arr [ 0 ];
  for ( int i = 2;
  i <= n;
  i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ];
  PriorityQueue < Integer > Q = new PriorityQueue < Integer > ( );
  for ( int i = 1;
  i <= n;
  i ++ ) {
    for ( int j = i;
    j <= n;
    j ++ ) {
      int x = sum [ j ] - sum [ i - 1 ];
      if ( Q . size ( ) < k ) Q . add ( x );
      else {
        if ( Q . peek ( ) < x ) {
          Q . poll ( );
          Q . add ( x );
        }
      }
    }
  }
  return Q . poll ( );
}


FIND_THE_LARGEST_THREE_ELEMENTS_IN_AN_ARRAY | void find3largest ( int [ ] arr ) {
  Arrays . sort ( arr );
  int n = arr . length;
  int check = 0, count = 1;
  for ( int i = 1;
  i <= n;
  i ++ ) {
    if ( count < 4 ) {
      if ( check != arr [ n - i ] ) {
        System . out . print ( arr [ n - i ] + " " );
        check = arr [ n - i ];
        count ++;
      }
    }
    else break;
  }
}


MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE | static int maxLower ( String str ) {
  int n = str . length ( );
  int i = 0;
  for (;
  i < n;
  i ++ ) {
    if ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) {
      i ++;
      break;
    }
  }
  int maxCount = 0;
  int count [ ] = new int [ MAX_CHAR ];
  for (;
  i < n;
  i ++ ) {
    if ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) {
      int currCount = 0;
      for ( int j = 0;
      j < MAX_CHAR;
      j ++ ) {
        if ( count [ j ] > 0 ) {
          currCount ++;
        }
      }
      maxCount = Math . max ( maxCount, currCount );
      Arrays . fill ( count, 0 );
    }
    if ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) {
      count [ str . charAt ( i ) - 'a' ] ++;
    }
  }
  return maxCount;
}


CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH_ONE_VARIATION_ALLOWED | static boolean isValidString ( String str ) {
  int freq [ ] = new int [ CHARS ];
  for ( int i = 0;
  i < str . length ( );
  i ++ ) {
    freq [ str . charAt ( i ) - 'a' ] ++;
  }
  int i, freq1 = 0, count_freq1 = 0;
  for ( i = 0;
  i < CHARS;
  i ++ ) {
    if ( freq [ i ] != 0 ) {
      freq1 = freq [ i ];
      count_freq1 = 1;
      break;
    }
  }
  int j, freq2 = 0, count_freq2 = 0;
  for ( j = i + 1;
  j < CHARS;
  j ++ ) {
    if ( freq [ j ] != 0 ) {
      if ( freq [ j ] == freq1 ) {
        count_freq1 ++;
      }
      else {
        count_freq2 = 1;
        freq2 = freq [ j ];
        break;
      }
    }
  }
  for ( int k = j + 1;
  k < CHARS;
  k ++ ) {
    if ( freq [ k ] != 0 ) {
      if ( freq [ k ] == freq1 ) {
        count_freq1 ++;
      }
      if ( freq [ k ] == freq2 ) {
        count_freq2 ++;
      }
      else {
        return false;
      }
    }
    if ( count_freq1 > 1 && count_freq2 > 1 ) {
      return false;
    }
  }
  return true;
}


MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY | static double largestSumOfAverages ( int [ ] A, int K ) {
  int n = A . length;
  double [ ] pre_sum = new double [ n + 1 ];
  pre_sum [ 0 ] = 0;
  for ( int i = 0;
  i < n;
  i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ];
  double [ ] dp = new double [ n ];
  double sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i );
  for ( int k = 0;
  k < K - 1;
  k ++ ) for ( int i = 0;
  i < n;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) dp [ i ] = Math . max ( dp [ i ], ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] );
  return dp [ 0 ];
}


FIND_SUBARRAY_WITH_GIVEN_SUM_IN_ARRAY_OF_INTEGERS | public static void subArraySum ( int [ ] arr, int n, int sum ) {
  int cur_sum = 0;
  int start = 0;
  int end = - 1;
  HashMap < Integer, Integer > hashMap = new HashMap < > ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    cur_sum = cur_sum + arr [ i ];
    if ( cur_sum - sum == 0 ) {
      start = 0;
      end = i;
      break;
    }
    if ( hashMap . containsKey ( cur_sum - sum ) ) {
      start = hashMap . get ( cur_sum - sum ) + 1;
      end = i;
      break;
    }
    hashMap . put ( cur_sum, i );
  }
  if ( end == - 1 ) {
    System . out . println ( "No subarray with given sum exists" );
  }
  else {
    System . out . println ( "Sum found between indexes " + start + " to " + end );
  }
}


REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX | static int minRemovalsDP ( int arr [ ], int n ) {
  int longest_start = - 1, longest_end = 0;
  for ( int start = 0;
  start < n;
  start ++ ) {
    int min = Integer . MAX_VALUE, max = Integer . MIN_VALUE;
    for ( int end = start;
    end < n;
    end ++ ) {
      int val = arr [ end ];
      if ( val < min ) {
        min = val;
      }
      if ( val > max ) {
        max = val;
      }
      if ( 2 * min <= max ) {
        break;
      }
      if ( end - start > longest_end - longest_start || longest_start == - 1 ) {
        longest_start = start;
        longest_end = end;
      }
    }
  }
  if ( longest_start == - 1 ) {
    return n;
  }
  return ( n - ( longest_end - longest_start + 1 ) );
}


FIND_THE_MISSING_NUMBER_1 | static int getMissingNo ( int a [ ], int n ) {
  int total = 1;
  for ( int i = 2;
  i <= ( n + 1 );
  i ++ ) {
    total += i;
    total -= a [ i - 2 ];
  }
  return total;
}


SIEVE_SUNDARAM_PRINT_PRIMES_SMALLER_N | static int SieveOfSundaram ( int n ) {
  int nNew = ( n - 2 ) / 2;
  boolean marked [ ] = new boolean [ nNew + 1 ];
  Arrays . fill ( marked, false );
  for ( int i = 1;
  i <= nNew;
  i ++ ) for ( int j = i;
  ( i + j + 2 * i * j ) <= nNew;
  j ++ ) marked [ i + j + 2 * i * j ] = true;
  if ( n > 2 ) System . out . print ( 2 + " " );
  for ( int i = 1;
  i <= nNew;
  i ++ ) if ( marked [ i ] == false ) System . out . print ( 2 * i + 1 + " " );
  return - 1;
}


MAXIMUM_PRODUCT_SUBSET_ARRAY | static int maxProductSubset ( int a [ ], int n ) {
  if ( n == 1 ) {
    return a [ 0 ];
  }
  int max_neg = Integer . MIN_VALUE;
  int count_neg = 0, count_zero = 0;
  int prod = 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( a [ i ] == 0 ) {
      count_zero ++;
      continue;
    }
    if ( a [ i ] < 0 ) {
      count_neg ++;
      max_neg = Math . max ( max_neg, a [ i ] );
    }
    prod = prod * a [ i ];
  }
  if ( count_zero == n ) {
    return 0;
  }
  if ( count_neg % 2 == 1 ) {
    if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) {
      return 0;
    }
    prod = prod / max_neg;
  }
  return prod;
}


FIND_THE_NEAREST_SMALLER_NUMBERS_ON_LEFT_SIDE_IN_AN_ARRAY | static void printPrevSmaller ( int [ ] arr, int n ) {
  System . out . print ( "_, " );
  for ( int i = 1;
  i < n;
  i ++ ) {
    int j;
    for ( j = i - 1;
    j >= 0;
    j -- ) {
      if ( arr [ j ] < arr [ i ] ) {
        System . out . print ( arr [ j ] + ", " );
        break;
      }
    }
    if ( j == - 1 ) System . out . print ( "_, " );
  }
}


FIND_NUMBER_PAIRS_ARRAY_XOR_0_1 | static int calculate ( int a [ ], int n ) {
  int maximum = Arrays . stream ( a ) . max ( ) . getAsInt ( );
  int frequency [ ] = new int [ maximum + 1 ];
  for ( int i = 0;
  i < n;
  i ++ ) {
    frequency [ a [ i ] ] += 1;
  }
  int answer = 0;
  for ( int i = 0;
  i < ( maximum ) + 1;
  i ++ ) {
    answer = answer + frequency [ i ] * ( frequency [ i ] - 1 );
  }
  return answer / 2;
}


SUM_BINOMIAL_COEFFICIENTS_1 | static int binomialCoeffSum ( int n ) {
  return ( 1 << n );
}


MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1 | static int maxSumPairWithDifferenceLessThanK ( int arr [ ], int N, int k ) {
  int maxSum = 0;
  Arrays . sort ( arr );
  for ( int i = N - 1;
  i > 0;
  -- i ) {
    if ( arr [ i ] - arr [ i - 1 ] < k ) {
      maxSum += arr [ i ];
      maxSum += arr [ i - 1 ];
      -- i;
    }
  }
  return maxSum;
}


KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT | static void printkthnode ( Vector < pair > adj [ ], int wt [ ], int n, int k ) {
  for ( int i = 0;
  i < n;
  i ++ ) Collections . sort ( adj [ i ], new Comparator < pair > ( ) {
    public int compare ( pair p1, pair p2 ) {
      return p1 . first - p2 . first;
    }
  }
  );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( adj [ i ] . size ( ) >= k ) System . out . print ( adj [ i ] . get ( adj [ i ] . size ( ) - k ) . second + " " );
    else System . out . print ( "-1" );
  }
}


SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM | static int KnapSack ( int val [ ], int wt [ ], int n, int W ) {
  int mat [ ] [ ] = new int [ 2 ] [ W + 1 ];
  int i = 0;
  while ( i < n ) {
    int j = 0;
    if ( i % 2 != 0 ) {
      while ( ++ j <= W ) {
        if ( wt [ i ] <= j ) {
          mat [ 1 ] [ j ] = Math . max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ], mat [ 0 ] [ j ] );
        }
        else {
          mat [ 1 ] [ j ] = mat [ 0 ] [ j ];
        }
      }
    }
    else {
      while ( ++ j <= W ) {
        if ( wt [ i ] <= j ) {
          mat [ 0 ] [ j ] = Math . max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ], mat [ 1 ] [ j ] );
        }
        else {
          mat [ 0 ] [ j ] = mat [ 1 ] [ j ];
        }
      }
    }
    i ++;
  }
  return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ];
}


BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1 | static void bin ( Integer n ) {
  if ( n > 1 ) bin ( n > > 1 );
  System . out . printf ( "%d", n & 1 );
}


PRIME_FACTORS_BIG_NUMBER | static void factorize ( long n ) {
  int count = 0;
  while ( ! ( n % 2 > 0 ) ) {
    n >>= 1;
    count ++;
  }
  if ( count > 0 ) {
    System . out . println ( "2" + " " + count );
  }
  for ( long i = 3;
  i <= ( long ) Math . sqrt ( n );
  i += 2 ) {
    count = 0;
    while ( n % i == 0 ) {
      count ++;
      n = n / i;
    }
    if ( count > 0 ) {
      System . out . println ( i + " " + count );
    }
  }
  if ( n > 2 ) {
    System . out . println ( n + " " + "1" );
  }
}


COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1 | static int countSubstringWithEqualEnds ( String s ) {
  int result = 0;
  int n = s . length ( );
  int [ ] count = new int [ MAX_CHAR ];
  for ( int i = 0;
  i < n;
  i ++ ) count [ s . charAt ( i ) - 'a' ] ++;
  for ( int i = 0;
  i < MAX_CHAR;
  i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 );
  return result;
}


LONGEST_PALINDROME_SUBSTRING_SET_1 | static void printSubStr ( String str, int low, int high ) {
  System . out . println ( str . substring ( low, high + 1 ) );
}


FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTERS_OF_ANOTHER_STRING | static String findSubString ( String str, String pat ) {
  int len1 = str . length ( );
  int len2 = pat . length ( );
  if ( len1 < len2 ) {
    System . out . println ( "No such window exists" );
    return "";
  }
  int hash_pat [ ] = new int [ no_of_chars ];
  int hash_str [ ] = new int [ no_of_chars ];
  for ( int i = 0;
  i < len2;
  i ++ ) hash_pat [ pat . charAt ( i ) ] ++;
  int start = 0, start_index = - 1, min_len = Integer . MAX_VALUE;
  int count = 0;
  for ( int j = 0;
  j < len1;
  j ++ ) {
    hash_str [ str . charAt ( j ) ] ++;
    if ( hash_pat [ str . charAt ( j ) ] != 0 && hash_str [ str . charAt ( j ) ] <= hash_pat [ str . charAt ( j ) ] ) count ++;
    if ( count == len2 ) {
      while ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] || hash_pat [ str . charAt ( start ) ] == 0 ) {
        if ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] ) hash_str [ str . charAt ( start ) ] --;
        start ++;
      }
      int len_window = j - start + 1;
      if ( min_len > len_window ) {
        min_len = len_window;
        start_index = start;
      }
    }
  }
  if ( start_index == - 1 ) {
    System . out . println ( "No such window exists" );
    return "";
  }
  return str . substring ( start_index, start_index + min_len );
}


MARKOV_MATRIX | static boolean checkMarkov ( double m [ ] [ ] ) {
  for ( int i = 0;
  i < m . length;
  i ++ ) {
    double sum = 0;
    for ( int j = 0;
    j < m [ i ] . length;
    j ++ ) sum = sum + m [ i ] [ j ];
    if ( sum != 1 ) return false;
  }
  return true;
}


LEAF_NODES_PREORDER_BINARY_SEARCH_TREE | static void leafNode ( int preorder [ ], int n ) {
  Stack < Integer > s = new Stack < Integer > ( );
  for ( int i = 0, j = 1;
  j < n;
  i ++, j ++ ) {
    boolean found = false;
    if ( preorder [ i ] > preorder [ j ] ) s . push ( preorder [ i ] );
    else {
      while ( ! s . isEmpty ( ) ) {
        if ( preorder [ j ] > s . peek ( ) ) {
          s . pop ( );
          found = true;
        }
        else break;
      }
    }
    if ( found ) System . out . print ( preorder [ i ] + " " );
  }
  System . out . println ( preorder [ n - 1 ] );
}


SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N | static int nextPowerOf2 ( int n ) {
  int count = 0;
  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n;
  while ( n != 0 ) {
    n >>= 1;
    count += 1;
  }
  return 1 << count;
}


PROGRAM_CHECK_WATER_TANK_OVERFLOWS_N_SOLID_BALLS_DIPPED_WATER_TANK | static void overflow ( int H, int r, int h, int N, int R ) {
  double tank_cap = 3.14 * r * r * H;
  double water_vol = 3.14 * r * r * h;
  double balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R;
  double vol = water_vol + balls_vol;
  if ( vol > tank_cap ) {
    System . out . println ( "Overflow" );
  }
  else {
    System . out . println ( "Not in overflow state" );
  }
}


SMALLEST_DERANGEMENT_SEQUENCE | static void generate_derangement ( int N ) {
  int S [ ] = new int [ N + 1 ];
  for ( int i = 1;
  i <= N;
  i ++ ) S [ i ] = i;
  int D [ ] = new int [ N + 1 ];
  for ( int i = 1;
  i <= N;
  i += 2 ) {
    if ( i == N ) {
      D [ N ] = S [ N - 1 ];
      D [ N - 1 ] = S [ N ];
    }
    else {
      D [ i ] = i + 1;
      D [ i + 1 ] = i;
    }
  }
  for ( int i = 1;
  i <= N;
  i ++ ) System . out . print ( D [ i ] + " " );
  System . out . println ( );
}


MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE | static int lis ( int [ ] arr, int n ) {
  int [ ] mpis = new int [ n ];
  int max = Integer . MIN_VALUE;
  for ( int i = 0;
  i < n;
  i ++ ) mpis [ i ] = arr [ i ];
  for ( int i = 1;
  i < n;
  i ++ ) for ( int j = 0;
  j < i;
  j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ];
  for ( int k = 0;
  k < mpis . length;
  k ++ ) {
    if ( mpis [ k ] > max ) {
      max = mpis [ k ];
    }
  }
  return max;
}


CHANGE_BITS_CAN_MADE_ONE_FLIP | static boolean canMakeAllSame ( String str ) {
  int zeros = 0, ones = 0;
  for ( int i = 0;
  i < str . length ( );
  i ++ ) {
    char ch = str . charAt ( i );
    if ( ch == '0' ) ++ zeros;
    else ++ ones;
  }
  return ( zeros == 1 || ones == 1 );
}


FIND_NUMBER_PAIRS_ARRAY_XOR_0 | static int calculate ( int a [ ], int n ) {
  Arrays . sort ( a );
  int count = 1;
  int answer = 0;
  for ( int i = 1;
  i < n;
  i ++ ) {
    if ( a [ i ] == a [ i - 1 ] ) {
      count += 1;
    }
    else {
      answer = answer + ( count * ( count - 1 ) ) / 2;
      count = 1;
    }
  }
  answer = answer + ( count * ( count - 1 ) ) / 2;
  return answer;
}


FIND_ROOT_TREE_CHILDREN_ID_SUM_EVERY_NODE_GIVEN | static int findRoot ( pair arr [ ], int n ) {
  int root = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    root += ( arr [ i ] . first - arr [ i ] . second );
  }
  return root;
}


BINARY_SEARCH | int binarySearch ( int arr [ ], int l, int r, int x ) {
  if ( r >= l ) {
    int mid = l + ( r - l ) / 2;
    if ( arr [ mid ] == x ) return mid;
    if ( arr [ mid ] > x ) return binarySearch ( arr, l, mid - 1, x );
    return binarySearch ( arr, mid + 1, r, x );
  }
  return - 1;
}


FIBONACCI_MODULO_P | static int findMinZero ( int p ) {
  int first = 1, second = 1, number = 2, next = 1;
  while ( next > 0 ) {
    next = ( first + second ) % p;
    first = second;
    second = next;
    number ++;
  }
  return number;
}


K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY | public static void kLargest ( Integer [ ] arr, int k ) {
  Arrays . sort ( arr, Collections . reverseOrder ( ) );
  for ( int i = 0;
  i < k;
  i ++ ) System . out . print ( arr [ i ] + " " );
}


C_PROGRAM_FIND_AREA_CIRCLE | static double findArea ( int r ) {
  return PI * Math . pow ( r, 2 );
}


SUM_TWO_LARGE_NUMBERS | static String findSum ( String str1, String str2 ) {
  if ( str1 . length ( ) > str2 . length ( ) ) {
    String t = str1;
    str1 = str2;
    str2 = t;
  }
  String str = "";
  int n1 = str1 . length ( ), n2 = str2 . length ( );
  str1 = new StringBuilder ( str1 ) . reverse ( ) . toString ( );
  str2 = new StringBuilder ( str2 ) . reverse ( ) . toString ( );
  int carry = 0;
  for ( int i = 0;
  i < n1;
  i ++ ) {
    int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i ) - '0' ) + carry );
    str += ( char ) ( sum % 10 + '0' );
    carry = sum / 10;
  }
  for ( int i = n1;
  i < n2;
  i ++ ) {
    int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry );
    str += ( char ) ( sum % 10 + '0' );
    carry = sum / 10;
  }
  if ( carry > 0 ) str += ( char ) ( carry + '0' );
  str = new StringBuilder ( str ) . reverse ( ) . toString ( );
  return str;
}


ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE | static int solveQuery ( int start, int end, int arr [ ] ) {
  Map < Integer, Integer > mp = new HashMap < > ( );
  for ( int i = start;
  i <= end;
  i ++ ) mp . put ( arr [ i ], mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 );
  int count = 0;
  for ( Map . Entry < Integer, Integer > entry : mp . entrySet ( ) ) if ( entry . getKey ( ) == entry . getValue ( ) ) count ++;
  return count;
}


COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS | static int countSubstringWithEqualEnds ( String s ) {
  int result = 0;
  int n = s . length ( );
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = i;
  j < n;
  j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++;
  return result;
}


DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM | static int maxTasks ( int high [ ], int low [ ], int n ) {
  if ( n <= 0 ) return 0;
  return Math . max ( high [ n - 1 ] + maxTasks ( high, low, ( n - 2 ) ), low [ n - 1 ] + maxTasks ( high, low, ( n - 1 ) ) );
}


MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX | static int maxRowDiff ( int mat [ ] [ ], int m, int n ) {
  int rowSum [ ] = new int [ m ];
  for ( int i = 0;
  i < m;
  i ++ ) {
    int sum = 0;
    for ( int j = 0;
    j < n;
    j ++ ) sum += mat [ i ] [ j ];
    rowSum [ i ] = sum;
  }
  int max_diff = rowSum [ 1 ] - rowSum [ 0 ];
  int min_element = rowSum [ 0 ];
  for ( int i = 1;
  i < m;
  i ++ ) {
    if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element;
    if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ];
  }
  return max_diff;
}


PAPER_CUT_MINIMUM_NUMBER_SQUARES | static int minimumSquare ( int a, int b ) {
  int result = 0, rem = 0;
  if ( a < b ) swap ( a, b );
  while ( b > 0 ) {
    result += a / b;
    rem = a % b;
    a = b;
    b = rem;
  }
  return result;
}


SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_ELEMENTS_IS_1 | static int search ( int arr [ ], int n, int x ) {
  int i = 0;
  while ( i < n ) {
    if ( arr [ i ] == x ) return i;
    i = i + Math . abs ( arr [ i ] - x );
  }
  System . out . println ( "number is not" + " present!" );
  return - 1;
}


PANGRAM_CHECKING | public static boolean checkPangram ( String str ) {
  boolean [ ] mark = new boolean [ 26 ];
  int index = 0;
  for ( int i = 0;
  i < str . length ( );
  i ++ ) {
    if ( 'A' <= str . charAt ( i ) && str . charAt ( i ) <= 'Z' ) index = str . charAt ( i ) - 'A';
    else if ( 'a' <= str . charAt ( i ) && str . charAt ( i ) <= 'z' ) index = str . charAt ( i ) - 'a';
    mark [ index ] = true;
  }
  for ( int i = 0;
  i <= 25;
  i ++ ) if ( mark [ i ] == false ) return ( false );
  return ( true );
}


PRINT_SHORTEST_COMMON_SUPERSEQUENCE | static String printShortestSuperSeq ( String X, String Y ) {
  int m = X . length ( );
  int n = Y . length ( );
  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= m;
  i ++ ) {
    for ( int j = 0;
    j <= n;
    j ++ ) {
      if ( i == 0 ) {
        dp [ i ] [ j ] = j;
      }
      else if ( j == 0 ) {
        dp [ i ] [ j ] = i;
      }
      else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) {
        dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ];
      }
      else {
        dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] );
      }
    }
  }
  int index = dp [ m ] [ n ];
  String str = "";
  int i = m, j = n;
  while ( i > 0 && j > 0 ) {
    if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) {
      str += ( X . charAt ( i - 1 ) );
      i --;
      j --;
      index --;
    }
    else if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) {
      str += ( Y . charAt ( j - 1 ) );
      j --;
      index --;
    }
    else {
      str += ( X . charAt ( i - 1 ) );
      i --;
      index --;
    }
  }
  while ( i > 0 ) {
    str += ( X . charAt ( i - 1 ) );
    i --;
    index --;
  }
  while ( j > 0 ) {
    str += ( Y . charAt ( j - 1 ) );
    j --;
    index --;
  }
  str = reverse ( str );
  return str;
}


FIND_PAIR_MAXIMUM_GCD_ARRAY_1 | public static int findMaxGCD ( int arr [ ], int n ) {
  int high = 0;
  for ( int i = 0;
  i < n;
  i ++ ) high = Math . max ( high, arr [ i ] );
  int count [ ] = new int [ high + 1 ];
  for ( int i = 0;
  i < n;
  i ++ ) count [ arr [ i ] ] ++;
  int counter = 0;
  for ( int i = high;
  i >= 1;
  i -- ) {
    int j = i;
    while ( j <= high ) {
      if ( count [ j ] > 0 ) counter += count [ j ];
      j += i;
      if ( counter == 2 ) return i;
    }
    counter = 0;
  }
  return 1;
}


PROGRAM_CALCULATE_AREA_OCTAGON | static double areaOctagon ( double side ) {
  return ( float ) ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side );
}


FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_1 | static int findExtra ( int arr1 [ ], int arr2 [ ], int n ) {
  int index = n;
  int left = 0, right = n - 1;
  while ( left <= right ) {
    int mid = ( left + right ) / 2;
    if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1;
    else {
      index = mid;
      right = mid - 1;
    }
  }
  return index;
}


NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL_TO_VALUE_1 | public static int nobleInteger ( int arr [ ] ) {
  Arrays . sort ( arr );
  int n = arr . length;
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    if ( arr [ i ] == arr [ i + 1 ] ) continue;
    if ( arr [ i ] == n - i - 1 ) return arr [ i ];
  }
  if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ];
  return - 1;
}


MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_ISOSCELES_TRIANGLE | static int maxSquare ( int b, int m ) {
  return ( b / m - 1 ) * ( b / m ) / 2;
}


HOW_TO_COMPUTE_MOD_OF_A_BIG_NUMBER | static int mod ( String num, int a ) {
  int res = 0;
  for ( int i = 0;
  i < num . length ( );
  i ++ ) res = ( res * 10 + ( int ) num . charAt ( i ) - '0' ) % a;
  return res;
}


LONGEST_COMMON_SUBSTRING_1 | static int lcs ( int i, int j, int count ) {
  if ( i == 0 || j == 0 ) {
    return count;
  }
  if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) {
    count = lcs ( i - 1, j - 1, count + 1 );
  }
  count = Math . max ( count, Math . max ( lcs ( i, j - 1, 0 ), lcs ( i - 1, j, 0 ) ) );
  return count;
}


FIND_PATTERNS_101_GIVEN_STRING | static int patternCount ( String str ) {
  char last = str . charAt ( 0 );
  int i = 1, counter = 0;
  while ( i < str . length ( ) ) {
    if ( str . charAt ( i ) == '0' && last == '1' ) {
      while ( str . charAt ( i ) == '0' ) i ++;
      if ( str . charAt ( i ) == '1' ) counter ++;
    }
    last = str . charAt ( i );
    i ++;
  }
  return counter;
}


LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE | public static int longOddEvenIncSeq ( int arr [ ], int n ) {
  int [ ] lioes = new int [ n ];
  int maxLen = 0;
  for ( int i = 0;
  i < n;
  i ++ ) lioes [ i ] = 1;
  for ( int i = 1;
  i < n;
  i ++ ) for ( int j = 0;
  j < i;
  j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1;
  for ( int i = 0;
  i < n;
  i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ];
  return maxLen;
}


COUNT_NUMBER_OF_SUBSTRINGS_WITH_EXACTLY_K_DISTINCT_CHARACTERS | int countkDist ( String str, int k ) {
  int res = 0;
  int n = str . length ( );
  int cnt [ ] = new int [ 26 ];
  for ( int i = 0;
  i < n;
  i ++ ) {
    int dist_count = 0;
    Arrays . fill ( cnt, 0 );
    for ( int j = i;
    j < n;
    j ++ ) {
      if ( cnt [ str . charAt ( j ) - 'a' ] == 0 ) dist_count ++;
      cnt [ str . charAt ( j ) - 'a' ] ++;
      if ( dist_count == k ) res ++;
    }
  }
  return res;
}


C_PROGRAM_FACTORIAL_NUMBER_1 | static int factorial ( int n ) {
  int res = 1, i;
  for ( i = 2;
  i <= n;
  i ++ ) res *= i;
  return res;
}


K_MAXIMUM_SUMS_NON_OVERLAPPING_CONTIGUOUS_SUB_ARRAYS | static void kmax ( int arr [ ], int k, int n ) {
  for ( int c = 0;
  c < k;
  c ++ ) {
    int max_so_far = Integer . MIN_VALUE;
    int max_here = 0;
    int start = 0, end = 0, s = 0;
    for ( int i = 0;
    i < n;
    i ++ ) {
      max_here += arr [ i ];
      if ( max_so_far < max_here ) {
        max_so_far = max_here;
        start = s;
        end = i;
      }
      if ( max_here < 0 ) {
        max_here = 0;
        s = i + 1;
      }
    }
    System . out . println ( "Maximum non-overlapping sub-arraysum" + ( c + 1 ) + ": " + max_so_far + ", starting index: " + start + ", ending index: " + end + "." );
    for ( int l = start;
    l <= end;
    l ++ ) arr [ l ] = Integer . MIN_VALUE;
  }
  System . out . println ( );
}


DISTANCE_NEAREST_CELL_1_BINARY_MATRIX | static void printDistance ( int mat [ ] [ ] ) {
  int ans [ ] [ ] = new int [ N ] [ M ];
  for ( int i = 0;
  i < N;
  i ++ ) for ( int j = 0;
  j < M;
  j ++ ) ans [ i ] [ j ] = Integer . MAX_VALUE;
  for ( int i = 0;
  i < N;
  i ++ ) for ( int j = 0;
  j < M;
  j ++ ) {
    for ( int k = 0;
    k < N;
    k ++ ) for ( int l = 0;
    l < M;
    l ++ ) {
      if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = Math . min ( ans [ i ] [ j ], Math . abs ( i - k ) + Math . abs ( j - l ) );
    }
  }
  for ( int i = 0;
  i < N;
  i ++ ) {
    for ( int j = 0;
    j < M;
    j ++ ) System . out . print ( ans [ i ] [ j ] + " " );
    System . out . println ( );
  }
}


MINIMUM_NUMBER_OF_BRACKET_REVERSALS_NEEDED_TO_MAKE_AN_EXPRESSION_BALANCED | static int countMinReversals ( String expr ) {
  int len = expr . length ( );
  if ( len % 2 != 0 ) return - 1;
  Stack < Character > s = new Stack < > ( );
  for ( int i = 0;
  i < len;
  i ++ ) {
    char c = expr . charAt ( i );
    if ( c == '}' && ! s . empty ( ) ) {
      if ( s . peek ( ) == '{' ) s . pop ( );
      else s . push ( c );
    }
    else s . push ( c );
  }
  int red_len = s . size ( );
  int n = 0;
  while ( ! s . empty ( ) && s . peek ( ) == '{' ) {
    s . pop ( );
    n ++;
  }
  return ( red_len / 2 + n % 2 );
}
public static void main ( String [ ] args ) {
  String expr = " } }

FIRST_NEGATIVE_INTEGER_EVERY_WINDOW_SIZE_K_1 | static void printFirstNegativeInteger ( int arr [ ], int n, int k ) {
  LinkedList < Integer > Di = new LinkedList < > ( );
  int i;
  for ( i = 0;
  i < k;
  i ++ ) if ( arr [ i ] < 0 ) Di . add ( i );
  for (;
  i < n;
  i ++ ) {
    if ( ! Di . isEmpty ( ) ) System . out . print ( arr [ Di . peek ( ) ] + " " );
    else System . out . print ( "0" + " " );
    while ( ( ! Di . isEmpty ( ) ) && Di . peek ( ) < ( i - k + 1 ) ) Di . remove ( );
    if ( arr [ i ] < 0 ) Di . add ( i );
  }
  if ( ! Di . isEmpty ( ) ) System . out . print ( arr [ Di . peek ( ) ] + " " );
  else System . out . print ( "0" + " " );
}


MAGIC_SQUARE | static void generateSquare ( int n ) {
  int [ ] [ ] magicSquare = new int [ n ] [ n ];
  int i = n / 2;
  int j = n - 1;
  for ( int num = 1;
  num <= n * n;
  ) {
    if ( i == - 1 && j == n ) {
      j = n - 2;
      i = 0;
    }
    else {
      if ( j == n ) j = 0;
      if ( i < 0 ) i = n - 1;
    }
    if ( magicSquare [ i ] [ j ] != 0 ) {
      j -= 2;
      i ++;
      continue;
    }
    else magicSquare [ i ] [ j ] = num ++;
    j ++;
    i --;
  }
  System . out . println ( "The Magic Square for " + n + ":" );
  System . out . println ( "Sum of each row or column " + n * ( n * n + 1 ) / 2 + ":" );
  for ( i = 0;
  i < n;
  i ++ ) {
    for ( j = 0;
    j < n;
    j ++ ) System . out . print ( magicSquare [ i ] [ j ] + " " );
    System . out . println ( );
  }
}


PROGRAM_BINOMIAL_COEFFICIENTS_TABLE | static void printbinomial ( int max ) {
  for ( int m = 0;
  m <= max;
  m ++ ) {
    System . out . print ( m + " " );
    int binom = 1;
    for ( int x = 0;
    x <= m;
    x ++ ) {
      if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x;
      System . out . print ( binom + " " );
    }
    System . out . println ( );
  }
}


CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION | static int findMinX ( int num [ ], int rem [ ], int k ) {
  int x = 1;
  while ( true ) {
    int j;
    for ( j = 0;
    j < k;
    j ++ ) if ( x % num [ j ] != rem [ j ] ) break;
    if ( j == k ) return x;
    x ++;
  }
}


MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_AXIS | static int findmin ( Point p [ ], int n ) {
  int a = 0, b = 0, c = 0, d = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( p [ i ] . x <= 0 ) a ++;
    else if ( p [ i ] . x >= 0 ) b ++;
    if ( p [ i ] . y >= 0 ) c ++;
    else if ( p [ i ] . y <= 0 ) d ++;
  }
  return Math . min ( Math . min ( a, b ), Math . min ( c, d ) );
}


REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE | static void translate ( char str [ ] ) {
  for ( int i = 1;
  i < str . length;
  i ++ ) {
    if ( str [ i - 1 ] == 'A' && str [ i ] == 'B' ) {
      str [ i - 1 ] = 'C';
      int j;
      for ( j = i;
      j < str . length - 1;
      j ++ ) str [ j ] = str [ j + 1 ];
      str [ j ] = ' ';
    }
  }
  return;
}


PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY | public static void printPairs ( int arr [ ], int n ) {
  Vector < Integer > v = new Vector < Integer > ( );
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) );
  if ( v . size ( ) == 0 ) return;
  Collections . sort ( v );
  for ( int i = 0;
  i < v . size ( );
  i ++ ) System . out . print ( - v . get ( i ) + " " + v . get ( i ) );
}


NON_REPEATING_ELEMENT_1 | static int firstNonRepeating ( int arr [ ], int n ) {
  Map < Integer, Integer > m = new HashMap < > ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( m . containsKey ( arr [ i ] ) ) {
      m . put ( arr [ i ], m . get ( arr [ i ] ) + 1 );
    }
    else {
      m . put ( arr [ i ], 1 );
    }
  }
  for ( int i = 0;
  i < n;
  i ++ ) if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ];
  return - 1;
}


PRINT_FIBONACCI_SERIES_REVERSE_ORDER | static void reverseFibonacci ( int n ) {
  int a [ ] = new int [ n ];
  a [ 0 ] = 0;
  a [ 1 ] = 1;
  for ( int i = 2;
  i < n;
  i ++ ) {
    a [ i ] = a [ i - 2 ] + a [ i - 1 ];
  }
  for ( int i = n - 1;
  i >= 0;
  i -- ) {
    System . out . print ( a [ i ] + " " );
  }
}


FIND_MINIMUM_DIFFERENCE_PAIR_1 | static int findMinDiff ( int [ ] arr, int n ) {
  Arrays . sort ( arr );
  int diff = Integer . MAX_VALUE;
  for ( int i = 0;
  i < n - 1;
  i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ];
  return diff;
}


MINIMUM_NUMBER_PLATFORMS_REQUIRED_RAILWAYBUS_STATION | static int findPlatform ( int arr [ ], int dep [ ], int n ) {
  Arrays . sort ( arr );
  Arrays . sort ( dep );
  int plat_needed = 1, result = 1;
  int i = 1, j = 0;
  while ( i < n && j < n ) {
    if ( arr [ i ] <= dep [ j ] ) {
      plat_needed ++;
      i ++;
      if ( plat_needed > result ) result = plat_needed;
    }
    else {
      plat_needed --;
      j ++;
    }
  }
  return result;
}


MULTIPLICATIVE_INVERSE_UNDER_MODULO_M_1 | static int modInverse ( int a, int m ) {
  int m0 = m;
  int y = 0, x = 1;
  if ( m == 1 ) return 0;
  while ( a > 1 ) {
    int q = a / m;
    int t = m;
    m = a % m;
    a = t;
    t = y;
    y = x - q * y;
    x = t;
  }
  if ( x < 0 ) x += m0;
  return x;
}


NUMBER_N_DIGIT_STEPPING_NUMBERS | static long answer ( int n ) {
  int dp [ ] [ ] = new int [ n + 1 ] [ 10 ];
  if ( n == 1 ) return 10;
  for ( int j = 0;
  j <= 9;
  j ++ ) dp [ 1 ] [ j ] = 1;
  for ( int i = 2;
  i <= n;
  i ++ ) {
    for ( int j = 0;
    j <= 9;
    j ++ ) {
      if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ];
      else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ];
      else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ];
    }
  }
  long sum = 0;
  for ( int j = 1;
  j <= 9;
  j ++ ) sum += dp [ n ] [ j ];
  return sum;
}


CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X | static void fill0X ( int m, int n ) {
  int i, k = 0, l = 0;
  int r = m, c = n;
  char a [ ] [ ] = new char [ m ] [ n ];
  char x = 'X';
  while ( k < m && l < n ) {
    for ( i = l;
    i < n;
    ++ i ) a [ k ] [ i ] = x;
    k ++;
    for ( i = k;
    i < m;
    ++ i ) a [ i ] [ n - 1 ] = x;
    n --;
    if ( k < m ) {
      for ( i = n - 1;
      i >= l;
      -- i ) a [ m - 1 ] [ i ] = x;
      m --;
    }
    if ( l < n ) {
      for ( i = m - 1;
      i >= k;
      -- i ) a [ i ] [ l ] = x;
      l ++;
    }
    x = ( x == '0' ) ? 'X' : '0';
  }
  for ( i = 0;
  i < r;
  i ++ ) {
    for ( int j = 0;
    j < c;
    j ++ ) System . out . print ( a [ i ] [ j ] + " " );
    System . out . println ( );
  }
}


FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY | static int findSubarraySum ( int [ ] arr, int n ) {
  int res = 0;
  HashMap < Integer, Integer > m = new HashMap < Integer, Integer > ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    int sum = 0;
    for ( int j = i;
    j < n;
    j ++ ) {
      sum += arr [ j ];
      if ( m . containsKey ( sum ) ) {
        m . put ( sum, m . get ( sum ) + 1 );
      }
      else {
        m . put ( sum, 1 );
      }
    }
  }
  for ( Map . Entry < Integer, Integer > x : m . entrySet ( ) ) if ( x . getValue ( ) == 1 ) res += x . getKey ( );
  return res;
}


REVERSE_A_STRING_USING_RECURSION | void reverse ( String str ) {
  if ( ( str == null ) || ( str . length ( ) <= 1 ) ) System . out . println ( str );
  else {
    System . out . print ( str . charAt ( str . length ( ) - 1 ) );
    reverse ( str . substring ( 0, str . length ( ) - 1 ) );
  }
}


PRINTING_ITEMS_01_KNAPSACK | static void printknapSack ( int W, int wt [ ], int val [ ], int n ) {
  int i, w;
  int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ];
  for ( i = 0;
  i <= n;
  i ++ ) {
    for ( w = 0;
    w <= W;
    w ++ ) {
      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0;
      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ], K [ i - 1 ] [ w ] );
      else K [ i ] [ w ] = K [ i - 1 ] [ w ];
    }
  }
  int res = K [ n ] [ W ];
  System . out . println ( res );
  w = W;
  for ( i = n;
  i > 0 && res > 0;
  i -- ) {
    if ( res == K [ i - 1 ] [ w ] ) continue;
    else {
      System . out . print ( wt [ i - 1 ] + " " );
      res = res - val [ i - 1 ];
      w = w - wt [ i - 1 ];
    }
  }
}


FIND_LARGEST_PRIME_FACTOR_NUMBER | static long maxPrimeFactors ( long n ) {
  long maxPrime = - 1;
  while ( n % 2 == 0 ) {
    maxPrime = 2;
    n >>= 1;
  }
  for ( int i = 3;
  i <= Math . sqrt ( n );
  i += 2 ) {
    while ( n % i == 0 ) {
      maxPrime = i;
      n = n / i;
    }
  }
  if ( n > 2 ) maxPrime = n;
  return maxPrime;
}


FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT | static int findElement ( int [ ] arr, int n ) {
  int [ ] leftMax = new int [ n ];
  leftMax [ 0 ] = Integer . MIN_VALUE;
  for ( int i = 1;
  i < n;
  i ++ ) leftMax [ i ] = Math . max ( leftMax [ i - 1 ], arr [ i - 1 ] );
  int rightMin = Integer . MAX_VALUE;
  for ( int i = n - 1;
  i >= 0;
  i -- ) {
    if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] ) return i;
    rightMin = Math . min ( rightMin, arr [ i ] );
  }
  return - 1;
}


COMMON_CHARACTERS_N_STRINGS | public static void commonCharacters ( String str [ ], int n ) {
  Boolean [ ] prim = new Boolean [ MAX_CHAR ];
  Arrays . fill ( prim, new Boolean ( true ) );
  for ( int i = 0;
  i < n;
  i ++ ) {
    Boolean [ ] sec = new Boolean [ MAX_CHAR ];
    Arrays . fill ( sec, new Boolean ( false ) );
    for ( int j = 0;
    j < str [ i ] . length ( );
    j ++ ) {
      if ( prim [ str [ i ] . charAt ( j ) - 'a' ] ) sec [ str [ i ] . charAt ( j ) - 'a' ] = true;
    }
    System . arraycopy ( sec, 0, prim, 0, MAX_CHAR );
  }
  for ( int i = 0;
  i < 26;
  i ++ ) if ( prim [ i ] ) {
    System . out . print ( Character . toChars ( i + 97 ) );
    System . out . print ( " " );
  }
}


MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING | static int minimalSteps ( String s, int n ) {
  int [ ] dp = new int [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) dp [ i ] = Integer . MAX_VALUE;
  String s1 = "", s2 = "";
  dp [ 0 ] = 1;
  s1 += s . charAt ( 0 );
  for ( int i = 1;
  i < n;
  i ++ ) {
    s1 += s . charAt ( i );
    s2 = s . substring ( i + 1, i + 1 );
    dp [ i ] = Math . min ( dp [ i ], dp [ i - 1 ] + 1 );
    if ( s1 == s2 ) dp [ i * 2 + 1 ] = Math . min ( dp [ i ] + 1, dp [ i * 2 + 1 ] );
  }
  return dp [ n - 1 ];
}


SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_1 | static int findSum ( int n ) {
  int sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) sum += i * ( n - i );
  return 2 * sum;
}


FIND_FREQUENCY_EVEN_ODD_NUMBERS_MATRIX | static void freq ( int ar [ ] [ ], int m, int n ) {
  int even = 0, odd = 0;
  for ( int i = 0;
  i < m;
  ++ i ) {
    for ( int j = 0;
    j < n;
    ++ j ) {
      if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even;
      else ++ odd;
    }
  }
  System . out . print ( " Frequency of odd number =" + odd + " \n" );
  System . out . print ( " Frequency of even number = " + even + " \n" );
}


COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS | static int countSubarrays ( int [ ] arr, int n ) {
  int difference = 0;
  int ans = 0;
  int [ ] hash_positive = new int [ n + 1 ];
  int [ ] hash_negative = new int [ n + 1 ];
  hash_positive [ 0 ] = 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( ( arr [ i ] & 1 ) == 1 ) {
      difference ++;
    }
    else {
      difference --;
    }
    if ( difference < 0 ) {
      ans += hash_negative [ - difference ];
      hash_negative [ - difference ] ++;
    }
    else {
      ans += hash_positive [ difference ];
      hash_positive [ difference ] ++;
    }
  }
  return ans;
}


PASCAL_TRIANGLE_1 | public static void printPascal ( int n ) {
  for ( int line = 1;
  line <= n;
  line ++ ) {
    int C = 1;
    for ( int i = 1;
    i <= line;
    i ++ ) {
      System . out . print ( C + " " );
      C = C * ( line - i ) / i;
    }
    System . out . println ( );
  }
}


NUMBER_OF_TRIANGLES_IN_A_PLANE_IF_NO_MORE_THAN_TWO_POINTS_ARE_COLLINEAR | static int countNumberOfTriangles ( int n ) {
  return n * ( n - 1 ) * ( n - 2 ) / 6;
}


MERGE_TWO_SORTED_ARRAYS_O1_EXTRA_SPACE | static void merge ( int m, int n ) {
  for ( int i = n - 1;
  i >= 0;
  i -- ) {
    int j, last = arr1 [ m - 1 ];
    for ( j = m - 2;
    j >= 0 && arr1 [ j ] > arr2 [ i ];
    j -- ) arr1 [ j + 1 ] = arr1 [ j ];
    if ( j != m - 2 || last > arr2 [ i ] ) {
      arr1 [ j + 1 ] = arr2 [ i ];
      arr2 [ i ] = last;
    }
  }
}


NEWMAN_SHANKS_WILLIAMS_PRIME | static int nswp ( int n ) {
  if ( n == 0 || n == 1 ) return 1;
  return 2 * nswp ( n - 1 ) + nswp ( n - 2 );
}


SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS | static int smallest ( int x, int y, int z ) {
  int c = 0;
  while ( x != 0 && y != 0 && z != 0 ) {
    x --;
    y --;
    z --;
    c ++;
  }
  return c;
}


COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X | static int countPairs ( int [ ] arr1, int [ ] arr2, int m, int n, int x ) {
  int count = 0;
  for ( int i = 0;
  i < m;
  i ++ ) for ( int j = 0;
  j < n;
  j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++;
  return count;
}


SORT_ARRAY_APPLYING_GIVEN_EQUATION | static void sortArray ( int arr [ ], int n, int A, int B, int C ) {
  for ( int i = 0;
  i < n;
  i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C;
  int index = - 1;
  int maximum = - 999999;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( maximum < arr [ i ] ) {
      index = i;
      maximum = arr [ i ];
    }
  }
  int i = 0, j = n - 1;
  int [ ] new_arr = new int [ n ];
  int k = 0;
  while ( i < index && j > index ) {
    if ( arr [ i ] < arr [ j ] ) new_arr [ k ++ ] = arr [ i ++ ];
    else new_arr [ k ++ ] = arr [ j -- ];
  }
  while ( i < index ) new_arr [ k ++ ] = arr [ i ++ ];
  while ( j > index ) new_arr [ k ++ ] = arr [ j -- ];
  new_arr [ n - 1 ] = maximum;
  for ( int p = 0;
  p < n;
  p ++ ) arr [ p ] = new_arr [ p ];
}


PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON | static float findArea ( float a ) {
  float area;
  area = ( float ) ( Math . sqrt ( 5 * ( 5 + 2 * ( Math . sqrt ( 5 ) ) ) ) * a * a ) / 4;
  return area;
}


MAXIMIZE_SUM_CONSECUTIVE_DIFFERENCES_CIRCULAR_ARRAY | static int maxSum ( int arr [ ], int n ) {
  int sum = 0;
  Arrays . sort ( arr );
  for ( int i = 0;
  i < n / 2;
  i ++ ) {
    sum -= ( 2 * arr [ i ] );
    sum += ( 2 * arr [ n - i - 1 ] );
  }
  return sum;
}


COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES | public static int countarray ( int n, int k, int x ) {
  int [ ] dp = new int [ 109 ];
  dp [ 0 ] = 0;
  dp [ 1 ] = 1;
  for ( int i = 2;
  i < n;
  i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ];
  return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] );
}


SUM_SERIES_12_32_52_2N_12 | static int sumOfSeries ( int n ) {
  int sum = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 );
  return sum;
}


FIND_THE_NEAREST_SMALLER_NUMBERS_ON_LEFT_SIDE_IN_AN_ARRAY_1 | static void printPrevSmaller ( int arr [ ], int n ) {
  Stack < Integer > S = new Stack < > ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    while ( ! S . empty ( ) && S . peek ( ) >= arr [ i ] ) {
      S . pop ( );
    }
    if ( S . empty ( ) ) {
      System . out . print ( "_, " );
    }
    else {
      System . out . print ( S . peek ( ) + ", " );
    }
    S . push ( arr [ i ] );
  }
}


FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1 | static void CountTriangles ( int [ ] A ) {
  int n = A . length;
  Arrays . sort ( A );
  int count = 0;
  for ( int i = n - 1;
  i >= 1;
  i -- ) {
    int l = 0, r = i - 1;
    while ( l < r ) {
      if ( A [ l ] + A [ r ] > A [ i ] ) {
        count += r - l;
        r --;
      }
      else {
        l ++;
      }
    }
  }
  System . out . print ( "No of possible solutions: " + count );
}


MAXIMUM_GAMES_PLAYED_WINNER | static int maxGameByWinner ( int N ) {
  int [ ] dp = new int [ N ];
  dp [ 0 ] = 1;
  dp [ 1 ] = 2;
  int i = 2;
  do {
    dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ];
  }
  while ( dp [ i ++ ] <= N );
  return ( i - 2 );
}


NUMBER_OF_SUBSTRINGS_WITH_ODD_DECIMAL_VALUE_IN_A_BINARY_STRING | static int countSubstr ( String s ) {
  int n = s . length ( );
  int [ ] auxArr = new int [ n ];
  if ( s . charAt ( 0 ) == '1' ) auxArr [ 0 ] = 1;
  for ( int i = 1;
  i < n;
  i ++ ) {
    if ( s . charAt ( i ) == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1;
    else auxArr [ i ] = auxArr [ i - 1 ];
  }
  int count = 0;
  for ( int i = n - 1;
  i >= 0;
  i -- ) if ( s . charAt ( i ) == '1' ) count += auxArr [ i ];
  return count;
}


ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY_1 | static int countNum ( int arr [ ], int n ) {
  HashSet < Integer > s = new HashSet < > ( );
  int count = 0, maxm = Integer . MIN_VALUE, minm = Integer . MAX_VALUE;
  for ( int i = 0;
  i < n;
  i ++ ) {
    s . add ( arr [ i ] );
    if ( arr [ i ] < minm ) minm = arr [ i ];
    if ( arr [ i ] > maxm ) maxm = arr [ i ];
  }
  for ( int i = minm;
  i <= maxm;
  i ++ ) if ( ! s . contains ( i ) ) count ++;
  return count;
}


WRITE_A_C_PROGRAM_TO_CALCULATE_POWXN_1 | static float power ( float x, int y ) {
  float temp;
  if ( y == 0 ) return 1;
  temp = power ( x, y / 2 );
  if ( y % 2 == 0 ) return temp * temp;
  else {
    if ( y > 0 ) return x * temp * temp;
    else return ( temp * temp ) / x;
  }
}


N_TH_TERM_SERIES_2_12_36_80_150 | public static int nthTerm ( int n ) {
  return ( n * n ) + ( n * n * n );
}


FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES | static int getOddOccurrence ( int arr [ ], int arr_size ) {
  int i;
  for ( i = 0;
  i < arr_size;
  i ++ ) {
    int count = 0;
    for ( int j = 0;
    j < arr_size;
    j ++ ) {
      if ( arr [ i ] == arr [ j ] ) count ++;
    }
    if ( count % 2 != 0 ) return arr [ i ];
  }
  return - 1;
}


EFFICIENT_METHOD_2S_COMPLEMENT_BINARY_STRING | static String findTwoscomplement ( StringBuffer str ) {
  int n = str . length ( );
  int i;
  for ( i = n - 1;
  i >= 0;
  i -- ) if ( str . charAt ( i ) == '1' ) break;
  if ( i == - 1 ) return "1" + str;
  for ( int k = i - 1;
  k >= 0;
  k -- ) {
    if ( str . charAt ( k ) == '1' ) str . replace ( k, k + 1, "0" );
    else str . replace ( k, k + 1, "1" );
  }
  return str . toString ( );
}


PAPER_CUT_MINIMUM_NUMBER_SQUARES_SET_2 | static int minimumSquare ( int m, int n ) {
  int vertical_min = Integer . MAX_VALUE;
  int horizontal_min = Integer . MAX_VALUE;
  if ( m == n ) return 1;
  if ( dp [ m ] [ n ] != 0 ) return dp [ m ] [ n ];
  for ( int i = 1;
  i <= m / 2;
  i ++ ) {
    horizontal_min = Math . min ( minimumSquare ( i, n ) + minimumSquare ( m - i, n ), horizontal_min );
  }
  for ( int j = 1;
  j <= n / 2;
  j ++ ) {
    vertical_min = Math . min ( minimumSquare ( m, j ) + minimumSquare ( m, n - j ), vertical_min );
  }
  dp [ m ] [ n ] = Math . min ( vertical_min, horizontal_min );
  return dp [ m ] [ n ];
}


MINIMIZE_ABSOLUTE_DIFFERENCE_SUM_TWO_SUBSETS | static void subsetDifference ( int n ) {
  int s = n * ( n + 1 ) / 2;
  if ( n % 4 == 0 ) {
    System . out . println ( "First subset sum = " + s / 2 );
    System . out . println ( "Second subset sum = " + s / 2 );
    System . out . println ( "Difference = " + 0 );
  }
  else {
    if ( n % 4 == 1 || n % 4 == 2 ) {
      System . out . println ( "First subset sum = " + s / 2 );
      System . out . println ( "Second subset sum = " + ( ( s / 2 ) + 1 ) );
      System . out . println ( "Difference = " + 1 );
    }
    else {
      System . out . println ( "First subset sum = " + s / 2 );
      System . out . println ( "Second subset sum = " + s / 2 );
      System . out . println ( "Difference = " + 0 );
    }
  }
}


PROGRAM_CALCULATE_VOLUME_ELLIPSOID | public static float volumeOfEllipsoid ( float r1, float r2, float r3 ) {
  float pi = ( float ) 3.14;
  return ( float ) 1.33 * pi * r1 * r2 * r3;
}


DYNAMIC_PROGRAMMING_SET_13_CUTTING_A_ROD | static int cutRod ( int price [ ], int n ) {
  int val [ ] = new int [ n + 1 ];
  val [ 0 ] = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) {
    int max_val = Integer . MIN_VALUE;
    for ( int j = 0;
    j < i;
    j ++ ) max_val = Math . max ( max_val, price [ j ] + val [ i - j - 1 ] );
    val [ i ] = max_val;
  }
  return val [ n ];
}


RECURSIVE_INSERTION_SORT | static void insertionSortRecursive ( int arr [ ], int n ) {
  if ( n <= 1 ) return;
  insertionSortRecursive ( arr, n - 1 );
  int last = arr [ n - 1 ];
  int j = n - 2;
  while ( j >= 0 && arr [ j ] > last ) {
    arr [ j + 1 ] = arr [ j ];
    j --;
  }
  arr [ j + 1 ] = last;
}


FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT | static boolean findDuplicateparenthesis ( String s ) {
  Stack < Character > Stack = new Stack < > ( );
  char [ ] str = s . toCharArray ( );
  for ( char ch : str ) {
    if ( ch == ')' ) {
      char top = Stack . peek ( );
      Stack . pop ( );
      int elementsInside = 0;
      while ( top != '(' ) {
        elementsInside ++;
        top = Stack . peek ( );
        Stack . pop ( );
      }
      if ( elementsInside < 1 ) {
        return true;
      }
    }
    else {
      Stack . push ( ch );
    }
  }
  return false;
}


FIND_REPETITIVE_ELEMENT_1_N_1 | static int findRepeating ( int [ ] arr, int n ) {
  int sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) sum += arr [ i ];
  return sum - ( ( ( n - 1 ) * n ) / 2 );
}


CHECK_ARRAY_CONTAINS_CONTIGUOUS_INTEGERS_DUPLICATES_ALLOWED | static boolean areElementsContiguous ( int arr [ ], int n ) {
  int max = Integer . MIN_VALUE;
  int min = Integer . MAX_VALUE;
  for ( int i = 0;
  i < n;
  i ++ ) {
    max = Math . max ( max, arr [ i ] );
    min = Math . min ( min, arr [ i ] );
  }
  int m = max - min + 1;
  if ( m > n ) return false;
  boolean visited [ ] = new boolean [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) visited [ arr [ i ] - min ] = true;
  for ( int i = 0;
  i < m;
  i ++ ) if ( visited [ i ] == false ) return false;
  return true;
}


LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1 | static int maxLength ( String s, int n ) {
  int invalidOpenBraces = 0;
  int invalidCloseBraces = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( s . charAt ( i ) == '(' ) {
      invalidOpenBraces ++;
    }
    else {
      if ( invalidOpenBraces == 0 ) {
        invalidCloseBraces ++;
      }
      else {
        invalidOpenBraces --;
      }
    }
  }
  return ( n - ( invalidOpenBraces + invalidCloseBraces ) );
}


SUM_SERIES_ALTERNATE_SIGNED_SQUARES_AP_1 | static int seiresSum ( int n, int [ ] a ) {
  return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 );
}


EQUILIBRIUM_INDEX_OF_AN_ARRAY | int equilibrium ( int arr [ ], int n ) {
  int i, j;
  int leftsum, rightsum;
  for ( i = 0;
  i < n;
  ++ i ) {
    leftsum = 0;
    for ( j = 0;
    j < i;
    j ++ ) leftsum += arr [ j ];
    rightsum = 0;
    for ( j = i + 1;
    j < n;
    j ++ ) rightsum += arr [ j ];
    if ( leftsum == rightsum ) return i;
  }
  return - 1;
}


COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3 | public static int findStep ( int n ) {
  if ( n == 1 || n == 0 ) return 1;
  else if ( n == 2 ) return 2;
  else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 );
}


FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE | static int minCoins ( int coins [ ], int m, int V ) {
  if ( V == 0 ) return 0;
  int res = Integer . MAX_VALUE;
  for ( int i = 0;
  i < m;
  i ++ ) {
    if ( coins [ i ] <= V ) {
      int sub_res = minCoins ( coins, m, V - coins [ i ] );
      if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1;
    }
  }
  return res;
}


BELL_NUMBERS_NUMBER_OF_WAYS_TO_PARTITION_A_SET | static int bellNumber ( int n ) {
  int [ ] [ ] bell = new int [ n + 1 ] [ n + 1 ];
  bell [ 0 ] [ 0 ] = 1;
  for ( int i = 1;
  i <= n;
  i ++ ) {
    bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ];
    for ( int j = 1;
    j <= i;
    j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ];
  }
  return bell [ n ] [ 0 ];
}


FIND_ELEMENT_GIVEN_INDEX_NUMBER_ROTATIONS | static int findElement ( int [ ] arr, int [ ] [ ] ranges, int rotations, int index ) {
  for ( int i = rotations - 1;
  i >= 0;
  i -- ) {
    int left = ranges [ i ] [ 0 ];
    int right = ranges [ i ] [ 1 ];
    if ( left <= index && right >= index ) {
      if ( index == left ) index = right;
      else index --;
    }
  }
  return arr [ index ];
}


DYCK_PATH | public static int countDyckPaths ( int n ) {
  int res = 1;
  for ( int i = 0;
  i < n;
  ++ i ) {
    res *= ( 2 * n - i );
    res /= ( i + 1 );
  }
  return res / ( n + 1 );
}


COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE | static int numberOfWays ( int x ) {
  if ( x == 0 || x == 1 ) return 1;
  else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 );
}


PROGRAM_DISPLAY_ASTROLOGICAL_SIGN_ZODIAC_SIGN_GIVEN_DATE_BIRTH | static void zodiac_sign ( int day, String month ) {
  String astro_sign = "";
  if ( month == "december" ) {
    if ( day < 22 ) astro_sign = "Sagittarius";
    else astro_sign = "capricorn";
  }
  else if ( month == "january" ) {
    if ( day < 20 ) astro_sign = "Capricorn";
    else astro_sign = "aquarius";
  }
  else if ( month == "february" ) {
    if ( day < 19 ) astro_sign = "Aquarius";
    else astro_sign = "pisces";
  }
  else if ( month == "march" ) {
    if ( day < 21 ) astro_sign = "Pisces";
    else astro_sign = "aries";
  }
  else if ( month == "april" ) {
    if ( day < 20 ) astro_sign = "Aries";
    else astro_sign = "taurus";
  }
  else if ( month == "may" ) {
    if ( day < 21 ) astro_sign = "Taurus";
    else astro_sign = "gemini";
  }
  else if ( month == "june" ) {
    if ( day < 21 ) astro_sign = "Gemini";
    else astro_sign = "cancer";
  }
  else if ( month == "july" ) {
    if ( day < 23 ) astro_sign = "Cancer";
    else astro_sign = "leo";
  }
  else if ( month == "august" ) {
    if ( day < 23 ) astro_sign = "Leo";
    else astro_sign = "virgo";
  }
  else if ( month == "september" ) {
    if ( day < 23 ) astro_sign = "Virgo";
    else astro_sign = "libra";
  }
  else if ( month == "october" ) {
    if ( day < 23 ) astro_sign = "Libra";
    else astro_sign = "scorpio";
  }
  else if ( month == "november" ) {
    if ( day < 22 ) astro_sign = "scorpio";
    else astro_sign = "sagittarius";
  }
  System . out . println ( astro_sign );
}


PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2 | static void recursiveReverse ( char [ ] str, int i ) {
  int n = str . length;
  if ( i == n / 2 ) return;
  swap ( str, i, n - i - 1 );
  recursiveReverse ( str, i + 1 );
}


K_TH_DIGIT_RAISED_POWER_B | public static int kthdigit ( int a, int b, int k ) {
  int p = ( int ) Math . pow ( a, b );
  int count = 0;
  while ( p > 0 && count < k ) {
    int rem = p % 10;
    count ++;
    if ( count == k ) return rem;
    p = p / 10;
  }
  return 0;
}


SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS | static int findSmallestDifference ( int A [ ], int B [ ], int m, int n ) {
  Arrays . sort ( A );
  Arrays . sort ( B );
  int a = 0, b = 0;
  int result = Integer . MAX_VALUE;
  while ( a < m && b < n ) {
    if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] );
    if ( A [ a ] < B [ b ] ) a ++;
    else b ++;
  }
  return result;
}


MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY_1 | static int findArea ( int arr [ ], int n ) {
  Set < Integer > s = new HashSet < > ( );
  int first = 0, second = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( ! s . contains ( arr [ i ] ) ) {
      s . add ( arr [ i ] );
      continue;
    }
    if ( arr [ i ] > first ) {
      second = first;
      first = arr [ i ];
    }
    else if ( arr [ i ] > second ) second = arr [ i ];
  }
  return ( first * second );
}


PROGRAM_PAGE_REPLACEMENT_ALGORITHMS_SET_2_FIFO | static int pageFaults ( int pages [ ], int n, int capacity ) {
  HashSet < Integer > s = new HashSet < > ( capacity );
  Queue < Integer > indexes = new LinkedList < > ( );
  int page_faults = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( s . size ( ) < capacity ) {
      if ( ! s . contains ( pages [ i ] ) ) {
        s . add ( pages [ i ] );
        page_faults ++;
        indexes . add ( pages [ i ] );
      }
    }
    else {
      if ( ! s . contains ( pages [ i ] ) ) {
        int val = indexes . peek ( );
        indexes . poll ( );
        s . remove ( val );
        s . add ( pages [ i ] );
        indexes . add ( pages [ i ] );
        page_faults ++;
      }
    }
  }
  return page_faults;
}


FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1 | static int findFourElements ( int [ ] arr, int n ) {
  HashMap < Integer, Indexes > map = new HashMap < > ( );
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    for ( int j = i + 1;
    j < n;
    j ++ ) {
      map . put ( arr [ i ] + arr [ j ], new Indexes ( i, j ) );
    }
  }
  int d = Integer . MIN_VALUE;
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    for ( int j = i + 1;
    j < n;
    j ++ ) {
      int abs_diff = Math . abs ( arr [ i ] - arr [ j ] );
      if ( map . containsKey ( abs_diff ) ) {
        Indexes indexes = map . get ( abs_diff );
        if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) {
          d = Math . max ( d, Math . max ( arr [ i ], arr [ j ] ) );
        }
      }
    }
  }
  return d;
}


PRINT_GIVEN_MATRIX_REVERSE_SPIRAL_FORM | public static void ReversespiralPrint ( int m, int n, int a [ ] [ ] ) {
  long b [ ] = new long [ 100 ];
  int i, k = 0, l = 0;
  int z = 0;
  int size = m * n;
  while ( k < m && l < n ) {
    int val;
    for ( i = l;
    i < n;
    ++ i ) {
      val = a [ k ] [ i ];
      b [ z ] = val;
      ++ z;
    }
    k ++;
    for ( i = k;
    i < m;
    ++ i ) {
      val = a [ i ] [ n - 1 ];
      b [ z ] = val;
      ++ z;
    }
    n --;
    if ( k < m ) {
      for ( i = n - 1;
      i >= l;
      -- i ) {
        val = a [ m - 1 ] [ i ];
        b [ z ] = val;
        ++ z;
      }
      m --;
    }
    if ( l < n ) {
      for ( i = m - 1;
      i >= k;
      -- i ) {
        val = a [ i ] [ l ];
        b [ z ] = val;
        ++ z;
      }
      l ++;
    }
  }
  for ( int x = size - 1;
  x >= 0;
  -- x ) {
    System . out . print ( b [ x ] + " " );
  }
}


NUMBER_N_DIGITS_NON_DECREASING_INTEGERS | static int nonDecNums ( int n ) {
  int [ ] [ ] a = new int [ n + 1 ] [ 10 ];
  for ( int i = 0;
  i <= 9;
  i ++ ) a [ 0 ] [ i ] = 1;
  for ( int i = 1;
  i <= n;
  i ++ ) a [ i ] [ 9 ] = 1;
  for ( int i = 1;
  i <= n;
  i ++ ) for ( int j = 8;
  j >= 0;
  j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ];
  return a [ n ] [ 0 ];
}


LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF | static int findLength ( String str ) {
  int n = str . length ( );
  int maxlen = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = i + 1;
    j < n;
    j += 2 ) {
      int length = j - i + 1;
      int leftsum = 0, rightsum = 0;
      for ( int k = 0;
      k < length / 2;
      k ++ ) {
        leftsum += ( str . charAt ( i + k ) - '0' );
        rightsum += ( str . charAt ( i + k + length / 2 ) - '0' );
      }
      if ( leftsum == rightsum && maxlen < length ) maxlen = length;
    }
  }
  return maxlen;
}


PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT | static void worstFit ( int blockSize [ ], int m, int processSize [ ], int n ) {
  int allocation [ ] = new int [ n ];
  for ( int i = 0;
  i < allocation . length;
  i ++ ) allocation [ i ] = - 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int wstIdx = - 1;
    for ( int j = 0;
    j < m;
    j ++ ) {
      if ( blockSize [ j ] >= processSize [ i ] ) {
        if ( wstIdx == - 1 ) wstIdx = j;
        else if ( blockSize [ wstIdx ] < blockSize [ j ] ) wstIdx = j;
      }
    }
    if ( wstIdx != - 1 ) {
      allocation [ i ] = wstIdx;
      blockSize [ wstIdx ] -= processSize [ i ];
    }
  }
  System . out . println ( "\nProcess No.\tProcess Size\tBlock no." );
  for ( int i = 0;
  i < n;
  i ++ ) {
    System . out . print ( "   " + ( i + 1 ) + "\t\t" + processSize [ i ] + "\t\t" );
    if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 );
    else System . out . print ( "Not Allocated" );
    System . out . println ( );
  }
}


SUM_SUBSETS_SET_FORMED_FIRST_N_NATURAL_NUMBERS | static long findSumSubsets ( int n ) {
  return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) );
}


ADD_TWO_NUMBERS_WITHOUT_USING_ARITHMETIC_OPERATORS | static int Add ( int x, int y ) {
  while ( y != 0 ) {
    int carry = x & y;
    x = x ^ y;
    y = carry << 1;
  }
  return x;
}


MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE | static int maxcoefficientvalue ( int n ) {
  int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) {
    for ( int j = 0;
    j <= Math . min ( i, n );
    j ++ ) {
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1;
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ];
    }
  }
  int maxvalue = 0;
  for ( int i = 0;
  i <= n;
  i ++ ) maxvalue = Math . max ( maxvalue, C [ n ] [ i ] );
  return maxvalue;
}


EULERIAN_PATH_UNDIRECTED_GRAPH | static void findpath ( int [ ] [ ] graph, int n ) {
  Vector < Integer > numofadj = new Vector < > ( );
  for ( int i = 0;
  i < n;
  i ++ ) numofadj . add ( accumulate ( graph [ i ], 0 ) );
  int startPoint = 0, numofodd = 0;
  for ( int i = n - 1;
  i >= 0;
  i -- ) {
    if ( numofadj . elementAt ( i ) % 2 == 1 ) {
      numofodd ++;
      startPoint = i;
    }
  }
  if ( numofodd > 2 ) {
    System . out . println ( "No Solution" );
    return;
  }
  Stack < Integer > stack = new Stack < > ( );
  Vector < Integer > path = new Vector < > ( );
  int cur = startPoint;
  while ( ! stack . isEmpty ( ) || accumulate ( graph [ cur ], 0 ) != 0 ) {
    if ( accumulate ( graph [ cur ], 0 ) == 0 ) {
      path . add ( cur );
      cur = stack . pop ( );
    }
    else {
      for ( int i = 0;
      i < n;
      i ++ ) {
        if ( graph [ cur ] [ i ] == 1 ) {
          stack . add ( cur );
          graph [ cur ] [ i ] = 0;
          graph [ i ] [ cur ] = 0;
          cur = i;
          break;
        }
      }
    }
  }
  for ( int ele : path ) System . out . print ( ele + " -> " );
  System . out . println ( cur );
}


RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS | static int countSubstrs ( String str, int i, int j, int n ) {
  if ( n == 1 ) return 1;
  if ( n <= 0 ) return 0;
  int res = countSubstrs ( str, i + 1, j, n - 1 ) + countSubstrs ( str, i, j - 1, n - 1 ) - countSubstrs ( str, i + 1, j - 1, n - 2 );
  if ( str . charAt ( i ) == str . charAt ( j ) ) res ++;
  return res;
}


FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1 | static int count ( String a, String b ) {
  int m = a . length ( );
  int n = b . length ( );
  int lookup [ ] [ ] = new int [ m + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= n;
  ++ i ) lookup [ 0 ] [ i ] = 0;
  for ( int i = 0;
  i <= m;
  ++ i ) lookup [ i ] [ 0 ] = 1;
  for ( int i = 1;
  i <= m;
  i ++ ) {
    for ( int j = 1;
    j <= n;
    j ++ ) {
      if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ];
      else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ];
    }
  }
  return lookup [ m ] [ n ];
}


AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES | public static double polygonArea ( double X [ ], double Y [ ], int n ) {
  double area = 0.0;
  int j = n - 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] );
    j = i;
  }
  return Math . abs ( area / 2.0 );
}


PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N | static void findConsecutive ( int N ) {
  int start = 1;
  int end = ( N + 1 ) / 2;
  while ( start < end ) {
    int sum = 0;
    for ( int i = start;
    i <= end;
    i ++ ) {
      sum = sum + i;
      if ( sum == N ) {
        for ( int j = start;
        j <= i;
        j ++ ) System . out . print ( j + " " );
        System . out . println ( );
        break;
      }
      if ( sum > N ) break;
    }
    sum = 0;
    start ++;
  }
}


BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_BRACKETS | static long arrangeBraces ( int n, int pos [ ], int k ) {
  boolean h [ ] = new boolean [ N ];
  int dp [ ] [ ] = new int [ N ] [ N ];
  for ( int i = 0;
  i < k;
  i ++ ) {
    h [ pos [ i ] ] = true;
  }
  dp [ 0 ] [ 0 ] = 1;
  for ( int i = 1;
  i <= 2 * n;
  i ++ ) {
    for ( int j = 0;
    j <= 2 * n;
    j ++ ) {
      if ( h [ i ] ) {
        if ( j != 0 ) {
          dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ];
        }
        else {
          dp [ i ] [ j ] = 0;
        }
      }
      else if ( j != 0 ) {
        dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ];
      }
      else {
        dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ];
      }
    }
  }
  return dp [ 2 * n ] [ 0 ];
}


GIVEN_1S_2S_3S_KS_PRINT_ZIG_ZAG_WAY | public static void ZigZag ( int rows, int columns, int numbers [ ] ) {
  int k = 0;
  int [ ] [ ] arr = new int [ rows ] [ columns ];
  for ( int i = 0;
  i < rows;
  i ++ ) {
    if ( i % 2 == 0 ) {
      for ( int j = 0;
      j < columns && numbers [ k ] > 0;
      j ++ ) {
        arr [ i ] [ j ] = k + 1;
        numbers [ k ] --;
        if ( numbers [ k ] == 0 ) k ++;
      }
    }
    else {
      for ( int j = columns - 1;
      j >= 0 && numbers [ k ] > 0;
      j -- ) {
        arr [ i ] [ j ] = k + 1;
        numbers [ k ] --;
        if ( numbers [ k ] == 0 ) k ++;
      }
    }
  }
  for ( int i = 0;
  i < rows;
  i ++ ) {
    for ( int j = 0;
    j < columns;
    j ++ ) System . out . print ( arr [ i ] [ j ] + " " );
    System . out . println ( );
  }
}


CONVERT_STRING_BINARY_SEQUENCE | static void strToBinary ( String s ) {
  int n = s . length ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    int val = Integer . valueOf ( s . charAt ( i ) );
    String bin = "";
    while ( val > 0 ) {
      if ( val % 2 == 1 ) {
        bin += '1';
      }
      else bin += '0';
      val /= 2;
    }
    bin = reverse ( bin );
    System . out . print ( bin + " " );
  }
}


LUCKY_NUMBERS | static boolean isLucky ( int n ) {
  int next_position = n;
  if ( counter > n ) return true;
  if ( n % counter == 0 ) return false;
  next_position -= next_position / counter;
  counter ++;
  return isLucky ( next_position );
}


SMALLEST_SUM_CONTIGUOUS_SUBARRAY | static int smallestSumSubarr ( int arr [ ], int n ) {
  int min_ending_here = 2147483647;
  int min_so_far = 2147483647;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( min_ending_here > 0 ) min_ending_here = arr [ i ];
    else min_ending_here += arr [ i ];
    min_so_far = Math . min ( min_so_far, min_ending_here );
  }
  return min_so_far;
}


PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE | public static void sequence ( int n ) {
  int f [ ] = new int [ n + 1 ];
  f [ 0 ] = 0;
  f [ 1 ] = 1;
  f [ 2 ] = 1;
  System . out . print ( f [ 1 ] + " " + f [ 2 ] + " " );
  for ( int i = 3;
  i <= n;
  i ++ ) {
    f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ];
    System . out . print ( f [ i ] + " " );
  }
}


MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES | static int fib ( int n ) {
  if ( n <= 1 ) return n;
  return fib ( n - 1 ) + fib ( n - 2 );
}


MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS | static int cost ( int [ ] a, int n ) {
  int min = a [ 0 ];
  for ( int i = 1;
  i < a . length;
  i ++ ) {
    if ( a [ i ] < min ) min = a [ i ];
  }
  return ( n - 1 ) * min;
}


CHOCOLATE_DISTRIBUTION_PROBLEM | static int findMinDiff ( int arr [ ], int n, int m ) {
  if ( m == 0 || n == 0 ) return 0;
  Arrays . sort ( arr );
  if ( n < m ) return - 1;
  int min_diff = Integer . MAX_VALUE;
  int first = 0, last = 0;
  for ( int i = 0;
  i + m - 1 < n;
  i ++ ) {
    int diff = arr [ i + m - 1 ] - arr [ i ];
    if ( diff < min_diff ) {
      min_diff = diff;
      first = i;
      last = i + m - 1;
    }
  }
  return ( arr [ last ] - arr [ first ] );
}


FIND_ONE_EXTRA_CHARACTER_STRING_1 | static char findExtraCharcter ( String strA, String strB ) {
  int res = 0, i;
  for ( i = 0;
  i < strA . length ( );
  i ++ ) {
    res ^= strA . charAt ( i );
  }
  for ( i = 0;
  i < strB . length ( );
  i ++ ) {
    res ^= strB . charAt ( i );
  }
  return ( ( char ) ( res ) );
}


CHECK_WHETHER_TWO_STRINGS_ARE_ANAGRAM_OF_EACH_OTHER | static boolean areAnagram ( char [ ] str1, char [ ] str2 ) {
  int n1 = str1 . length;
  int n2 = str2 . length;
  if ( n1 != n2 ) return false;
  Arrays . sort ( str1 );
  Arrays . sort ( str2 );
  for ( int i = 0;
  i < n1;
  i ++ ) if ( str1 [ i ] != str2 [ i ] ) return false;
  return true;
}


CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING | static int calcMaxValue ( String str ) {
  int res = str . charAt ( 0 ) - '0';
  for ( int i = 1;
  i < str . length ( );
  i ++ ) {
    if ( str . charAt ( i ) == '0' || str . charAt ( i ) == '1' || res < 2 ) res += ( str . charAt ( i ) - '0' );
    else res *= ( str . charAt ( i ) - '0' );
  }
  return res;
}


FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER | static int findSum ( int N, int K ) {
  int ans = 0;
  for ( int i = 1;
  i <= N;
  i ++ ) ans += ( i % K );
  return ans;
}


DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1 | static boolean checkCount ( int arr [ ], int n, int k ) {
  HashMap < Integer, Integer > hash = new HashMap < > ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( ! hash . containsKey ( arr [ i ] ) ) hash . put ( arr [ i ], 0 );
    hash . put ( arr [ i ], hash . get ( arr [ i ] ) + 1 );
  }
  for ( Map . Entry x : hash . entrySet ( ) ) if ( ( int ) x . getValue ( ) > 2 * k ) return false;
  return true;
}


SEARCH_IN_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX | private static void search ( int [ ] [ ] mat, int n, int x ) {
  int i = 0, j = n - 1;
  while ( i < n && j >= 0 ) {
    if ( mat [ i ] [ j ] == x ) {
      System . out . print ( "n Found at " + i + " " + j );
      return;
    }
    if ( mat [ i ] [ j ] > x ) j --;
    else i ++;
  }
  System . out . print ( "n Element not found" );
  return;
}


RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX | static StringBuilder findLeft ( StringBuilder str ) {
  int n = str . length ( );
  while ( n > 0 ) {
    n --;
    if ( str . charAt ( n ) == 'd' ) {
      str . setCharAt ( n, 'c' );
      break;
    }
    if ( str . charAt ( n ) == 'b' ) {
      str . setCharAt ( n, 'a' );
      break;
    }
    if ( str . charAt ( n ) == 'a' ) str . setCharAt ( n, 'b' );
    else if ( str . charAt ( n ) == 'c' ) str . setCharAt ( n, 'd' );
  }
  return str;
}


SUM_FACTORS_NUMBER | static int divSum ( int n ) {
  int result = 0;
  for ( int i = 2;
  i <= Math . sqrt ( n );
  i ++ ) {
    if ( n % i == 0 ) {
      if ( i == ( n / i ) ) result += i;
      else result += ( i + n / i );
    }
  }
  return ( result + n + 1 );
}


HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT_2 | static int sumDigits ( int no ) {
  return no == 0 ? 0 : no % 10 + sumDigits ( no / 10 );
}


CHECK_POSSIBLE_SORT_ARRAY_CONDITIONAL_SWAPPING_ADJACENT_ALLOWED | static boolean checkForSorting ( int arr [ ], int n ) {
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    if ( arr [ i ] > arr [ i + 1 ] ) {
      if ( arr [ i ] - arr [ i + 1 ] == 1 ) {
        int temp = arr [ i ];
        arr [ i ] = arr [ i + 1 ];
        arr [ i + 1 ] = temp;
      }
      else return false;
    }
  }
  return true;
}


SUPER_PRIME | static void SieveOfEratosthenes ( int n, boolean isPrime [ ] ) {
  isPrime [ 0 ] = isPrime [ 1 ] = false;
  for ( int i = 2;
  i <= n;
  i ++ ) isPrime [ i ] = true;
  for ( int p = 2;
  p * p <= n;
  p ++ ) {
    if ( isPrime [ p ] == true ) {
      for ( int i = p * 2;
      i <= n;
      i += p ) isPrime [ i ] = false;
    }
  }
}


PROGRAM_BINARY_DECIMAL_CONVERSION_1 | static int binaryToDecimal ( String n ) {
  String num = n;
  int dec_value = 0;
  int base = 1;
  int len = num . length ( );
  for ( int i = len - 1;
  i >= 0;
  i -- ) {
    if ( num . charAt ( i ) == '1' ) dec_value += base;
    base = base * 2;
  }
  return dec_value;
}


LEONARDO_NUMBER | static int leonardo ( int n ) {
  if ( n == 0 || n == 1 ) return 1;
  return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 );
}


CHECK_ARRAY_CONTAINS_CONTIGUOUS_INTEGERS_DUPLICATES_ALLOWED_1 | static Boolean areElementsContiguous ( int arr [ ], int n ) {
  HashSet < Integer > us = new HashSet < Integer > ( );
  for ( int i = 0;
  i < n;
  i ++ ) us . add ( arr [ i ] );
  int count = 1;
  int curr_ele = arr [ 0 ] - 1;
  while ( us . contains ( curr_ele ) == true ) {
    count ++;
    curr_ele --;
  }
  curr_ele = arr [ 0 ] + 1;
  while ( us . contains ( curr_ele ) == true ) {
    count ++;
    curr_ele ++;
  }
  return ( count == ( us . size ( ) ) );
}


SQUARE_ROOT_OF_AN_INTEGER | static int floorSqrt ( int x ) {
  if ( x == 0 || x == 1 ) return x;
  int i = 1, result = 1;
  while ( result <= x ) {
    i ++;
    result = i * i;
  }
  return i - 1;
}


LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_LEAST_K_TIMES | static void subsequence ( char s [ ], char t [ ], int n, int k ) {
  int last = 0, cnt = 0, new_last = 0, size = 0;
  for ( char ch = 'z';
  ch >= 'a';
  ch -- ) {
    cnt = 0;
    for ( int i = last;
    i < n;
    i ++ ) {
      if ( s [ i ] == ch ) cnt ++;
    }
    if ( cnt >= k ) {
      for ( int i = last;
      i < n;
      i ++ ) {
        if ( s [ i ] == ch ) {
          t [ size ++ ] = ch;
          new_last = i;
        }
      }
      last = new_last;
    }
  }
  t [ size ] = '\0';
}


RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM | static int breakSum ( int n ) {
  if ( n == 0 || n == 1 ) return n;
  return Math . max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ), n );
}


MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY | public static int minSwaps ( int [ ] arr ) {
  int n = arr . length;
  ArrayList < Pair < Integer, Integer > > arrpos = new ArrayList < Pair < Integer, Integer > > ( );
  for ( int i = 0;
  i < n;
  i ++ ) arrpos . add ( new Pair < Integer, Integer > ( arr [ i ], i ) );
  arrpos . sort ( new Comparator < Pair < Integer, Integer > > ( ) {
    @ Override public int compare ( Pair < Integer, Integer > o1, Pair < Integer, Integer > o2 ) {
      if ( o1 . getKey ( ) > o2 . getKey ( ) ) return - 1;
      else if ( o1 . getKey ( ) . equals ( o2 . getKey ( ) ) ) return 0;
      else return 1;
    }
  }
  );
  Boolean [ ] vis = new Boolean [ n ];
  Arrays . fill ( vis, false );
  int ans = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( vis [ i ] || arrpos . get ( i ) . getValue ( ) == i ) continue;
    int cycle_size = 0;
    int j = i;
    while ( ! vis [ j ] ) {
      vis [ j ] = true;
      j = arrpos . get ( j ) . getValue ( );
      cycle_size ++;
    }
    if ( cycle_size > 0 ) {
      ans += ( cycle_size - 1 );
    }
  }
  return ans;
}


DIAGONALLY_DOMINANT_MATRIX | static boolean isDDM ( int m [ ] [ ], int n ) {
  for ( int i = 0;
  i < n;
  i ++ ) {
    int sum = 0;
    for ( int j = 0;
    j < n;
    j ++ ) sum += Math . abs ( m [ i ] [ j ] );
    sum -= Math . abs ( m [ i ] [ i ] );
    if ( Math . abs ( m [ i ] [ i ] ) < sum ) return false;
  }
  return true;
}


SPLIT_N_MAXIMUM_COMPOSITE_NUMBERS | static int count ( int n ) {
  if ( n < 4 ) return - 1;
  int rem = n % 4;
  if ( rem == 0 ) return n / 4;
  if ( rem == 1 ) {
    if ( n < 9 ) return - 1;
    return ( n - 9 ) / 4 + 1;
  }
  if ( rem == 2 ) return ( n - 6 ) / 4 + 1;
  if ( rem == 3 ) {
    if ( n < 15 ) return - 1;
    return ( n - 15 ) / 4 + 2;
  }
  return 0;
}


FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE | static void findDimen ( int H, int A ) {
  if ( H * H < 4 * A ) {
    System . out . println ( "Not Possible" );
    return;
  }
  double apb = Math . sqrt ( H * H + 4 * A );
  double asb = Math . sqrt ( H * H - 4 * A );
  System . out . println ( "P = " + Math . round ( ( ( apb - asb ) / 2.0 ) * 100.0 ) / 100.0 );
  System . out . print ( "B = " + Math . round ( ( ( apb + asb ) / 2.0 ) * 100.0 ) / 100.0 );
}


PRODUCT_MAXIMUM_FIRST_ARRAY_MINIMUM_SECOND_1 | public static int minMaxProduct ( int arr1 [ ], int arr2 [ ], int n1, int n2 ) {
  int max = arr1 [ 0 ];
  int min = arr2 [ 0 ];
  int i;
  for ( i = 1;
  i < n1 && i < n2;
  ++ i ) {
    if ( arr1 [ i ] > max ) max = arr1 [ i ];
    if ( arr2 [ i ] < min ) min = arr2 [ i ];
  }
  while ( i < n1 ) {
    if ( arr1 [ i ] > max ) max = arr1 [ i ];
    i ++;
  }
  while ( i < n2 ) {
    if ( arr2 [ i ] < min ) min = arr2 [ i ];
    i ++;
  }
  return max * min;
}


PROGRAM_CALCULATE_VOLUME_OCTAHEDRON | static double vol_of_octahedron ( double side ) {
  return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) );
}


SORT_STRING_CHARACTERS_1 | public static String sortString ( String inputString ) {
  char tempArray [ ] = inputString . toCharArray ( );
  Arrays . sort ( tempArray );
  return new String ( tempArray );
}


MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL | static void moveSpaceInFront ( char str [ ] ) {
  int i = str . length - 1;
  for ( int j = i;
  j >= 0;
  j -- ) if ( str [ j ] != ' ' ) str [ i -- ] = str [ j ];
  while ( i >= 0 ) str [ i -- ] = ' ';
}


MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL | static int minOps ( int arr [ ], int n, int k ) {
  Arrays . sort ( arr );
  int max = arr [ arr . length - 1 ];
  int res = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( ( max - arr [ i ] ) % k != 0 ) return - 1;
    else res += ( max - arr [ i ] ) / k;
  }
  return res;
}


PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1 | static int factorial ( int n ) {
  int res = 1, i;
  for ( i = 2;
  i <= n;
  i ++ ) res *= i;
  return res;
}


MINIMUM_TIME_TO_FINISH_TASKS_WITHOUT_SKIPPING_TWO_CONSECUTIVE | static int minTime ( int arr [ ], int n ) {
  if ( n <= 0 ) return 0;
  int incl = arr [ 0 ];
  int excl = 0;
  for ( int i = 1;
  i < n;
  i ++ ) {
    int incl_new = arr [ i ] + Math . min ( excl, incl );
    int excl_new = incl;
    incl = incl_new;
    excl = excl_new;
  }
  return Math . min ( incl, excl );
}


CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT | public static boolean areEqual ( int arr1 [ ], int arr2 [ ] ) {
  int n = arr1 . length;
  int m = arr2 . length;
  if ( n != m ) return false;
  Arrays . sort ( arr1 );
  Arrays . sort ( arr2 );
  for ( int i = 0;
  i < n;
  i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false;
  return true;
}


MINIMUM_DIFFERENCE_MAX_MIN_K_SIZE_SUBSETS | static int minDifferenceAmongMaxMin ( int arr [ ], int N, int K ) {
  Arrays . sort ( arr );
  int res = 2147483647;
  for ( int i = 0;
  i <= ( N - K );
  i ++ ) {
    int curSeqDiff = arr [ i + K - 1 ] - arr [ i ];
    res = Math . min ( res, curSeqDiff );
  }
  return res;
}


SWAP_BITS_IN_A_GIVEN_NUMBER | static int swapBits ( int x, int p1, int p2, int n ) {
  int set1 = ( x > > p1 ) & ( ( 1 << n ) - 1 );
  int set2 = ( x > > p2 ) & ( ( 1 << n ) - 1 );
  int xor = ( set1 ^ set2 );
  xor = ( xor << p1 ) | ( xor << p2 );
  int result = x ^ xor;
  return result;
}


COUNT_NUMBER_OF_WAYS_TO_FILL_A_N_X_4_GRID_USING_1_X_4_TILES | static int count ( int n ) {
  int [ ] dp = new int [ n + 1 ];
  dp [ 0 ] = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) {
    if ( i >= 1 && i <= 3 ) dp [ i ] = 1;
    else if ( i == 4 ) dp [ i ] = 2;
    else {
      dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ];
    }
  }
  return dp [ n ];
}


MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1 | static char maxRepeating ( String str ) {
  int n = str . length ( );
  int count = 0;
  char res = str . charAt ( 0 );
  int cur_count = 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) cur_count ++;
    else {
      if ( cur_count > count ) {
        count = cur_count;
        res = str . charAt ( i );
      }
      cur_count = 1;
    }
  }
  return res;
}


PASCAL_TRIANGLE | public static void printPascal ( int n ) {
  int [ ] [ ] arr = new int [ n ] [ n ];
  for ( int line = 0;
  line < n;
  line ++ ) {
    for ( int i = 0;
    i <= line;
    i ++ ) {
      if ( line == i || i == 0 ) arr [ line ] [ i ] = 1;
      else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ];
      System . out . print ( arr [ line ] [ i ] );
    }
    System . out . println ( "" );
  }
}


TURN_OFF_THE_RIGHTMOST_SET_BIT | static int fun ( int n ) {
  return n & ( n - 1 );
}


REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE | public static void rearrange ( int arr [ ], int n ) {
  int max_idx = n - 1, min_idx = 0;
  int max_elem = arr [ n - 1 ] + 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( i % 2 == 0 ) {
      arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem;
      max_idx --;
    }
    else {
      arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem;
      min_idx ++;
    }
  }
  for ( int i = 0;
  i < n;
  i ++ ) arr [ i ] = arr [ i ] / max_elem;
}


COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX | static int countZeroes ( int mat [ ] [ ] ) {
  int row = N - 1, col = 0;
  int count = 0;
  while ( col < N ) {
    while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count;
    count += ( row + 1 );
    col ++;
  }
  return count;
}


MINIMUM_COST_FOR_ACQUIRING_ALL_COINS_WITH_K_EXTRA_COINS_ALLOWED_WITH_EVERY_COIN | static int minCost ( int coin [ ], int n, int k ) {
  Arrays . sort ( coin );
  int coins_needed = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) );
  int ans = 0;
  for ( int i = 0;
  i <= coins_needed - 1;
  i ++ ) ans += coin [ i ];
  return ans;
}


COUNT_SUBARRAYS_TOTAL_DISTINCT_ELEMENTS_ORIGINAL_ARRAY | static int countDistictSubarray ( int arr [ ], int n ) {
  HashMap < Integer, Integer > vis = new HashMap < Integer, Integer > ( ) {
    @ Override public Integer get ( Object key ) {
      if ( ! containsKey ( key ) ) return 0;
      return super . get ( key );
    }
  };
  for ( int i = 0;
  i < n;
  ++ i ) vis . put ( arr [ i ], 1 );
  int k = vis . size ( );
  vis . clear ( );
  int ans = 0, right = 0, window = 0;
  for ( int left = 0;
  left < n;
  ++ left ) {
    while ( right < n && window < k ) {
      vis . put ( arr [ right ], vis . get ( arr [ right ] ) + 1 );
      if ( vis . get ( arr [ right ] ) == 1 ) ++ window;
      ++ right;
    }
    if ( window == k ) ans += ( n - right + 1 );
    vis . put ( arr [ left ], vis . get ( arr [ left ] ) - 1 );
    if ( vis . get ( arr [ left ] ) == 0 ) -- window;
  }
  return ans;
}


FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT | static void possibleOrNot ( long a1, long a2, long b1, long b2, long c1, long c2 ) {
  long dis1 = ( long ) Math . pow ( b1 - a1, 2 ) + ( long ) Math . pow ( b2 - a2, 2 );
  long dis2 = ( long ) Math . pow ( c1 - b1, 2 ) + ( long ) Math . pow ( c2 - b2, 2 );
  if ( dis1 != dis2 ) System . out . print ( "No" );
  else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) System . out . print ( "No" );
  else System . out . print ( "Yes" );
}


TIME_MEET_ANIMALS | static void timeToMeet ( double s, double v ) {
  double V = 3 * v / 2;
  double time = s / V;
  System . out . println ( ( float ) time );
}


BRESENHAMS_LINE_GENERATION_ALGORITHM | static void bresenham ( int x1, int y1, int x2, int y2 ) {
  int m_new = 2 * ( y2 - y1 );
  int slope_error_new = m_new - ( x2 - x1 );
  for ( int x = x1, y = y1;
  x <= x2;
  x ++ ) {
    System . out . print ( "(" + x + "," + y + ")\n" );
    slope_error_new += m_new;
    if ( slope_error_new >= 0 ) {
      y ++;
      slope_error_new -= 2 * ( x2 - x1 );
    }
  }
}


MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS | static int maxNumOfChocolates ( int arr [ ], int n, int k ) {
  HashMap < Integer, Integer > um = new HashMap < Integer, Integer > ( );
  int [ ] sum = new int [ n ];
  int curr_rem;
  int maxSum = 0;
  sum [ 0 ] = arr [ 0 ];
  for ( int i = 1;
  i < n;
  i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ];
  for ( int i = 0;
  i < n;
  i ++ ) {
    curr_rem = sum [ i ] % k;
    if ( curr_rem == 0 ) {
      if ( maxSum < sum [ i ] ) maxSum = sum [ i ];
    }
    else if ( ! um . containsKey ( curr_rem ) ) um . put ( curr_rem, i );
    else if ( maxSum < ( sum [ i ] - sum [ um . get ( curr_rem ) ] ) ) maxSum = sum [ i ] - sum [ um . get ( curr_rem ) ];
  }
  return ( maxSum / k );
}


CHECK_TWO_STRINGS_K_ANAGRAMS_NOT_1 | static boolean areKAnagrams ( String str1, String str2, int k ) {
  int n = str1 . length ( );
  if ( str2 . length ( ) != n ) return false;
  int [ ] hash_str1 = new int [ MAX_CHAR ];
  for ( int i = 0;
  i < n;
  i ++ ) hash_str1 [ str1 . charAt ( i ) - 'a' ] ++;
  int count = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( hash_str1 [ str2 . charAt ( i ) - 'a' ] > 0 ) hash_str1 [ str2 . charAt ( i ) - 'a' ] --;
    else count ++;
    if ( count > k ) return false;
  }
  return true;
}


DIVISIBILITY_CHECK | static void divisibilityCheck ( List < Integer > arr, int n ) {
  List < Integer > s = new ArrayList < Integer > ( );
  int max_ele = Integer . MIN_VALUE;
  for ( int i = 0;
  i < n;
  i ++ ) {
    s . add ( arr . get ( i ) );
    max_ele = Math . max ( max_ele, arr . get ( i ) );
  }
  LinkedHashSet < Integer > res = new LinkedHashSet < Integer > ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( arr . get ( i ) != 0 ) for ( int j = arr . get ( i ) * 2;
    j <= max_ele;
    j += arr . get ( i ) ) {
      if ( s . contains ( j ) ) res . add ( j );
    }
  }
  List < Integer > list = new ArrayList < Integer > ( res );
  Collections . reverse ( list );
  for ( Integer temp : list ) System . out . print ( temp + " " );
}


MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER | static int maxPrefix ( String s, String t ) {
  int count = 0;
  for ( int i = 0;
  i < t . length ( );
  i ++ ) {
    if ( count == t . length ( ) ) break;
    if ( t . charAt ( i ) == s . charAt ( count ) ) count ++;
  }
  return count;
}


COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K | static void countDistinct ( int arr [ ], int k ) {
  HashMap < Integer, Integer > hM = new HashMap < Integer, Integer > ( );
  int dist_count = 0;
  for ( int i = 0;
  i < k;
  i ++ ) {
    if ( hM . get ( arr [ i ] ) == null ) {
      hM . put ( arr [ i ], 1 );
      dist_count ++;
    }
    else {
      int count = hM . get ( arr [ i ] );
      hM . put ( arr [ i ], count + 1 );
    }
  }
  System . out . println ( dist_count );
  for ( int i = k;
  i < arr . length;
  i ++ ) {
    if ( hM . get ( arr [ i - k ] ) == 1 ) {
      hM . remove ( arr [ i - k ] );
      dist_count --;
    }
    else {
      int count = hM . get ( arr [ i - k ] );
      hM . put ( arr [ i - k ], count - 1 );
    }
    if ( hM . get ( arr [ i ] ) == null ) {
      hM . put ( arr [ i ], 1 );
      dist_count ++;
    }
    else {
      int count = hM . get ( arr [ i ] );
      hM . put ( arr [ i ], count + 1 );
    }
    System . out . println ( dist_count );
  }
}


LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K | static int longestSubsequenceCommonSegment ( int k, String s1, String s2 ) {
  int n = s1 . length ( );
  int m = s2 . length ( );
  int lcs [ ] [ ] = new int [ n + 1 ] [ m + 1 ];
  int cnt [ ] [ ] = new int [ n + 1 ] [ m + 1 ];
  for ( int i = 1;
  i <= n;
  i ++ ) {
    for ( int j = 1;
    j <= m;
    j ++ ) {
      lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ], lcs [ i ] [ j - 1 ] );
      if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 ) ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1;
      if ( cnt [ i ] [ j ] >= k ) {
        for ( int a = k;
        a <= cnt [ i ] [ j ];
        a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ], lcs [ i - a ] [ j - a ] + a );
      }
    }
  }
  return lcs [ n ] [ m ];
}


PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1 | static void printDistinct ( int arr [ ], int n ) {
  Arrays . sort ( arr );
  for ( int i = 0;
  i < n;
  i ++ ) {
    while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++;
    System . out . print ( arr [ i ] + " " );
  }
}


PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES | static boolean isPrime ( int p ) {
  double checkNumber = Math . pow ( 2, p ) - 1;
  double nextval = 4 % checkNumber;
  for ( int i = 1;
  i < p - 1;
  i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber;
  return ( nextval == 0 );
}


KTH_NON_REPEATING_CHARACTER | static int kthNonRepeating ( String str, int k ) {
  int n = str . length ( );
  int [ ] count = new int [ MAX_CHAR ];
  int [ ] index = new int [ MAX_CHAR ];
  for ( int i = 0;
  i < MAX_CHAR;
  i ++ ) {
    count [ i ] = 0;
    index [ i ] = n;
  }
  for ( int i = 0;
  i < n;
  i ++ ) {
    char x = str . charAt ( i );
    ++ count [ x ];
    if ( count [ x ] == 1 ) index [ x ] = i;
    if ( count [ x ] == 2 ) index [ x ] = n;
  }
  Arrays . sort ( index );
  return ( index [ k - 1 ] != n ) ? index [ k - 1 ] : - 1;
}


FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE | static char first ( String str ) {
  for ( int i = 0;
  i < str . length ( );
  i ++ ) if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i );
  return 0;
}


GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND | static boolean isSubSequence ( String str1, String str2, int m, int n ) {
  if ( m == 0 ) return true;
  if ( n == 0 ) return false;
  if ( str1 . charAt ( m - 1 ) == str2 . charAt ( n - 1 ) ) return isSubSequence ( str1, str2, m - 1, n - 1 );
  return isSubSequence ( str1, str2, m, n - 1 );
}


C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1 | static int largest ( int [ ] arr, int n ) {
  Arrays . sort ( arr );
  return arr [ n - 1 ];
}


DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY | static int findDiff ( int arr [ ], int n ) {
  Arrays . sort ( arr );
  int count = 0, max_count = 0, min_count = n;
  for ( int i = 0;
  i < ( n - 1 );
  i ++ ) {
    if ( arr [ i ] == arr [ i + 1 ] ) {
      count += 1;
      continue;
    }
    else {
      max_count = Math . max ( max_count, count );
      min_count = Math . min ( min_count, count );
      count = 0;
    }
  }
  return ( max_count - min_count );
}


PROGRAM_FOR_FACTORIAL_OF_A_NUMBER | static int factorial ( int n ) {
  if ( n == 0 ) return 1;
  return n * factorial ( n - 1 );
}


