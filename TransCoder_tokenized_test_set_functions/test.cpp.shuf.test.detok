MAXIMUM_NUMBER_CHARACTERS_TWO_CHARACTER_STRING | int maximumChars ( string & str ) {
  int n = str . length ( );
  int res = - 1;
  for ( int i = 0;
  i < n - 1;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) if ( str [ i ] == str [ j ] ) res = max ( res, abs ( j - i - 1 ) );
  return res;
}


FIND_MIRROR_IMAGE_POINT_2_D_PLANE | pair < double, double > mirrorImage ( double a, double b, double c, double x1, double y1 ) {
  double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b );
  double x = temp * a + x1;
  double y = temp * b + y1;
  return make_pair ( x, y );
}


EFFICIENTLY_COMPUTE_SUMS_OF_DIAGONALS_OF_A_MATRIX | void printDiagonalSums ( int mat [ ] [ MAX ], int n ) {
  int principal = 0, secondary = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( i == j ) principal += mat [ i ] [ j ];
      if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ];
    }
  }
  cout << "Principal Diagonal:" << principal << endl;
  cout << "Secondary Diagonal:" << secondary << endl;
}


COUNTS_PATHS_POINT_REACH_ORIGIN | int countPaths ( int n, int m ) {
  if ( n == 0 || m == 0 ) return 1;
  return ( countPaths ( n - 1, m ) + countPaths ( n, m - 1 ) );
}


FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_1 | bool find3Numbers ( int A [ ], int arr_size, int sum ) {
  int l, r;
  sort ( A, A + arr_size );
  for ( int i = 0;
  i < arr_size - 2;
  i ++ ) {
    l = i + 1;
    r = arr_size - 1;
    while ( l < r ) {
      if ( A [ i ] + A [ l ] + A [ r ] == sum ) {
        printf ( "Triplet is %d, %d, %d", A [ i ], A [ l ], A [ r ] );
        return true;
      }
      else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++;
      else r --;
    }
  }
  return false;
}


CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT | bool isMagicSquare ( int mat [ ] [ N ] ) {
  int sum = 0, sum2 = 0;
  for ( int i = 0;
  i < N;
  i ++ ) sum = sum + mat [ i ] [ i ];
  for ( int i = 0;
  i < N;
  i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ];
  if ( sum != sum2 ) return false;
  for ( int i = 0;
  i < N;
  i ++ ) {
    int rowSum = 0;
    for ( int j = 0;
    j < N;
    j ++ ) rowSum += mat [ i ] [ j ];
    if ( rowSum != sum ) return false;
  }
  for ( int i = 0;
  i < N;
  i ++ ) {
    int colSum = 0;
    for ( int j = 0;
    j < N;
    j ++ ) colSum += mat [ j ] [ i ];
    if ( sum != colSum ) return false;
  }
  return true;
}


SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1 | int getTotalNumberOfSequences ( int m, int n ) {
  int T [ m + 1 ] [ n + 1 ];
  for ( int i = 0;
  i < m + 1;
  i ++ ) {
    for ( int j = 0;
    j < n + 1;
    j ++ ) {
      if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0;
      else if ( i < j ) T [ i ] [ j ] = 0;
      else if ( j == 1 ) T [ i ] [ j ] = i;
      else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ];
    }
  }
  return T [ m ] [ n ];
}


FIND_DIFFERENCE_BETWEEN_SUMS_OF_TWO_DIAGONALS_1 | int difference ( int arr [ ] [ MAX ], int n ) {
  int d1 = 0, d2 = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    d1 += arr [ i ] [ i ];
    d2 += arr [ i ] [ n - i - 1 ];
  }
  return abs ( d1 - d2 );
}


MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS | int subset ( int ar [ ], int n ) {
  int res = 0;
  sort ( ar, ar + n );
  for ( int i = 0;
  i < n;
  i ++ ) {
    int count = 1;
    for (;
    i < n - 1;
    i ++ ) {
      if ( ar [ i ] == ar [ i + 1 ] ) count ++;
      else break;
    }
    res = max ( res, count );
  }
  return res;
}


DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS | string decToBin ( int n ) {
  if ( n == 0 ) return "0";
  string bin = "";
  while ( n > 0 ) {
    bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin;
    n >>= 1;
  }
  return bin;
}


FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE | string Dragon_Curve_Sequence ( int n ) {
  string s = "1";
  for ( int i = 2;
  i <= n;
  i ++ ) {
    string temp = "1";
    char prev = '1', zero = '0', one = '1';
    for ( int j = 0;
    j < s . length ( );
    j ++ ) {
      temp += s [ j ];
      if ( prev == '0' ) {
        temp += one;
        prev = one;
      }
      else {
        temp += zero;
        prev = zero;
      }
    }
    s = temp;
  }
  return s;
}


STACK_SET_3_REVERSE_STRING_USING_STACK | void reverse ( char str [ ] ) {
  int n = strlen ( str ), i;
  for ( i = 0;
  i < n / 2;
  i ++ ) swap ( & str [ i ], & str [ n - i - 1 ] );
}


SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER_1 | void bitonicGenerator ( int arr [ ], int n ) {
  int i = 1;
  int j = n - 1;
  if ( j % 2 != 0 ) j --;
  while ( i < j ) {
    swap ( arr [ i ], arr [ j ] );
    i += 2;
    j -= 2;
  }
  sort ( arr, arr + ( n + 1 ) / 2 );
  sort ( arr + ( n + 1 ) / 2, arr + n, greater < int > ( ) );
}


GIVEN_TWO_NUMBERS_B_FIND_X_X_B | void modularEquation ( int a, int b ) {
  if ( a < b ) {
    cout << "No solution possible " << endl;
    return;
  }
  if ( a == b ) {
    cout << "Infinite Solution possible " << endl;
    return;
  }
  int count = 0;
  int n = a - b;
  int y = sqrt ( a - b );
  for ( int i = 1;
  i <= y;
  ++ i ) {
    if ( n % i == 0 ) {
      if ( n / i > b ) count ++;
      if ( i > b ) count ++;
    }
  }
  if ( y * y == n && y > b ) count --;
  cout << count << endl;
}


CHECK_CHARACTERS_GIVEN_STRING_CAN_REARRANGED_FORM_PALINDROME | bool canFormPalindrome ( string str ) {
  int count [ NO_OF_CHARS ] = {
    0 };
    for ( int i = 0;
    str [ i ];
    i ++ ) count [ str [ i ] ] ++;
    int odd = 0;
    for ( int i = 0;
    i < NO_OF_CHARS;
    i ++ ) {
      if ( count [ i ] & 1 ) odd ++;
      if ( odd > 1 ) return false;
    }
    return true;
  }
  

MAXIMUM_TRIPLET_SUM_ARRAY_1 | int maxTripletSum ( int arr [ ], int n ) {
  sort ( arr, arr + n );
  return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ];
}


FIND_MEDIAN_ROW_WISE_SORTED_MATRIX | int binaryMedian ( int m [ ] [ MAX ], int r, int c ) {
  int min = INT_MAX, max = INT_MIN;
  for ( int i = 0;
  i < r;
  i ++ ) {
    if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ];
    if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ];
  }
  int desired = ( r * c + 1 ) / 2;
  while ( min < max ) {
    int mid = min + ( max - min ) / 2;
    int place = 0;
    for ( int i = 0;
    i < r;
    ++ i ) place += upper_bound ( m [ i ], m [ i ] + c, mid ) - m [ i ];
    if ( place < desired ) min = mid + 1;
    else max = mid;
  }
  return min;
}


HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN | int findHeight ( int * parent, int n ) {
  int res = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int p = i, current = 1;
    while ( parent [ p ] != - 1 ) {
      current ++;
      p = parent [ p ];
    }
    res = max ( res, current );
  }
  return res;
}


CHECK_LARGE_NUMBER_DIVISIBLE_20 | bool divisibleBy20 ( string num ) {
  int lastTwoDigits = stoi ( num . substr ( num . length ( ) - 2, num . length ( ) - 1 ) );
  return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) );
}


MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING | int maxDP ( int n ) {
  int res [ n + 1 ];
  res [ 0 ] = 0;
  res [ 1 ] = 1;
  for ( int i = 2;
  i <= n;
  i ++ ) res [ i ] = max ( i, ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) );
  return res [ n ];
}


QUERIES_ON_ARRAY_WITH_DISAPPEARING_AND_REAPPEARING_ELEMENTS | void PerformQueries ( vector < int > & a, vector < pair < long long, int > > & vec ) {
  vector < int > ans;
  int n = ( int ) a . size ( ) - 1;
  int q = ( int ) vec . size ( );
  for ( int i = 0;
  i < q;
  ++ i ) {
    long long t = vec [ i ] . first;
    int m = vec [ i ] . second;
    if ( m > n ) {
      ans . push_back ( - 1 );
      continue;
    }
    int turn = t / n;
    int rem = t % n;
    if ( rem == 0 and turn % 2 == 1 ) {
      ans . push_back ( - 1 );
      continue;
    }
    if ( rem == 0 and turn % 2 == 0 ) {
      ans . push_back ( a [ m ] );
      continue;
    }
    if ( turn % 2 == 0 ) {
      int cursize = n - rem;
      if ( cursize < m ) {
        ans . push_back ( - 1 );
        continue;
      }
      ans . push_back ( a [ m + rem ] );
    }
    else {
      int cursize = rem;
      if ( cursize < m ) {
        ans . push_back ( - 1 );
        continue;
      }
      ans . push_back ( a [ m ] );
    }
  }
  for ( int i : ans ) cout << i << "\n";
}


FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS_1 | int minDist ( int arr [ ], int n, int x, int y ) {
  int i = 0;
  int min_dist = INT_MAX;
  int prev;
  for ( i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] == x || arr [ i ] == y ) {
      prev = i;
      break;
    }
  }
  for (;
  i < n;
  i ++ ) {
    if ( arr [ i ] == x || arr [ i ] == y ) {
      if ( arr [ prev ] != arr [ i ] && ( i - prev ) < min_dist ) {
        min_dist = i - prev;
        prev = i;
      }
      else prev = i;
    }
  }
  return min_dist;
}


UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2 | int printUnion ( int arr1 [ ], int arr2 [ ], int m, int n ) {
  int i = 0, j = 0;
  while ( i < m && j < n ) {
    if ( arr1 [ i ] < arr2 [ j ] ) cout << arr1 [ i ++ ] << " ";
    else if ( arr2 [ j ] < arr1 [ i ] ) cout << arr2 [ j ++ ] << " ";
    else {
      cout << arr2 [ j ++ ] << " ";
      i ++;
    }
  }
  while ( i < m ) cout << arr1 [ i ++ ] << " ";
  while ( j < n ) cout << arr2 [ j ++ ] << " ";
}


WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION | void solveWordWrap ( int arr [ ], int n, int k ) {
  int i, j;
  int currlen;
  int cost;
  int dp [ n ];
  int ans [ n ];
  dp [ n - 1 ] = 0;
  ans [ n - 1 ] = n - 1;
  for ( i = n - 2;
  i >= 0;
  i -- ) {
    currlen = - 1;
    dp [ i ] = INT_MAX;
    for ( j = i;
    j < n;
    j ++ ) {
      currlen += ( arr [ j ] + 1 );
      if ( currlen > k ) break;
      if ( j == n - 1 ) cost = 0;
      else cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ];
      if ( cost < dp [ i ] ) {
        dp [ i ] = cost;
        ans [ i ] = j;
      }
    }
  }
  i = 0;
  while ( i < n ) {
    cout << i + 1 << " " << ans [ i ] + 1 << " ";
    i = ans [ i ] + 1;
  }
}


COUNT_DISTINCT_SUBSEQUENCES | int countSub ( string str ) {
  vector < int > last ( MAX_CHAR, - 1 );
  int n = str . length ( );
  int dp [ n + 1 ];
  dp [ 0 ] = 1;
  for ( int i = 1;
  i <= n;
  i ++ ) {
    dp [ i ] = 2 * dp [ i - 1 ];
    if ( last [ str [ i - 1 ] ] != - 1 ) dp [ i ] = dp [ i ] - dp [ last [ str [ i - 1 ] ] ];
    last [ str [ i - 1 ] ] = ( i - 1 );
  }
  return dp [ n ];
}


LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3 | int findLength ( string str, int n ) {
  int ans = 0;
  for ( int i = 0;
  i <= n - 2;
  i ++ ) {
    int l = i, r = i + 1;
    int lsum = 0, rsum = 0;
    while ( r < n && l >= 0 ) {
      lsum += str [ l ] - '0';
      rsum += str [ r ] - '0';
      if ( lsum == rsum ) ans = max ( ans, r - l + 1 );
      l --;
      r ++;
    }
  }
  return ans;
}


MAXIMUM_PATH_SUM_MATRIX | int findMaxPath ( int mat [ ] [ M ] ) {
  for ( int i = 1;
  i < N;
  i ++ ) {
    for ( int j = 0;
    j < M;
    j ++ ) {
      if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ], max ( mat [ i - 1 ] [ j - 1 ], mat [ i - 1 ] [ j + 1 ] ) );
      else if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ], mat [ i - 1 ] [ j - 1 ] );
      else if ( j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ], mat [ i - 1 ] [ j + 1 ] );
    }
  }
  int res = 0;
  for ( int j = 0;
  j < M;
  j ++ ) res = max ( mat [ N - 1 ] [ j ], res );
  return res;
}


MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING | char maxRepeating ( string str ) {
  int len = str . length ( );
  int count = 0;
  char res = str [ 0 ];
  for ( int i = 0;
  i < len;
  i ++ ) {
    int cur_count = 1;
    for ( int j = i + 1;
    j < len;
    j ++ ) {
      if ( str [ i ] != str [ j ] ) break;
      cur_count ++;
    }
    if ( cur_count > count ) {
      count = cur_count;
      res = str [ i ];
    }
  }
  return res;
}


MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHER_0_1 | int maxLenSub ( int arr [ ], int n ) {
  int mls [ n ], max = 0;
  for ( int i = 0;
  i < n;
  i ++ ) mls [ i ] = 1;
  for ( int i = 1;
  i < n;
  i ++ ) for ( int j = 0;
  j < i;
  j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1;
  for ( int i = 0;
  i < n;
  i ++ ) if ( max < mls [ i ] ) max = mls [ i ];
  return max;
}


BREAKING_NUMBER_FIRST_PART_INTEGRAL_DIVISION_SECOND_POWER_10 | int calculate ( string N ) {
  int len = N . length ( );
  int l = ( len ) / 2;
  int count = 0;
  for ( int i = 1;
  i <= l;
  i ++ ) {
    string s = N . substr ( 0, i );
    int l1 = s . length ( );
    string t = N . substr ( i, l1 );
    if ( s [ 0 ] == '0' || t [ 0 ] == '0' ) continue;
    if ( s . compare ( t ) == 0 ) count ++;
  }
  return count;
}


PROGRAM_BINARY_DECIMAL_CONVERSION | int binaryToDecimal ( int n ) {
  int num = n;
  int dec_value = 0;
  int base = 1;
  int temp = num;
  while ( temp ) {
    int last_digit = temp % 10;
    temp = temp / 10;
    dec_value += last_digit * base;
    base = base * 2;
  }
  return dec_value;
}


HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT | public : int getSum ( int n ) {
  int sum = 0;
  while ( n != 0 ) {
    sum = sum + n % 10;
    n = n / 10;
  }
  return sum;
}


FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES | int findSDSFunc ( int n ) {
  int DP [ n + 1 ];
  DP [ 0 ] = 0;
  DP [ 1 ] = 1;
  for ( int i = 2;
  i <= n;
  i ++ ) {
    if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ];
    else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ];
  }
  return DP [ n ];
}


NUMBER_SINK_NODES_GRAPH | int countSink ( int n, int m, int edgeFrom [ ], int edgeTo [ ] ) {
  int mark [ n ];
  memset ( mark, 0, sizeof mark );
  for ( int i = 0;
  i < m;
  i ++ ) mark [ edgeFrom [ i ] ] = 1;
  int count = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) if ( ! mark [ i ] ) count ++;
  return count;
}


BREAK_NUMBER_THREE_PARTS | ll count_of_ways ( ll n ) {
  ll count = 0;
  for ( int i = 0;
  i <= n;
  i ++ ) for ( int j = 0;
  j <= n;
  j ++ ) for ( int k = 0;
  k <= n;
  k ++ ) if ( i + j + k == n ) count ++;
  return count;
}


PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY | void printDistinct ( int arr [ ], int n ) {
  for ( int i = 0;
  i < n;
  i ++ ) {
    int j;
    for ( j = 0;
    j < i;
    j ++ ) if ( arr [ i ] == arr [ j ] ) break;
    if ( i == j ) cout << arr [ i ] << " ";
  }
}


MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C | int maximumSegments ( int n, int a, int b, int c ) {
  int dp [ n + 1 ];
  memset ( dp, - 1, sizeof ( dp ) );
  dp [ 0 ] = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( dp [ i ] != - 1 ) {
      if ( i + a <= n ) dp [ i + a ] = max ( dp [ i ] + 1, dp [ i + a ] );
      if ( i + b <= n ) dp [ i + b ] = max ( dp [ i ] + 1, dp [ i + b ] );
      if ( i + c <= n ) dp [ i + c ] = max ( dp [ i ] + 1, dp [ i + c ] );
    }
  }
  return dp [ n ];
}


CHECK_VALID_SEQUENCE_DIVISIBLE_M | bool isPossible ( int n, int index, int sum, int M, int arr [ ], int dp [ ] [ MAX ] ) {
  if ( index == n ) {
    if ( ( sum % M ) == 0 ) return true;
    return false;
  }
  if ( dp [ index ] [ sum ] != - 1 ) return dp [ index ] [ sum ];
  bool placeAdd = isPossible ( n, index + 1, sum + arr [ index ], M, arr, dp );
  bool placeMinus = isPossible ( n, index + 1, sum - arr [ index ], M, arr, dp );
  bool res = ( placeAdd || placeMinus );
  dp [ index ] [ sum ] = res;
  return res;
}


FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY | int findGreatest ( int arr [ ], int n ) {
  int result = - 1;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 0;
  j < n - 1;
  j ++ ) for ( int k = j + 1;
  k < n;
  k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = max ( result, arr [ i ] );
  return result;
}


MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION | int maxSubArraySumRepeated ( int a [ ], int n, int k ) {
  int max_so_far = INT_MIN, max_ending_here = 0;
  for ( int i = 0;
  i < n * k;
  i ++ ) {
    max_ending_here = max_ending_here + a [ i % n ];
    if ( max_so_far < max_ending_here ) max_so_far = max_ending_here;
    if ( max_ending_here < 0 ) max_ending_here = 0;
  }
  return max_so_far;
}


LEONARDO_NUMBER_1 | int leonardo ( int n ) {
  int dp [ n + 1 ];
  dp [ 0 ] = dp [ 1 ] = 1;
  for ( int i = 2;
  i <= n;
  i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1;
  return dp [ n ];
}


SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER | int sumOfSubstrings ( string num ) {
  int n = num . length ( );
  int sumofdigit [ n ];
  sumofdigit [ 0 ] = toDigit ( num [ 0 ] );
  int res = sumofdigit [ 0 ];
  for ( int i = 1;
  i < n;
  i ++ ) {
    int numi = toDigit ( num [ i ] );
    sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ];
    res += sumofdigit [ i ];
  }
  return res;
}


PRUFER_CODE_TREE_CREATION | void printTreeEdges ( int prufer [ ], int m ) {
  int vertices = m + 2;
  int vertex_set [ vertices ];
  for ( int i = 0;
  i < vertices;
  i ++ ) vertex_set [ i ] = 0;
  for ( int i = 0;
  i < vertices - 2;
  i ++ ) vertex_set [ prufer [ i ] - 1 ] += 1;
  cout << "\nThe edge set E(G) is :\n";
  int j = 0;
  for ( int i = 0;
  i < vertices - 2;
  i ++ ) {
    for ( j = 0;
    j < vertices;
    j ++ ) {
      if ( vertex_set [ j ] == 0 ) {
        vertex_set [ j ] = - 1;
        cout << "(" << ( j + 1 ) << ", " << prufer [ i ] << ")  ";
        vertex_set [ prufer [ i ] - 1 ] --;
        break;
      }
    }
  }
  j = 0;
  for ( int i = 0;
  i < vertices;
  i ++ ) {
    if ( vertex_set [ i ] == 0 && j == 0 ) {
      cout << "(" << ( i + 1 ) << ", ";
      j ++;
    }
    else if ( vertex_set [ i ] == 0 && j == 1 ) cout << ( i + 1 ) << ")\n";
  }
}


PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCLE | int findMinimumAngle ( int arr [ ], int n ) {
  int l = 0, sum = 0, ans = 360;
  for ( int i = 0;
  i < n;
  i ++ ) {
    sum += arr [ i ];
    while ( sum >= 180 ) {
      ans = min ( ans, 2 * abs ( 180 - sum ) );
      sum -= arr [ l ];
      l ++;
    }
    ans = min ( ans, 2 * abs ( 180 - sum ) );
  }
  return ans;
}


FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH | int findMaxAverage ( int arr [ ], int n, int k ) {
  if ( k > n ) return - 1;
  int * csum = new int [ n ];
  csum [ 0 ] = arr [ 0 ];
  for ( int i = 1;
  i < n;
  i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ];
  int max_sum = csum [ k - 1 ], max_end = k - 1;
  for ( int i = k;
  i < n;
  i ++ ) {
    int curr_sum = csum [ i ] - csum [ i - k ];
    if ( curr_sum > max_sum ) {
      max_sum = curr_sum;
      max_end = i;
    }
  }
  delete [ ] csum;
  return max_end - k + 1;
}


SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES | int findS ( int s ) {
  int sum = 0;
  for ( int n = 1;
  sum < s;
  n ++ ) {
    sum += n * n;
    if ( sum == s ) return n;
  }
  return - 1;
}


PROGRAM_TO_CALCULATE_AREA_OF_AN_CIRCLE_INSCRIBED_IN_A_SQUARE | float areaOfInscribedCircle ( float a ) {
  return ( PI / 4 ) * a * a;
}


MINIMUM_NUMBER_CHARACTERS_REMOVED_MAKE_BINARY_STRING_ALTERNATE | void countToMake0lternate ( const string & s ) {
  int result = 0;
  for ( int i = 0;
  i < ( s . length ( ) - 1 );
  i ++ ) if ( s [ i ] == s [ i + 1 ] ) result ++;
  return result;
}


FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND | void findMissing ( int a [ ], int b [ ], int n, int m ) {
  for ( int i = 0;
  i < n;
  i ++ ) {
    int j;
    for ( j = 0;
    j < m;
    j ++ ) if ( a [ i ] == b [ j ] ) break;
    if ( j == m ) cout << a [ i ] << " ";
  }
}


REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM | void rearrange ( int arr [ ], int n ) {
  int temp [ n ];
  int small = 0, large = n - 1;
  int flag = true;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( flag ) temp [ i ] = arr [ large -- ];
    else temp [ i ] = arr [ small ++ ];
    flag = ! flag;
  }
  for ( int i = 0;
  i < n;
  i ++ ) arr [ i ] = temp [ i ];
}


DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE | int lbs ( int arr [ ], int n ) {
  int i, j;
  int * lis = new int [ n ];
  for ( i = 0;
  i < n;
  i ++ ) lis [ i ] = 1;
  for ( i = 1;
  i < n;
  i ++ ) for ( j = 0;
  j < i;
  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1;
  int * lds = new int [ n ];
  for ( i = 0;
  i < n;
  i ++ ) lds [ i ] = 1;
  for ( i = n - 2;
  i >= 0;
  i -- ) for ( j = n - 1;
  j > i;
  j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1;
  int max = lis [ 0 ] + lds [ 0 ] - 1;
  for ( i = 1;
  i < n;
  i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1;
  return max;
}


COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY | int countPairs ( int arr [ ], int n ) {
  int result = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = i + 1;
    j < n;
    j ++ ) {
      int product = arr [ i ] * arr [ j ];
      for ( int k = 0;
      k < n;
      k ++ ) {
        if ( arr [ k ] == product ) {
          result ++;
          break;
        }
      }
    }
  }
  return result;
}


COUNT_SINGLE_NODE_ISOLATED_SUB_GRAPHS_DISCONNECTED_GRAPH | int compute ( vector < int > graph [ ], int N ) {
  int count = 0;
  for ( int i = 1;
  i <= N;
  i ++ ) if ( graph [ i ] . size ( ) == 0 ) count ++;
  return count;
}


HARDY_RAMANUJAN_THEOREM | int exactPrimeFactorCount ( int n ) {
  int count = 0;
  if ( n % 2 == 0 ) {
    count ++;
    while ( n % 2 == 0 ) n = n / 2;
  }
  for ( int i = 3;
  i <= sqrt ( n );
  i = i + 2 ) {
    if ( n % i == 0 ) {
      count ++;
      while ( n % i == 0 ) n = n / i;
    }
  }
  if ( n > 2 ) count ++;
  return count;
}


SHORTEST_COMMON_SUPERSEQUENCE_1 | int superSeq ( char * X, char * Y, int m, int n ) {
  int dp [ m + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= m;
  i ++ ) {
    for ( int j = 0;
    j <= n;
    j ++ ) {
      if ( ! i ) dp [ i ] [ j ] = j;
      else if ( ! j ) dp [ i ] [ j ] = i;
      else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ];
      else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] );
    }
  }
  return dp [ m ] [ n ];
}


POWER_SET | public : void printPowerSet ( char * set, int set_size ) {
  unsigned int pow_set_size = pow ( 2, set_size );
  int counter, j;
  for ( counter = 0;
  counter < pow_set_size;
  counter ++ ) {
    for ( j = 0;
    j < set_size;
    j ++ ) {
      if ( counter & ( 1 << j ) ) cout << set [ j ];
    }
    cout << endl;
  }
}


CHECK_ARRAY_MAJORITY_ELEMENT | bool isMajority ( int a [ ], int n ) {
  unordered_map < int, int > mp;
  for ( int i = 0;
  i < n;
  i ++ ) mp [ a [ i ] ] ++;
  for ( auto x : mp ) if ( x . second >= n / 2 ) return true;
  return false;
}


PRINT_GIVEN_MATRIX_COUNTER_CLOCK_WISE_SPIRAL_FORM | void counterClockspiralPrint ( int m, int n, int arr [ R ] [ C ] ) {
  int i, k = 0, l = 0;
  int cnt = 0;
  int total = m * n;
  while ( k < m && l < n ) {
    if ( cnt == total ) break;
    for ( i = k;
    i < m;
    ++ i ) {
      cout << arr [ i ] [ l ] << " ";
      cnt ++;
    }
    l ++;
    if ( cnt == total ) break;
    for ( i = l;
    i < n;
    ++ i ) {
      cout << arr [ m - 1 ] [ i ] << " ";
      cnt ++;
    }
    m --;
    if ( cnt == total ) break;
    if ( k < m ) {
      for ( i = m - 1;
      i >= k;
      -- i ) {
        cout << arr [ i ] [ n - 1 ] << " ";
        cnt ++;
      }
      n --;
    }
    if ( cnt == total ) break;
    if ( l < n ) {
      for ( i = n - 1;
      i >= l;
      -- i ) {
        cout << arr [ k ] [ i ] << " ";
        cnt ++;
      }
      k ++;
    }
  }
}


PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD | bool isPrime ( int n ) {
  if ( n <= 1 ) return false;
  for ( int i = 2;
  i < n;
  i ++ ) if ( n % i == 0 ) return false;
  return true;
}


FIND_CHARACTER_FIRST_STRING_PRESENT_MINIMUM_INDEX_SECOND_STRING | void printMinIndexChar ( string str, string patt ) {
  int minIndex = INT_MAX;
  int m = str . size ( );
  int n = patt . size ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < m;
    j ++ ) {
      if ( patt [ i ] == str [ j ] && j < minIndex ) {
        minIndex = j;
        break;
      }
    }
  }
  if ( minIndex != INT_MAX ) cout << "Minimum Index Character = " << str [ minIndex ];
  else cout << "No character present";
}


PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_1 | void transpose ( int A [ ] [ N ], int B [ ] [ M ] ) {
  int i, j;
  for ( i = 0;
  i < N;
  i ++ ) for ( j = 0;
  j < M;
  j ++ ) B [ i ] [ j ] = A [ j ] [ i ];
}


COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER | int countNumber ( int n ) {
  int result = 0;
  for ( int i = 1;
  i <= 9;
  i ++ ) {
    stack < int > s;
    if ( i <= n ) {
      s . push ( i );
      result ++;
    }
    while ( ! s . empty ( ) ) {
      int tp = s . top ( );
      s . pop ( );
      for ( int j = tp % 10;
      j <= 9;
      j ++ ) {
        int x = tp * 10 + j;
        if ( x <= n ) {
          s . push ( x );
          result ++;
        }
      }
    }
  }
  return result;
}


FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X | int firstFactorialDivisibleNumber ( int x ) {
  int i = 1;
  int fact = 1;
  for ( i = 1;
  i < x;
  i ++ ) {
    fact = fact * i;
    if ( fact % x == 0 ) break;
  }
  return i;
}


PRINT_EQUAL_SUM_SETS_ARRAY_PARTITION_PROBLEM_SET_2 | void printEqualSumSets ( int arr [ ], int n ) {
  int i, currSum;
  int sum = accumulate ( arr, arr + n, 0 );
  if ( sum & 1 ) {
    cout << "-1";
    return;
  }
  int k = sum >> 1;
  bool dp [ n + 1 ] [ k + 1 ];
  for ( i = 1;
  i <= k;
  i ++ ) dp [ 0 ] [ i ] = false;
  for ( i = 0;
  i <= n;
  i ++ ) dp [ i ] [ 0 ] = true;
  for ( i = 1;
  i <= n;
  i ++ ) {
    for ( currSum = 1;
    currSum <= k;
    currSum ++ ) {
      dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ];
      if ( arr [ i - 1 ] <= currSum ) dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ];
    }
  }
  vector < int > set1, set2;
  if ( ! dp [ n ] [ k ] ) {
    cout << "-1\n";
    return;
  }
  i = n;
  currSum = k;
  while ( i > 0 && currSum >= 0 ) {
    if ( dp [ i - 1 ] [ currSum ] ) {
      i --;
      set2 . push_back ( arr [ i ] );
    }
    else if ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) {
      i --;
      currSum -= arr [ i ];
      set1 . push_back ( arr [ i ] );
    }
  }
  cout << "Set 1 elements: ";
  for ( i = 0;
  i < set1 . size ( );
  i ++ ) cout << set1 [ i ] << " ";
  cout << "\nSet 2 elements: ";
  for ( i = 0;
  i < set2 . size ( );
  i ++ ) cout << set2 [ i ] << " ";
}


COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1 | int numberOfWays ( int x ) {
  int dp [ x + 1 ];
  dp [ 0 ] = dp [ 1 ] = 1;
  for ( int i = 2;
  i <= x;
  i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ];
  return dp [ x ];
}


COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX | int countNegative ( int M [ ] [ 4 ], int n, int m ) {
  int count = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < m;
    j ++ ) {
      if ( M [ i ] [ j ] < 0 ) count += 1;
      else break;
    }
  }
  return count;
}


COUNT_SET_BITS_IN_AN_INTEGER | unsigned int countSetBits ( unsigned int n ) {
  unsigned int count = 0;
  while ( n ) {
    count += n & 1;
    n >>= 1;
  }
  return count;
}


MODULUS_TWO_FLOAT_DOUBLE_NUMBERS | double findMod ( double a, double b ) {
  double mod;
  if ( a < 0 ) mod = - a;
  else mod = a;
  if ( b < 0 ) b = - b;
  while ( mod >= b ) mod = mod - b;
  if ( a < 0 ) return - mod;
  return mod;
}


FIND_A_SPECIFIC_PAIR_IN_MATRIX_1 | int findMaxValue ( int mat [ ] [ N ] ) {
  int maxValue = INT_MIN;
  int maxArr [ N ] [ N ];
  maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ];
  int maxv = mat [ N - 1 ] [ N - 1 ];
  for ( int j = N - 2;
  j >= 0;
  j -- ) {
    if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ];
    maxArr [ N - 1 ] [ j ] = maxv;
  }
  maxv = mat [ N - 1 ] [ N - 1 ];
  for ( int i = N - 2;
  i >= 0;
  i -- ) {
    if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ];
    maxArr [ i ] [ N - 1 ] = maxv;
  }
  for ( int i = N - 2;
  i >= 0;
  i -- ) {
    for ( int j = N - 2;
    j >= 0;
    j -- ) {
      if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ];
      maxArr [ i ] [ j ] = max ( mat [ i ] [ j ], max ( maxArr [ i ] [ j + 1 ], maxArr [ i + 1 ] [ j ] ) );
    }
  }
  return maxValue;
}


MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY | int solve ( int arr [ ], int n ) {
  sort ( arr, arr + n );
  int a = 0, b = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( i & 1 ) a = a * 10 + arr [ i ];
    else b = b * 10 + arr [ i ];
  }
  return a + b;
}


COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2_1 | int countSolutions ( int n ) {
  int x = 0, yCount, res = 0;
  for ( yCount = 0;
  yCount * yCount < n;
  yCount ++ );
  while ( yCount != 0 ) {
    res += yCount;
    x ++;
    while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount --;
  }
  return res;
}


FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME | int findIndex ( int n ) {
  if ( n <= 1 ) return n;
  int a = 0, b = 1, c = 1;
  int res = 1;
  while ( c < n ) {
    c = a + b;
    res ++;
    a = b;
    b = c;
  }
  return res;
}


PROGRAM_OCTAL_DECIMAL_CONVERSION | int octalToDecimal ( int n ) {
  int num = n;
  int dec_value = 0;
  int base = 1;
  int temp = num;
  while ( temp ) {
    int last_digit = temp % 10;
    temp = temp / 10;
    dec_value += last_digit * base;
    base = base * 8;
  }
  return dec_value;
}


FIND_PERMUTED_ROWS_GIVEN_ROW_MATRIX | void permutatedRows ( int mat [ ] [ MAX ], int m, int n, int r ) {
  unordered_set < int > s;
  for ( int j = 0;
  j < n;
  j ++ ) s . insert ( mat [ r ] [ j ] );
  for ( int i = 0;
  i < m;
  i ++ ) {
    if ( i == r ) continue;
    int j;
    for ( j = 0;
    j < n;
    j ++ ) if ( s . find ( mat [ i ] [ j ] ) == s . end ( ) ) break;
    if ( j != n ) continue;
    cout << i << ", ";
  }
}


PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES | string noAdjacentDup ( string s ) {
  int n = s . length ( );
  for ( int i = 1;
  i < n;
  i ++ ) {
    if ( s [ i ] == s [ i - 1 ] ) {
      s [ i ] = 'a';
      while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++;
      i ++;
    }
  }
  return s;
}


SUM_MANHATTAN_DISTANCES_PAIRS_POINTS | int distancesum ( int x [ ], int y [ ], int n ) {
  int sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) );
  return sum;
}


PROGRAM_FIND_STRING_START_END_GEEKS | bool isCornerPresent ( string str, string corner ) {
  int n = str . length ( );
  int cl = corner . length ( );
  if ( n < cl ) return false;
  return ( str . substr ( 0, cl ) . compare ( corner ) == 0 && str . substr ( n - cl, cl ) . compare ( corner ) == 0 );
}


LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S | int lenOfLongSubarr ( int arr [ ], int n ) {
  unordered_map < int, int > um;
  int sum = 0, maxLen = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    sum += arr [ i ] == 0 ? - 1 : 1;
    if ( sum == 1 ) maxLen = i + 1;
    else if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i;
    if ( um . find ( sum - 1 ) != um . end ( ) ) {
      if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um [ sum - 1 ];
    }
  }
  return maxLen;
}


DIVIDE_CONQUER_SET_6_SEARCH_ROW_WISE_COLUMN_WISE_SORTED_2D_ARRAY | void search ( int mat [ ROW ] [ COL ], int fromRow, int toRow, int fromCol, int toCol, int key ) {
  int i = fromRow + ( toRow - fromRow ) / 2;
  int j = fromCol + ( toCol - fromCol ) / 2;
  if ( mat [ i ] [ j ] == key ) cout << "Found " << key << " at " << i << " " << j << endl;
  else {
    if ( i != toRow || j != fromCol ) search ( mat, fromRow, i, j, toCol, key );
    if ( fromRow == toRow && fromCol + 1 == toCol ) if ( mat [ fromRow ] [ toCol ] == key ) cout << "Found " << key << " at " << fromRow << " " << toCol << endl;
    if ( mat [ i ] [ j ] < key ) {
      if ( i + 1 <= toRow ) search ( mat, i + 1, toRow, fromCol, toCol, key );
    }
    else {
      if ( j - 1 >= fromCol ) search ( mat, fromRow, toRow, fromCol, j - 1, key );
    }
  }
}


SHORTEST_COMMON_SUPERSEQUENCE | int superSeq ( char * X, char * Y, int m, int n ) {
  if ( ! m ) return n;
  if ( ! n ) return m;
  if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X, Y, m - 1, n - 1 );
  return 1 + min ( superSeq ( X, Y, m - 1, n ), superSeq ( X, Y, m, n - 1 ) );
}


URLIFY_GIVEN_STRING_REPLACE_SPACES | int replaceSpaces ( char str [ ] ) {
  int space_count = 0, i;
  for ( i = 0;
  str [ i ];
  i ++ ) if ( str [ i ] == ' ' ) space_count ++;
  while ( str [ i - 1 ] == ' ' ) {
    space_count --;
    i --;
  }
  int new_length = i + space_count * 2 + 1;
  if ( new_length > MAX ) return - 1;
  int index = new_length - 1;
  str [ index -- ] = '\0';
  for ( int j = i - 1;
  j >= 0;
  j -- ) {
    if ( str [ j ] == ' ' ) {
      str [ index ] = '0';
      str [ index - 1 ] = '2';
      str [ index - 2 ] = '%';
      index = index - 3;
    }
    else {
      str [ index ] = str [ j ];
      index --;
    }
  }
  return new_length;
}


MAXIMUM_PATH_SUM_STARTING_CELL_0_TH_ROW_ENDING_CELL_N_1_TH_ROW | int MaximumPath ( int Mat [ ] [ N ] ) {
  int result = 0;
  int dp [ N ] [ N + 2 ];
  memset ( dp, 0, sizeof ( dp ) );
  for ( int i = 0;
  i < N;
  i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ];
  for ( int i = 1;
  i < N;
  i ++ ) for ( int j = 1;
  j <= N;
  j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ], max ( dp [ i - 1 ] [ j ], dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ];
  for ( int i = 0;
  i <= N;
  i ++ ) result = max ( result, dp [ N - 1 ] [ i ] );
  return result;
}


COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING | unsigned int getAbs ( int n ) {
  int const mask = n >> ( sizeof ( int ) * CHARBIT - 1 );
  return ( ( n + mask ) ^ mask );
}


COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1 | int countPS ( int i, int j ) {
  if ( i >= n || j < 0 ) return 0;
  if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ];
  if ( abs ( i - j ) == 1 ) {
    if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = 3;
    else return dp [ i ] [ j ] = 2;
  }
  if ( i == j ) return dp [ 1 ] [ j ] = 1;
  else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1, j ) + countPS ( i, j - 1 ) + 1;
  else return dp [ i ] [ j ] = countPS ( i + 1, j ) + countPS ( i, j - 1 ) - countPS ( i + 1, j - 1 );
}


LARGEST_SUM_CONTIGUOUS_SUBARRAY_2 | int maxSubArraySum ( int a [ ], int size ) {
  int max_so_far = a [ 0 ];
  int curr_max = a [ 0 ];
  for ( int i = 1;
  i < size;
  i ++ ) {
    curr_max = max ( a [ i ], curr_max + a [ i ] );
    max_so_far = max ( max_so_far, curr_max );
  }
  return max_so_far;
}


COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY | int countMinOperations ( unsigned int target [ ], int n ) {
  int result = 0;
  while ( 1 ) {
    int zero_count = 0;
    int i;
    for ( i = 0;
    i < n;
    i ++ ) {
      if ( target [ i ] & 1 ) break;
      else if ( target [ i ] == 0 ) zero_count ++;
    }
    if ( zero_count == n ) return result;
    if ( i == n ) {
      for ( int j = 0;
      j < n;
      j ++ ) target [ j ] = target [ j ] / 2;
      result ++;
    }
    for ( int j = i;
    j < n;
    j ++ ) {
      if ( target [ j ] & 1 ) {
        target [ j ] --;
        result ++;
      }
    }
  }
}


PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1 | void fib ( int n ) {
  int a = 0, b = 1;
  if ( n >= 0 ) cout << a << " ";
  if ( n >= 1 ) cout << b << " ";
  for ( int i = 2;
  i <= n;
  i ++ ) {
    cout << a + b << " ";
    b = a + b;
    a = b - a;
  }
}


PROGRAM_CHECK_INPUT_INTEGER_STRING | bool isNumber ( string s ) {
  for ( int i = 0;
  i < s . length ( );
  i ++ ) if ( isdigit ( s [ i ] ) == false ) return false;
  return true;
}


MINIMUM_HEIGHT_TRIANGLE_GIVEN_BASE_AREA | int minHeight ( int base, int area ) {
  return ceil ( ( float ) ( 2 * area ) / base );
}


FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7 | int findpos ( string n ) {
  int i = 0, pos = 0;
  while ( n [ i ] != '\0' ) {
    switch ( n [ i ] ) {
      case '4' : pos = pos * 2 + 1;
      break;
      case '7' : pos = pos * 2 + 2;
      break;
    }
    i ++;
  }
  return pos;
}


MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX | int minOperation ( bool arr [ N ] [ M ] ) {
  int ans = 0;
  for ( int i = N - 1;
  i >= 0;
  i -- ) {
    for ( int j = M - 1;
    j >= 0;
    j -- ) {
      if ( arr [ i ] [ j ] == 0 ) {
        ans ++;
        for ( int k = 0;
        k <= i;
        k ++ ) {
          for ( int h = 0;
          h <= j;
          h ++ ) {
            if ( arr [ k ] [ h ] == 1 ) arr [ k ] [ h ] = 0;
            else arr [ k ] [ h ] = 1;
          }
        }
      }
    }
  }
  return ans;
}


LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2 | int findLength ( string str, int n ) {
  int sum [ n + 1 ];
  sum [ 0 ] = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) sum [ i ] = ( sum [ i - 1 ] + str [ i - 1 ] - '0' );
  int ans = 0;
  for ( int len = 2;
  len <= n;
  len += 2 ) {
    for ( int i = 0;
    i <= n - len;
    i ++ ) {
      int j = i + len - 1;
      if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len / 2 ] ) ans = max ( ans, len );
    }
  }
  return ans;
}


MULTIPLY_LARGE_NUMBERS_REPRESENTED_AS_STRINGS | string multiply ( string num1, string num2 ) {
  int len1 = num1 . size ( );
  int len2 = num2 . size ( );
  if ( len1 == 0 || len2 == 0 ) return "0";
  vector < int > result ( len1 + len2, 0 );
  int i_n1 = 0;
  int i_n2 = 0;
  for ( int i = len1 - 1;
  i >= 0;
  i -- ) {
    int carry = 0;
    int n1 = num1 [ i ] - '0';
    i_n2 = 0;
    for ( int j = len2 - 1;
    j >= 0;
    j -- ) {
      int n2 = num2 [ j ] - '0';
      int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry;
      carry = sum / 10;
      result [ i_n1 + i_n2 ] = sum % 10;
      i_n2 ++;
    }
    if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry;
    i_n1 ++;
  }
  int i = result . size ( ) - 1;
  while ( i >= 0 && result [ i ] == 0 ) i --;
  if ( i == - 1 ) return "0";
  string s = "";
  while ( i >= 0 ) s += std :: to_string ( result [ i -- ] );
  return s;
}


PARTITION_NUMBER_TWO_DIVISBLE_PARTS | void findDivision ( string & str, int a, int b ) {
  int len = str . length ( );
  vector < int > lr ( len + 1, 0 );
  lr [ 0 ] = ( str [ 0 ] - '0' ) % a;
  for ( int i = 1;
  i < len;
  i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( str [ i ] - '0' ) ) % a;
  vector < int > rl ( len + 1, 0 );
  rl [ len - 1 ] = ( str [ len - 1 ] - '0' ) % b;
  int power10 = 10;
  for ( int i = len - 2;
  i >= 0;
  i -- ) {
    rl [ i ] = ( rl [ i + 1 ] + ( str [ i ] - '0' ) * power10 ) % b;
    power10 = ( power10 * 10 ) % b;
  }
  for ( int i = 0;
  i < len - 1;
  i ++ ) {
    if ( lr [ i ] != 0 ) continue;
    if ( rl [ i + 1 ] == 0 ) {
      cout << "YES\n";
      for ( int k = 0;
      k <= i;
      k ++ ) cout << str [ k ];
      cout << ", ";
      for ( int k = i + 1;
      k < len;
      k ++ ) cout << str [ k ];
      return;
    }
  }
  cout << "NO\n";
}


PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT | void bestFit ( int blockSize [ ], int m, int processSize [ ], int n ) {
  int allocation [ n ];
  memset ( allocation, - 1, sizeof ( allocation ) );
  for ( int i = 0;
  i < n;
  i ++ ) {
    int bestIdx = - 1;
    for ( int j = 0;
    j < m;
    j ++ ) {
      if ( blockSize [ j ] >= processSize [ i ] ) {
        if ( bestIdx == - 1 ) bestIdx = j;
        else if ( blockSize [ bestIdx ] > blockSize [ j ] ) bestIdx = j;
      }
    }
    if ( bestIdx != - 1 ) {
      allocation [ i ] = bestIdx;
      blockSize [ bestIdx ] -= processSize [ i ];
    }
  }
  cout << "\nProcess No.\tProcess Size\tBlock no.\n";
  for ( int i = 0;
  i < n;
  i ++ ) {
    cout << "   " << i + 1 << "\t\t" << processSize [ i ] << "\t\t";
    if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 1;
    else cout << "Not Allocated";
    cout << endl;
  }
}


FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS | int largestKSubmatrix ( int a [ ] [ Col ] ) {
  int dp [ Row ] [ Col ];
  memset ( dp, sizeof ( dp ), 0 );
  int result = 0;
  for ( int i = 0;
  i < Row;
  i ++ ) {
    for ( int j = 0;
    j < Col;
    j ++ ) {
      if ( i == 0 || j == 0 ) dp [ i ] [ j ] = 1;
      else {
        if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] ), dp [ i - 1 ] [ j - 1 ] ) + 1;
        else dp [ i ] [ j ] = 1;
      }
      result = max ( result, dp [ i ] [ j ] );
    }
  }
  return result;
}


FRIENDS_PAIRING_PROBLEM_1 | int countFriendsPairings ( int n ) {
  if ( dp [ n ] != - 1 ) return dp [ n ];
  if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 );
  else return dp [ n ] = n;
}


FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY | int firstElement ( int arr [ ], int n, int k ) {
  unordered_map < int, int > count_map;
  for ( int i = 0;
  i < n;
  i ++ ) count_map [ arr [ i ] ] ++;
  for ( int i = 0;
  i < n;
  i ++ ) if ( count_map [ arr [ i ] ] == k ) return arr [ i ];
  return - 1;
}


SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS | float sumOfSeries ( int n ) {
  return ( 0.666 ) * ( 1 - 1 / pow ( 10, n ) );
}


COUNT_WORDS_IN_A_GIVEN_STRING | unsigned countWords ( char * str ) {
  int state = OUT;
  unsigned wc = 0;
  while ( * str ) {
    if ( * str == ' ' || * str == '\n' || * str == '\t' ) state = OUT;
    else if ( state == OUT ) {
      state = IN;
      ++ wc;
    }
    ++ str;
  }
  return wc;
}


PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_THE_DIFFERENCE_OF_SUMS_IS_MAXIMUM | int maxDifference ( int arr [ ], int N, int k ) {
  int M, S = 0, S1 = 0, max_difference = 0;
  for ( int i = 0;
  i < N;
  i ++ ) S += arr [ i ];
  sort ( arr, arr + N, greater < int > ( ) );
  M = max ( k, N - k );
  for ( int i = 0;
  i < M;
  i ++ ) S1 += arr [ i ];
  max_difference = S1 - ( S - S1 );
  return max_difference;
}


HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP | public : void printNos ( unsigned int n ) {
  if ( n > 0 ) {
    printNos ( n - 1 );
    cout << n << " ";
  }
  return;
}


GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1 | int pairsInSortedRotated ( int arr [ ], int n, int x ) {
  int i;
  for ( i = 0;
  i < n - 1;
  i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break;
  int l = ( i + 1 ) % n;
  int r = i;
  int cnt = 0;
  while ( l != r ) {
    if ( arr [ l ] + arr [ r ] == x ) {
      cnt ++;
      if ( l == ( r - 1 + n ) % n ) {
        return cnt;
      }
      l = ( l + 1 ) % n;
      r = ( r - 1 + n ) % n;
    }
    else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n;
    else r = ( n + r - 1 ) % n;
  }
  return cnt;
}


FIND_THE_ELEMENT_THAT_APPEARS_ONCE | int getSingle ( int arr [ ], int n ) {
  int ones = 0, twos = 0;
  int common_bit_mask;
  for ( int i = 0;
  i < n;
  i ++ ) {
    twos = twos | ( ones & arr [ i ] );
    ones = ones ^ arr [ i ];
    common_bit_mask = ~ ( ones & twos );
    ones &= common_bit_mask;
    twos &= common_bit_mask;
  }
  return ones;
}


CASSINIS_IDENTITY | int cassini ( int n ) {
  return ( n & 1 ) ? - 1 : 1;
}


DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION | bool distributingBalls ( int k, int n, string str ) {
  int a [ MAX_CHAR ] = {
    0 };
    for ( int i = 0;
    i < n;
    i ++ ) {
      a [ str [ i ] - 'a' ] ++;
    }
    for ( int i = 0;
    i < MAX_CHAR;
    i ++ ) if ( a [ i ] > k ) return false;
    return true;
  }
  

DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE | bool checkCount ( int arr [ ], int n, int k ) {
  int count;
  for ( int i = 0;
  i < n;
  i ++ ) {
    count = 0;
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( arr [ j ] == arr [ i ] ) count ++;
      if ( count > 2 * k ) return false;
    }
  }
  return true;
}


MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L | - 100000000 int findMaxValue ( int arr [ ], int n ) {
  if ( n < 4 ) {
    printf ( "The array should have atlest 4 elements\n" );
    return MIN;
  }
  int table1 [ n + 1 ], table2 [ n ], table3 [ n - 1 ], table4 [ n - 2 ];
  for ( int i = 0;
  i <= n;
  i ++ ) table1 [ i ] = table2 [ i ] = table3 [ i ] = table4 [ i ] = MIN;
  for ( int i = n - 1;
  i >= 0;
  i -- ) table1 [ i ] = max ( table1 [ i + 1 ], arr [ i ] );
  for ( int i = n - 2;
  i >= 0;
  i -- ) table2 [ i ] = max ( table2 [ i + 1 ], table1 [ i + 1 ] - arr [ i ] );
  for ( int i = n - 3;
  i >= 0;
  i -- ) table3 [ i ] = max ( table3 [ i + 1 ], table2 [ i + 1 ] + arr [ i ] );
  for ( int i = n - 4;
  i >= 0;
  i -- ) table4 [ i ] = max ( table4 [ i + 1 ], table3 [ i + 1 ] - arr [ i ] );
  return table4 [ 0 ];
}


COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_1 | int countNegative ( int M [ ] [ 4 ], int n, int m ) {
  int count = 0;
  int i = 0;
  int j = m - 1;
  while ( j >= 0 && i < n ) {
    if ( M [ i ] [ j ] < 0 ) {
      count += j + 1;
      i += 1;
    }
    else j -= 1;
  }
  return count;
}


SORT_AN_ARRAY_OF_0S_1S_AND_2S | void sort012 ( int a [ ], int arr_size ) {
  int lo = 0;
  int hi = arr_size - 1;
  int mid = 0;
  while ( mid <= hi ) {
    switch ( a [ mid ] ) {
      case 0 : swap ( a [ lo ++ ], a [ mid ++ ] );
      break;
      case 1 : mid ++;
      break;
      case 2 : swap ( a [ mid ], a [ hi -- ] );
      break;
    }
  }
}


NTH_EVEN_FIBONACCI_NUMBER | long int evenFib ( int n ) {
  if ( n < 1 ) return n;
  if ( n == 1 ) return 2;
  return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) );
}


NEXT_GREATER_ELEMENT | void printNGE ( int arr [ ], int n ) {
  int next, i, j;
  for ( i = 0;
  i < n;
  i ++ ) {
    next = - 1;
    for ( j = i + 1;
    j < n;
    j ++ ) {
      if ( arr [ i ] < arr [ j ] ) {
        next = arr [ j ];
        break;
      }
    }
    cout << arr [ i ] << " -- " << next << endl;
  }
}


CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_CIRCLE_INNER_CIRCLE | void fitOrNotFit ( int R, int r, int x, int y, int rad ) {
  double val = sqrt ( pow ( x, 2 ) + pow ( y, 2 ) );
  if ( val + rad <= R && val - rad >= R - r ) cout << "Fits\n";
  else cout << "Doesn't Fit\n";
}


BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS_1 | int gcdExtended ( int a, int b, int * x, int * y ) {
  if ( a == 0 ) {
    * x = 0;
    * y = 1;
    return b;
  }
  int x1, y1;
  int gcd = gcdExtended ( b % a, a, & x1, & y1 );
  * x = y1 - ( b / a ) * x1;
  * y = x1;
  return gcd;
}


FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS | void findSmallestRange ( int arr [ ] [ N ], int n, int k ) {
  int i, minval, maxval, minrange, minel, maxel, flag, minind;
  for ( i = 0;
  i <= k;
  i ++ ) ptr [ i ] = 0;
  minrange = INT_MAX;
  while ( 1 ) {
    minind = - 1;
    minval = INT_MAX;
    maxval = INT_MIN;
    flag = 0;
    for ( i = 0;
    i < k;
    i ++ ) {
      if ( ptr [ i ] == n ) {
        flag = 1;
        break;
      }
      if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) {
        minind = i;
        minval = arr [ i ] [ ptr [ i ] ];
      }
      if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) {
        maxval = arr [ i ] [ ptr [ i ] ];
      }
    }
    if ( flag ) break;
    ptr [ minind ] ++;
    if ( ( maxval - minval ) < minrange ) {
      minel = minval;
      maxel = maxval;
      minrange = maxel - minel;
    }
  }
  printf ( "The smallest range is [%d , %d]\n", minel, maxel );
}


FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STATION_IS_CONNECTED_IN_ONE_DIRECTION | INT_MAX int minCost ( int cost [ ] [ N ] ) {
  int dist [ N ];
  for ( int i = 0;
  i < N;
  i ++ ) dist [ i ] = INF;
  dist [ 0 ] = 0;
  for ( int i = 0;
  i < N;
  i ++ ) for ( int j = i + 1;
  j < N;
  j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ];
  return dist [ N - 1 ];
}


MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1 | int middleOfThree ( int a, int b, int c ) {
  if ( a > b ) {
    if ( b > c ) return b;
    else if ( a > c ) return c;
    else return a;
  }
  else {
    if ( a > c ) return a;
    else if ( b > c ) return c;
    else return b;
  }
}


CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT | int check ( string str ) {
  int n = str . length ( );
  int oddDigSum = 0, evenDigSum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - '0' );
    else evenDigSum += ( str [ i ] - '0' );
  }
  return ( ( oddDigSum - evenDigSum ) % 11 == 0 );
}


COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER | unsigned int getModulo ( unsigned int n, unsigned int d ) {
  return ( n & ( d - 1 ) );
}


COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS | int countStrings ( int n, int k ) {
  int dp [ n + 1 ] [ k + 1 ] [ 2 ];
  memset ( dp, 0, sizeof ( dp ) );
  dp [ 1 ] [ 0 ] [ 0 ] = 1;
  dp [ 1 ] [ 0 ] [ 1 ] = 1;
  for ( int i = 2;
  i <= n;
  i ++ ) {
    for ( int j = 0;
    j < i;
    j ++ ) {
      dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ];
      dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ];
      if ( j - 1 >= 0 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ];
    }
  }
  return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ];
}


FINDING_K_MODULUS_ARRAY_ELEMENT | void printEqualModNumbers ( int arr [ ], int n ) {
  sort ( arr, arr + n );
  int d = arr [ n - 1 ] - arr [ 0 ];
  vector < int > v;
  for ( int i = 1;
  i * i <= d;
  i ++ ) {
    if ( d % i == 0 ) {
      v . push_back ( i );
      if ( i != d / i ) v . push_back ( d / i );
    }
  }
  for ( int i = 0;
  i < v . size ( );
  i ++ ) {
    int temp = arr [ 0 ] % v [ i ];
    int j;
    for ( j = 1;
    j < n;
    j ++ ) if ( arr [ j ] % v [ i ] != temp ) break;
    if ( j == n ) cout << v [ i ] << " ";
  }
}


CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SPIRAL_WAY | void spiralFill ( int m, int n, int a [ ] [ MAX ] ) {
  int val = 1;
  int k = 0, l = 0;
  while ( k < m && l < n ) {
    for ( int i = l;
    i < n;
    ++ i ) a [ k ] [ i ] = val ++;
    k ++;
    for ( int i = k;
    i < m;
    ++ i ) a [ i ] [ n - 1 ] = val ++;
    n --;
    if ( k < m ) {
      for ( int i = n - 1;
      i >= l;
      -- i ) a [ m - 1 ] [ i ] = val ++;
      m --;
    }
    if ( l < n ) {
      for ( int i = m - 1;
      i >= k;
      -- i ) a [ i ] [ l ] = val ++;
      l ++;
    }
  }
}


FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2 | void printRepeating ( int arr [ ], int size ) {
  int Xor = arr [ 0 ];
  int set_bit_no;
  int i;
  int n = size - 2;
  int x = 0, y = 0;
  for ( i = 1;
  i < size;
  i ++ ) Xor ^= arr [ i ];
  for ( i = 1;
  i <= n;
  i ++ ) Xor ^= i;
  set_bit_no = Xor & ~ ( Xor - 1 );
  for ( i = 0;
  i < size;
  i ++ ) {
    if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ];
    else y = y ^ arr [ i ];
  }
  for ( i = 1;
  i <= n;
  i ++ ) {
    if ( i & set_bit_no ) x = x ^ i;
    else y = y ^ i;
  }
  cout << "The two repeating elements are " << y << " " << x;
}


COUNT_POSSIBLE_WAYS_TO_CONSTRUCT_BUILDINGS | int countWays ( int N ) {
  if ( N == 1 ) return 4;
  int countB = 1, countS = 1, prev_countB, prev_countS;
  for ( int i = 2;
  i <= N;
  i ++ ) {
    prev_countB = countB;
    prev_countS = countS;
    countS = prev_countB + prev_countS;
    countB = prev_countS;
  }
  int result = countS + countB;
  return ( result * result );
}


ONE_LINE_FUNCTION_FOR_FACTORIAL_OF_A_NUMBER | int factorial ( int n ) {
  return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 );
}


CHECK_GIVEN_MATRIX_SPARSE_NOT | bool isSparse ( int array [ ] [ MAX ], int m, int n ) {
  int counter = 0;
  for ( int i = 0;
  i < m;
  ++ i ) for ( int j = 0;
  j < n;
  ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter;
  return ( counter > ( ( m * n ) / 2 ) );
}


DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM | int knapSack ( int W, int wt [ ], int val [ ], int n ) {
  if ( n == 0 || W == 0 ) return 0;
  if ( wt [ n - 1 ] > W ) return knapSack ( W, wt, val, n - 1 );
  else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ], wt, val, n - 1 ), knapSack ( W, wt, val, n - 1 ) );
}


FIND_SUBARRAY_LEAST_AVERAGE | void findMinAvgSubarray ( int arr [ ], int n, int k ) {
  if ( n < k ) return;
  int res_index = 0;
  int curr_sum = 0;
  for ( int i = 0;
  i < k;
  i ++ ) curr_sum += arr [ i ];
  int min_sum = curr_sum;
  for ( int i = k;
  i < n;
  i ++ ) {
    curr_sum += arr [ i ] - arr [ i - k ];
    if ( curr_sum < min_sum ) {
      min_sum = curr_sum;
      res_index = ( i - k + 1 );
    }
  }
  cout << "Subarray between [" << res_index << ", " << res_index + k - 1 << "] has minimum average";
}


QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING | void query ( char s [ ], int i, int j ) {
  int n = strlen ( s );
  i %= n;
  j %= n;
  ( s [ i ] == s [ j ] ) ? ( cout << "Yes" << endl ) : ( cout << "No" << endl );
}


A_PRODUCT_ARRAY_PUZZLE_1 | void productArray ( int arr [ ], int n ) {
  if ( n == 1 ) {
    cout << 0;
    return;
  }
  int i, temp = 1;
  int * prod = new int [ ( sizeof ( int ) * n ) ];
  memset ( prod, 1, n );
  for ( i = 0;
  i < n;
  i ++ ) {
    prod [ i ] = temp;
    temp *= arr [ i ];
  }
  temp = 1;
  for ( i = n - 1;
  i >= 0;
  i -- ) {
    prod [ i ] *= temp;
    temp *= arr [ i ];
  }
  for ( i = 0;
  i < n;
  i ++ ) cout << prod [ i ] << " ";
  return;
}


FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS | void pairSum ( int mat [ ] [ MAX ], int n, int sum ) {
  for ( int i = 0;
  i < n;
  i ++ ) sort ( mat [ i ], mat [ i ] + n );
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    for ( int j = i + 1;
    j < n;
    j ++ ) {
      int left = 0, right = n - 1;
      while ( left < n && right >= 0 ) {
        if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) {
          cout << "(" << mat [ i ] [ left ] << ", " << mat [ j ] [ right ] << "), ";
          left ++;
          right --;
        }
        else {
          if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++;
          else right --;
        }
      }
    }
  }
}


CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES | bool isRotated ( string str1, string str2 ) {
  if ( str1 . length ( ) != str2 . length ( ) ) return false;
  string clock_rot = "";
  string anticlock_rot = "";
  int len = str2 . length ( );
  anticlock_rot = anticlock_rot + str2 . substr ( len - 2, 2 ) + str2 . substr ( 0, len - 2 );
  clock_rot = clock_rot + str2 . substr ( 2 ) + str2 . substr ( 0, 2 );
  return ( str1 . compare ( clock_rot ) == 0 || str1 . compare ( anticlock_rot ) == 0 );
}


N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN | int findNth ( int n ) {
  int count = 0;
  for ( int curr = 1;
  ;
  curr ++ ) {
    int sum = 0;
    for ( int x = curr;
    x > 0;
    x = x / 10 ) sum = sum + x % 10;
    if ( sum == 10 ) count ++;
    if ( count == n ) return curr;
  }
  return - 1;
}


PROGRAM_FIND_SLOPE_LINE | float slope ( float x1, float y1, float x2, float y2 ) {
  return ( y2 - y1 ) / ( x2 - x1 );
}


GCD_ELEMENTS_GIVEN_RANGE | int rangeGCD ( int n, int m ) {
  return ( n == m ) ? n : 1;
}


LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARRAY_1 | void alternateSubarray ( bool arr [ ], int n ) {
  int count = 1;
  int prev = arr [ 0 ];
  for ( int i = 1;
  i < n;
  ++ i ) {
    if ( ( arr [ i ] ^ prev ) == 0 ) {
      while ( count ) cout << count -- << " ";
    }
    ++ count;
    prev = arr [ i ];
  }
  while ( count ) cout << count -- << " ";
}


FIND_UNIT_DIGIT_X_RAISED_POWER_Y | int unitDigitXRaisedY ( int x, int y ) {
  int res = 1;
  for ( int i = 0;
  i < y;
  i ++ ) res = ( res * x ) % 10;
  return res;
}


MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO | long long moduloMultiplication ( long long a, long long b, long long mod ) {
  long long res = 0;
  a %= mod;
  while ( b ) {
    if ( b & 1 ) res = ( res + a ) % mod;
    a = ( 2 * a ) % mod;
    b >>= 1;
  }
  return res;
}


FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SUM | void findSmallest ( int m, int s ) {
  if ( s == 0 ) {
    ( m == 1 ) ? cout << "Smallest number is " << 0 : cout << "Not possible";
    return;
  }
  if ( s > 9 * m ) {
    cout << "Not possible";
    return;
  }
  int res [ m ];
  s -= 1;
  for ( int i = m - 1;
  i > 0;
  i -- ) {
    if ( s > 9 ) {
      res [ i ] = 9;
      s -= 9;
    }
    else {
      res [ i ] = s;
      s = 0;
    }
  }
  res [ 0 ] = s + 1;
  cout << "Smallest number is ";
  for ( int i = 0;
  i < m;
  i ++ ) cout << res [ i ];
}


C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY | int largest ( int arr [ ], int n ) {
  int i;
  int max = arr [ 0 ];
  for ( i = 1;
  i < n;
  i ++ ) if ( arr [ i ] > max ) max = arr [ i ];
  return max;
}


COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS | int countNums ( int n, int x, int y ) {
  vector < bool > arr ( n + 1, false );
  if ( x <= n ) arr [ x ] = true;
  if ( y <= n ) arr [ y ] = true;
  int result = 0;
  for ( int i = min ( x, y );
  i <= n;
  i ++ ) {
    if ( arr [ i ] ) {
      if ( i + x <= n ) arr [ i + x ] = true;
      if ( i + y <= n ) arr [ i + y ] = true;
      result ++;
    }
  }
  return result;
}


BUBBLE_SORT_1 | void bubbleSort ( int arr [ ], int n ) {
  int i, j;
  bool swapped;
  for ( i = 0;
  i < n - 1;
  i ++ ) {
    swapped = false;
    for ( j = 0;
    j < n - i - 1;
    j ++ ) {
      if ( arr [ j ] > arr [ j + 1 ] ) {
        swap ( & arr [ j ], & arr [ j + 1 ] );
        swapped = true;
      }
    }
    if ( swapped == false ) break;
  }
}


MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT | int maxSum ( int grid [ 2 ] [ MAX ], int n ) {
  int incl = max ( grid [ 0 ] [ 0 ], grid [ 1 ] [ 0 ] );
  int excl = 0, excl_new;
  for ( int i = 1;
  i < n;
  i ++ ) {
    excl_new = max ( excl, incl );
    incl = excl + max ( grid [ 0 ] [ i ], grid [ 1 ] [ i ] );
    excl = excl_new;
  }
  return max ( excl, incl );
}


GCD_FACTORIALS_TWO_NUMBERS | int gcdOfFactorial ( int m, int n ) {
  return factorial ( min ( m, n ) );
}


AREA_OF_A_SECTOR | void SectorArea ( double radius, double angle ) {
  if ( angle >= 360 ) cout << "Angle not possible";
  else {
    double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 );
    cout << sector;
  }
}


COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS_1 | int countSeq ( int n ) {
  int nCr = 1, res = 1;
  for ( int r = 1;
  r <= n;
  r ++ ) {
    nCr = ( nCr * ( n + 1 - r ) ) / r;
    res += nCr * nCr;
  }
  return res;
}


LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1 | int findLength ( char * str ) {
  int n = strlen ( str );
  int maxlen = 0;
  int sum [ n ] [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) sum [ i ] [ i ] = str [ i ] - '0';
  for ( int len = 2;
  len <= n;
  len ++ ) {
    for ( int i = 0;
    i < n - len + 1;
    i ++ ) {
      int j = i + len - 1;
      int k = len / 2;
      sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ];
      if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] && len > maxlen ) maxlen = len;
    }
  }
  return maxlen;
}


SWAP_ALL_ODD_AND_EVEN_BITS | unsigned int swapBits ( unsigned int x ) {
  unsigned int even_bits = x & 0xAAAAAAAA;
  unsigned int odd_bits = x & 0x55555555;
  even_bits >>= 1;
  odd_bits <<= 1;
  return ( even_bits | odd_bits );
}


SORT_ARRAY_WAVE_FORM_2 | void sortInWave ( int arr [ ], int n ) {
  sort ( arr, arr + n );
  for ( int i = 0;
  i < n - 1;
  i += 2 ) swap ( & arr [ i ], & arr [ i + 1 ] );
}


FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN | double compute ( int a, int b ) {
  double AM, GM, HM;
  AM = ( a + b ) / 2;
  GM = sqrt ( a * b );
  HM = ( GM * GM ) / AM;
  return HM;
}


COUNT_BALANCED_BINARY_TREES_HEIGHT_H | long long int countBT ( int h ) {
  long long int dp [ h + 1 ];
  dp [ 0 ] = dp [ 1 ] = 1;
  for ( int i = 2;
  i <= h;
  i ++ ) {
    dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod + dp [ i - 1 ] ) % mod ) % mod;
  }
  return dp [ h ];
}


MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME_WITH_PERMUTATIONS_ALLOWED | int minInsertion ( string str ) {
  int n = str . length ( );
  int res = 0;
  int count [ 26 ] = {
    0 };
    for ( int i = 0;
    i < n;
    i ++ ) count [ str [ i ] - 'a' ] ++;
    for ( int i = 0;
    i < 26;
    i ++ ) if ( count [ i ] % 2 == 1 ) res ++;
    return ( res == 0 ) ? 0 : res - 1;
  }
  

SHUFFLE_A_GIVEN_ARRAY | void randomize ( int arr [ ], int n ) {
  srand ( time ( NULL ) );
  for ( int i = n - 1;
  i > 0;
  i -- ) {
    int j = rand ( ) % ( i + 1 );
    swap ( & arr [ i ], & arr [ j ] );
  }
}


UGLY_NUMBERS | unsigned getNthUglyNo ( unsigned n ) {
  unsigned ugly [ n ];
  unsigned i2 = 0, i3 = 0, i5 = 0;
  unsigned next_multiple_of_2 = 2;
  unsigned next_multiple_of_3 = 3;
  unsigned next_multiple_of_5 = 5;
  unsigned next_ugly_no = 1;
  ugly [ 0 ] = 1;
  for ( int i = 1;
  i < n;
  i ++ ) {
    next_ugly_no = min ( next_multiple_of_2, min ( next_multiple_of_3, next_multiple_of_5 ) );
    ugly [ i ] = next_ugly_no;
    if ( next_ugly_no == next_multiple_of_2 ) {
      i2 = i2 + 1;
      next_multiple_of_2 = ugly [ i2 ] * 2;
    }
    if ( next_ugly_no == next_multiple_of_3 ) {
      i3 = i3 + 1;
      next_multiple_of_3 = ugly [ i3 ] * 3;
    }
    if ( next_ugly_no == next_multiple_of_5 ) {
      i5 = i5 + 1;
      next_multiple_of_5 = ugly [ i5 ] * 5;
    }
  }
  return next_ugly_no;
}


MINIMUM_COST_CUT_BOARD_SQUARES | int minimumCostOfBreaking ( int X [ ], int Y [ ], int m, int n ) {
  int res = 0;
  sort ( X, X + m, greater < int > ( ) );
  sort ( Y, Y + n, greater < int > ( ) );
  int hzntl = 1, vert = 1;
  int i = 0, j = 0;
  while ( i < m && j < n ) {
    if ( X [ i ] > Y [ j ] ) {
      res += X [ i ] * vert;
      hzntl ++;
      i ++;
    }
    else {
      res += Y [ j ] * hzntl;
      vert ++;
      j ++;
    }
  }
  int total = 0;
  while ( i < m ) total += X [ i ++ ];
  res += total * vert;
  total = 0;
  while ( j < n ) total += Y [ j ++ ];
  res += total * hzntl;
  return res;
}


DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1 | int knapSack ( int W, int wt [ ], int val [ ], int n ) {
  int i, w;
  int K [ n + 1 ] [ W + 1 ];
  for ( i = 0;
  i <= n;
  i ++ ) {
    for ( w = 0;
    w <= W;
    w ++ ) {
      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0;
      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ], K [ i - 1 ] [ w ] );
      else K [ i ] [ w ] = K [ i - 1 ] [ w ];
    }
  }
  return K [ n ] [ W ];
}


STACK_PERMUTATIONS_CHECK_IF_AN_ARRAY_IS_STACK_PERMUTATION_OF_OTHER | bool checkStackPermutation ( int ip [ ], int op [ ], int n ) {
  queue < int > input;
  for ( int i = 0;
  i < n;
  i ++ ) input . push ( ip [ i ] );
  queue < int > output;
  for ( int i = 0;
  i < n;
  i ++ ) output . push ( op [ i ] );
  stack < int > tempStack;
  while ( ! input . empty ( ) ) {
    int ele = input . front ( );
    input . pop ( );
    if ( ele == output . front ( ) ) {
      output . pop ( );
      while ( ! tempStack . empty ( ) ) {
        if ( tempStack . top ( ) == output . front ( ) ) {
          tempStack . pop ( );
          output . pop ( );
        }
        else break;
      }
    }
    else tempStack . push ( ele );
  }
  return ( input . empty ( ) && tempStack . empty ( ) );
}


PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP | double procal ( int n ) {
  return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 );
}


REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS | char * simplify ( string str ) {
  int len = str . length ( );
  char * res = new char ( len );
  int index = 0, i = 0;
  stack < int > s;
  s . push ( 0 );
  while ( i < len ) {
    if ( str [ i ] == '+' ) {
      if ( s . top ( ) == 1 ) res [ index ++ ] = '-';
      if ( s . top ( ) == 0 ) res [ index ++ ] = '+';
    }
    else if ( str [ i ] == '-' ) {
      if ( s . top ( ) == 1 ) res [ index ++ ] = '+';
      else if ( s . top ( ) == 0 ) res [ index ++ ] = '-';
    }
    else if ( str [ i ] == '(' && i > 0 ) {
      if ( str [ i - 1 ] == '-' ) {
        int x = ( s . top ( ) == 1 ) ? 0 : 1;
        s . push ( x );
      }
      else if ( str [ i - 1 ] == '+' ) s . push ( s . top ( ) );
    }
    else if ( str [ i ] == ')' ) s . pop ( );
    else res [ index ++ ] = str [ i ];
    i ++;
  }
  return res;
}


FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS | int countSquares ( int a, int b ) {
  int cnt = 0;
  for ( int i = a;
  i <= b;
  i ++ ) for ( int j = 1;
  j * j <= i;
  j ++ ) if ( j * j == i ) cnt ++;
  return cnt;
}


K_NUMBERS_DIFFERENCE_MAXIMUM_MINIMUM_K_NUMBER_MINIMIZED | int minDiff ( int arr [ ], int n, int k ) {
  int result = INT_MAX;
  sort ( arr, arr + n );
  for ( int i = 0;
  i <= n - k;
  i ++ ) result = min ( result, arr [ i + k - 1 ] - arr [ i ] );
  return result;
}


CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT | bool checkDivisibility ( string num ) {
  int length = num . size ( );
  if ( length == 1 && num [ 0 ] == '0' ) return true;
  if ( length % 3 == 1 ) {
    num += "00";
    length += 2;
  }
  else if ( length % 3 == 2 ) {
    num += "0";
    length += 1;
  }
  int sum = 0, p = 1;
  for ( int i = length - 1;
  i >= 0;
  i -- ) {
    int group = 0;
    group += num [ i -- ] - '0';
    group += ( num [ i -- ] - '0' ) * 10;
    group += ( num [ i ] - '0' ) * 100;
    sum = sum + group * p;
    p *= ( - 1 );
  }
  sum = abs ( sum );
  return ( sum % 13 == 0 );
}


GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K | void printSumSimple ( int mat [ ] [ n ], int k ) {
  if ( k > n ) return;
  for ( int i = 0;
  i < n - k + 1;
  i ++ ) {
    for ( int j = 0;
    j < n - k + 1;
    j ++ ) {
      int sum = 0;
      for ( int p = i;
      p < k + i;
      p ++ ) for ( int q = j;
      q < k + j;
      q ++ ) sum += mat [ p ] [ q ];
      cout << sum << "  ";
    }
    cout << endl;
  }
}


FIND_THE_POINT_WHERE_MAXIMUM_INTERVALS_OVERLAP_1 | void maxOverlap ( vector < int > & start, vector < int > & end ) {
  int n = start . size ( );
  int maxa = * max_element ( start . begin ( ), start . end ( ) );
  int maxb = * max_element ( end . begin ( ), end . end ( ) );
  int maxc = max ( maxa, maxb );
  int x [ maxc + 2 ];
  memset ( x, 0, sizeof x );
  int cur = 0, idx;
  for ( int i = 0;
  i < n;
  i ++ ) {
    ++ x [ start [ i ] ];
    -- x [ end [ i ] + 1 ];
  }
  int maxy = INT_MIN;
  for ( int i = 0;
  i <= maxc;
  i ++ ) {
    cur += x [ i ];
    if ( maxy < cur ) {
      maxy = cur;
      idx = i;
    }
  }
  cout << "Maximum value is " << maxy << " at position " << idx << endl;
}


MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1 | int maxSumWO3Consec ( int n ) {
  if ( sum [ n ] != - 1 ) return sum [ n ];
  if ( n == 0 ) return sum [ n ] = 0;
  if ( n == 1 ) return sum [ n ] = arr [ 0 ];
  if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ];
  return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ), maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ), arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) );
}


C_PROGRAM_ADDITION_TWO_MATRICES | void add ( int A [ ] [ N ], int B [ ] [ N ], int C [ ] [ N ] ) {
  int i, j;
  for ( i = 0;
  i < N;
  i ++ ) for ( j = 0;
  j < N;
  j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ];
}


FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1 | int findMaxAverage ( int arr [ ], int n, int k ) {
  if ( k > n ) return - 1;
  int sum = arr [ 0 ];
  for ( int i = 1;
  i < k;
  i ++ ) sum += arr [ i ];
  int max_sum = sum, max_end = k - 1;
  for ( int i = k;
  i < n;
  i ++ ) {
    int sum = sum + arr [ i ] - arr [ i - k ];
    if ( sum > max_sum ) {
      max_sum = sum;
      max_end = i;
    }
  }
  return max_end - k + 1;
}


FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER | void center ( int x1, int x2, int y1, int y2 ) {
  cout << ( float ) ( x1 + x2 ) / 2 << ", " << ( float ) ( y1 + y2 ) / 2;
}


TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS | long long int countNonDecreasing ( int n ) {
  long long int dp [ 10 ] [ n + 1 ];
  memset ( dp, 0, sizeof dp );
  for ( int i = 0;
  i < 10;
  i ++ ) dp [ i ] [ 1 ] = 1;
  for ( int digit = 0;
  digit <= 9;
  digit ++ ) {
    for ( int len = 2;
    len <= n;
    len ++ ) {
      for ( int x = 0;
      x <= digit;
      x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ];
    }
  }
  long long int count = 0;
  for ( int i = 0;
  i < 10;
  i ++ ) count += dp [ i ] [ n ];
  return count;
}


PRINT_REVERSE_STRING_REMOVING_VOWELS | void replaceOriginal ( string s, int n ) {
  string r ( n, ' ' );
  for ( int i = 0;
  i < n;
  i ++ ) {
    r [ i ] = s [ n - 1 - i ];
    if ( s [ i ] != 'a' && s [ i ] != 'e' && s [ i ] != 'i' && s [ i ] != 'o' && s [ i ] != 'u' ) {
      cout << r [ i ];
    }
  }
  cout << endl;
}


FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1 | void findMissing ( int a [ ], int b [ ], int n, int m ) {
  unordered_set < int > s;
  for ( int i = 0;
  i < m;
  i ++ ) s . insert ( b [ i ] );
  for ( int i = 0;
  i < n;
  i ++ ) if ( s . find ( a [ i ] ) == s . end ( ) ) cout << a [ i ] << " ";
}


COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS | int countStr ( int n, int bCount, int cCount ) {
  if ( bCount < 0 || cCount < 0 ) return 0;
  if ( n == 0 ) return 1;
  if ( bCount == 0 && cCount == 0 ) return 1;
  int res = countStr ( n - 1, bCount, cCount );
  res += countStr ( n - 1, bCount - 1, cCount );
  res += countStr ( n - 1, bCount, cCount - 1 );
  return res;
}


GOLD_MINE_PROBLEM | int getMaxGold ( int gold [ ] [ MAX ], int m, int n ) {
  int goldTable [ m ] [ n ];
  memset ( goldTable, 0, sizeof ( goldTable ) );
  for ( int col = n - 1;
  col >= 0;
  col -- ) {
    for ( int row = 0;
    row < m;
    row ++ ) {
      int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ];
      int right_up = ( row == 0 || col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ];
      int right_down = ( row == m - 1 || col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ];
      goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right, max ( right_up, right_down ) );
    }
  }
  int res = goldTable [ 0 ] [ 0 ];
  for ( int i = 1;
  i < m;
  i ++ ) res = max ( res, goldTable [ i ] [ 0 ] );
  return res;
}


COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS | long countWays ( int n ) {
  long dp [ 2 ] [ n + 1 ];
  dp [ 0 ] [ 1 ] = 1;
  dp [ 1 ] [ 1 ] = 2;
  for ( int i = 2;
  i <= n;
  i ++ ) {
    dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ];
    dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ];
  }
  return dp [ 0 ] [ n ] + dp [ 1 ] [ n ];
}


RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1 | void maxProduct ( int arr [ ], int n ) {
  if ( n < 2 ) {
    cout << "No pairs exists\n";
    return;
  }
  if ( n == 2 ) {
    cout << arr [ 0 ] << " " << arr [ 1 ] << endl;
    return;
  }
  int posa = INT_MIN, posb = INT_MIN;
  int nega = INT_MIN, negb = INT_MIN;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] > posa ) {
      posb = posa;
      posa = arr [ i ];
    }
    else if ( arr [ i ] > posb ) posb = arr [ i ];
    if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( nega ) ) {
      negb = nega;
      nega = arr [ i ];
    }
    else if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( negb ) ) negb = arr [ i ];
  }
  if ( nega * negb > posa * posb ) cout << "Max product pair is {" << nega << ", " << negb << "}";
  else cout << "Max product pair is {" << posa << ", " << posb << "}";
}


POSITION_OF_RIGHTMOST_SET_BIT | public : unsigned int getFirstSetBitPos ( int n ) {
  return log2 ( n & - n ) + 1;
}


LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_TIMES | void longestSubseqWithK ( string str, int k ) {
  int n = str . size ( );
  int freq [ MAX_CHARS ] = {
    0 };
    for ( int i = 0;
    i < n;
    i ++ ) freq [ str [ i ] - 'a' ] ++;
    for ( int i = 0;
    i < n;
    i ++ ) if ( freq [ str [ i ] - 'a' ] >= k ) cout << str [ i ];
  }
  

POSSIBLE_TO_MAKE_A_DIVISIBLE_BY_3_NUMBER_USING_ALL_DIGITS_IN_AN_ARRAY | bool isPossibleToMakeDivisible ( int arr [ ], int n ) {
  int remainder = 0;
  for ( int i = 0;
  i < n;
  i ++ ) remainder = ( remainder + arr [ i ] ) % 3;
  return ( remainder == 0 );
}


AREA_SQUARE_CIRCUMSCRIBED_CIRCLE | int find_Area ( int r ) {
  return ( 2 * r * r );
}


FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S | long long int MaxDotProduct ( int A [ ], int B [ ], int m, int n ) {
  long long int dp [ n + 1 ] [ m + 1 ];
  memset ( dp, 0, sizeof ( dp ) );
  for ( int i = 1;
  i <= n;
  i ++ ) for ( int j = i;
  j <= m;
  j ++ ) dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ), dp [ i ] [ j - 1 ] );
  return dp [ n ] [ m ];
}


FIND_DISTINCT_SUBSET_SUBSEQUENCE_SUMS_ARRAY | void printDistSum ( int arr [ ], int n ) {
  int sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) sum += arr [ i ];
  bool dp [ n + 1 ] [ sum + 1 ];
  memset ( dp, 0, sizeof ( dp ) );
  for ( int i = 0;
  i <= n;
  i ++ ) dp [ i ] [ 0 ] = true;
  for ( int i = 1;
  i <= n;
  i ++ ) {
    dp [ i ] [ arr [ i - 1 ] ] = true;
    for ( int j = 1;
    j <= sum;
    j ++ ) {
      if ( dp [ i - 1 ] [ j ] == true ) {
        dp [ i ] [ j ] = true;
        dp [ i ] [ j + arr [ i - 1 ] ] = true;
      }
    }
  }
  for ( int j = 0;
  j <= sum;
  j ++ ) if ( dp [ n ] [ j ] == true ) cout << j << " ";
}


SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING | void splitString ( string str ) {
  string alpha, num, special;
  for ( int i = 0;
  i < str . length ( );
  i ++ ) {
    if ( isdigit ( str [ i ] ) ) num . push_back ( str [ i ] );
    else if ( ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) || ( str [ i ] >= 'a' && str [ i ] <= 'z' ) ) alpha . push_back ( str [ i ] );
    else special . push_back ( str [ i ] );
  }
  cout << alpha << endl;
  cout << num << endl;
  cout << special << endl;
}


MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM | int maxAlternateSum ( int arr [ ], int n ) {
  if ( n == 1 ) return arr [ 0 ];
  int dec [ n ];
  memset ( dec, 0, sizeof ( dec ) );
  int inc [ n ];
  memset ( inc, 0, sizeof ( inc ) );
  dec [ 0 ] = inc [ 0 ] = arr [ 0 ];
  int flag = 0;
  for ( int i = 1;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < i;
    j ++ ) {
      if ( arr [ j ] > arr [ i ] ) {
        dec [ i ] = max ( dec [ i ], inc [ j ] + arr [ i ] );
        flag = 1;
      }
      else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = max ( inc [ i ], dec [ j ] + arr [ i ] );
    }
  }
  int result = INT_MIN;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( result < inc [ i ] ) result = inc [ i ];
    if ( result < dec [ i ] ) result = dec [ i ];
  }
  return result;
}


FIND_PAIR_MAXIMUM_GCD_ARRAY | int findMaxGCD ( int arr [ ], int n ) {
  int high = 0;
  for ( int i = 0;
  i < n;
  i ++ ) high = max ( high, arr [ i ] );
  int divisors [ high + 1 ] = {
    0 };
    for ( int i = 0;
    i < n;
    i ++ ) {
      for ( int j = 1;
      j <= sqrt ( arr [ i ] );
      j ++ ) {
        if ( arr [ i ] % j == 0 ) {
          divisors [ j ] ++;
          if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++;
        }
      }
    }
    for ( int i = high;
    i >= 1;
    i -- ) if ( divisors [ i ] > 1 ) return i;
  }
  

FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1 | int minCoins ( int coins [ ], int m, int V ) {
  int table [ V + 1 ];
  table [ 0 ] = 0;
  for ( int i = 1;
  i <= V;
  i ++ ) table [ i ] = INT_MAX;
  for ( int i = 1;
  i <= V;
  i ++ ) {
    for ( int j = 0;
    j < m;
    j ++ ) if ( coins [ j ] <= i ) {
      int sub_res = table [ i - coins [ j ] ];
      if ( sub_res != INT_MAX && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1;
    }
  }
  return table [ V ];
}


SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING | int sumAtKthLevel ( string tree, int k ) {
  int level = - 1;
  int sum = 0;
  int n = tree . length ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( tree [ i ] == '(' ) level ++;
    else if ( tree [ i ] == ')' ) level --;
    else {
      if ( level == k ) sum += ( tree [ i ] - '0' );
    }
  }
  return sum;
}


DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE | int lcs ( char * X, char * Y, int m, int n ) {
  if ( m == 0 || n == 0 ) return 0;
  if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X, Y, m - 1, n - 1 );
  else return max ( lcs ( X, Y, m, n - 1 ), lcs ( X, Y, m - 1, n ) );
}


CHECK_GIVEN_SENTENCE_GIVEN_SET_SIMPLE_GRAMMER_RULES | bool checkSentence ( char str [ ] ) {
  int len = strlen ( str );
  if ( str [ 0 ] < 'A' || str [ 0 ] > 'Z' ) return false;
  if ( str [ len - 1 ] != '.' ) return false;
  int prev_state = 0, curr_state = 0;
  int index = 1;
  while ( str [ index ] ) {
    if ( str [ index ] >= 'A' && str [ index ] <= 'Z' ) curr_state = 0;
    else if ( str [ index ] == ' ' ) curr_state = 1;
    else if ( str [ index ] >= 'a' && str [ index ] <= 'z' ) curr_state = 2;
    else if ( str [ index ] == '.' ) curr_state = 3;
    if ( prev_state == curr_state && curr_state != 2 ) return false;
    if ( prev_state == 2 && curr_state == 0 ) return false;
    if ( curr_state == 3 && prev_state != 1 ) return ( str [ index + 1 ] == '\0' );
    index ++;
    prev_state = curr_state;
  }
  return false;
}


CHECK_DIVISIBILITY_LARGE_NUMBER_999 | bool isDivisible999 ( string num ) {
  int n = num . length ( );
  if ( n == 0 && num [ 0 ] == '0' ) return true;
  if ( n % 3 == 1 ) num = "00" + num;
  if ( n % 3 == 2 ) num = "0" + num;
  int gSum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int group = 0;
    group += ( num [ i ++ ] - '0' ) * 100;
    group += ( num [ i ++ ] - '0' ) * 10;
    group += num [ i ] - '0';
    gSum += group;
  }
  if ( gSum > 1000 ) {
    num = to_string ( gSum );
    n = num . length ( );
    gSum = isDivisible999 ( num );
  }
  return ( gSum == 999 );
}


CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT | int check ( string str ) {
  int n = str . length ( );
  int digitSum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) digitSum += ( str [ i ] - '0' );
  return ( digitSum % 9 == 0 );
}


NUMBER_OF_BINARY_TREES_FOR_GIVEN_PREORDER_SEQUENCE_LENGTH | int countTrees ( int n ) {
  int BT [ n + 1 ];
  memset ( BT, 0, sizeof ( BT ) );
  BT [ 0 ] = BT [ 1 ] = 1;
  for ( int i = 2;
  i <= n;
  ++ i ) for ( int j = 0;
  j < i;
  j ++ ) BT [ i ] += BT [ j ] * BT [ i - j - 1 ];
  return BT [ n ];
}


PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_MATRIX | void swapUpperToLower ( int arr [ n ] [ n ] ) {
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = i + 1;
    j < n;
    j ++ ) {
      int temp = arr [ i ] [ j ];
      arr [ i ] [ j ] = arr [ j ] [ i ];
      arr [ j ] [ i ] = temp;
    }
  }
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < n;
    j ++ ) cout << arr [ i ] [ j ] << " ";
    cout << endl;
  }
}


FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER_1 | int findSum ( int N, int K ) {
  int ans = 0;
  int y = N / K;
  int x = N % K;
  ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2;
  return ans;
}


WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO | int xorZero ( string str ) {
  int one_count = 0, zero_count = 0;
  int n = str . length ( );
  for ( int i = 0;
  i < n;
  i ++ ) if ( str [ i ] == '1' ) one_count ++;
  else zero_count ++;
  if ( one_count % 2 == 0 ) return zero_count;
  return one_count;
}


DYNAMIC_PROGRAMMING_SET_7_COIN_CHANGE | int count ( int S [ ], int m, int n ) {
  if ( n == 0 ) return 1;
  if ( n < 0 ) return 0;
  if ( m <= 0 && n >= 1 ) return 0;
  return count ( S, m - 1, n ) + count ( S, m, n - S [ m - 1 ] );
}


MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED | int minSum ( int arr [ ], int n ) {
  int dp [ n ];
  if ( n == 1 ) return arr [ 0 ];
  if ( n == 2 ) return min ( arr [ 0 ], arr [ 1 ] );
  if ( n == 3 ) return min ( arr [ 0 ], min ( arr [ 1 ], arr [ 2 ] ) );
  if ( n == 4 ) return min ( min ( arr [ 0 ], arr [ 1 ] ), min ( arr [ 2 ], arr [ 3 ] ) );
  dp [ 0 ] = arr [ 0 ];
  dp [ 1 ] = arr [ 1 ];
  dp [ 2 ] = arr [ 2 ];
  dp [ 3 ] = arr [ 3 ];
  for ( int i = 4;
  i < n;
  i ++ ) dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ], dp [ i - 2 ] ), min ( dp [ i - 3 ], dp [ i - 4 ] ) );
  return min ( min ( dp [ n - 1 ], dp [ n - 2 ] ), min ( dp [ n - 4 ], dp [ n - 3 ] ) );
}


MAXIMUM_PATH_SUM_TRIANGLE | int maxPathSum ( int tri [ ] [ N ], int m, int n ) {
  for ( int i = m - 1;
  i >= 0;
  i -- ) {
    for ( int j = 0;
    j <= i;
    j ++ ) {
      if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ];
      else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ];
    }
  }
  return tri [ 0 ] [ 0 ];
}


FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K | bool findTriplet ( int a1 [ ], int a2 [ ], int a3 [ ], int n1, int n2, int n3, int sum ) {
  for ( int i = 0;
  i < n1;
  i ++ ) for ( int j = 0;
  j < n2;
  j ++ ) for ( int k = 0;
  k < n3;
  k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true;
  return false;
}


TAIL_RECURSION_FIBONACCI | int fib ( int n, int a = 0, int b = 1 ) {
  if ( n == 0 ) return a;
  if ( n == 1 ) return b;
  return fib ( n - 1, b, a + b );
}


PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DIFFERENT | bool isLucky ( int n ) {
  bool arr [ 10 ];
  for ( int i = 0;
  i < 10;
  i ++ ) arr [ i ] = false;
  while ( n > 0 ) {
    int digit = n % 10;
    if ( arr [ digit ] ) return false;
    arr [ digit ] = true;
    n = n / 10;
  }
  return true;
}


GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K_1 | void printSumTricky ( int mat [ ] [ n ], int k ) {
  if ( k > n ) return;
  int stripSum [ n ] [ n ];
  for ( int j = 0;
  j < n;
  j ++ ) {
    int sum = 0;
    for ( int i = 0;
    i < k;
    i ++ ) sum += mat [ i ] [ j ];
    stripSum [ 0 ] [ j ] = sum;
    for ( int i = 1;
    i < n - k + 1;
    i ++ ) {
      sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] );
      stripSum [ i ] [ j ] = sum;
    }
  }
  for ( int i = 0;
  i < n - k + 1;
  i ++ ) {
    int sum = 0;
    for ( int j = 0;
    j < k;
    j ++ ) sum += stripSum [ i ] [ j ];
    cout << sum << "  ";
    for ( int j = 1;
    j < n - k + 1;
    j ++ ) {
      sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] );
      cout << sum << "  ";
    }
    cout << endl;
  }
}


SCHEDULE_ELEVATOR_TO_REDUCE_THE_TOTAL_TIME_TAKEN | int minTime ( int n, int k, int a [ ] ) {
  sort ( a, a + n, greater < int > ( ) );
  int minTime = 0;
  for ( int i = 0;
  i < n;
  i += k ) minTime += ( 2 * a [ i ] );
  return minTime;
}


ODD_EVEN_SORT_BRICK_SORT | void oddEvenSort ( int arr [ ], int n ) {
  bool isSorted = false;
  while ( ! isSorted ) {
    isSorted = true;
    for ( int i = 1;
    i <= n - 2;
    i = i + 2 ) {
      if ( arr [ i ] > arr [ i + 1 ] ) {
        swap ( arr [ i ], arr [ i + 1 ] );
        isSorted = false;
      }
    }
    for ( int i = 0;
    i <= n - 2;
    i = i + 2 ) {
      if ( arr [ i ] > arr [ i + 1 ] ) {
        swap ( arr [ i ], arr [ i + 1 ] );
        isSorted = false;
      }
    }
  }
  return;
}


RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING | char getMaxOccuringChar ( char * str ) {
  int count [ ASCII_SIZE ] = {
    0 };
    int len = strlen ( str );
    int max = 0;
    char result;
    for ( int i = 0;
    i < len;
    i ++ ) {
      count [ str [ i ] ] ++;
      if ( max < count [ str [ i ] ] ) {
        max = count [ str [ i ] ];
        result = str [ i ];
      }
    }
    return result;
  }
  

COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B | int CountPairs ( int n ) {
  int k = n;
  int imin = 1;
  int ans = 0;
  while ( imin <= n ) {
    int imax = n / k;
    ans += k * ( imax - imin + 1 );
    imin = imax + 1;
    k = n / imin;
  }
  return ans;
}


K_TH_DISTINCT_OR_NON_REPEATING_ELEMENT_IN_AN_ARRAY_1 | int printKDistinct ( int arr [ ], int n, int k ) {
  unordered_map < int, int > h;
  for ( int i = 0;
  i < n;
  i ++ ) h [ arr [ i ] ] ++;
  if ( h . size ( ) < k ) return - 1;
  int dist_count = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( h [ arr [ i ] ] == 1 ) dist_count ++;
    if ( dist_count == k ) return arr [ i ];
  }
  return - 1;
}


GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS | void generate ( int ones, int zeroes, string str, int len ) {
  if ( len == str . length ( ) ) {
    cout << str << "  ";
    return;
  }
  generate ( ones + 1, zeroes, str + "1", len );
  if ( ones > zeroes ) generate ( ones, zeroes + 1, str + "0", len );
}


SEARCH_INSERT_AND_DELETE_IN_AN_UNSORTED_ARRAY | int findElement ( int arr [ ], int n, int key ) {
  int i;
  for ( i = 0;
  i < n;
  i ++ ) if ( arr [ i ] == key ) return i;
  return - 1;
}


LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS | int lcsOf3 ( string X, string Y, string Z, int m, int n, int o ) {
  int L [ m + 1 ] [ n + 1 ] [ o + 1 ];
  for ( int i = 0;
  i <= m;
  i ++ ) {
    for ( int j = 0;
    j <= n;
    j ++ ) {
      for ( int k = 0;
      k <= o;
      k ++ ) {
        if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0;
        else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1;
        else L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ], L [ i ] [ j - 1 ] [ k ] ), L [ i ] [ j ] [ k - 1 ] );
      }
    }
  }
  return L [ m ] [ n ] [ o ];
}


MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT | int maxSumSubarrayRemovingOneEle ( int arr [ ], int n ) {
  int fw [ n ], bw [ n ];
  int cur_max = arr [ 0 ], max_so_far = arr [ 0 ];
  fw [ 0 ] = arr [ 0 ];
  for ( int i = 1;
  i < n;
  i ++ ) {
    cur_max = max ( arr [ i ], cur_max + arr [ i ] );
    max_so_far = max ( max_so_far, cur_max );
    fw [ i ] = cur_max;
  }
  cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ];
  for ( int i = n - 2;
  i >= 0;
  i -- ) {
    cur_max = max ( arr [ i ], cur_max + arr [ i ] );
    max_so_far = max ( max_so_far, cur_max );
    bw [ i ] = cur_max;
  }
  int fans = max_so_far;
  for ( int i = 1;
  i < n - 1;
  i ++ ) fans = max ( fans, fw [ i - 1 ] + bw [ i + 1 ] );
  return fans;
}


COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES | int countWays ( int n, int m ) {
  int count [ n + 1 ];
  count [ 0 ] = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) {
    if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ];
    else if ( i < m ) count [ i ] = 1;
    else count [ i ] = 2;
  }
  return count [ n ];
}


MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS | int middleOfThree ( int a, int b, int c ) {
  if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b;
  else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a;
  else return c;
}


LONGEST_COMMON_INCREASING_SUBSEQUENCE_LCS_LIS | int LCIS ( int arr1 [ ], int n, int arr2 [ ], int m ) {
  int table [ m ];
  for ( int j = 0;
  j < m;
  j ++ ) table [ j ] = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int current = 0;
    for ( int j = 0;
    j < m;
    j ++ ) {
      if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1;
      if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ];
    }
  }
  int result = 0;
  for ( int i = 0;
  i < m;
  i ++ ) if ( table [ i ] > result ) result = table [ i ];
  return result;
}


MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE | int maxSumWO3Consec ( int arr [ ], int n ) {
  int sum [ n ];
  if ( n >= 1 ) sum [ 0 ] = arr [ 0 ];
  if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ];
  if ( n > 2 ) sum [ 2 ] = max ( sum [ 1 ], max ( arr [ 1 ] + arr [ 2 ], arr [ 0 ] + arr [ 2 ] ) );
  for ( int i = 3;
  i < n;
  i ++ ) sum [ i ] = max ( max ( sum [ i - 1 ], sum [ i - 2 ] + arr [ i ] ), arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] );
  return sum [ n - 1 ];
}


EULERIAN_NUMBER_1 | int eulerian ( int n, int m ) {
  int dp [ n + 1 ] [ m + 1 ];
  memset ( dp, 0, sizeof ( dp ) );
  for ( int i = 1;
  i <= n;
  i ++ ) {
    for ( int j = 0;
    j <= m;
    j ++ ) {
      if ( i > j ) {
        if ( j == 0 ) dp [ i ] [ j ] = 1;
        else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] );
      }
    }
  }
  return dp [ n ] [ m ];
}


DOUBLE_FACTORIAL | unsigned int doublefactorial ( unsigned int n ) {
  if ( n == 0 || n == 1 ) return 1;
  return n * doublefactorial ( n - 2 );
}


REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH | void GFG :: rearrange ( int arr [ ], int n ) {
  int i = - 1;
  for ( int j = 0;
  j < n;
  j ++ ) {
    if ( arr [ j ] < 0 ) {
      i ++;
      swap ( & arr [ i ], & arr [ j ] );
    }
  }
  int pos = i + 1, neg = 0;
  while ( pos < n && neg < pos && arr [ neg ] < 0 ) {
    swap ( & arr [ neg ], & arr [ pos ] );
    pos ++;
    neg += 2;
  }
}


MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS | int maximumSum ( int arr [ ], int n, int k ) {
  for ( int i = 1;
  i <= k;
  i ++ ) {
    int min = INT_MAX;
    int index = - 1;
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( arr [ j ] < min ) {
        min = arr [ j ];
        index = j;
      }
    }
    if ( min == 0 ) break;
    arr [ index ] = - arr [ index ];
  }
  int sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) sum += arr [ i ];
  return sum;
}


MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ELEMENT_AFTER_PREFIX_IS_MUST | ll pre_compute ( ll a [ ], ll n, ll index, ll k ) {
  ll dp [ n ] [ n ] = {
    0 };
    for ( int i = 0;
    i < n;
    i ++ ) {
      if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ];
      else dp [ 0 ] [ i ] = a [ i ];
    }
    for ( int i = 1;
    i < n;
    i ++ ) {
      for ( int j = 0;
      j < n;
      j ++ ) {
        if ( a [ j ] > a [ i ] && j > i ) {
          if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ];
          else dp [ i ] [ j ] = dp [ i - 1 ] [ j ];
        }
        else dp [ i ] [ j ] = dp [ i - 1 ] [ j ];
      }
    }
    return dp [ index ] [ k ];
  }
  

FUNCTION_COPY_STRING_ITERATIVE_RECURSIVE | void myCopy ( char s1 [ ], char s2 [ ] ) {
  int i = 0;
  for ( i = 0;
  s1 [ i ] != '\0';
  i ++ ) s2 [ i ] = s1 [ i ];
  s2 [ i ] = '\0';
}


GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND_1 | bool isSubSequence ( char str1 [ ], char str2 [ ], int m, int n ) {
  int j = 0;
  for ( int i = 0;
  i < n && j < m;
  i ++ ) if ( str1 [ j ] == str2 [ i ] ) j ++;
  return ( j == m );
}


FIND_UNIT_DIGIT_X_RAISED_POWER_Y_1 | int unitnumber ( int x, int y ) {
  x = x % 10;
  if ( y != 0 ) y = y % 4 + 4;
  return ( ( ( int ) ( pow ( x, y ) ) ) % 10 );
}


PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT | void NextFit ( int blockSize [ ], int m, int processSize [ ], int n ) {
  int allocation [ n ], j = 0;
  memset ( allocation, - 1, sizeof ( allocation ) );
  for ( int i = 0;
  i < n;
  i ++ ) {
    while ( j < m ) {
      if ( blockSize [ j ] >= processSize [ i ] ) {
        allocation [ i ] = j;
        blockSize [ j ] -= processSize [ i ];
        break;
      }
      j = ( j + 1 ) % m;
    }
  }
  cout << "\nProcess No.\tProcess Size\tBlock no.\n";
  for ( int i = 0;
  i < n;
  i ++ ) {
    cout << " " << i + 1 << "\t\t" << processSize [ i ] << "\t\t";
    if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 1;
    else cout << "Not Allocated";
    cout << endl;
  }
}


NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL_TO_VALUE | int nobleInteger ( int arr [ ], int size ) {
  for ( int i = 0;
  i < size;
  i ++ ) {
    int count = 0;
    for ( int j = 0;
    j < size;
    j ++ ) if ( arr [ i ] < arr [ j ] ) count ++;
    if ( count == arr [ i ] ) return arr [ i ];
  }
  return - 1;
}


MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC | int minimumflip ( int mat [ ] [ N ], int n ) {
  int transpose [ n ] [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 0;
  j < n;
  j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ];
  int flip = 0;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 0;
  j < n;
  j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++;
  return flip / 2;
}


SEGREGATE_EVEN_ODD_NUMBERS_SET_3 | void arrayEvenAndOdd ( int arr [ ], int n ) {
  int i = - 1, j = 0;
  int t;
  while ( j != n ) {
    if ( arr [ j ] % 2 == 0 ) {
      i ++;
      swap ( arr [ i ], arr [ j ] );
    }
    j ++;
  }
  for ( int i = 0;
  i < n;
  i ++ ) cout << arr [ i ] << " ";
}


DFS_N_ARY_TREE_ACYCLIC_GRAPH_REPRESENTED_ADJACENCY_LIST | void dfs ( vector < int > list [ ], int node, int arrival ) {
  cout << node << '\n';
  for ( int i = 0;
  i < list [ node ] . size ( );
  i ++ ) {
    if ( list [ node ] [ i ] != arrival ) dfs ( list, list [ node ] [ i ], node );
  }
}


HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER | int turnOffK ( int n, int k ) {
  if ( k <= 0 ) return n;
  return ( n & ~ ( 1 << ( k - 1 ) ) );
}


NUMBER_SUBSTRINGS_DIVISIBLE_8_NOT_3 | int count ( char s [ ], int len ) {
  int cur = 0, dig = 0;
  int sum [ MAX ], dp [ MAX ] [ 3 ];
  memset ( sum, 0, sizeof ( sum ) );
  memset ( dp, 0, sizeof ( dp ) );
  dp [ 0 ] [ 0 ] = 1;
  for ( int i = 1;
  i <= len;
  i ++ ) {
    dig = int ( s [ i - 1 ] ) - 48;
    cur += dig;
    cur %= 3;
    sum [ i ] = cur;
    dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ];
    dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ];
    dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ];
    dp [ i ] [ sum [ i ] ] ++;
  }
  int ans = 0, dprev = 0, value = 0, dprev2 = 0;
  for ( int i = 1;
  i <= len;
  i ++ ) {
    dig = int ( s [ i - 1 ] ) - 48;
    if ( dig == 8 ) ans ++;
    if ( i - 2 >= 0 ) {
      dprev = int ( s [ i - 2 ] ) - 48;
      value = dprev * 10 + dig;
      if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) ans ++;
    }
    if ( i - 3 >= 0 ) {
      dprev2 = int ( s [ i - 3 ] ) - 48;
      dprev = int ( s [ i - 2 ] ) - 48;
      value = dprev2 * 100 + dprev * 10 + dig;
      if ( value % 8 != 0 ) continue;
      ans += ( i - 2 );
      ans -= ( dp [ i - 3 ] [ sum [ i ] ] );
    }
  }
  return ans;
}


ADD_1_TO_A_GIVEN_NUMBER_1 | int addOne ( int x ) {
  return ( - ( ~ x ) );
}


CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT | bool isAnBn ( string str ) {
  int n = str . length ( );
  int i;
  for ( i = 0;
  i < n;
  i ++ ) if ( str [ i ] != 'a' ) break;
  if ( i * 2 != n ) return false;
  int j;
  for ( j = i;
  j < n;
  j ++ ) if ( str [ j ] != 'b' ) return false;
  return true;
}


FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS | void printFirstRepeating ( int arr [ ], int n ) {
  int min = - 1;
  set < int > myset;
  for ( int i = n - 1;
  i >= 0;
  i -- ) {
    if ( myset . find ( arr [ i ] ) != myset . end ( ) ) min = i;
    else myset . insert ( arr [ i ] );
  }
  if ( min != - 1 ) cout << "The first repeating element is " << arr [ min ];
  else cout << "There are no repeating elements";
}


COST_BALANCE_PARANTHESES | int costToBalance ( string s ) {
  if ( s . length ( ) == 0 ) cout << 0 << endl;
  int ans = 0;
  int o = 0, c = 0;
  for ( int i = 0;
  i < s . length ( );
  i ++ ) {
    if ( s [ i ] == '(' ) o ++;
    if ( s [ i ] == ')' ) c ++;
  }
  if ( o != c ) return - 1;
  int a [ s . size ( ) ];
  if ( s [ 0 ] == '(' ) a [ 0 ] = 1;
  else a [ 0 ] = - 1;
  if ( a [ 0 ] < 0 ) ans += abs ( a [ 0 ] );
  for ( int i = 1;
  i < s . length ( );
  i ++ ) {
    if ( s [ i ] == '(' ) a [ i ] = a [ i - 1 ] + 1;
    else a [ i ] = a [ i - 1 ] - 1;
    if ( a [ i ] < 0 ) ans += abs ( a [ i ] );
  }
  return ans;
}


COIN_GAME_WINNER_EVERY_PLAYER_THREE_CHOICES | bool findWinner ( int x, int y, int n ) {
  int dp [ n + 1 ];
  dp [ 0 ] = false;
  dp [ 1 ] = true;
  for ( int i = 2;
  i <= n;
  i ++ ) {
    if ( i - 1 >= 0 and ! dp [ i - 1 ] ) dp [ i ] = true;
    else if ( i - x >= 0 and ! dp [ i - x ] ) dp [ i ] = true;
    else if ( i - y >= 0 and ! dp [ i - y ] ) dp [ i ] = true;
    else dp [ i ] = false;
  }
  return dp [ n ];
}


SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS | int getTotalNumberOfSequences ( int m, int n ) {
  if ( m < n ) return 0;
  if ( n == 0 ) return 1;
  return getTotalNumberOfSequences ( m - 1, n ) + getTotalNumberOfSequences ( m / 2, n - 1 );
}


FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE | void printDuplicates ( int arr [ ], int n ) {
  unordered_map < int, int > freq;
  for ( int i = 0;
  i < n;
  i ++ ) freq [ arr [ i ] ] ++;
  bool dup = false;
  unordered_map < int, int > :: iterator itr;
  for ( itr = freq . begin ( );
  itr != freq . end ( );
  itr ++ ) {
    if ( itr -> second > 1 ) {
      cout << itr -> first << " ";
      dup = true;
    }
  }
  if ( dup == false ) cout << "-1";
}


LONGEST_REPEATING_SUBSEQUENCE_1 | int findLongestRepeatingSubSeq ( string X, int m, int n ) {
  if ( dp [ m ] [ n ] != - 1 ) return dp [ m ] [ n ];
  if ( m == 0 || n == 0 ) return dp [ m ] [ n ] = 0;
  if ( X [ m - 1 ] == X [ n - 1 ] && m != n ) return dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X, m - 1, n - 1 ) + 1;
  return dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X, m, n - 1 ), findLongestRepeatingSubSeq ( X, m - 1, n ) );
}


COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_SUM | void findCount ( int n, int sum ) {
  int start = pow ( 10, n - 1 );
  int end = pow ( 10, n ) - 1;
  int count = 0;
  int i = start;
  while ( i <= end ) {
    int cur = 0;
    int temp = i;
    while ( temp != 0 ) {
      cur += temp % 10;
      temp = temp / 10;
    }
    if ( cur == sum ) {
      count ++;
      i += 9;
    }
    else i ++;
  }
  cout << count;
}


MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY | int minimum_cost ( int a [ ], int n ) {
  int mn = INT_MAX;
  int sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    mn = min ( a [ i ], mn );
    sum += a [ i ];
  }
  return mn * ( sum - mn );
}


FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2 | void printDivisors ( int n ) {
  vector < int > v;
  for ( int i = 1;
  i <= sqrt ( n );
  i ++ ) {
    if ( n % i == 0 ) {
      if ( n / i == i ) printf ( "%d ", i );
      else {
        printf ( "%d ", i );
        v . push_back ( n / i );
      }
    }
  }
  for ( int i = v . size ( ) - 1;
  i >= 0;
  i -- ) printf ( "%d ", v [ i ] );
}


SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1 | void diagonalsquare ( int mat [ ] [ MAX ], int row, int column ) {
  cout << " \nDiagonal one : ";
  for ( int i = 0;
  i < row;
  i ++ ) {
    cout << mat [ i ] [ i ] * mat [ i ] [ i ] << " ";
  }
  cout << " \n\nDiagonal two : ";
  for ( int i = 0;
  i < row;
  i ++ ) {
    cout << mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] << " ";
  }
}


C_PROGRAM_FIND_AREA_TRIANGLE_1 | double polygonArea ( double X [ ], double Y [ ], int n ) {
  double area = 0.0;
  int j = n - 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] );
    j = i;
  }
  return abs ( area / 2.0 );
}


RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS | int findFrequency ( int arr [ ], int n, int left, int right, int element ) {
  int count = 0;
  for ( int i = left - 1;
  i <= right;
  ++ i ) if ( arr [ i ] == element ) ++ count;
  return count;
}


SERIES_LARGEST_GCD_SUM_EQUALS_N | void print_sequence ( int n, int k ) {
  int b = n / ( k * ( k + 1 ) / 2 );
  if ( b == 0 ) {
    cout << - 1 << endl;
  }
  else {
    int r = 1;
    for ( int x = 1;
    x * x <= n;
    x ++ ) {
      if ( n % x != 0 ) continue;
      if ( x <= b && x > r ) r = x;
      if ( n / x <= b && n / x > r ) r = n / x;
    }
    for ( int i = 1;
    i < k;
    i ++ ) cout << r * i << " ";
    int res = n - ( r * ( k * ( k - 1 ) / 2 ) );
    cout << res << endl;
  }
}


FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K_1 | bool findTriplet ( int a1 [ ], int a2 [ ], int a3 [ ], int n1, int n2, int n3, int sum ) {
  unordered_set < int > s;
  for ( int i = 0;
  i < n1;
  i ++ ) s . insert ( a1 [ i ] );
  for ( int i = 0;
  i < n2;
  i ++ ) {
    for ( int j = 0;
    j < n3;
    j ++ ) {
      if ( s . find ( sum - a2 [ i ] - a3 [ j ] ) != s . end ( ) ) return true;
    }
  }
  return false;
}


FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASING_AND_THEN_DECREASING_1 | int findMaximum ( int arr [ ], int low, int high ) {
  if ( low == high ) return arr [ low ];
  if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ];
  if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ];
  int mid = ( low + high ) / 2;
  if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ];
  if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr, low, mid - 1 );
  else return findMaximum ( arr, mid + 1, high );
}


DYNAMIC_PROGRAMMING_SET_1 | int fib ( int n ) {
  if ( lookup [ n ] == NIL ) {
    if ( n <= 1 ) lookup [ n ] = n;
    else lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 );
  }
  return lookup [ n ];
}


MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC | int power ( int x, unsigned int y, int p ) {
  int res = 1;
  x = x % p;
  while ( y > 0 ) {
    if ( y & 1 ) res = ( res * x ) % p;
    y = y >> 1;
    x = ( x * x ) % p;
  }
  return res;
}


WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TWO_1 | int bool isPowerOfTwo ( int x ) {
  return x && ( ! ( x & ( x - 1 ) ) );
}


LONGEST_COMMON_SUBSEQUENCE_WITH_PERMUTATIONS_ALLOWED | void longestString ( string str1, string str2 ) {
  int count1 [ 26 ] = {
    0 },
    count2 [ 26 ] = {
      0 };
      for ( int i = 0;
      i < str1 . length ( );
      i ++ ) count1 [ str1 [ i ] - 'a' ] ++;
      for ( int i = 0;
      i < str2 . length ( );
      i ++ ) count2 [ str2 [ i ] - 'a' ] ++;
      string result;
      for ( int i = 0;
      i < 26;
      i ++ ) for ( int j = 1;
      j <= min ( count1 [ i ], count2 [ i ] );
      j ++ ) result . push_back ( 'a' + i );
      cout << result;
    }
    

DIFFERENCE_MAXIMUM_SUM_MINIMUM_SUM_N_M_ELEMENTSIN_REVIEW | int find_difference ( int arr [ ], int n, int m ) {
  int max = 0, min = 0;
  sort ( arr, arr + n );
  for ( int i = 0, j = n - 1;
  i < m;
  i ++, j -- ) {
    min += arr [ i ];
    max += arr [ j ];
  }
  return ( max - min );
}


PRINT_NUMBER_ASCENDING_ORDER_CONTAINS_1_2_3_DIGITS | string printNumbers ( int numbers [ ], int n ) {
  vector < int > oneTwoThree;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( findContainsOneTwoThree ( numbers [ i ] ) ) oneTwoThree . push_back ( numbers [ i ] );
  }
  sort ( oneTwoThree . begin ( ), oneTwoThree . end ( ) );
  string result = "";
  for ( auto number : oneTwoThree ) {
    int value = number;
    if ( result . length ( ) > 0 ) result += ", ";
    result += to_string ( value );
  }
  return ( result . length ( ) > 0 ) ? result : "-1";
}


DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE | int lis ( int arr [ ], int n ) {
  int max = 1;
  _lis ( arr, n, & max );
  return max;
}


MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET | int minRevolutions ( double r, int x1, int y1, int x2, int y2 ) {
  double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) );
  return ceil ( d / ( 2 * r ) );
}


CHECK_TWO_GIVEN_SETS_DISJOINT | bool areDisjoint ( int set1 [ ], int set2 [ ], int m, int n ) {
  for ( int i = 0;
  i < m;
  i ++ ) for ( int j = 0;
  j < n;
  j ++ ) if ( set1 [ i ] == set2 [ j ] ) return false;
  return true;
}


FIND_MINIMUM_SUM_FACTORS_NUMBER | int findMinSum ( int num ) {
  int sum = 0;
  for ( int i = 2;
  i * i <= num;
  i ++ ) {
    while ( num % i == 0 ) {
      sum += i;
      num /= i;
    }
  }
  sum += num;
  return sum;
}


FREQUENT_ELEMENT_ARRAY | int mostFrequent ( int arr [ ], int n ) {
  sort ( arr, arr + n );
  int max_count = 1, res = arr [ 0 ], curr_count = 1;
  for ( int i = 1;
  i < n;
  i ++ ) {
    if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++;
    else {
      if ( curr_count > max_count ) {
        max_count = curr_count;
        res = arr [ i - 1 ];
      }
      curr_count = 1;
    }
  }
  if ( curr_count > max_count ) {
    max_count = curr_count;
    res = arr [ n - 1 ];
  }
  return res;
}


MINIMUM_XOR_VALUE_PAIR_1 | int minXOR ( int arr [ ], int n ) {
  sort ( arr, arr + n );
  int minXor = INT_MAX;
  int val = 0;
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    val = arr [ i ] ^ arr [ i + 1 ];
    minXor = min ( minXor, val );
  }
  return minXor;
}


MINIMUM_SUM_PRODUCT_TWO_ARRAYS | int minproduct ( int a [ ], int b [ ], int n, int k ) {
  int diff = 0, res = 0;
  int temp;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int pro = a [ i ] * b [ i ];
    res = res + pro;
    if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ];
    else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ];
    else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ];
    else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ];
    int d = abs ( pro - temp );
    if ( d > diff ) diff = d;
  }
  return res - diff;
}


FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERATOR_RUSSIAN_PEASANTS_ALGORITHM | unsigned int russianPeasant ( unsigned int a, unsigned int b ) {
  int res = 0;
  while ( b > 0 ) {
    if ( b & 1 ) res = res + a;
    a = a << 1;
    b = b >> 1;
  }
  return res;
}


DIVISIBILITY_9_USING_BITWISE_OPERATORS | bool isDivBy9 ( int n ) {
  if ( n == 0 || n == 9 ) return true;
  if ( n < 9 ) return false;
  return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) );
}


CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT | bool isInorder ( int arr [ ], int n ) {
  if ( n == 0 || n == 1 ) return true;
  for ( int i = 1;
  i < n;
  i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false;
  return true;
}


GIVEN_TWO_UNSORTED_ARRAYS_FIND_PAIRS_WHOSE_SUM_X | void findPairs ( int arr1 [ ], int arr2 [ ], int n, int m, int x ) {
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 0;
  j < m;
  j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) cout << arr1 [ i ] << " " << arr2 [ j ] << endl;
}


BINARY_REPRESENTATION_OF_NEXT_NUMBER | string nextGreater ( string num ) {
  int l = num . size ( );
  for ( int i = l - 1;
  i >= 0;
  i -- ) {
    if ( num . at ( i ) == '0' ) {
      num . at ( i ) = '1';
      break;
    }
    else num . at ( i ) = '0';
  }
  if ( i < 0 ) num = "1" + num;
  return num;
}


LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S | int findSubArray ( int arr [ ], int n ) {
  int sum = 0;
  int maxsize = - 1, startindex;
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    sum = ( arr [ i ] == 0 ) ? - 1 : 1;
    for ( int j = i + 1;
    j < n;
    j ++ ) {
      ( arr [ j ] == 0 ) ? ( sum += - 1 ) : ( sum += 1 );
      if ( sum == 0 && maxsize < j - i + 1 ) {
        maxsize = j - i + 1;
        startindex = i;
      }
    }
  }
  if ( maxsize == - 1 ) cout << "No such subarray";
  else cout << startindex << " to " << startindex + maxsize - 1;
  return maxsize;
}


COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1 | int countPairs ( int arr [ ], int n ) {
  int result = 0;
  set < int > Hash;
  for ( int i = 0;
  i < n;
  i ++ ) Hash . insert ( arr [ i ] );
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = i + 1;
    j < n;
    j ++ ) {
      int product = arr [ i ] * arr [ j ];
      if ( Hash . find ( product ) != Hash . end ( ) ) result ++;
    }
  }
  return result;
}


DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE | int lps ( char * str ) {
  int n = strlen ( str );
  int i, j, cl;
  int L [ n ] [ n ];
  for ( i = 0;
  i < n;
  i ++ ) L [ i ] [ i ] = 1;
  for ( cl = 2;
  cl <= n;
  cl ++ ) {
    for ( i = 0;
    i < n - cl + 1;
    i ++ ) {
      j = i + cl - 1;
      if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ] = 2;
      else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2;
      else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ], L [ i + 1 ] [ j ] );
    }
  }
  return L [ 0 ] [ n - 1 ];
}


COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1 | int getInvCount ( int arr [ ], int n ) {
  int invcount = 0;
  for ( int i = 1;
  i < n - 1;
  i ++ ) {
    int small = 0;
    for ( int j = i + 1;
    j < n;
    j ++ ) if ( arr [ i ] > arr [ j ] ) small ++;
    int great = 0;
    for ( int j = i - 1;
    j >= 0;
    j -- ) if ( arr [ i ] < arr [ j ] ) great ++;
    invcount += great * small;
  }
  return invcount;
}


DECIMAL_REPRESENTATION_GIVEN_BINARY_STRING_DIVISIBLE_10_NOT | bool isDivisibleBy10 ( string bin ) {
  int n = bin . size ( );
  if ( bin [ n - 1 ] == '1' ) return false;
  int sum = 0;
  for ( int i = n - 2;
  i >= 0;
  i -- ) {
    if ( bin [ i ] == '1' ) {
      int posFromRight = n - i - 1;
      if ( posFromRight % 4 == 1 ) sum = sum + 2;
      else if ( posFromRight % 4 == 2 ) sum = sum + 4;
      else if ( posFromRight % 4 == 3 ) sum = sum + 8;
      else if ( posFromRight % 4 == 0 ) sum = sum + 6;
    }
  }
  if ( sum % 10 == 0 ) return true;
  return false;
}


FIND_WHETHER_AN_ARRAY_IS_SUBSET_OF_ANOTHER_ARRAY_SET_1_1 | bool isSubset ( int arr1 [ ], int arr2 [ ], int m, int n ) {
  int i = 0, j = 0;
  if ( m < n ) return 0;
  sort ( arr1, arr1 + m );
  sort ( arr2, arr2 + n );
  while ( i < n && j < m ) {
    if ( arr1 [ j ] < arr2 [ i ] ) j ++;
    else if ( arr1 [ j ] == arr2 [ i ] ) {
      j ++;
      i ++;
    }
    else if ( arr1 [ j ] > arr2 [ i ] ) return 0;
  }
  return ( i < n ) ? false : true;
}


DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1 | bool isSubsetSum ( int set [ ], int n, int sum ) {
  bool subset [ n + 1 ] [ sum + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) subset [ i ] [ 0 ] = true;
  for ( int i = 1;
  i <= sum;
  i ++ ) subset [ 0 ] [ i ] = false;
  for ( int i = 1;
  i <= n;
  i ++ ) {
    for ( int j = 1;
    j <= sum;
    j ++ ) {
      if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ];
      if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ];
    }
  }
  return subset [ n ] [ sum ];
}


SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS_1 | int kthgroupsum ( int k ) {
  return k * k * k;
}


THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS | void thirdLargest ( int arr [ ], int arr_size ) {
  if ( arr_size < 3 ) {
    printf ( " Invalid Input " );
    return;
  }
  int first = arr [ 0 ];
  for ( int i = 1;
  i < arr_size;
  i ++ ) if ( arr [ i ] > first ) first = arr [ i ];
  int second = INT_MIN;
  for ( int i = 0;
  i < arr_size;
  i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ];
  int third = INT_MIN;
  for ( int i = 0;
  i < arr_size;
  i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ];
  printf ( "The third Largest element is %d\n", third );
}


FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1 | int sumNodes ( int l ) {
  int leafNodeCount = pow ( 2, l - 1 );
  int sumLastLevel = 0;
  sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2;
  int sum = sumLastLevel * l;
  return sum;
}


MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2 | int middleOfThree ( int a, int b, int c ) {
  int x = a - b;
  int y = b - c;
  int z = a - c;
  if ( x * y > 0 ) return b;
  else if ( x * z > 0 ) return c;
  else return a;
}


MAXIMUM_TRIPLET_SUM_ARRAY_2 | int maxTripletSum ( int arr [ ], int n ) {
  int maxA = INT_MIN, maxB = INT_MIN, maxC = INT_MIN;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] > maxA ) {
      maxC = maxB;
      maxB = maxA;
      maxA = arr [ i ];
    }
    else if ( arr [ i ] > maxB ) {
      maxC = maxB;
      maxB = arr [ i ];
    }
    else if ( arr [ i ] > maxC ) maxC = arr [ i ];
  }
  return ( maxA + maxB + maxC );
}


COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1 | int countPairs ( int arr1 [ ], int arr2 [ ], int m, int n, int x ) {
  int count = 0;
  unordered_set < int > us;
  for ( int i = 0;
  i < m;
  i ++ ) us . insert ( arr1 [ i ] );
  for ( int j = 0;
  j < n;
  j ++ ) if ( us . find ( x - arr2 [ j ] ) != us . end ( ) ) count ++;
  return count;
}


MINIMUM_STEPS_REACH_END_ARRAY_CONSTRAINTS | int getMinStepToReachEnd ( int arr [ ], int N ) {
  bool visit [ N ];
  int distance [ N ];
  vector < int > digit [ 10 ];
  memset ( visit, false, sizeof ( visit ) );
  for ( int i = 1;
  i < N;
  i ++ ) digit [ arr [ i ] ] . push_back ( i );
  distance [ 0 ] = 0;
  visit [ 0 ] = true;
  queue < int > q;
  q . push ( 0 );
  while ( ! q . empty ( ) ) {
    int idx = q . front ( );
    q . pop ( );
    if ( idx == N - 1 ) break;
    int d = arr [ idx ];
    for ( int i = 0;
    i < digit [ d ] . size ( );
    i ++ ) {
      int nextidx = digit [ d ] [ i ];
      if ( ! visit [ nextidx ] ) {
        visit [ nextidx ] = true;
        q . push ( nextidx );
        distance [ nextidx ] = distance [ idx ] + 1;
      }
    }
    digit [ d ] . clear ( );
    if ( idx - 1 >= 0 && ! visit [ idx - 1 ] ) {
      visit [ idx - 1 ] = true;
      q . push ( idx - 1 );
      distance [ idx - 1 ] = distance [ idx ] + 1;
    }
    if ( idx + 1 < N && ! visit [ idx + 1 ] ) {
      visit [ idx + 1 ] = true;
      q . push ( idx + 1 );
      distance [ idx + 1 ] = distance [ idx ] + 1;
    }
  }
  return distance [ N - 1 ];
}


LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS | void minimizeWithKSwaps ( int arr [ ], int n, int k ) {
  for ( int i = 0;
  i < n - 1 && k > 0;
  ++ i ) {
    int pos = i;
    for ( int j = i + 1;
    j < n;
    ++ j ) {
      if ( j - i > k ) break;
      if ( arr [ j ] < arr [ pos ] ) pos = j;
    }
    for ( int j = pos;
    j > i;
    -- j ) swap ( arr [ j ], arr [ j - 1 ] );
    k -= pos - i;
  }
}


CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE | string printSequence ( string arr [ ], string input ) {
  string output = "";
  int n = input . length ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( input [ i ] == ' ' ) output = output + "0";
    else {
      int position = input [ i ] - 'A';
      output = output + arr [ position ];
    }
  }
  return output;
}


PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE | int arraySortedOrNot ( int arr [ ], int n ) {
  if ( n == 1 || n == 0 ) return 1;
  if ( arr [ n - 1 ] < arr [ n - 2 ] ) return 0;
  return arraySortedOrNot ( arr, n - 1 );
}


CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT | int circle ( int x1, int y1, int x2, int y2, int r1, int r2 ) {
  int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 );
  int radSumSq = ( r1 + r2 ) * ( r1 + r2 );
  if ( distSq == radSumSq ) return 1;
  else if ( distSq > radSumSq ) return - 1;
  else return 0;
}


SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2 | unsigned int nextPowerOf2 ( unsigned int n ) {
  n --;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n ++;
  return n;
}


PADOVAN_SEQUENCE | int pad ( int n ) {
  int pPrevPrev = 1, pPrev = 1, pCurr = 1, pNext = 1;
  for ( int i = 3;
  i <= n;
  i ++ ) {
    pNext = pPrevPrev + pPrev;
    pPrevPrev = pPrev;
    pPrev = pCurr;
    pCurr = pNext;
  }
  return pNext;
}


CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS | bool check ( string s ) {
  if ( s . size ( ) >= 10 ) return true;
  for ( int i = 1;
  i < s . size ( );
  i ++ ) {
    for ( int j = i + 1;
    j < s . size ( );
    j ++ ) {
      for ( int k = j + 1;
      k < s . size ( );
      k ++ ) {
        string s1 = s . substr ( 0, i );
        string s2 = s . substr ( i, j - i );
        string s3 = s . substr ( j, k - j );
        string s4 = s . substr ( k, s . size ( ) - k );
        if ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 && s2 != s4 && s3 != s4 ) return true;
      }
    }
  }
  return false;
}


PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K | bool isPossible ( int a [ ], int b [ ], int n, int k ) {
  sort ( a, a + n );
  sort ( b, b + n, greater < int > ( ) );
  for ( int i = 0;
  i < n;
  i ++ ) if ( a [ i ] + b [ i ] < k ) return false;
  return true;
}


ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES | int winner ( int a [ ], int n, int k ) {
  if ( k >= n - 1 ) return n;
  int best = 0, times = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( a [ i ] > best ) {
      best = a [ i ];
      if ( i ) times = 1;
    }
    else times += 1;
    if ( times >= k ) return best;
  }
  return best;
}


DIRECTION_LAST_SQUARE_BLOCK | void direction ( ll R, ll C ) {
  if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) {
    cout << "Left" << endl;
    return;
  }
  if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) {
    cout << "Up" << endl;
    return;
  }
  if ( R == C && R % 2 != 0 && C % 2 != 0 ) {
    cout << "Right" << endl;
    return;
  }
  if ( R == C && R % 2 == 0 && C % 2 == 0 ) {
    cout << "Left" << endl;
    return;
  }
  if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) {
    cout << "Right" << endl;
    return;
  }
  if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) {
    cout << "Down" << endl;
    return;
  }
  if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) {
    cout << "Left" << endl;
    return;
  }
  if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) {
    cout << "Up" << endl;
    return;
  }
  if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) {
    cout << "Down" << endl;
    return;
  }
  if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) {
    cout << "Right" << endl;
    return;
  }
}


NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N | int countIntegralSolutions ( int n ) {
  int result = 0;
  for ( int i = 0;
  i <= n;
  i ++ ) for ( int j = 0;
  j <= n - i;
  j ++ ) for ( int k = 0;
  k <= ( n - i - j );
  k ++ ) if ( i + j + k == n ) result ++;
  return result;
}


SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX | void swapDiagonal ( int matrix [ ] [ N ] ) {
  for ( int i = 0;
  i < N;
  i ++ ) swap ( matrix [ i ] [ i ], matrix [ i ] [ N - i - 1 ] );
}


MINIMUM_OPERATIONS_MAKE_GCD_ARRAY_MULTIPLE_K | int MinOperation ( int a [ ], int n, int k ) {
  int result = 0;
  for ( int i = 0;
  i < n;
  ++ i ) {
    if ( a [ i ] != 1 && a [ i ] > k ) {
      result = result + min ( a [ i ] % k, k - a [ i ] % k );
    }
    else {
      result = result + k - a [ i ];
    }
  }
  return result;
}


MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX | long long int maxDecimalValue ( int mat [ ] [ N ], int i, int j, int p ) {
  if ( i >= N || j >= N ) return 0;
  int result = max ( maxDecimalValue ( mat, i, j + 1, p + 1 ), maxDecimalValue ( mat, i + 1, j, p + 1 ) );
  if ( mat [ i ] [ j ] == 1 ) return pow ( 2, p ) + result;
  else return result;
}


SQUARE_ROOT_OF_A_PERFECT_SQUARE_1 | public : float squareRoot ( float n ) {
  float x = n;
  float y = 1;
  float e = 0.000001;
  while ( x - y > e ) {
    x = ( x + y ) / 2;
    y = n / x;
  }
  return x;
}


FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX | void KMP ( int m, int n, string str2, string str1 ) {
  int pos = 0, len = 0;
  int p [ m + 1 ];
  int k = 0;
  p [ 1 ] = 0;
  for ( int i = 2;
  i <= n;
  i ++ ) {
    while ( k > 0 && str1 [ k ] != str1 [ i - 1 ] ) k = p [ k ];
    if ( str1 [ k ] == str1 [ i - 1 ] ) ++ k;
    p [ i ] = k;
  }
  for ( int j = 0, i = 0;
  i < m;
  i ++ ) {
    while ( j > 0 && str1 [ j ] != str2 [ i ] ) j = p [ j ];
    if ( str1 [ j ] == str2 [ i ] ) j ++;
    if ( j > len ) {
      len = j;
      pos = i - j + 1;
    }
  }
  cout << "Shift = " << pos << endl;
  cout << "Prefix = " << str1 . substr ( 0, len );
}


SORTED_ORDER_PRINTING_OF_AN_ARRAY_THAT_REPRESENTS_A_BST | void printSorted ( int arr [ ], int start, int end ) {
  if ( start > end ) return;
  printSorted ( arr, start * 2 + 1, end );
  cout << arr [ start ] << " ";
  printSorted ( arr, start * 2 + 2, end );
}


CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE | bool check ( int degree [ ], int n ) {
  int deg_sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) deg_sum += degree [ i ];
  return ( 2 * ( n - 1 ) == deg_sum );
}


MOVE_ZEROES_END_ARRAY | void pushZerosToEnd ( int arr [ ], int n ) {
  int count = 0;
  for ( int i = 0;
  i < n;
  i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ];
  while ( count < n ) arr [ count ++ ] = 0;
}


COUNT_ELEMENTS_WHICH_DIVIDE_ALL_NUMBERS_IN_RANGE_L_R | int answerQuery ( int a [ ], int n, int l, int r ) {
  int count = 0;
  l = l - 1;
  for ( int i = l;
  i < r;
  i ++ ) {
    int element = a [ i ];
    int divisors = 0;
    for ( int j = l;
    j < r;
    j ++ ) {
      if ( a [ j ] % a [ i ] == 0 ) divisors ++;
      else break;
    }
    if ( divisors == ( r - l ) ) count ++;
  }
  return count;
}


SUM_LARGEST_PRIME_FACTOR_NUMBER_LESS_EQUAL_N | int sumOfLargePrimeFactor ( int n ) {
  int prime [ n + 1 ], sum = 0;
  memset ( prime, 0, sizeof ( prime ) );
  int max = n / 2;
  for ( int p = 2;
  p <= max;
  p ++ ) {
    if ( prime [ p ] == 0 ) {
      for ( int i = p * 2;
      i <= n;
      i += p ) prime [ i ] = p;
    }
  }
  for ( int p = 2;
  p <= n;
  p ++ ) {
    if ( prime [ p ] ) sum += prime [ p ];
    else sum += p;
  }
  return sum;
}


REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SUM | string arrangeString ( string str ) {
  int char_count [ MAX_CHAR ] = {
    0 };
    int sum = 0;
    for ( int i = 0;
    i < str . length ( );
    i ++ ) {
      if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) char_count [ str [ i ] - 'A' ] ++;
      else sum = sum + ( str [ i ] - '0' );
    }
    string res = "";
    for ( int i = 0;
    i < MAX_CHAR;
    i ++ ) {
      char ch = ( char ) ( 'A' + i );
      while ( char_count [ i ] -- ) res = res + ch;
    }
    if ( sum > 0 ) res = res + to_string ( sum );
    return res;
  }
  

COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1 | int numberOfPaths ( int m, int n ) {
  int count [ m ] [ n ];
  for ( int i = 0;
  i < m;
  i ++ ) count [ i ] [ 0 ] = 1;
  for ( int j = 0;
  j < n;
  j ++ ) count [ 0 ] [ j ] = 1;
  for ( int i = 1;
  i < m;
  i ++ ) {
    for ( int j = 1;
    j < n;
    j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ];
  }
  return count [ m - 1 ] [ n - 1 ];
}


DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1 | int editDistDP ( string str1, string str2, int m, int n ) {
  int dp [ m + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= m;
  i ++ ) {
    for ( int j = 0;
    j <= n;
    j ++ ) {
      if ( i == 0 ) dp [ i ] [ j ] = j;
      else if ( j == 0 ) dp [ i ] [ j ] = i;
      else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ];
      else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ], dp [ i - 1 ] [ j - 1 ] );
    }
  }
  return dp [ m ] [ n ];
}


FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES | int countSol ( int coeff [ ], int start, int end, int rhs ) {
  if ( rhs == 0 ) return 1;
  int result = 0;
  for ( int i = start;
  i <= end;
  i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff, i, end, rhs - coeff [ i ] );
  return result;
}


SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1 | void minheapify ( int a [ ], int index ) {
  int small = index;
  int l = 2 * index + 1;
  int r = 2 * index + 2;
  if ( l < n && a [ l ] < a [ small ] ) small = l;
  if ( r < n && a [ r ] < a [ small ] ) small = r;
  if ( small != index ) {
    swap ( a [ small ], a [ index ] );
    minheapify ( a, small );
  }
}


SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM | void computeLPSArray ( char * pat, int M, int * lps ) {
  int len = 0;
  lps [ 0 ] = 0;
  int i = 1;
  while ( i < M ) {
    if ( pat [ i ] == pat [ len ] ) {
      len ++;
      lps [ i ] = len;
      i ++;
    }
    else {
      if ( len != 0 ) {
        len = lps [ len - 1 ];
      }
      else {
        lps [ i ] = 0;
        i ++;
      }
    }
  }
}


FIND_MINIMUM_DIFFERENCE_PAIR | int findMinDiff ( int arr [ ], int n ) {
  int diff = INT_MAX;
  for ( int i = 0;
  i < n - 1;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = abs ( arr [ i ] - arr [ j ] );
  return diff;
}


PRINT_FIRST_K_DIGITS_1N_N_POSITIVE_INTEGER | void print ( int n, int k ) {
  int rem = 1;
  for ( int i = 0;
  i < k;
  i ++ ) {
    cout << ( 10 * rem ) / n;
    rem = ( 10 * rem ) % n;
  }
}


GROUP_MULTIPLE_OCCURRENCE_OF_ARRAY_ELEMENTS_ORDERED_BY_FIRST_OCCURRENCE | void groupElements ( int arr [ ], int n ) {
  bool * visited = new bool [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) visited [ i ] = false;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( ! visited [ i ] ) {
      cout << arr [ i ] << " ";
      for ( int j = i + 1;
      j < n;
      j ++ ) {
        if ( arr [ i ] == arr [ j ] ) {
          cout << arr [ i ] << " ";
          visited [ j ] = true;
        }
      }
    }
  }
  delete [ ] visited;
}


CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY | bool checkIsAP ( int arr [ ], int n ) {
  if ( n == 1 ) return true;
  sort ( arr, arr + n );
  int d = arr [ 1 ] - arr [ 0 ];
  for ( int i = 2;
  i < n;
  i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false;
  return true;
}


NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES | int findPosition ( int k, int n ) {
  unsigned long long int f1 = 0, f2 = 1, f3;
  for ( int i = 2;
  i <= MAX;
  i ++ ) {
    f3 = f1 + f2;
    f1 = f2;
    f2 = f3;
    if ( f2 % k == 0 ) return n * i;
  }
}


COUNT_PAIRS_DIFFERENCE_EQUAL_K_1 | int countPairsWithDiffK ( int arr [ ], int n, int k ) {
  int count = 0;
  sort ( arr, arr + n );
  int l = 0;
  int r = 0;
  while ( r < n ) {
    if ( arr [ r ] - arr [ l ] == k ) {
      count ++;
      l ++;
      r ++;
    }
    else if ( arr [ r ] - arr [ l ] > k ) l ++;
    else r ++;
  }
  return count;
}


ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY | int countNum ( int arr [ ], int n ) {
  int count = 0;
  sort ( arr, arr + n );
  for ( int i = 0;
  i < n - 1;
  i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1;
  return count;
}


MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS | string maximumPalinUsingKChanges ( string str, int k ) {
  string palin = str;
  int l = 0;
  int r = str . length ( ) - 1;
  while ( l < r ) {
    if ( str [ l ] != str [ r ] ) {
      palin [ l ] = palin [ r ] = max ( str [ l ], str [ r ] );
      k --;
    }
    l ++;
    r --;
  }
  if ( k < 0 ) return "Not possible";
  l = 0;
  r = str . length ( ) - 1;
  while ( l <= r ) {
    if ( l == r ) {
      if ( k > 0 ) palin [ l ] = '9';
    }
    if ( palin [ l ] < '9' ) {
      if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ] == str [ r ] ) {
        k -= 2;
        palin [ l ] = palin [ r ] = '9';
      }
      else if ( k >= 1 && ( palin [ l ] != str [ l ] || palin [ r ] != str [ r ] ) ) {
        k --;
        palin [ l ] = palin [ r ] = '9';
      }
    }
    l ++;
    r --;
  }
  return palin;
}


SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THEM | void subArray ( int arr [ ], int n ) {
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = i;
    j < n;
    j ++ ) {
      for ( int k = i;
      k <= j;
      k ++ ) cout << arr [ k ] << " ";
      cout << endl;
    }
  }
}


MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS | int maximumSum ( int a [ ] [ M ], int n ) {
  for ( int i = 0;
  i < n;
  i ++ ) sort ( a [ i ], a [ i ] + M );
  int sum = a [ n - 1 ] [ M - 1 ];
  int prev = a [ n - 1 ] [ M - 1 ];
  int i, j;
  for ( i = n - 2;
  i >= 0;
  i -- ) {
    for ( j = M - 1;
    j >= 0;
    j -- ) {
      if ( a [ i ] [ j ] < prev ) {
        prev = a [ i ] [ j ];
        sum += prev;
        break;
      }
    }
    if ( j == - 1 ) return 0;
  }
  return sum;
}


C_PROGRAM_FACTORIAL_NUMBER | unsigned int factorial ( unsigned int n ) {
  if ( n == 0 ) return 1;
  return n * factorial ( n - 1 );
}


PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING | void printSquares ( int n ) {
  int square = 0, prev_x = 0;
  for ( int x = 0;
  x < n;
  x ++ ) {
    square = ( square + x + prev_x );
    cout << square << " ";
    prev_x = x;
  }
}


ROPES_DATA_STRUCTURE_FAST_STRING_CONCATENATION | void concatenate ( char a [ ], char b [ ], char c [ ], int n1, int n2 ) {
  int i;
  for ( i = 0;
  i < n1;
  i ++ ) c [ i ] = a [ i ];
  for ( int j = 0;
  j < n2;
  j ++ ) c [ i ++ ] = b [ j ];
  c [ i ] = '\0';
}


GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_X | void printClosest ( int ar1 [ ], int ar2 [ ], int m, int n, int x ) {
  int diff = INT_MAX;
  int res_l, res_r;
  int l = 0, r = n - 1;
  while ( l < m && r >= 0 ) {
    if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) {
      res_l = l;
      res_r = r;
      diff = abs ( ar1 [ l ] + ar2 [ r ] - x );
    }
    if ( ar1 [ l ] + ar2 [ r ] > x ) r --;
    else l ++;
  }
  cout << "The closest pair is [" << ar1 [ res_l ] << ", " << ar2 [ res_r ] << "] \n";
}


CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES | int minRemove ( int arr [ ], int n ) {
  int LIS [ n ], len = 0;
  for ( int i = 0;
  i < n;
  i ++ ) LIS [ i ] = 1;
  for ( int i = 1;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < i;
    j ++ ) {
      if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) {
        LIS [ i ] = max ( LIS [ i ], LIS [ j ] + 1 );
      }
    }
    len = max ( len, LIS [ i ] );
  }
  return n - len;
}


TAIL_RECURSION | unsigned int fact ( unsigned int n ) {
  if ( n == 0 ) return 1;
  return n * fact ( n - 1 );
}


RECURSIVE_FUNCTIONS | void tower ( int n, char sourcePole, char destinationPole, char auxiliaryPole ) {
  if ( 0 == n ) return;
  tower ( n - 1, sourcePole, auxiliaryPole, destinationPole );
  cout << "Move the disk " << n << " from " << sourcePole << " to " << destinationPole << endl;
  tower ( n - 1, auxiliaryPole, destinationPole, sourcePole );
}


FIND_X_Y_SATISFYING_AX_N | void solution ( int a, int b, int n ) {
  for ( int i = 0;
  i * a <= n;
  i ++ ) {
    if ( ( n - ( i * a ) ) % b == 0 ) {
      cout << "x = " << i << ", y = " << ( n - ( i * a ) ) / b;
      return;
    }
  }
  cout << "No solution";
}


EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1 | long exponentiation ( long base, long exp ) {
  long t = 1L;
  while ( exp > 0 ) {
    if ( exp % 2 != 0 ) t = ( t * base ) % N;
    base = ( base * base ) % N;
    exp /= 2;
  }
  return t % N;
}


CHECK_OCCURRENCES_CHARACTER_APPEAR_TOGETHER | bool checkIfAllTogether ( string s, char c ) {
  bool oneSeen = false;
  int i = 0, n = s . length ( );
  while ( i < n ) {
    if ( s [ i ] == c ) {
      if ( oneSeen == true ) return false;
      while ( i < n && s [ i ] == c ) i ++;
      oneSeen = true;
    }
    else i ++;
  }
  return true;
}


MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY | int findArea ( int arr [ ], int n ) {
  sort ( arr, arr + n, greater < int > ( ) );
  int dimension [ 2 ] = {
    0, 0 };
    for ( int i = 0, j = 0;
    i < n - 1 && j < 2;
    i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ];
    return ( dimension [ 0 ] * dimension [ 1 ] );
  }
  

PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE | int Circumference ( int a ) {
  return 4 * a;
}


CYCLE_SORT | void cycleSort ( int arr [ ], int n ) {
  int writes = 0;
  for ( int cycle_start = 0;
  cycle_start <= n - 2;
  cycle_start ++ ) {
    int item = arr [ cycle_start ];
    int pos = cycle_start;
    for ( int i = cycle_start + 1;
    i < n;
    i ++ ) if ( arr [ i ] < item ) pos ++;
    if ( pos == cycle_start ) continue;
    while ( item == arr [ pos ] ) pos += 1;
    if ( pos != cycle_start ) {
      swap ( item, arr [ pos ] );
      writes ++;
    }
    while ( pos != cycle_start ) {
      pos = cycle_start;
      for ( int i = cycle_start + 1;
      i < n;
      i ++ ) if ( arr [ i ] < item ) pos += 1;
      while ( item == arr [ pos ] ) pos += 1;
      if ( item != arr [ pos ] ) {
        swap ( item, arr [ pos ] );
        writes ++;
      }
    }
  }
}


SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE | int selectRandom ( int x ) {
  static int res;
  static int count = 0;
  count ++;
  if ( count == 1 ) res = x;
  else {
    int i = rand ( ) % count;
    if ( i == count - 1 ) res = x;
  }
  return res;
}


HOSOYAS_TRIANGLE | void printHosoya ( int n ) {
  int dp [ N ] [ N ];
  memset ( dp, 0, sizeof ( dp ) );
  dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1;
  for ( int i = 2;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ];
      else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ];
    }
  }
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j <= i;
    j ++ ) cout << dp [ i ] [ j ] << " ";
    cout << endl;
  }
}


DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION | int lastPosition ( int n, int m, int k ) {
  if ( m <= n - k + 1 ) return m + k - 1;
  m = m - ( n - k + 1 );
  return ( m % n == 0 ) ? n : ( m % n );
}


PRINTING_LONGEST_INCREASING_CONSECUTIVE_SUBSEQUENCE | void longestSubsequence ( int a [ ], int n ) {
  unordered_map < int, int > mp;
  int dp [ n ];
  memset ( dp, 0, sizeof ( dp ) );
  int maximum = INT_MIN;
  int index = - 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( mp . find ( a [ i ] - 1 ) != mp . end ( ) ) {
      int lastIndex = mp [ a [ i ] - 1 ] - 1;
      dp [ i ] = 1 + dp [ lastIndex ];
    }
    else dp [ i ] = 1;
    mp [ a [ i ] ] = i + 1;
    if ( maximum < dp [ i ] ) {
      maximum = dp [ i ];
      index = i;
    }
  }
  for ( int curr = a [ index ] - maximum + 1;
  curr <= a [ index ];
  curr ++ ) cout << curr << " ";
}


NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS | int countTriangle ( int graph [ V ] [ V ], bool isDirected ) {
  int count_Triangle = 0;
  for ( int i = 0;
  i < V;
  i ++ ) {
    for ( int j = 0;
    j < V;
    j ++ ) {
      for ( int k = 0;
      k < V;
      k ++ ) {
        if ( graph [ i ] [ j ] && graph [ j ] [ k ] && graph [ k ] [ i ] ) count_Triangle ++;
      }
    }
  }
  isDirected ? count_Triangle /= 3 : count_Triangle /= 6;
  return count_Triangle;
}


CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTANCE | bool checkDuplicatesWithinK ( int arr [ ], int n, int k ) {
  unordered_set < int > myset;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( myset . find ( arr [ i ] ) != myset . end ( ) ) return true;
    myset . insert ( arr [ i ] );
    if ( i >= k ) myset . erase ( arr [ i - k ] );
  }
  return false;
}


MINIMUM_INSERTIONS_SORT_ARRAY | int minInsertionStepToSortArray ( int arr [ ], int N ) {
  int lis [ N ];
  for ( int i = 0;
  i < N;
  i ++ ) lis [ i ] = 1;
  for ( int i = 1;
  i < N;
  i ++ ) for ( int j = 0;
  j < i;
  j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1;
  int max = 0;
  for ( int i = 0;
  i < N;
  i ++ ) if ( max < lis [ i ] ) max = lis [ i ];
  return ( N - max );
}


GENERATE_TWO_OUTPUT_STRINGS_DEPENDING_UPON_OCCURRENCE_CHARACTER_INPUT_STRING | void printDuo ( string & str ) {
  int countChar [ MAX_CHAR ] = {
    0 };
    int n = str . length ( );
    for ( int i = 0;
    i < n;
    i ++ ) countChar [ str [ i ] - 'a' ] ++;
    string str1 = "", str2 = "";
    for ( int i = 0;
    i < MAX_CHAR;
    i ++ ) {
      if ( countChar [ i ] > 1 ) str2 = str2 + ( char ) ( i + 'a' );
      else if ( countChar [ i ] == 1 ) str1 = str1 + ( char ) ( i + 'a' );
    }
    cout << "String with characters occurring " << "once:\n";
    cout << str1 << "\n";
    cout << "String with characters occurring " << "multiple times:\n";
    cout << str2 << "\n";
  }
  

NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1 | int countDigits ( int a, int b ) {
  if ( a == 0 || b == 0 ) return 1;
  return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) ) + 1;
}


TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1 | long long int countNonDecreasing ( int n ) {
  int N = 10;
  long long count = 1;
  for ( int i = 1;
  i <= n;
  i ++ ) {
    count *= ( N + i - 1 );
    count /= i;
  }
  return count;
}


COUNT_STRINGS_ADJACENT_CHARACTERS_DIFFERENCE_ONE | int countStrs ( int n ) {
  long int dp [ n + 1 ] [ 27 ];
  memset ( dp, 0, sizeof ( dp ) );
  for ( int i = 0;
  i <= 25;
  i ++ ) dp [ 1 ] [ i ] = 1;
  for ( int i = 2;
  i <= n;
  i ++ ) {
    for ( int j = 0;
    j <= 25;
    j ++ ) if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ];
    else dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] );
  }
  long int sum = 0;
  for ( int i = 0;
  i <= 25;
  i ++ ) sum = ( sum + dp [ n ] [ i ] );
  return sum;
}


PROGRAM_TO_EFFICIENTLY_CALCULATE_EX | float exponential ( int n, float x ) {
  float sum = 1.0f;
  for ( int i = n - 1;
  i > 0;
  -- i ) sum = 1 + x * sum / i;
  return sum;
}


EFFICIENTLY_COMPUTE_SUMS_OF_DIAGONALS_OF_A_MATRIX_1 | void printDiagonalSums ( int mat [ ] [ MAX ], int n ) {
  int principal = 0, secondary = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    principal += mat [ i ] [ i ];
    secondary += mat [ i ] [ n - i - 1 ];
  }
  cout << "Principal Diagonal:" << principal << endl;
  cout << "Secondary Diagonal:" << secondary << endl;
}


PRINT_WAYS_BREAK_STRING_BRACKET_FORM | void findCombinations ( string str, int index, string out ) {
  if ( index == str . length ( ) ) cout << out << endl;
  for ( int i = index;
  i < str . length ( );
  i ++ ) findCombinations ( str, i + 1, out + "(" + str . substr ( index, i + 1 - index ) + ")" );
}


LINEAR_SEARCH | int search ( int arr [ ], int n, int x ) {
  int i;
  for ( i = 0;
  i < n;
  i ++ ) if ( arr [ i ] == x ) return i;
  return - 1;
}


FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2 | int singleNumber ( int a [ ], int n ) {
  unordered_set < int > s ( a, a + n );
  int arr_sum = accumulate ( a, a + n, 0 );
  int set_sum = accumulate ( s . begin ( ), s . end ( ), 0 );
  return ( 3 * set_sum - arr_sum ) / 2;
}


SEARCH_ALMOST_SORTED_ARRAY | int binarySearch ( int arr [ ], int l, int r, int x ) {
  if ( r >= l ) {
    int mid = l + ( r - l ) / 2;
    if ( arr [ mid ] == x ) return mid;
    if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 );
    if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 );
    if ( arr [ mid ] > x ) return binarySearch ( arr, l, mid - 2, x );
    return binarySearch ( arr, mid + 2, r, x );
  }
  return - 1;
}


EULERS_TOTIENT_FUNCTION_FOR_ALL_NUMBERS_SMALLER_THAN_OR_EQUAL_TO_N | void computeTotient ( int n ) {
  long long phi [ n + 1 ];
  for ( int i = 1;
  i <= n;
  i ++ ) phi [ i ] = i;
  for ( int p = 2;
  p <= n;
  p ++ ) {
    if ( phi [ p ] == p ) {
      phi [ p ] = p - 1;
      for ( int i = 2 * p;
      i <= n;
      i += p ) {
        phi [ i ] = ( phi [ i ] / p ) * ( p - 1 );
      }
    }
  }
  for ( int i = 1;
  i <= n;
  i ++ ) cout << "Totient of " << i << " is " << phi [ i ] << endl;
}


FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE | int findMinNumber ( int n ) {
  int count = 0, ans = 1;
  while ( n % 2 == 0 ) {
    count ++;
    n /= 2;
  }
  if ( count % 2 ) ans *= 2;
  for ( int i = 3;
  i <= sqrt ( n );
  i += 2 ) {
    count = 0;
    while ( n % i == 0 ) {
      count ++;
      n /= i;
    }
    if ( count % 2 ) ans *= i;
  }
  if ( n > 2 ) ans *= n;
  return ans;
}


COUNT_NUMBER_WAYS_JUMP_REACH_END | void countWaysToJump ( int arr [ ], int n ) {
  int count_jump [ n ];
  memset ( count_jump, 0, sizeof ( count_jump ) );
  for ( int i = n - 2;
  i >= 0;
  i -- ) {
    if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++;
    for ( int j = i + 1;
    j < n - 1 && j <= arr [ i ] + i;
    j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ];
    if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1;
  }
  for ( int i = 0;
  i < n;
  i ++ ) cout << count_jump [ i ] << " ";
}


CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1 | int substringConversions ( string str, int k, int b ) {
  int i = 0, sum = 0, counter = k - 1;
  for ( i;
  i < k;
  i ++ ) {
    sum = sum + ( ( str . at ( i ) - '0' ) * pow ( b, counter ) );
    counter --;
  }
  cout << sum << " ";
  int prev = sum;
  sum = 0, counter = 0;
  for ( i;
  i < str . size ( );
  i ++ ) {
    sum = prev - ( ( str . at ( i - k ) - '0' ) * pow ( b, k - 1 ) );
    sum = sum * b;
    sum = sum + ( str . at ( i ) - '0' );
    cout << sum << " ";
    prev = sum;
    counter ++;
  }
}


TWO_ELEMENTS_WHOSE_SUM_IS_CLOSEST_TO_ZERO | void minAbsSumPair ( int arr [ ], int arr_size ) {
  int inv_count = 0;
  int l, r, min_sum, sum, min_l, min_r;
  if ( arr_size < 2 ) {
    cout << "Invalid Input";
    return;
  }
  min_l = 0;
  min_r = 1;
  min_sum = arr [ 0 ] + arr [ 1 ];
  for ( l = 0;
  l < arr_size - 1;
  l ++ ) {
    for ( r = l + 1;
    r < arr_size;
    r ++ ) {
      sum = arr [ l ] + arr [ r ];
      if ( abs ( min_sum ) > abs ( sum ) ) {
        min_sum = sum;
        min_l = l;
        min_r = r;
      }
    }
  }
  cout << "The two elements whose sum is minimum are " << arr [ min_l ] << " and " << arr [ min_r ];
}


HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS | int findoptimal ( int N ) {
  if ( N <= 6 ) return N;
  int screen [ N ];
  int b;
  int n;
  for ( n = 1;
  n <= 6;
  n ++ ) screen [ n - 1 ] = n;
  for ( n = 7;
  n <= N;
  n ++ ) {
    screen [ n - 1 ] = max ( 2 * screen [ n - 4 ], max ( 3 * screen [ n - 5 ], 4 * screen [ n - 6 ] ) );
  }
  return screen [ N - 1 ];
}


PROGRAM_DECIMAL_BINARY_CONVERSION_2 | unsigned long long int int decimalToBinary ( int N ) {
  ull B_Number = 0;
  int cnt = 0;
  while ( N != 0 ) {
    int rem = N % 2;
    ull c = pow ( 10, cnt );
    B_Number += rem * c;
    N /= 2;
    cnt ++;
  }
  return B_Number;
}


COUNTS_PATHS_POINT_REACH_ORIGIN_1 | int countPaths ( int n, int m ) {
  int dp [ n + 1 ] [ m + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) dp [ i ] [ 0 ] = 1;
  for ( int i = 0;
  i <= m;
  i ++ ) dp [ 0 ] [ i ] = 1;
  for ( int i = 1;
  i <= n;
  i ++ ) for ( int j = 1;
  j <= m;
  j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ];
  return dp [ n ] [ m ];
}


SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS | int sumBetweenTwoKth ( int arr [ ], int n, int k1, int k2 ) {
  sort ( arr, arr + n );
  return accumulate ( arr + k1, arr + k2 - 1, 0 );
}


SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS | void minRange ( int arr [ ], int n, int k ) {
  int l = 0, r = n;
  for ( int i = 0;
  i < n;
  i ++ ) {
    unordered_set < int > s;
    int j;
    for ( j = i;
    j < n;
    j ++ ) {
      s . insert ( arr [ j ] );
      if ( s . size ( ) == k ) {
        if ( ( j - i ) < ( r - l ) ) {
          r = j;
          l = i;
        }
        break;
      }
    }
    if ( j == n ) break;
  }
  if ( l == 0 && r == n ) cout << "Invalid k";
  else cout << l << " " << r;
}


AREA_OF_A_HEXAGON | double hexagonArea ( double s ) {
  return ( ( 3 * sqrt ( 3 ) * ( s * s ) ) / 2 );
}


NEXT_POWER_OF_2_2 | unsigned int nextPowerOf2 ( unsigned int n ) {
  n --;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n ++;
  return n;
}


COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES | int countOfSubstringWithKOnes ( string s, int K ) {
  int N = s . length ( );
  int res = 0;
  int countOfOne = 0;
  int freq [ N + 1 ] = {
    0 };
    freq [ 0 ] = 1;
    for ( int i = 0;
    i < N;
    i ++ ) {
      countOfOne += ( s [ i ] - '0' );
      if ( countOfOne >= K ) {
        res += freq [ countOfOne - K ];
      }
      freq [ countOfOne ] ++;
    }
    return res;
  }
  

NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE | int answer_query ( int a [ ], int n, int l, int r ) {
  int count = 0;
  for ( int i = l;
  i < r;
  i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1;
  return count;
}


CHECK_WHETHER_NUMBER_DUCK_NUMBER_NOT | int check_duck ( char * num ) {
  int len = strlen ( num );
  int count_zero = 0;
  char ch;
  for ( int i = 1;
  i < len;
  i ++ ) {
    ch = num [ i ];
    if ( ch == '0' ) count_zero ++;
  }
  return count_zero;
}


NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N_1 | int countIntegralSolutions ( int n ) {
  return ( ( n + 1 ) * ( n + 2 ) ) / 2;
}


MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_K_TIMES_1 | int maxProfit ( int price [ ], int n, int k ) {
  int profit [ k + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= k;
  i ++ ) profit [ i ] [ 0 ] = 0;
  for ( int j = 0;
  j <= n;
  j ++ ) profit [ 0 ] [ j ] = 0;
  for ( int i = 1;
  i <= k;
  i ++ ) {
    int prevDiff = INT_MIN;
    for ( int j = 1;
    j < n;
    j ++ ) {
      prevDiff = max ( prevDiff, profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] );
      profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ], price [ j ] + prevDiff );
    }
  }
  return profit [ k ] [ n - 1 ];
}


COUNT_CHARACTERS_POSITION_ENGLISH_ALPHABETS | int findCount ( string str ) {
  int result = 0;
  for ( int i = 0;
  i < str . size ( );
  i ++ ) if ( i == ( str [ i ] - 'a' ) || i == ( str [ i ] - 'A' ) ) result ++;
  return result;
}


COUNT_GFG_SUBSEQUENCES_GIVEN_STRING | void countSubsequence ( char s [ ], int n ) {
  int cntG = 0, cntF = 0, result = 0, C = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    switch ( s [ i ] ) {
      case 'G' : cntG ++;
      result += C;
      break;
      case 'F' : cntF ++;
      C += cntG;
      break;
      default : continue;
    }
  }
  cout << result << endl;
}


FIND_SMALLEST_VALUE_REPRESENTED_SUM_SUBSET_GIVEN_ARRAY | int findSmallest ( int arr [ ], int n ) {
  int res = 1;
  for ( int i = 0;
  i < n && arr [ i ] <= res;
  i ++ ) res = res + arr [ i ];
  return res;
}


MAXIMUM_POINTS_COLLECTED_BY_TWO_PERSONS_ALLOWED_TO_MEET_ONCE | int findMaxPoints ( int A [ ] [ M ] ) {
  int P1S [ M + 1 ] [ N + 1 ], P1E [ M + 1 ] [ N + 1 ];
  memset ( P1S, 0, sizeof ( P1S ) );
  memset ( P1E, 0, sizeof ( P1E ) );
  int P2S [ M + 1 ] [ N + 1 ], P2E [ M + 1 ] [ N + 1 ];
  memset ( P2S, 0, sizeof ( P2S ) );
  memset ( P2E, 0, sizeof ( P2E ) );
  for ( int i = 1;
  i <= N;
  i ++ ) for ( int j = 1;
  j <= M;
  j ++ ) P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ], P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ];
  for ( int i = N;
  i >= 1;
  i -- ) for ( int j = M;
  j >= 1;
  j -- ) P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ], P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ];
  for ( int i = N;
  i >= 1;
  i -- ) for ( int j = 1;
  j <= M;
  j ++ ) P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ], P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ];
  for ( int i = 1;
  i <= N;
  i ++ ) for ( int j = M;
  j >= 1;
  j -- ) P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ], P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ];
  int ans = 0;
  for ( int i = 2;
  i < N;
  i ++ ) {
    for ( int j = 2;
    j < M;
    j ++ ) {
      int op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ];
      int op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ];
      ans = max ( ans, max ( op1, op2 ) );
    }
  }
  return ans;
}


PROGRAM_FIND_CIRCUMFERENCE_CIRCLE | double circumference ( double r ) {
  double cir = 2 * PI * r;
  return cir;
}


QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY | void leftRotate ( int arr [ ], int n, int k ) {
  for ( int i = k;
  i < k + n;
  i ++ ) cout << arr [ i % n ] << " ";
}


MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY | int minSum ( int A [ ], int n ) {
  int min_val = * min_element ( A, A + n );
  return ( min_val * ( n - 1 ) );
}


RECURSIVE_PROGRAM_PRIME_NUMBER | bool isPrime ( int n, int i = 2 ) {
  if ( n <= 2 ) return ( n == 2 ) ? true : false;
  if ( n % i == 0 ) return false;
  if ( i * i > n ) return true;
  return isPrime ( n, i + 1 );
}


SPARSE_SEARCH | int sparseSearch ( string arr [ ], string x, int n ) {
  return binarySearch ( arr, 0, n - 1, x );
}


FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING | int count ( string a, string b, int m, int n ) {
  if ( ( m == 0 && n == 0 ) || n == 0 ) return 1;
  if ( m == 0 ) return 0;
  if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a, b, m - 1, n - 1 ) + count ( a, b, m - 1, n );
  else return count ( a, b, m - 1, n );
}


PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1 | bool arraySortedOrNot ( int arr [ ], int n ) {
  if ( n == 0 || n == 1 ) return true;
  for ( int i = 1;
  i < n;
  i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false;
  return true;
}


FIND_INDEX_0_REPLACED_1_GET_LONGEST_CONTINUOUS_SEQUENCE_1S_BINARY_ARRAY | int maxOnesIndex ( bool arr [ ], int n ) {
  int max_count = 0;
  int max_index;
  int prev_zero = - 1;
  int prev_prev_zero = - 1;
  for ( int curr = 0;
  curr < n;
  ++ curr ) {
    if ( arr [ curr ] == 0 ) {
      if ( curr - prev_prev_zero > max_count ) {
        max_count = curr - prev_prev_zero;
        max_index = prev_zero;
      }
      prev_prev_zero = prev_zero;
      prev_zero = curr;
    }
  }
  if ( n - prev_prev_zero > max_count ) max_index = prev_zero;
  return max_index;
}


FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1 | int maxProduct ( int arr [ ], int n ) {
  if ( n < 3 ) return - 1;
  sort ( arr, arr + n );
  return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ], arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] );
}


COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE | void printRect ( int X [ ], int Y [ ], int n ) {
  int Xmax = * max_element ( X, X + n );
  int Xmin = * min_element ( X, X + n );
  int Ymax = * max_element ( Y, Y + n );
  int Ymin = * min_element ( Y, Y + n );
  cout << "{" << Xmin << ", " << Ymin << "}" << endl;
  cout << "{" << Xmin << ", " << Ymax << "}" << endl;
  cout << "{" << Xmax << ", " << Ymax << "}" << endl;
  cout << "{" << Xmax << ", " << Ymin << "}" << endl;
}


COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N | int countOfBinaryNumberLessThanN ( int N ) {
  queue < int > q;
  q . push ( 1 );
  int cnt = 0;
  int t;
  while ( ! q . empty ( ) ) {
    t = q . front ( );
    q . pop ( );
    if ( t <= N ) {
      cnt ++;
      q . push ( t * 10 );
      q . push ( t * 10 + 1 );
    }
  }
  return cnt;
}


CONVERT_DECIMAL_FRACTION_BINARY_NUMBER | string decimalToBinary ( double num, int k_prec ) {
  string binary = "";
  int Integral = num;
  double fractional = num - Integral;
  while ( Integral ) {
    int rem = Integral % 2;
    binary . push_back ( rem + '0' );
    Integral /= 2;
  }
  reverse ( binary . begin ( ), binary . end ( ) );
  binary . push_back ( '.' );
  while ( k_prec -- ) {
    fractional *= 2;
    int fract_bit = fractional;
    if ( fract_bit == 1 ) {
      fractional -= fract_bit;
      binary . push_back ( 1 + '0' );
    }
    else binary . push_back ( 0 + '0' );
  }
  return binary;
}


MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSETS_OF_SIZE_K | int maximumZeros ( int * arr, int n, int k ) {
  int subset [ k + 1 ] [ MAX5 + 5 ];
  memset ( subset, - 1, sizeof ( subset ) );
  subset [ 0 ] [ 0 ] = 0;
  for ( int p = 0;
  p < n;
  p ++ ) {
    int pw2 = 0, pw5 = 0;
    while ( arr [ p ] % 2 == 0 ) {
      pw2 ++;
      arr [ p ] /= 2;
    }
    while ( arr [ p ] % 5 == 0 ) {
      pw5 ++;
      arr [ p ] /= 5;
    }
    for ( int i = k - 1;
    i >= 0;
    i -- ) for ( int j = 0;
    j < MAX5;
    j ++ ) if ( subset [ i ] [ j ] != - 1 ) subset [ i + 1 ] [ j + pw5 ] = max ( subset [ i + 1 ] [ j + pw5 ], subset [ i ] [ j ] + pw2 );
  }
  int ans = 0;
  for ( int i = 0;
  i < MAX5;
  i ++ ) ans = max ( ans, min ( i, subset [ k ] [ i ] ) );
  return ans;
}


SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY | int search ( int arr [ ], int l, int h, int key ) {
  if ( l > h ) return - 1;
  int mid = ( l + h ) / 2;
  if ( arr [ mid ] == key ) return mid;
  if ( arr [ l ] <= arr [ mid ] ) {
    if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr, l, mid - 1, key );
    return search ( arr, mid + 1, h, key );
  }
  if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr, mid + 1, h, key );
  return search ( arr, l, mid - 1, key );
}


PROGRAM_FIND_AREA_CIRCULAR_SEGMENT | float area_of_segment ( float radius, float angle ) {
  float area_of_sector = pi * ( radius * radius ) * ( angle / 360 );
  float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * sin ( ( angle * pi ) / 180 );
  return area_of_sector - area_of_triangle;
}


K_SMALLEST_ELEMENTS_ORDER_USING_O1_EXTRA_SPACE | void printSmall ( int arr [ ], int n, int k ) {
  for ( int i = k;
  i < n;
  ++ i ) {
    int max_var = arr [ k - 1 ];
    int pos = k - 1;
    for ( int j = k - 2;
    j >= 0;
    j -- ) {
      if ( arr [ j ] > max_var ) {
        max_var = arr [ j ];
        pos = j;
      }
    }
    if ( max_var > arr [ i ] ) {
      int j = pos;
      while ( j < k - 1 ) {
        arr [ j ] = arr [ j + 1 ];
        j ++;
      }
      arr [ k - 1 ] = arr [ i ];
    }
  }
  for ( int i = 0;
  i < k;
  i ++ ) cout << arr [ i ] << " ";
}


NTH_NON_FIBONACCI_NUMBER | int nonFibonacci ( int n ) {
  int prevPrev = 1, prev = 2, curr = 3;
  while ( n > 0 ) {
    prevPrev = prev;
    prev = curr;
    curr = prevPrev + prev;
    n = n - ( curr - prev - 1 );
  }
  n = n + ( curr - prev - 1 );
  return prev + n;
}


ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS | int search ( int arr [ ], int n, int x ) {
  int i;
  for ( i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] == x ) return i;
  }
  return - 1;
}


ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION | int nearestSmallerEqFib ( int n ) {
  if ( n == 0 || n == 1 ) return n;
  int f1 = 0, f2 = 1, f3 = 1;
  while ( f3 <= n ) {
    f1 = f2;
    f2 = f3;
    f3 = f1 + f2;
  }
  return f2;
}


PRINT_MAXIMUM_SHORTEST_DISTANCE | int find_maximum ( int a [ ], int n, int k ) {
  unordered_map < int, int > b;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int x = a [ i ];
    int d = min ( 1 + i, n - i );
    if ( b . find ( x ) == b . end ( ) ) b [ x ] = d;
    else b [ x ] = min ( d, b [ x ] );
  }
  int ans = INT_MAX;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int x = a [ i ];
    if ( x != k - x && b . find ( k - x ) != b . end ( ) ) ans = min ( max ( b [ x ], b [ k - x ] ), ans );
  }
  return ans;
}


GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOGRAPHIC_ORDER | void generate ( set < string > & st, string s ) {
  if ( s . size ( ) == 0 ) return;
  if ( st . find ( s ) == st . end ( ) ) {
    st . insert ( s );
    for ( int i = 0;
    i < s . size ( );
    i ++ ) {
      string t = s;
      t . erase ( i, 1 );
      generate ( st, t );
    }
  }
  return;
}


WRITE_YOU_OWN_POWER_WITHOUT_USING_MULTIPLICATION_AND_DIVISION | int pow ( int a, int b ) {
  if ( b == 0 ) return 1;
  int answer = a;
  int increment = a;
  int i, j;
  for ( i = 1;
  i < b;
  i ++ ) {
    for ( j = 1;
    j < a;
    j ++ ) {
      answer += increment;
    }
    increment = answer;
  }
  return answer;
}


MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1 | int maxvolume ( int s ) {
  int length = s / 3;
  s -= length;
  int breadth = s / 2;
  int height = s - breadth;
  return length * breadth * height;
}


HORNERS_METHOD_POLYNOMIAL_EVALUATION | int horner ( int poly [ ], int n, int x ) {
  int result = poly [ 0 ];
  for ( int i = 1;
  i < n;
  i ++ ) result = result * x + poly [ i ];
  return result;
}


MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS | int minTime ( int arr [ ], int n, int m ) {
  int t = 0;
  while ( 1 ) {
    int items = 0;
    for ( int i = 0;
    i < n;
    i ++ ) items += ( t / arr [ i ] );
    if ( items >= m ) return t;
    t ++;
  }
}


FIND_DIFFERENCE_BETWEEN_SUMS_OF_TWO_DIAGONALS | int difference ( int arr [ ] [ MAX ], int n ) {
  int d1 = 0, d2 = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( i == j ) d1 += arr [ i ] [ j ];
      if ( i == n - j - 1 ) d2 += arr [ i ] [ j ];
    }
  }
  return abs ( d1 - d2 );
}


SHORTEST_UNCOMMON_SUBSEQUENCE | int shortestSeq ( char * S, char * T ) {
  int m = strlen ( S ), n = strlen ( T );
  int dp [ m + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= m;
  i ++ ) dp [ i ] [ 0 ] = 1;
  for ( int i = 0;
  i <= n;
  i ++ ) dp [ 0 ] [ i ] = MAX;
  for ( int i = 1;
  i <= m;
  i ++ ) {
    for ( int j = 1;
    j <= n;
    j ++ ) {
      char ch = S [ i - 1 ];
      int k;
      for ( k = j - 1;
      k >= 0;
      k -- ) if ( T [ k ] == ch ) break;
      if ( k == - 1 ) dp [ i ] [ j ] = 1;
      else dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ], dp [ i - 1 ] [ k ] + 1 );
    }
  }
  int ans = dp [ m ] [ n ];
  if ( ans >= MAX ) ans = - 1;
  return ans;
}


MIN_FLIPS_OF_CONTINUOUS_CHARACTERS_TO_MAKE_ALL_CHARACTERS_SAME_IN_A_STRING | int findFlips ( char str [ ], int n ) {
  char last = ' ';
  int res = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( last != str [ i ] ) res ++;
    last = str [ i ];
  }
  return res / 2;
}


DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME | int findMinInsertions ( char str [ ], int l, int h ) {
  if ( l > h ) return INT_MAX;
  if ( l == h ) return 0;
  if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1;
  return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str, l + 1, h - 1 ) : ( min ( findMinInsertions ( str, l, h - 1 ), findMinInsertions ( str, l + 1, h ) ) + 1 );
}


COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS | int countPairs ( string str ) {
  int result = 0;
  int n = str . length ( );
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) result ++;
  return result;
}


MULTISTAGE_GRAPH_SHORTEST_PATH | INT_MAX int shortestDist ( int graph [ N ] [ N ] ) {
  int dist [ N ];
  dist [ N - 1 ] = 0;
  for ( int i = N - 2;
  i >= 0;
  i -- ) {
    dist [ i ] = INF;
    for ( int j = i;
    j < N;
    j ++ ) {
      if ( graph [ i ] [ j ] == INF ) continue;
      dist [ i ] = min ( dist [ i ], graph [ i ] [ j ] + dist [ j ] );
    }
  }
  return dist [ 0 ];
}


MAXIMUM_SIZE_SUB_MATRIX_WITH_ALL_1S_IN_A_BINARY_MATRIX | void printMaxSubSquare ( bool M [ R ] [ C ] ) {
  int i, j;
  int S [ R ] [ C ];
  int max_of_s, max_i, max_j;
  for ( i = 0;
  i < R;
  i ++ ) S [ i ] [ 0 ] = M [ i ] [ 0 ];
  for ( j = 0;
  j < C;
  j ++ ) S [ 0 ] [ j ] = M [ 0 ] [ j ];
  for ( i = 1;
  i < R;
  i ++ ) {
    for ( j = 1;
    j < C;
    j ++ ) {
      if ( M [ i ] [ j ] == 1 ) S [ i ] [ j ] = min ( S [ i ] [ j - 1 ], min ( S [ i - 1 ] [ j ], S [ i - 1 ] [ j - 1 ] ) ) + 1;
      else S [ i ] [ j ] = 0;
    }
  }
  max_of_s = S [ 0 ] [ 0 ];
  max_i = 0;
  max_j = 0;
  for ( i = 0;
  i < R;
  i ++ ) {
    for ( j = 0;
    j < C;
    j ++ ) {
      if ( max_of_s < S [ i ] [ j ] ) {
        max_of_s = S [ i ] [ j ];
        max_i = i;
        max_j = j;
      }
    }
  }
  cout << "Maximum size sub-matrix is: \n";
  for ( i = max_i;
  i > max_i - max_of_s;
  i -- ) {
    for ( j = max_j;
    j > max_j - max_of_s;
    j -- ) {
      cout << M [ i ] [ j ] << " ";
    }
    cout << "\n";
  }
}


GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST_X | void printClosest ( int arr [ ], int n, int x ) {
  int res_l, res_r;
  int l = 0, r = n - 1, diff = INT_MAX;
  while ( r > l ) {
    if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) {
      res_l = l;
      res_r = r;
      diff = abs ( arr [ l ] + arr [ r ] - x );
    }
    if ( arr [ l ] + arr [ r ] > x ) r --;
    else l ++;
  }
  cout << " The closest pair is " << arr [ res_l ] << " and " << arr [ res_r ];
}


SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1 | bool sortedAfterSwap ( int A [ ], bool B [ ], int n ) {
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    if ( B [ i ] ) {
      if ( A [ i ] != i + 1 ) swap ( A [ i ], A [ i + 1 ] );
    }
  }
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( A [ i ] != i + 1 ) return false;
  }
  return true;
}


TILE_STACKING_PROBLEM | int possibleWays ( int n, int m, int k ) {
  int dp [ N ] [ N ];
  int presum [ N ] [ N ];
  memset ( dp, 0, sizeof dp );
  memset ( presum, 0, sizeof presum );
  for ( int i = 1;
  i < n + 1;
  i ++ ) {
    dp [ 0 ] [ i ] = 0;
    presum [ 0 ] [ i ] = 1;
  }
  for ( int i = 0;
  i < m + 1;
  i ++ ) presum [ i ] [ 0 ] = dp [ i ] [ 0 ] = 1;
  for ( int i = 1;
  i < m + 1;
  i ++ ) {
    for ( int j = 1;
    j < n + 1;
    j ++ ) {
      dp [ i ] [ j ] = presum [ i - 1 ] [ j ];
      if ( j > k ) {
        dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ];
      }
    }
    for ( int j = 1;
    j < n + 1;
    j ++ ) presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ];
  }
  return dp [ m ] [ n ];
}


NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT | int sumEqualProduct ( int a [ ], int n ) {
  int zero = 0, two = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( a [ i ] == 0 ) {
      zero ++;
    }
    if ( a [ i ] == 2 ) {
      two ++;
    }
  }
  int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2;
  return cnt;
}


DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING | int minPalPartion ( char * str ) {
  int n = strlen ( str );
  int C [ n ] [ n ];
  bool P [ n ] [ n ];
  int i, j, k, L;
  for ( i = 0;
  i < n;
  i ++ ) {
    P [ i ] [ i ] = true;
    C [ i ] [ i ] = 0;
  }
  for ( L = 2;
  L <= n;
  L ++ ) {
    for ( i = 0;
    i < n - L + 1;
    i ++ ) {
      j = i + L - 1;
      if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ] );
      else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1 ];
      if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0;
      else {
        C [ i ] [ j ] = INT_MAX;
        for ( k = i;
        k <= j - 1;
        k ++ ) C [ i ] [ j ] = min ( C [ i ] [ j ], C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 );
      }
    }
  }
  return C [ 0 ] [ n - 1 ];
}


FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY | int findRepeatingNumber ( const int arr [ ], int n ) {
  int sq = sqrt ( n );
  int range = ( n / sq ) + 1;
  int count [ range ] = {
    0 };
    for ( int i = 0;
    i <= n;
    i ++ ) {
      count [ ( arr [ i ] - 1 ) / sq ] ++;
    }
    int selected_block = range - 1;
    for ( int i = 0;
    i < range - 1;
    i ++ ) {
      if ( count [ i ] > sq ) {
        selected_block = i;
        break;
      }
    }
    unordered_map < int, int > m;
    for ( int i = 0;
    i <= n;
    i ++ ) {
      if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) {
        m [ arr [ i ] ] ++;
        if ( m [ arr [ i ] ] > 1 ) return arr [ i ];
      }
    }
    return - 1;
  }
  

MINIMUM_SUM_PATH_TRIANGLE | int minSumPath ( vector < vector < int > > & A ) {
  int memo [ A . size ( ) ];
  int n = A . size ( ) - 1;
  for ( int i = 0;
  i < A [ n ] . size ( );
  i ++ ) memo [ i ] = A [ n ] [ i ];
  for ( int i = A . size ( ) - 2;
  i >= 0;
  i -- ) for ( int j = 0;
  j < A [ i ] . size ( );
  j ++ ) memo [ j ] = A [ i ] [ j ] + min ( memo [ j ], memo [ j + 1 ] );
  return memo [ 0 ];
}


HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT_1 | public : int getSum ( int n ) {
  int sum;
  for ( sum = 0;
  n > 0;
  sum += n % 10, n /= 10 );
  return sum;
}


RECURSION | void printFun ( int test ) {
  if ( test < 1 ) return;
  else {
    cout << test << " ";
    printFun ( test - 1 );
    cout << test << " ";
    return;
  }
}


MAXIMUM_TRIPLET_SUM_ARRAY | int maxTripletSum ( int arr [ ], int n ) {
  int sum = INT_MIN;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) for ( int k = j + 1;
  k < n;
  k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ];
  return sum;
}


MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1 | int minJumps ( int arr [ ], int n ) {
  int * jumps = new int [ n ];
  int i, j;
  if ( n == 0 || arr [ 0 ] == 0 ) return INT_MAX;
  jumps [ 0 ] = 0;
  for ( i = 1;
  i < n;
  i ++ ) {
    jumps [ i ] = INT_MAX;
    for ( j = 0;
    j < i;
    j ++ ) {
      if ( i <= j + arr [ j ] && jumps [ j ] != INT_MAX ) {
        jumps [ i ] = min ( jumps [ i ], jumps [ j ] + 1 );
        break;
      }
    }
  }
  return jumps [ n - 1 ];
}


MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER | int findMaxVal ( int arr [ ], int n, int num, int maxLimit ) {
  int ind;
  int val;
  int dp [ n ] [ maxLimit + 1 ];
  for ( ind = 0;
  ind < n;
  ind ++ ) {
    for ( val = 0;
    val <= maxLimit;
    val ++ ) {
      if ( ind == 0 ) {
        if ( num - arr [ ind ] == val || num + arr [ ind ] == val ) {
          dp [ ind ] [ val ] = 1;
        }
        else {
          dp [ ind ] [ val ] = 0;
        }
      }
      else {
        if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) {
          dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] || dp [ ind - 1 ] [ val + arr [ ind ] ];
        }
        else if ( val - arr [ ind ] >= 0 ) {
          dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ];
        }
        else if ( val + arr [ ind ] <= maxLimit ) {
          dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ];
        }
        else {
          dp [ ind ] [ val ] = 0;
        }
      }
    }
  }
  for ( val = maxLimit;
  val >= 0;
  val -- ) {
    if ( dp [ n - 1 ] [ val ] ) {
      return val;
    }
  }
  return - 1;
}


PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM | int Resources ( int process, int need ) {
  int minResources = 0;
  minResources = process * ( need - 1 ) + 1;
  return minResources;
}


NUMBER_DIGITS_PRODUCT_TWO_NUMBERS | int countDigits ( int a, int b ) {
  int count = 0;
  int p = abs ( a * b );
  if ( p == 0 ) return 1;
  while ( p > 0 ) {
    count ++;
    p = p / 10;
  }
  return count;
}


FLOOR_IN_A_SORTED_ARRAY | int floorSearch ( int arr [ ], int n, int x ) {
  if ( x >= arr [ n - 1 ] ) return n - 1;
  if ( x < arr [ 0 ] ) return - 1;
  for ( int i = 1;
  i < n;
  i ++ ) if ( arr [ i ] > x ) return ( i - 1 );
  return - 1;
}


CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN | bool checkValidity ( int a, int b, int c ) {
  if ( a + b <= c || a + c <= b || b + c <= a ) return false;
  else return true;
}


PRINT_N_X_N_SPIRAL_MATRIX_USING_O1_EXTRA_SPACE | void printSpiral ( int n ) {
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < n;
    j ++ ) {
      int x;
      x = min ( min ( i, j ), min ( n - 1 - i, n - 1 - j ) );
      if ( i <= j ) printf ( "%d\t ", ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) );
      else printf ( "%d\t ", ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) );
    }
    printf ( "\n" );
  }
}


POSITION_ELEMENT_STABLE_SORT | int getIndexInSortedArray ( int arr [ ], int n, int idx ) {
  int result = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] < arr [ idx ] ) result ++;
    if ( arr [ i ] == arr [ idx ] && i < idx ) result ++;
  }
  return result;
}


MAXIMUM_SEGMENT_VALUE_PUTTING_K_BREAKPOINTS_NUMBER | int findMaxSegment ( string & s, int k ) {
  int seg_len = s . length ( ) - k;
  int res = 0;
  for ( int i = 0;
  i < seg_len;
  i ++ ) res = res * 10 + ( s [ i ] - '0' );
  int seg_len_pow = pow ( 10, seg_len - 1 );
  int curr_val = res;
  for ( int i = 1;
  i <= ( s . length ( ) - seg_len );
  i ++ ) {
    curr_val = curr_val - ( s [ i - 1 ] - '0' ) * seg_len_pow;
    curr_val = curr_val * 10 + ( s [ i + seg_len - 1 ] - '0' );
    res = max ( res, curr_val );
  }
  return res;
}


FINDING_POWER_PRIME_NUMBER_P_N_1 | int PowerOFPINnfactorial ( int n, int p ) {
  int ans = 0;
  int temp = p;
  while ( temp <= n ) {
    ans += n / temp;
    temp = temp * p;
  }
  return ans;
}


PROGRAM_PRINT_IDENTITY_MATRIX | int Identity ( int num ) {
  int row, col;
  for ( row = 0;
  row < num;
  row ++ ) {
    for ( col = 0;
    col < num;
    col ++ ) {
      if ( row == col ) cout << 1 << " ";
      else cout << 0 << " ";
    }
    cout << endl;
  }
  return 0;
}


SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN | int findSum ( int n ) {
  int ans = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) for ( int j = 1;
  j <= n;
  j ++ ) ans += ( i / j );
  return ans;
}


TILING_WITH_DOMINOES | int countWays ( int n ) {
  int A [ n + 1 ], B [ n + 1 ];
  A [ 0 ] = 1, A [ 1 ] = 0, B [ 0 ] = 0, B [ 1 ] = 1;
  for ( int i = 2;
  i <= n;
  i ++ ) {
    A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ];
    B [ i ] = A [ i - 1 ] + B [ i - 2 ];
  }
  return A [ n ];
}


COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION | int countDer ( int n ) {
  if ( n == 1 ) return 0;
  if ( n == 0 ) return 1;
  if ( n == 2 ) return 1;
  return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) );
}


FREQUENCY_ELEMENT_UNSORTED_ARRAY_1 | void countFreq ( int a [ ], int n ) {
  unordered_map < int, int > hm;
  for ( int i = 0;
  i < n;
  i ++ ) hm [ a [ i ] ] ++;
  int cumul = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    cumul += hm [ a [ i ] ];
    if ( hm [ a [ i ] ] ) {
      cout << a [ i ] << "->" << cumul << endl;
    }
    hm [ a [ i ] ] = 0;
  }
}


MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N | int minSum ( int n ) {
  int sum = 0;
  while ( n > 0 ) {
    sum += ( n % 10 );
    n /= 10;
  }
  if ( sum == 1 ) return 10;
  return sum;
}


DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM | void maximizecube ( int l, int b, int h ) {
  int side = __gcd ( l, __gcd ( b, h ) );
  int num = l / side;
  num = ( num * b / side );
  num = ( num * h / side );
  cout << side << " " << num << endl;
}


CHECK_NUMBER_POWER_K_USING_BASE_CHANGING_METHOD | bool isPowerOfK ( unsigned int n, unsigned int k ) {
  bool oneSeen = false;
  while ( n > 0 ) {
    int digit = n % k;
    if ( digit > 1 ) return false;
    if ( digit == 1 ) {
      if ( oneSeen ) return false;
      oneSeen = true;
    }
    n /= k;
  }
  return true;
}


POSITION_OF_RIGHTMOST_SET_BIT_1 | int PositionRightmostSetbit ( int n ) {
  int position = 1;
  int m = 1;
  while ( ! ( n & m ) ) {
    m = m << 1;
    position ++;
  }
  return position;
}


SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1 | int insertSorted ( int arr [ ], int n, int key, int capacity ) {
  if ( n >= capacity ) return n;
  int i;
  for ( i = n - 1;
  ( i >= 0 && arr [ i ] > key );
  i -- ) arr [ i + 1 ] = arr [ i ];
  arr [ i + 1 ] = key;
  return ( n + 1 );
}


FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN_ARRAY_1 | void printMaxOfMin ( int arr [ ], int n ) {
  stack < int > s;
  int left [ n + 1 ];
  int right [ n + 1 ];
  for ( int i = 0;
  i < n;
  i ++ ) {
    left [ i ] = - 1;
    right [ i ] = n;
  }
  for ( int i = 0;
  i < n;
  i ++ ) {
    while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) s . pop ( );
    if ( ! s . empty ( ) ) left [ i ] = s . top ( );
    s . push ( i );
  }
  while ( ! s . empty ( ) ) s . pop ( );
  for ( int i = n - 1;
  i >= 0;
  i -- ) {
    while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) s . pop ( );
    if ( ! s . empty ( ) ) right [ i ] = s . top ( );
    s . push ( i );
  }
  int ans [ n + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) ans [ i ] = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int len = right [ i ] - left [ i ] - 1;
    ans [ len ] = max ( ans [ len ], arr [ i ] );
  }
  for ( int i = n - 1;
  i >= 1;
  i -- ) ans [ i ] = max ( ans [ i ], ans [ i + 1 ] );
  for ( int i = 1;
  i <= n;
  i ++ ) cout << ans [ i ] << " ";
}


MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1 | long long int MaximumDecimalValue ( int mat [ ] [ N ], int n ) {
  int dp [ n ] [ n ];
  memset ( dp, 0, sizeof ( dp ) );
  if ( mat [ 0 ] [ 0 ] == 1 ) dp [ 0 ] [ 0 ] = 1;
  for ( int i = 1;
  i < n;
  i ++ ) {
    if ( mat [ 0 ] [ i ] == 1 ) dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + pow ( 2, i );
    else dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ];
  }
  for ( int i = 1;
  i < n;
  i ++ ) {
    if ( mat [ i ] [ 0 ] == 1 ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + pow ( 2, i );
    else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ];
  }
  for ( int i = 1;
  i < n;
  i ++ ) {
    for ( int j = 1;
    j < n;
    j ++ ) {
      if ( mat [ i ] [ j ] == 1 ) dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ] ) + pow ( 2, i + j );
      else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ] );
    }
  }
  return dp [ n - 1 ] [ n - 1 ];
}


COUNT_NUMBER_OF_WAYS_TO_COVER_A_DISTANCE | int printCountRec ( int dist ) {
  if ( dist < 0 ) return 0;
  if ( dist == 0 ) return 1;
  return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 );
}


MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED | void segregateElements ( int arr [ ], int n ) {
  int temp [ n ];
  int j = 0;
  for ( int i = 0;
  i < n;
  i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ];
  if ( j == n || j == 0 ) return;
  for ( int i = 0;
  i < n;
  i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ];
  memcpy ( arr, temp, sizeof ( temp ) );
}


MINIMUM_PERIMETER_N_BLOCKS | int minPerimeter ( int n ) {
  int l = sqrt ( n );
  int sq = l * l;
  if ( sq == n ) return l * 4;
  else {
    long long int row = n / l;
    long long int perimeter = 2 * ( l + row );
    if ( n % l != 0 ) perimeter += 2;
    return perimeter;
  }
}


DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT | int maxProd ( int n ) {
  if ( n == 0 || n == 1 ) return 0;
  int max_val = 0;
  for ( int i = 1;
  i < n;
  i ++ ) max_val = max ( max_val, i * ( n - i ), maxProd ( n - i ) * i );
  return max_val;
}


LONGEST_COMMON_SUBSTRING_SPACE_OPTIMIZED_DP_SOLUTION | int LCSubStr ( string X, string Y ) {
  int m = X . length ( );
  int n = Y . length ( );
  int result = 0;
  int len [ 2 ] [ n ];
  int currRow = 0;
  for ( int i = 0;
  i <= m;
  i ++ ) {
    for ( int j = 0;
    j <= n;
    j ++ ) {
      if ( i == 0 || j == 0 ) {
        len [ currRow ] [ j ] = 0;
      }
      else if ( X [ i - 1 ] == Y [ j - 1 ] ) {
        len [ currRow ] [ j ] = len [ 1 - currRow ] [ j - 1 ] + 1;
        result = max ( result, len [ currRow ] [ j ] );
      }
      else {
        len [ currRow ] [ j ] = 0;
      }
    }
    currRow = 1 - currRow;
  }
  return result;
}


CHECK_GIVEN_STRING_ROTATION_PALINDROME | bool isPalindrome ( string str ) {
  int l = 0;
  int h = str . length ( ) - 1;
  while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return false;
  return true;
}


FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_1 | int countSol ( int coeff [ ], int n, int rhs ) {
  int dp [ rhs + 1 ];
  memset ( dp, 0, sizeof ( dp ) );
  dp [ 0 ] = 1;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = coeff [ i ];
  j <= rhs;
  j ++ ) dp [ j ] += dp [ j - coeff [ i ] ];
  return dp [ rhs ];
}


FIND_THE_LARGEST_PAIR_SUM_IN_AN_UNSORTED_ARRAY | int findLargestSumPair ( int arr [ ], int n ) {
  int first, second;
  if ( arr [ 0 ] > arr [ 1 ] ) {
    first = arr [ 0 ];
    second = arr [ 1 ];
  }
  else {
    first = arr [ 1 ];
    second = arr [ 0 ];
  }
  for ( int i = 2;
  i < n;
  i ++ ) {
    if ( arr [ i ] > first ) {
      second = first;
      first = arr [ i ];
    }
    else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ];
  }
  return ( first + second );
}


FIND_BITONIC_POINT_GIVEN_BITONIC_SEQUENCE | int binarySearch ( int arr [ ], int left, int right ) {
  if ( left <= right ) {
    int mid = ( left + right ) / 2;
    if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid;
    if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr, mid + 1, right );
    else return binarySearch ( arr, left, mid - 1 );
  }
  return - 1;
}


PRINT_ALL_DISTINCT_CHARACTERS_OF_A_STRING_IN_ORDER_3_METHODS_1 | void printDistinct ( string str ) {
  int n = str . length ( );
  int count [ MAX_CHAR ];
  int index [ MAX_CHAR ];
  for ( int i = 0;
  i < MAX_CHAR;
  i ++ ) {
    count [ i ] = 0;
    index [ i ] = n;
  }
  for ( int i = 0;
  i < n;
  i ++ ) {
    char x = str [ i ];
    ++ count [ x ];
    if ( count [ x ] == 1 && x != ' ' ) index [ x ] = i;
    if ( count [ x ] == 2 ) index [ x ] = n;
  }
  sort ( index, index + MAX_CHAR );
  for ( int i = 0;
  i < MAX_CHAR && index [ i ] != n;
  i ++ ) cout << str [ index [ i ] ];
}


FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE | void printOtherSides ( int n ) {
  if ( n & 1 ) {
    if ( n == 1 ) cout << - 1 << endl;
    else {
      int b = ( n * n - 1 ) / 2;
      int c = ( n * n + 1 ) / 2;
      cout << "b = " << b << ", c = " << c << endl;
    }
  }
  else {
    if ( n == 2 ) cout << - 1 << endl;
    else {
      int b = n * n / 4 - 1;
      int c = n * n / 4 + 1;
      cout << "b = " << b << ", c = " << c << endl;
    }
  }
}


COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINATION | int possibleStrings ( int n, int r, int b, int g ) {
  int fact [ n + 1 ];
  fact [ 0 ] = 1;
  for ( int i = 1;
  i <= n;
  i ++ ) fact [ i ] = fact [ i - 1 ] * i;
  int left = n - ( r + g + b );
  int sum = 0;
  for ( int i = 0;
  i <= left;
  i ++ ) {
    for ( int j = 0;
    j <= left - i;
    j ++ ) {
      int k = left - ( i + j );
      sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] );
    }
  }
  return sum;
}


REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_1 | void rearrange ( int arr [ ], int n ) {
  int max_ele = arr [ n - 1 ];
  int min_ele = arr [ 0 ];
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( i % 2 == 0 ) {
      arr [ i ] = max_ele;
      max_ele -= 1;
    }
    else {
      arr [ i ] = min_ele;
      min_ele += 1;
    }
  }
}


EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND | int calculateSum ( string arr [ ], int n ) {
  if ( n == 0 ) return 0;
  string s = arr [ 0 ];
  int value = stoi ( s );
  int sum = value;
  for ( int i = 2;
  i < n;
  i = i + 2 ) {
    s = arr [ i ];
    int value = stoi ( s );
    char operation = arr [ i - 1 ] [ 0 ];
    if ( operation == '+' ) sum += value;
    else sum -= value;
  }
  return sum;
}


SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1 | int findSum ( int n ) {
  int ans = 0, temp = 0, num;
  for ( int i = 1;
  i <= n && temp < n;
  i ++ ) {
    temp = i - 1;
    num = 1;
    while ( temp < n ) {
      if ( temp + i <= n ) ans += ( i * num );
      else ans += ( ( n - temp ) * num );
      temp += i;
      num ++;
    }
  }
  return ans;
}


SHUFFLE_A_DECK_OF_CARDS_3 | void shuffle ( int card [ ], int n ) {
  srand ( time ( 0 ) );
  for ( int i = 0;
  i < n;
  i ++ ) {
    int r = i + ( rand ( ) % ( 52 - i ) );
    swap ( card [ i ], card [ r ] );
  }
}


DOOLITTLE_ALGORITHM_LU_DECOMPOSITION | void luDecomposition ( int mat [ ] [ MAX ], int n ) {
  int lower [ n ] [ n ], upper [ n ] [ n ];
  memset ( lower, 0, sizeof ( lower ) );
  memset ( upper, 0, sizeof ( upper ) );
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int k = i;
    k < n;
    k ++ ) {
      int sum = 0;
      for ( int j = 0;
      j < i;
      j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] );
      upper [ i ] [ k ] = mat [ i ] [ k ] - sum;
    }
    for ( int k = i;
    k < n;
    k ++ ) {
      if ( i == k ) lower [ i ] [ i ] = 1;
      else {
        int sum = 0;
        for ( int j = 0;
        j < i;
        j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] );
        lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ];
      }
    }
  }
  cout << setw ( 6 ) << "      Lower Triangular" << setw ( 32 ) << "Upper Triangular" << endl;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < n;
    j ++ ) cout << setw ( 6 ) << lower [ i ] [ j ] << "\t";
    cout << "\t";
    for ( int j = 0;
    j < n;
    j ++ ) cout << setw ( 6 ) << upper [ i ] [ j ] << "\t";
    cout << endl;
  }
}


PROGRAM_NTH_CATALAN_NUMBER | unsigned long int catalan ( unsigned int n ) {
  if ( n <= 1 ) return 1;
  unsigned long int res = 0;
  for ( int i = 0;
  i < n;
  i ++ ) res += catalan ( i ) * catalan ( n - i - 1 );
  return res;
}


NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3 | int divisible ( string num ) {
  int n = num . length ( );
  int sum = accumulate ( begin ( num ), end ( num ), 0 ) - '0' * 1;
  if ( sum % 3 == 0 ) return 0;
  if ( n == 1 ) return - 1;
  for ( int i = 0;
  i < n;
  i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1;
  if ( n == 2 ) return - 1;
  return 2;
}


CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1 | bool isPower ( int x, int y ) {
  int res1 = log ( y ) / log ( x );
  double res2 = log ( y ) / log ( x );
  return ( res1 == res2 );
}


LARGEST_SUBSEQUENCE_GCD_GREATER_1 | int largestGCDSubsequence ( int arr [ ], int n ) {
  int ans = 0;
  int maxele = * max_element ( arr, arr + n );
  for ( int i = 2;
  i <= maxele;
  ++ i ) {
    int count = 0;
    for ( int j = 0;
    j < n;
    ++ j ) {
      if ( arr [ j ] % i == 0 ) ++ count;
    }
    ans = max ( ans, count );
  }
  return ans;
}


FIND_COMMON_ELEMENT_ROWS_ROW_WISE_SORTED_MATRIX | int findCommon ( int mat [ M ] [ N ] ) {
  int column [ M ];
  int min_row;
  int i;
  for ( i = 0;
  i < M;
  i ++ ) column [ i ] = N - 1;
  min_row = 0;
  while ( column [ min_row ] >= 0 ) {
    for ( i = 0;
    i < M;
    i ++ ) {
      if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i;
    }
    int eq_count = 0;
    for ( i = 0;
    i < M;
    i ++ ) {
      if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) {
        if ( column [ i ] == 0 ) return - 1;
        column [ i ] -= 1;
      }
      else eq_count ++;
    }
    if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ];
  }
  return - 1;
}


CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CONCENTRIC_CIRCLES | bool checkcircle ( int r, int R, int r1, int x1, int y1 ) {
  int dis = sqrt ( x1 * x1 + y1 * y1 );
  return ( dis - r1 >= R && dis + r1 <= r );
}


COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N | int countSetBits ( int n ) {
  int i = 0;
  int ans = 0;
  while ( ( 1 << i ) <= n ) {
    bool k = 0;
    int change = 1 << i;
    for ( int j = 0;
    j <= n;
    j ++ ) {
      ans += k;
      if ( change == 1 ) {
        k = ! k;
        change = 1 << i;
      }
      else {
        change --;
      }
    }
    i ++;
  }
  return ans;
}


LONGEST_REPEATING_SUBSEQUENCE | int findLongestRepeatingSubSeq ( string str ) {
  int n = str . length ( );
  int dp [ n + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) for ( int j = 0;
  j <= n;
  j ++ ) dp [ i ] [ j ] = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) {
    for ( int j = 1;
    j <= n;
    j ++ ) {
      if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ];
      else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ] );
    }
  }
  return dp [ n ] [ n ];
}


FIND_THE_FIRST_MISSING_NUMBER | int findFirstMissing ( int array [ ], int start, int end ) {
  if ( start > end ) return end + 1;
  if ( start != array [ start ] ) return start;
  int mid = ( start + end ) / 2;
  if ( array [ mid ] == mid ) return findFirstMissing ( array, mid + 1, end );
  return findFirstMissing ( array, start, mid );
}


SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1 | void sortSquares ( int arr [ ], int n ) {
  int K = 0;
  for ( K = 0;
  K < n;
  K ++ ) if ( arr [ K ] >= 0 ) break;
  int i = K - 1;
  int j = K;
  int ind = 0;
  int temp [ n ];
  while ( i >= 0 && j < n ) {
    if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) {
      temp [ ind ] = arr [ i ] * arr [ i ];
      i --;
    }
    else {
      temp [ ind ] = arr [ j ] * arr [ j ];
      j ++;
    }
    ind ++;
  }
  while ( i >= 0 ) {
    temp [ ind ] = arr [ i ] * arr [ i ];
    i --;
    ind ++;
  }
  while ( j < n ) {
    temp [ ind ] = arr [ j ] * arr [ j ];
    j ++;
    ind ++;
  }
  for ( int i = 0;
  i < n;
  i ++ ) arr [ i ] = temp [ i ];
}


PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR | int getRemainder ( int num, int divisor ) {
  return ( num - divisor * ( num / divisor ) );
}


MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG | int MinimumCost ( int cost [ ], int n, int W ) {
  vector < int > val, wt;
  int size = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( cost [ i ] != - 1 ) {
      val . push_back ( cost [ i ] );
      wt . push_back ( i + 1 );
      size ++;
    }
  }
  n = size;
  int min_cost [ n + 1 ] [ W + 1 ];
  for ( int i = 0;
  i <= W;
  i ++ ) min_cost [ 0 ] [ i ] = INF;
  for ( int i = 1;
  i <= n;
  i ++ ) min_cost [ i ] [ 0 ] = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) {
    for ( int j = 1;
    j <= W;
    j ++ ) {
      if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ];
      else min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ], min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] );
    }
  }
  return ( min_cost [ n ] [ W ] == INF ) ? - 1 : min_cost [ n ] [ W ];
}


COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1 | int countPairs ( string str ) {
  int result = 0;
  int n = str . length ( );
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 1;
  ( i + j ) < n && j <= MAX_CHAR;
  j ++ ) if ( ( abs ( str [ i + j ] - str [ i ] ) == j ) ) result ++;
  return result;
}


A_PRODUCT_ARRAY_PUZZLE | void productArray ( int arr [ ], int n ) {
  if ( n == 1 ) {
    cout << 0;
    return;
  }
  int * left = new int [ sizeof ( int ) * n ];
  int * right = new int [ sizeof ( int ) * n ];
  int * prod = new int [ sizeof ( int ) * n ];
  int i, j;
  left [ 0 ] = 1;
  right [ n - 1 ] = 1;
  for ( i = 1;
  i < n;
  i ++ ) left [ i ] = arr [ i - 1 ] * left [ i - 1 ];
  for ( j = n - 2;
  j >= 0;
  j -- ) right [ j ] = arr [ j + 1 ] * right [ j + 1 ];
  for ( i = 0;
  i < n;
  i ++ ) prod [ i ] = left [ i ] * right [ i ];
  for ( i = 0;
  i < n;
  i ++ ) cout << prod [ i ] << " ";
  return;
}


FREQUENT_ELEMENT_ARRAY_1 | int mostFrequent ( int arr [ ], int n ) {
  unordered_map < int, int > hash;
  for ( int i = 0;
  i < n;
  i ++ ) hash [ arr [ i ] ] ++;
  int max_count = 0, res = - 1;
  for ( auto i : hash ) {
    if ( max_count < i . second ) {
      res = i . first;
      max_count = i . second;
    }
  }
  return res;
}


PRINT_UNIQUE_ROWS | void printArray ( int arr [ ] [ 5 ], int row, int col ) {
  unordered_set < string > uset;
  for ( int i = 0;
  i < row;
  i ++ ) {
    string s = "";
    for ( int j = 0;
    j < col;
    j ++ ) s += to_string ( arr [ i ] [ j ] );
    if ( uset . count ( s ) == 0 ) {
      uset . insert ( s );
      cout << s << endl;
    }
  }
}


COUNT_1S_SORTED_BINARY_ARRAY | int countOnes ( bool arr [ ], int low, int high ) {
  if ( high >= low ) {
    int mid = low + ( high - low ) / 2;
    if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1;
    if ( arr [ mid ] == 1 ) return countOnes ( arr, ( mid + 1 ), high );
    return countOnes ( arr, low, ( mid - 1 ) );
  }
  return 0;
}


POSSIBLE_MOVES_KNIGHT | int findPossibleMoves ( int mat [ n ] [ m ], int p, int q ) {
  int X [ 8 ] = {
    2, 1, - 1, - 2, - 2, - 1, 1, 2 };
    int Y [ 8 ] = {
      1, 2, 2, 1, - 1, - 2, - 2, - 1 };
      int count = 0;
      for ( int i = 0;
      i < 8;
      i ++ ) {
        int x = p + X [ i ];
        int y = q + Y [ i ];
        if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++;
      }
      return count;
    }
    

ROTATE_MATRIX_ELEMENTS | void rotatematrix ( int m, int n, int mat [ R ] [ C ] ) {
  int row = 0, col = 0;
  int prev, curr;
  while ( row < m && col < n ) {
    if ( row + 1 == m || col + 1 == n ) break;
    prev = mat [ row + 1 ] [ col ];
    for ( int i = col;
    i < n;
    i ++ ) {
      curr = mat [ row ] [ i ];
      mat [ row ] [ i ] = prev;
      prev = curr;
    }
    row ++;
    for ( int i = row;
    i < m;
    i ++ ) {
      curr = mat [ i ] [ n - 1 ];
      mat [ i ] [ n - 1 ] = prev;
      prev = curr;
    }
    n --;
    if ( row < m ) {
      for ( int i = n - 1;
      i >= col;
      i -- ) {
        curr = mat [ m - 1 ] [ i ];
        mat [ m - 1 ] [ i ] = prev;
        prev = curr;
      }
    }
    m --;
    if ( col < n ) {
      for ( int i = m - 1;
      i >= row;
      i -- ) {
        curr = mat [ i ] [ col ];
        mat [ i ] [ col ] = prev;
        prev = curr;
      }
    }
    col ++;
  }
  for ( int i = 0;
  i < R;
  i ++ ) {
    for ( int j = 0;
    j < C;
    j ++ ) cout << mat [ i ] [ j ] << " ";
    cout << endl;
  }
}


FIND_KTH_CHARACTER_OF_DECRYPTED_STRING | char encodedChar ( string str, int k ) {
  string expand = "";
  string temp;
  int freq = 0;
  for ( int i = 0;
  str [ i ] != '\0';
  ) {
    temp = "";
    freq = 0;
    while ( str [ i ] >= 'a' && str [ i ] <= 'z' ) {
      temp . push_back ( str [ i ] );
      i ++;
    }
    while ( str [ i ] >= '1' && str [ i ] <= '9' ) {
      freq = freq * 10 + str [ i ] - '0';
      i ++;
    }
    for ( int j = 1;
    j <= freq;
    j ++ ) expand . append ( temp );
  }
  if ( freq == 0 ) expand . append ( temp );
  return expand [ k - 1 ];
}


EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_IS_1 | int search ( int arr [ ], int n, int x ) {
  int i = 0;
  while ( i <= n - 1 ) {
    if ( arr [ i ] == x ) return i;
    i += abs ( arr [ i ] - x );
  }
  return - 1;
}


MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQUE | int returnMaxSum ( int A [ ], int B [ ], int n ) {
  unordered_set < int > mp;
  int result = 0;
  int curr_sum = 0, curr_begin = 0;
  for ( int i = 0;
  i < n;
  ++ i ) {
    while ( mp . find ( A [ i ] ) != mp . end ( ) ) {
      mp . erase ( A [ curr_begin ] );
      curr_sum -= B [ curr_begin ];
      curr_begin ++;
    }
    mp . insert ( A [ i ] );
    curr_sum += B [ i ];
    result = max ( result, curr_sum );
  }
  return result;
}


WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF_3 | int isMultipleOf3 ( int n ) {
  int odd_count = 0;
  int even_count = 0;
  if ( n < 0 ) n = - n;
  if ( n == 0 ) return 1;
  if ( n == 1 ) return 0;
  while ( n ) {
    if ( n & 1 ) odd_count ++;
    if ( n & 2 ) even_count ++;
    n = n >> 2;
  }
  return isMultipleOf3 ( abs ( odd_count - even_count ) );
}


MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1 | int maxSum ( int arr [ ], int n ) {
  int cum_sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) cum_sum += arr [ i ];
  int curr_val = 0;
  for ( int i = 0;
  i < n;
  i ++ ) curr_val += i * arr [ i ];
  int res = curr_val;
  for ( int i = 1;
  i < n;
  i ++ ) {
    int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 );
    curr_val = next_val;
    res = max ( res, next_val );
  }
  return res;
}


DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING | int carAssembly ( int a [ ] [ NUM_STATION ], int t [ ] [ NUM_STATION ], int * e, int * x ) {
  int T1 [ NUM_STATION ], T2 [ NUM_STATION ], i;
  T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ];
  T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ];
  for ( i = 1;
  i < NUM_STATION;
  ++ i ) {
    T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ], T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] );
    T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ], T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] );
  }
  return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ], T2 [ NUM_STATION - 1 ] + x [ 1 ] );
}


PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT | void printSpiral ( int mat [ ] [ MAX ], int r, int c ) {
  int i, a = 0, b = 2;
  int low_row = ( 0 > a ) ? 0 : a;
  int low_column = ( 0 > b ) ? 0 : b - 1;
  int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1;
  int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1;
  while ( ( low_row > 0 - r && low_column > 0 - c ) ) {
    for ( i = low_column + 1;
    i <= high_column && i < c && low_row >= 0;
    ++ i ) cout << mat [ low_row ] [ i ] << " ";
    low_row -= 1;
    for ( i = low_row + 2;
    i <= high_row && i < r && high_column < c;
    ++ i ) cout << mat [ i ] [ high_column ] << " ";
    high_column += 1;
    for ( i = high_column - 2;
    i >= low_column && i >= 0 && high_row < r;
    -- i ) cout << mat [ high_row ] [ i ] << " ";
    high_row += 1;
    for ( i = high_row - 2;
    i > low_row && i >= 0 && low_column >= 0;
    -- i ) cout << mat [ i ] [ low_column ] << " ";
    low_column -= 1;
  }
  cout << endl;
}


MID_POINT_CIRCLE_DRAWING_ALGORITHM | void midPointCircleDraw ( int x_centre, int y_centre, int r ) {
  int x = r, y = 0;
  cout << "(" << x + x_centre << ", " << y + y_centre << ") ";
  if ( r > 0 ) {
    cout << "(" << x + x_centre << ", " << - y + y_centre << ") ";
    cout << "(" << y + x_centre << ", " << x + y_centre << ") ";
    cout << "(" << - y + x_centre << ", " << x + y_centre << ")\n";
  }
  int P = 1 - r;
  while ( x > y ) {
    y ++;
    if ( P <= 0 ) P = P + 2 * y + 1;
    else {
      x --;
      P = P + 2 * y - 2 * x + 1;
    }
    if ( x < y ) break;
    cout << "(" << x + x_centre << ", " << y + y_centre << ") ";
    cout << "(" << - x + x_centre << ", " << y + y_centre << ") ";
    cout << "(" << x + x_centre << ", " << - y + y_centre << ") ";
    cout << "(" << - x + x_centre << ", " << - y + y_centre << ")\n";
    if ( x != y ) {
      cout << "(" << y + x_centre << ", " << x + y_centre << ") ";
      cout << "(" << - y + x_centre << ", " << x + y_centre << ") ";
      cout << "(" << y + x_centre << ", " << - x + y_centre << ") ";
      cout << "(" << - y + x_centre << ", " << - x + y_centre << ")\n";
    }
  }
}


SMALLEST_ELEMENT_REPEATED_EXACTLY_K_TIMES_NOT_LIMITED_SMALL_RANGE | int smallestKFreq ( int a [ ], int n, int k ) {
  unordered_map < int, int > m;
  for ( int i = 0;
  i < n;
  i ++ ) m [ a [ i ] ] ++;
  int res = INT_MAX;
  for ( auto it = m . begin ( );
  it != m . end ( );
  ++ it ) if ( it -> second == k ) res = min ( res, it -> first );
  return ( res != INT_MAX ) ? res : - 1;
}


MINIMUM_XOR_VALUE_PAIR | int minXOR ( int arr [ ], int n ) {
  int min_xor = INT_MAX;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) min_xor = min ( min_xor, arr [ i ] ^ arr [ j ] );
  return min_xor;
}


MIRROR_CHARACTERS_STRING | string compute ( string str, int n ) {
  string reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba";
  int l = str . length ( );
  for ( int i = n;
  i < l;
  i ++ ) str [ i ] = reverseAlphabet [ str [ i ] - 'a' ];
  return str;
}


PROGRAM_CHECK_PLUS_PERFECT_NUMBER | bool checkplusperfect ( int x ) {
  int temp = x;
  int n = 0;
  while ( x != 0 ) {
    x /= 10;
    n ++;
  }
  x = temp;
  int sum = 0;
  while ( x != 0 ) {
    sum += pow ( x % 10, n );
    x /= 10;
  }
  return ( sum == temp );
}


ARC_LENGTH_ANGLE | double arcLength ( double diameter, double angle ) {
  double pi = 22.0 / 7.0;
  double arc;
  if ( angle >= 360 ) {
    cout << "Angle cannot", " be formed";
    return 0;
  }
  else {
    arc = ( pi * diameter ) * ( angle / 360.0 );
    return arc;
  }
}


FIND_LAST_INDEX_CHARACTER_STRING | int findLastIndex ( string & str, char x ) {
  int index = - 1;
  for ( int i = 0;
  i < str . length ( );
  i ++ ) if ( str [ i ] == x ) index = i;
  return index;
}


COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER | int findTrailingZeros ( int n ) {
  int count = 0;
  for ( int i = 5;
  n / i >= 1;
  i *= 5 ) count += n / i;
  return count;
}


ROTATE_MATRIX_180_DEGREE | void rotateMatrix ( int mat [ ] [ N ] ) {
  for ( int i = N - 1;
  i >= 0;
  i -- ) {
    for ( int j = N - 1;
    j >= 0;
    j -- ) printf ( "%d ", mat [ i ] [ j ] );
    printf ( "\n" );
  }
}


SUM_FIBONACCI_NUMBERS | int calculateSum ( int n ) {
  if ( n <= 0 ) return 0;
  int fibo [ n + 1 ];
  fibo [ 0 ] = 0, fibo [ 1 ] = 1;
  int sum = fibo [ 0 ] + fibo [ 1 ];
  for ( int i = 2;
  i <= n;
  i ++ ) {
    fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ];
    sum += fibo [ i ];
  }
  return sum;
}


LARGEST_LEXICOGRAPHIC_ARRAY_WITH_AT_MOST_K_CONSECUTIVE_SWAPS | void KSwapMaximum ( int arr [ ], int n, int k ) {
  for ( int i = 0;
  i < n - 1 && k > 0;
  ++ i ) {
    int indexPosition = i;
    for ( int j = i + 1;
    j < n;
    ++ j ) {
      if ( k <= j - i ) break;
      if ( arr [ j ] > arr [ indexPosition ] ) indexPosition = j;
    }
    for ( int j = indexPosition;
    j > i;
    -- j ) swap ( arr [ j ], arr [ j - 1 ] );
    k -= indexPosition - i;
  }
}


FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT | bool check ( int n ) {
  return 1162261467 % n == 0;
}


FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY | void printRepeating ( int arr [ ], int size ) {
  int i, j;
  printf ( " Repeating elements are " );
  for ( i = 0;
  i < size;
  i ++ ) for ( j = i + 1;
  j < size;
  j ++ ) if ( arr [ i ] == arr [ j ] ) cout << arr [ i ] << " ";
}


C_PROGRAM_FIND_AREA_TRIANGLE | float findArea ( float a, float b, float c ) {
  if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <= b || b + c <= a ) {
    cout << "Not a valid trianglen";
    exit ( 0 );
  }
  float s = ( a + b + c ) / 2;
  return sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) );
}


GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1 | bool isSubSeqDivisible ( string str ) {
  int n = str . length ( );
  int dp [ n + 1 ] [ 10 ];
  memset ( dp, 0, sizeof ( dp ) );
  int arr [ n + 1 ];
  for ( int i = 1;
  i <= n;
  i ++ ) arr [ i ] = str [ i - 1 ] - '0';
  for ( int i = 1;
  i <= n;
  i ++ ) {
    dp [ i ] [ arr [ i ] % 8 ] = 1;
    for ( int j = 0;
    j < 8;
    j ++ ) {
      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ];
      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ];
    }
  }
  for ( int i = 1;
  i <= n;
  i ++ ) {
    if ( dp [ i ] [ 0 ] == 1 ) return true;
  }
  return false;
}


DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_SMALLER | void deleteElements ( int arr [ ], int n, int k ) {
  stack < int > s;
  s . push ( arr [ 0 ] );
  int count = 0;
  for ( int i = 1;
  i < n;
  i ++ ) {
    while ( ! s . empty ( ) && s . top ( ) < arr [ i ] && count < k ) {
      s . pop ( );
      count ++;
    }
    s . push ( arr [ i ] );
  }
  int m = s . size ( );
  vector < int > v ( m );
  while ( ! s . empty ( ) ) {
    v [ -- m ] = s . top ( );
    s . pop ( );
  }
  for ( auto x : v ) cout << x << " ";
  cout << endl;
}


MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE | int smallestSubWithSum ( int arr [ ], int n, int x ) {
  int curr_sum = 0, min_len = n + 1;
  int start = 0, end = 0;
  while ( end < n ) {
    while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ];
    while ( curr_sum > x && start < n ) {
      if ( end - start < min_len ) min_len = end - start;
      curr_sum -= arr [ start ++ ];
    }
  }
  return min_len;
}


FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1 | void findPair ( int arr [ ], int n ) {
  unordered_set < int > s;
  for ( int i = 0;
  i < n;
  i ++ ) s . insert ( arr [ i ] );
  bool found = false;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = i + 1;
    j < n;
    j ++ ) {
      if ( s . find ( arr [ i ] + arr [ j ] ) != s . end ( ) ) {
        cout << arr [ i ] << " " << arr [ j ] << endl;
        found = true;
      }
    }
  }
  if ( found == false ) cout << "Not exist" << endl;
}


COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY | int numofAP ( int a [ ], int n ) {
  int minarr = INT_MAX, maxarr = INT_MIN;
  for ( int i = 0;
  i < n;
  i ++ ) {
    minarr = min ( minarr, a [ i ] );
    maxarr = max ( maxarr, a [ i ] );
  }
  int dp [ n ], sum [ MAX ];
  int ans = n + 1;
  for ( int d = ( minarr - maxarr );
  d <= ( maxarr - minarr );
  d ++ ) {
    memset ( sum, 0, sizeof sum );
    for ( int i = 0;
    i < n;
    i ++ ) {
      dp [ i ] = 1;
      if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [ i ] += sum [ a [ i ] - d ];
      ans += dp [ i ] - 1;
      sum [ a [ i ] ] += dp [ i ];
    }
  }
  return ans;
}


COUNT_NUMBERS_THAT_DONT_CONTAIN_3 | int count ( int n ) {
  if ( n < 3 ) return n;
  if ( n >= 3 && n < 10 ) return n - 1;
  int po = 1;
  while ( n / po > 9 ) po = po * 10;
  int msd = n / po;
  if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po );
  else return count ( msd * po - 1 );
}


PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2 | void transpose ( int A [ ] [ N ] ) {
  for ( int i = 0;
  i < N;
  i ++ ) for ( int j = i + 1;
  j < N;
  j ++ ) swap ( A [ i ] [ j ], A [ j ] [ i ] );
}


SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX | int spiralDiaSum ( int n ) {
  if ( n == 1 ) return 1;
  return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) );
}


COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY | int getInvCount ( int arr [ ], int n ) {
  int invcount = 0;
  for ( int i = 0;
  i < n - 2;
  i ++ ) {
    for ( int j = i + 1;
    j < n - 1;
    j ++ ) {
      if ( arr [ i ] > arr [ j ] ) {
        for ( int k = j + 1;
        k < n;
        k ++ ) {
          if ( arr [ j ] > arr [ k ] ) invcount ++;
        }
      }
    }
  }
  return invcount;
}


FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE | int sumNodes ( int l ) {
  int leafNodeCount = pow ( 2, l - 1 );
  vector < int > vec [ l ];
  for ( int i = 1;
  i <= leafNodeCount;
  i ++ ) vec [ l - 1 ] . push_back ( i );
  for ( int i = l - 2;
  i >= 0;
  i -- ) {
    int k = 0;
    while ( k < vec [ i + 1 ] . size ( ) - 1 ) {
      vec [ i ] . push_back ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] );
      k += 2;
    }
  }
  int sum = 0;
  for ( int i = 0;
  i < l;
  i ++ ) {
    for ( int j = 0;
    j < vec [ i ] . size ( );
    j ++ ) sum += vec [ i ] [ j ];
  }
  return sum;
}


SUM_OF_ALL_PROPER_DIVISORS_OF_A_NATURAL_NUMBER | int divSum ( int num ) {
  int result = 0;
  for ( int i = 2;
  i <= sqrt ( num );
  i ++ ) {
    if ( num % i == 0 ) {
      if ( i == ( num / i ) ) result += i;
      else result += ( i + num / i );
    }
  }
  return ( result + 1 );
}


FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_2 | bool find3Numbers ( int A [ ], int arr_size, int sum ) {
  for ( int i = 0;
  i < arr_size - 2;
  i ++ ) {
    unordered_set < int > s;
    int curr_sum = sum - A [ i ];
    for ( int j = i + 1;
    j < arr_size;
    j ++ ) {
      if ( s . find ( curr_sum - A [ j ] ) != s . end ( ) ) {
        printf ( "Triplet is %d, %d, %d", A [ i ], A [ j ], curr_sum - A [ j ] );
        return true;
      }
      s . insert ( A [ j ] );
    }
  }
  return false;
}


NTH_EVEN_LENGTH_PALINDROME | string evenlength ( string n ) {
  string res = n;
  for ( int j = n . length ( ) - 1;
  j >= 0;
  -- j ) res += n [ j ];
  return res;
}


FINDING_POWER_PRIME_NUMBER_P_N | int PowerOFPINnfactorial ( int n, int p ) {
  int ans = 0;
  int temp = p;
  while ( temp <= n ) {
    ans += n / temp;
    temp = temp * p;
  }
  return ans;
}


MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K | int solve ( char X [ ], char Y [ ], int l, int r, int k, int dp [ ] [ N ] [ N ] ) {
  if ( ! k ) return 0;
  if ( l < 0 | r < 0 ) return 1e9;
  if ( dp [ l ] [ r ] [ k ] != - 1 ) return dp [ l ] [ r ] [ k ];
  int cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' );
  return dp [ l ] [ r ] [ k ] = min ( {
    cost + solve ( X, Y, l - 1, r - 1, k - 1, dp ), solve ( X, Y, l - 1, r, k, dp ), solve ( X, Y, l, r - 1, k, dp ) }
    );
  }
  

PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES | void printString ( string str, char ch, int count ) {
  int occ = 0, i;
  if ( count == 0 ) {
    cout << str;
    return;
  }
  for ( i = 0;
  i < str . length ( );
  i ++ ) {
    if ( str [ i ] == ch ) occ ++;
    if ( occ == count ) break;
  }
  if ( i < str . length ( ) - 1 ) cout << str . substr ( i + 1, str . length ( ) - ( i + 1 ) );
  else cout << "Empty string";
}


SORT_1_N_SWAPPING_ADJACENT_ELEMENTS | bool sortedAfterSwap ( int A [ ], bool B [ ], int n ) {
  int i, j;
  for ( i = 0;
  i < n - 1;
  i ++ ) {
    if ( B [ i ] ) {
      j = i;
      while ( B [ j ] ) j ++;
      sort ( A + i, A + 1 + j );
      i = j;
    }
  }
  for ( i = 0;
  i < n;
  i ++ ) {
    if ( A [ i ] != i + 1 ) return false;
  }
  return true;
}


GENERATE_PYTHAGOREAN_TRIPLETS | void pythagoreanTriplets ( int limit ) {
  int a, b, c = 0;
  int m = 2;
  while ( c < limit ) {
    for ( int n = 1;
    n < m;
    ++ n ) {
      a = m * m - n * n;
      b = 2 * m * n;
      c = m * m + n * n;
      if ( c > limit ) break;
      printf ( "%d %d %d\n", a, b, c );
    }
    m ++;
  }
}


COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS | int countSeq ( int n, int diff ) {
  if ( abs ( diff ) > n ) return 0;
  if ( n == 1 && diff == 0 ) return 2;
  if ( n == 1 && abs ( diff ) == 1 ) return 1;
  int res = countSeq ( n - 1, diff + 1 ) + 2 * countSeq ( n - 1, diff ) + countSeq ( n - 1, diff - 1 );
  return res;
}


POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES | bool isPossibleTriangle ( int arr [ ], int N ) {
  if ( N < 3 ) return false;
  sort ( arr, arr + N );
  for ( int i = 0;
  i < N - 2;
  i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true;
}


PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_ANOTHER | void printInSortedOrder ( string arr [ ], int n ) {
  int index [ n ];
  int i, j, min;
  for ( i = 0;
  i < n;
  i ++ ) index [ i ] = i;
  for ( i = 0;
  i < n - 1;
  i ++ ) {
    min = i;
    for ( j = i + 1;
    j < n;
    j ++ ) {
      if ( arr [ index [ min ] ] . compare ( arr [ index [ j ] ] ) > 0 ) min = j;
    }
    if ( min != i ) {
      int temp = index [ min ];
      index [ min ] = index [ i ];
      index [ i ] = temp;
    }
  }
  for ( i = 0;
  i < n;
  i ++ ) cout << arr [ index [ i ] ] << " ";
}


GAME_REPLACING_ARRAY_ELEMENTS | int playGame ( int arr [ ], int n ) {
  unordered_set < int > hash;
  for ( int i = 0;
  i < n;
  i ++ ) hash . insert ( arr [ i ] );
  return ( hash . size ( ) % 2 == 0 ? 1 : 2 );
}


BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS | int gcd ( int a, int b ) {
  if ( a == 0 ) return b;
  return gcd ( b % a, a );
}


SORT_ARRAY_WAVE_FORM_2_1 | void sortInWave ( int arr [ ], int n ) {
  for ( int i = 0;
  i < n;
  i += 2 ) {
    if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( & arr [ i ], & arr [ i - 1 ] );
    if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( & arr [ i ], & arr [ i + 1 ] );
  }
}


MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM | int maximumSumSubarray ( int arr [ ], int n ) {
  int min_prefix_sum = 0;
  int res = numeric_limits < int > :: min ( );
  int prefix_sum [ n ];
  prefix_sum [ 0 ] = arr [ 0 ];
  for ( int i = 1;
  i < n;
  i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ];
  for ( int i = 0;
  i < n;
  i ++ ) {
    res = max ( res, prefix_sum [ i ] - min_prefix_sum );
    min_prefix_sum = min ( min_prefix_sum, prefix_sum [ i ] );
  }
  return res;
}


STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES | string firstLetterWord ( string str ) {
  string result = "";
  bool v = true;
  for ( int i = 0;
  i < str . length ( );
  i ++ ) {
    if ( str [ i ] == ' ' ) v = true;
    else if ( str [ i ] != ' ' && v == true ) {
      result . push_back ( str [ i ] );
      v = false;
    }
  }
  return result;
}


SUM_PAIRWISE_PRODUCTS_1 | long long int findSum ( int n ) {
  long long int multiTerms = n * ( n + 1 ) / 2;
  long long int sum = multiTerms;
  for ( int i = 2;
  i <= n;
  i ++ ) {
    multiTerms = multiTerms - ( i - 1 );
    sum = sum + multiTerms * i;
  }
  return sum;
}


CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFERENCES_IS_MINIMUM_1 | int minCost ( int a [ ], int n, int k ) {
  int dp [ n + 1 ] [ k + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) for ( int j = 0;
  j <= k;
  j ++ ) dp [ i ] [ j ] = inf;
  dp [ 0 ] [ 0 ] = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) for ( int j = 1;
  j <= k;
  j ++ ) for ( int m = i - 1;
  m >= 0;
  m -- ) dp [ i ] [ j ] = min ( dp [ i ] [ j ], dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) );
  return dp [ n ] [ k ];
}


LEIBNIZ_HARMONIC_TRIANGLE | void LeibnizHarmonicTriangle ( int n ) {
  int C [ n + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) {
    for ( int j = 0;
    j <= min ( i, n );
    j ++ ) {
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1;
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ];
    }
  }
  for ( int i = 1;
  i <= n;
  i ++ ) {
    for ( int j = 1;
    j <= i;
    j ++ ) cout << "1/" << i * C [ i - 1 ] [ j - 1 ] << " ";
    cout << endl;
  }
}


CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COUNT_ARRAY | bool canMakeStr2 ( string str1, string str2 ) {
  int count [ MAX ] = {
    0 };
    for ( int i = 0;
    i < str1 . length ( );
    i ++ ) count [ str1 [ i ] ] ++;
    for ( int i = 0;
    i < str2 . length ( );
    i ++ ) {
      if ( count [ str2 [ i ] ] == 0 ) return false;
      count [ str2 [ i ] ] --;
    }
    return true;
  }
  

SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K | int SumOfKsubArray ( int arr [ ], int n, int k ) {
  int sum = 0;
  deque < int > S ( k ), G ( k );
  int i = 0;
  for ( i = 0;
  i < k;
  i ++ ) {
    while ( ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= arr [ i ] ) S . pop_back ( );
    while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= arr [ i ] ) G . pop_back ( );
    G . push_back ( i );
    S . push_back ( i );
  }
  for (;
  i < n;
  i ++ ) {
    sum += arr [ S . front ( ) ] + arr [ G . front ( ) ];
    while ( ! S . empty ( ) && S . front ( ) <= i - k ) S . pop_front ( );
    while ( ! G . empty ( ) && G . front ( ) <= i - k ) G . pop_front ( );
    while ( ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= arr [ i ] ) S . pop_back ( );
    while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= arr [ i ] ) G . pop_back ( );
    G . push_back ( i );
    S . push_back ( i );
  }
  sum += arr [ S . front ( ) ] + arr [ G . front ( ) ];
  return sum;
}


LONGEST_COMMON_SUBSEQUENCE | int lcs ( char * X, char * Y, int m, int n ) {
  if ( m == 0 || n == 0 ) return 0;
  if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X, Y, m - 1, n - 1 );
  else return max ( lcs ( X, Y, m, n - 1 ), lcs ( X, Y, m - 1, n ) );
}


MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS | long long int findMinSum ( int a [ ], int b [ ], int n ) {
  sort ( a, a + n );
  sort ( b, b + n );
  long long int sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) sum = sum + abs ( a [ i ] - b [ i ] );
  return sum;
}


COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2 | int countSolutions ( int n ) {
  int res = 0;
  for ( int x = 0;
  x * x < n;
  x ++ ) for ( int y = 0;
  x * x + y * y < n;
  y ++ ) res ++;
  return res;
}


FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL | int countOps ( int A [ ] [ MAX ], int B [ ] [ MAX ], int m, int n ) {
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 0;
  j < m;
  j ++ ) A [ i ] [ j ] -= B [ i ] [ j ];
  for ( int i = 1;
  i < n;
  i ++ ) for ( int j = 1;
  j < m;
  j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1;
  int result = 0;
  for ( int i = 0;
  i < n;
  i ++ ) result += abs ( A [ i ] [ 0 ] );
  for ( int j = 0;
  j < m;
  j ++ ) result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] );
  return ( result );
}


EFFICIENTLY_FIND_FIRST_REPEATED_CHARACTER_STRING_WITHOUT_USING_ADDITIONAL_DATA_STRUCTURE_ONE_TRAVERSAL | int FirstRepeated ( string str ) {
  int checker = 0;
  for ( int i = 0;
  i < str . length ( );
  ++ i ) {
    int val = ( str [ i ] - 'a' );
    if ( ( checker & ( 1 << val ) ) > 0 ) return i;
    checker |= ( 1 << val );
  }
  return - 1;
}


MAXIMUM_UNIQUE_ELEMENT_EVERY_SUBARRAY_SIZE_K | void find_max ( int A [ ], int N, int K ) {
  map < int, int > Count;
  for ( int i = 0;
  i < K - 1;
  i ++ ) Count [ A [ i ] ] ++;
  set < int > Myset;
  for ( auto x : Count ) if ( x . second == 1 ) Myset . insert ( x . first );
  for ( int i = K - 1;
  i < N;
  i ++ ) {
    Count [ A [ i ] ] ++;
    if ( Count [ A [ i ] ] == 1 ) Myset . insert ( A [ i ] );
    else Myset . erase ( A [ i ] );
    if ( Myset . size ( ) == 0 ) printf ( "Nothing\n" );
    else printf ( "%d\n", * Myset . rbegin ( ) );
    int x = A [ i - K + 1 ];
    Count [ x ] --;
    if ( Count [ x ] == 1 ) Myset . insert ( x );
    if ( Count [ x ] == 0 ) Myset . erase ( x );
  }
}


MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1 | int calculateEnergy ( int mat [ SIZE ] [ SIZE ], int n ) {
  int i_des, j_des, q;
  int tot_energy = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < n;
    j ++ ) {
      q = mat [ i ] [ j ] / n;
      i_des = q;
      j_des = mat [ i ] [ j ] - ( n * q );
      tot_energy += abs ( i_des - i ) + abs ( j_des - j );
    }
  }
  return tot_energy;
}


LONGEST_COMMON_SUBSTRING | int LCSubStr ( char * X, char * Y, int m, int n ) {
  int LCSuff [ m + 1 ] [ n + 1 ];
  int result = 0;
  for ( int i = 0;
  i <= m;
  i ++ ) {
    for ( int j = 0;
    j <= n;
    j ++ ) {
      if ( i == 0 || j == 0 ) LCSuff [ i ] [ j ] = 0;
      else if ( X [ i - 1 ] == Y [ j - 1 ] ) {
        LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1;
        result = max ( result, LCSuff [ i ] [ j ] );
      }
      else LCSuff [ i ] [ j ] = 0;
    }
  }
  return result;
}


MAXIMUM_SUM_BITONIC_SUBARRAY | int maxSumBitonicSubArr ( int arr [ ], int n ) {
  int msis [ n ], msds [ n ];
  int max_sum = INT_MIN;
  msis [ 0 ] = arr [ 0 ];
  for ( int i = 1;
  i < n;
  i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ];
  else msis [ i ] = arr [ i ];
  msds [ n - 1 ] = arr [ n - 1 ];
  for ( int i = n - 2;
  i >= 0;
  i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ];
  else msds [ i ] = arr [ i ];
  for ( int i = 0;
  i < n;
  i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ];
  return max_sum;
}


NEWMAN_CONWAY_SEQUENCE | int sequence ( int n ) {
  if ( n == 1 || n == 2 ) return 1;
  else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) );
}


PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP | void printAllAPTriplets ( int arr [ ], int n ) {
  unordered_set < int > s;
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    for ( int j = i + 1;
    j < n;
    j ++ ) {
      int diff = arr [ j ] - arr [ i ];
      if ( s . find ( arr [ i ] - diff ) != s . end ( ) ) cout << arr [ i ] - diff << " " << arr [ i ] << " " << arr [ j ] << endl;
    }
    s . insert ( arr [ i ] );
  }
}


QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE | int countInRange ( int arr [ ], int n, int x, int y ) {
  int count = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] >= x && arr [ i ] <= y ) count ++;
  }
  return count;
}


HIGHWAY_BILLBOARD_PROBLEM | int maxRevenue ( int m, int x [ ], int revenue [ ], int n, int t ) {
  int maxRev [ m + 1 ];
  memset ( maxRev, 0, sizeof ( maxRev ) );
  int nxtbb = 0;
  for ( int i = 1;
  i <= m;
  i ++ ) {
    if ( nxtbb < n ) {
      if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ];
      else {
        if ( i <= t ) maxRev [ i ] = max ( maxRev [ i - 1 ], revenue [ nxtbb ] );
        else maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ], maxRev [ i - 1 ] );
        nxtbb ++;
      }
    }
    else maxRev [ i ] = maxRev [ i - 1 ];
  }
  return maxRev [ m ];
}


CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES | void printMat ( int degseq [ ], int n ) {
  int mat [ n ] [ n ];
  memset ( mat, 0, sizeof ( mat ) );
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = i + 1;
    j < n;
    j ++ ) {
      if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) {
        degseq [ i ] --;
        degseq [ j ] --;
        mat [ i ] [ j ] = 1;
        mat [ j ] [ i ] = 1;
      }
    }
  }
  cout << "\n" << setw ( 3 ) << "     ";
  for ( int i = 0;
  i < n;
  i ++ ) cout << setw ( 3 ) << "(" << i << ")";
  cout << "\n\n";
  for ( int i = 0;
  i < n;
  i ++ ) {
    cout << setw ( 4 ) << "(" << i << ")";
    for ( int j = 0;
    j < n;
    j ++ ) cout << setw ( 5 ) << mat [ i ] [ j ];
    cout << "\n";
  }
}


DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS | bool oppositeSigns ( int x, int y ) {
  return ( ( x ^ y ) < 0 );
}


TRIANGULAR_NUMBERS_1 | bool isTriangular ( int num ) {
  if ( num < 0 ) return false;
  int c = ( - 2 * num );
  int b = 1, a = 1;
  int d = ( b * b ) - ( 4 * a * c );
  if ( d < 0 ) return false;
  float root1 = ( - b + sqrt ( d ) ) / ( 2 * a );
  float root2 = ( - b - sqrt ( d ) ) / ( 2 * a );
  if ( root1 > 0 && floor ( root1 ) == root1 ) return true;
  if ( root2 > 0 && floor ( root2 ) == root2 ) return true;
  return false;
}


FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT | public : bool isPowerOfFour ( int n ) {
  if ( n == 0 ) return 0;
  while ( n != 1 ) {
    if ( n % 4 != 0 ) return 0;
    n = n / 4;
  }
  return 1;
}


LAST_NON_ZERO_DIGIT_FACTORIAL | int lastNon0Digit ( int n ) {
  if ( n < 10 ) return dig [ n ];
  if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10;
  else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10;
}


SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING | void sortByPattern ( string & str, string pat ) {
  int count [ MAX_CHAR ] = {
    0 };
    for ( int i = 0;
    i < str . length ( );
    i ++ ) count [ str [ i ] - 'a' ] ++;
    int index = 0;
    for ( int i = 0;
    i < pat . length ( );
    i ++ ) for ( int j = 0;
    j < count [ pat [ i ] - 'a' ];
    j ++ ) str [ index ++ ] = pat [ i ];
  }
  

NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER | int minimumBox ( int arr [ ], int n ) {
  queue < int > q;
  sort ( arr, arr + n );
  q . push ( arr [ 0 ] );
  for ( int i = 1;
  i < n;
  i ++ ) {
    int now = q . front ( );
    if ( arr [ i ] >= 2 * now ) q . pop ( );
    q . push ( arr [ i ] );
  }
  return q . size ( );
}


SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY | int binarySearch ( int arr [ ], int low, int high, int key ) {
  if ( high < low ) return - 1;
  int mid = ( low + high ) / 2;
  if ( key == arr [ mid ] ) return mid;
  if ( key > arr [ mid ] ) return binarySearch ( arr, ( mid + 1 ), high, key );
  return binarySearch ( arr, low, ( mid - 1 ), key );
}


FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3 | void printRepeating ( int arr [ ], int size ) {
  int i;
  cout << "The repeating elements are";
  for ( i = 0;
  i < size;
  i ++ ) {
    if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ];
    else cout << " " << abs ( arr [ i ] ) << " ";
  }
}


COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3 | int findgroups ( int arr [ ], int n ) {
  int c [ 3 ] = {
    0 },
    i;
    int res = 0;
    for ( i = 0;
    i < n;
    i ++ ) c [ arr [ i ] % 3 ] ++;
    res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 );
    res += c [ 1 ] * c [ 2 ];
    res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6;
    res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6;
    res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 );
    res += c [ 0 ] * c [ 1 ] * c [ 2 ];
    return res;
  }
  

PRINT_STRING_IGNORING_ALTERNATE_OCCURRENCES_CHARACTER | void printStringAlternate ( string str ) {
  unordered_map < char, int > occ;
  for ( int i = 0;
  i < str . length ( );
  i ++ ) {
    char temp = tolower ( str [ i ] );
    occ [ temp ] ++;
    if ( occ [ temp ] & 1 ) cout << str [ i ];
  }
  cout << endl;
}


NUMBER_DAYS_TANK_WILL_BECOME_EMPTY | int minDaysToEmpty ( int C, int l ) {
  if ( l >= C ) return C;
  double eq_root = ( std :: sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2;
  return std :: ceil ( eq_root ) + l;
}


REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE | string reversingString ( string str, int start, int end ) {
  while ( start < end ) {
    str [ start ] ^= str [ end ];
    str [ end ] ^= str [ start ];
    str [ start ] ^= str [ end ];
    ++ start;
    -- end;
  }
  return str;
}


FREQUENCY_ELEMENT_UNSORTED_ARRAY | void countFreq ( int a [ ], int n ) {
  unordered_map < int, int > hm;
  for ( int i = 0;
  i < n;
  i ++ ) hm [ a [ i ] ] ++;
  set < pair < int, int > > st;
  for ( auto x : hm ) {
    st . insert ( {
      x . first, x . second }
      );
    }
    int cumul = 0;
    for ( auto x : st ) {
      cumul += x . second;
      cout << x . first << " " << cumul << endl;
    }
  }
  

FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY | int countRotations ( int arr [ ], int n ) {
  int min = arr [ 0 ], min_index;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( min > arr [ i ] ) {
      min = arr [ i ];
      min_index = i;
    }
  }
  return min_index;
}


LONGEST_INCREASING_SUBSEQUENCE_1 | int lis ( int arr [ ], int n ) {
  int lis [ n ];
  lis [ 0 ] = 1;
  for ( int i = 1;
  i < n;
  i ++ ) {
    lis [ i ] = 1;
    for ( int j = 0;
    j < i;
    j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1;
  }
  return * max_element ( lis, lis + n );
}


MEDIAN_OF_TWO_SORTED_ARRAYS | int getMedian ( int ar1 [ ], int ar2 [ ], int n ) {
  int i = 0;
  int j = 0;
  int count;
  int m1 = - 1, m2 = - 1;
  for ( count = 0;
  count <= n;
  count ++ ) {
    if ( i == n ) {
      m1 = m2;
      m2 = ar2 [ 0 ];
      break;
    }
    else if ( j == n ) {
      m1 = m2;
      m2 = ar1 [ 0 ];
      break;
    }
    if ( ar1 [ i ] < ar2 [ j ] ) {
      m1 = m2;
      m2 = ar1 [ i ];
      i ++;
    }
    else {
      m1 = m2;
      m2 = ar2 [ j ];
      j ++;
    }
  }
  return ( m1 + m2 ) / 2;
}


LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION | string minLexRotation ( string str ) {
  int n = str . length ( );
  string arr [ n ];
  string concat = str + str;
  for ( int i = 0;
  i < n;
  i ++ ) arr [ i ] = concat . substr ( i, n );
  sort ( arr, arr + n );
  return arr [ 0 ];
}


INTERPOLATION_SEARCH | int interpolationSearch ( int arr [ ], int n, int x ) {
  int lo = 0, hi = ( n - 1 );
  while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) {
    if ( lo == hi ) {
      if ( arr [ lo ] == x ) return lo;
      return - 1;
    }
    int pos = lo + ( ( ( double ) ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) );
    if ( arr [ pos ] == x ) return pos;
    if ( arr [ pos ] < x ) lo = pos + 1;
    else hi = pos - 1;
  }
  return - 1;
}


COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_2 | int countPairs ( int arr1 [ ], int arr2 [ ], int m, int n, int x ) {
  int count = 0;
  int l = 0, r = n - 1;
  while ( l < m && r >= 0 ) {
    if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) {
      l ++;
      r --;
      count ++;
    }
    else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++;
    else r --;
  }
  return count;
}


COUNT_SUBSETS_DISTINCT_EVEN_NUMBERS | int countSubsets ( int arr [ ], int n ) {
  unordered_set < int > us;
  int even_count = 0;
  for ( int i = 0;
  i < n;
  i ++ ) if ( arr [ i ] % 2 == 0 ) us . insert ( arr [ i ] );
  unordered_set < int > :: iterator itr;
  for ( itr = us . begin ( );
  itr != us . end ( );
  itr ++ ) even_count ++;
  return ( pow ( 2, even_count ) - 1 );
}


COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY | int countOccurrences ( int arr [ ], int n, int x ) {
  int res = 0;
  for ( int i = 0;
  i < n;
  i ++ ) if ( x == arr [ i ] ) res ++;
  return res;
}


CONSTRUCT_THE_ROOTED_TREE_BY_USING_START_AND_FINISH_TIME_OF_ITS_DFS_TRAVERSAL | vector < int > Restore_Tree ( int Start [ ], int End [ ] ) {
  vector < int > Identity ( N, 0 );
  for ( int i = 0;
  i < N;
  i ++ ) {
    Identity [ Start [ i ] ] = i;
  }
  vector < int > parent ( N, - 1 );
  int curr_parent = Identity [ 0 ];
  for ( int j = 1;
  j < N;
  j ++ ) {
    int child = Identity [ j ];
    if ( End [ child ] - j > 1 ) {
      parent [ child ] = curr_parent;
      curr_parent = child;
    }
    else parent [ child ] = curr_parent;
    while ( End [ child ] == End [ parent [ child ] ] ) {
      child = parent [ child ];
      curr_parent = parent [ child ];
      if ( curr_parent == Identity [ 0 ] ) break;
    }
  }
  for ( int i = 0;
  i < N;
  i ++ ) parent [ i ] += 1;
  return parent;
}


NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES | int countOccurrences ( string s, int K ) {
  int n = s . length ( );
  int C, c1 = 0, c2 = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( s [ i ] == 'a' ) c1 ++;
    if ( s [ i ] == 'b' ) {
      c2 ++;
      C += c1;
    }
  }
  return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2;
}


NUMBER_SUBSTRINGS_STRING | int countNonEmptySubstr ( string str ) {
  int n = str . length ( );
  return n * ( n + 1 ) / 2;
}


MAXIMUM_NUMBER_CHARACTERS_TWO_CHARACTER_STRING_1 | int maximumChars ( string & str ) {
  int n = str . length ( );
  int res = - 1;
  int firstInd [ MAX_CHAR ];
  for ( int i = 0;
  i < MAX_CHAR;
  i ++ ) firstInd [ i ] = - 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int first_ind = firstInd [ str [ i ] ];
    if ( first_ind == - 1 ) firstInd [ str [ i ] ] = i;
    else res = max ( res, abs ( i - first_ind - 1 ) );
  }
  return res;
}


SUM_SQUARES_BINOMIAL_COEFFICIENTS | int sumofsquare ( int n ) {
  int C [ n + 1 ] [ n + 1 ];
  int i, j;
  for ( i = 0;
  i <= n;
  i ++ ) {
    for ( j = 0;
    j <= min ( i, n );
    j ++ ) {
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1;
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ];
    }
  }
  int sum = 0;
  for ( int i = 0;
  i <= n;
  i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] );
  return sum;
}


PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2 | void printSubsequences ( string str ) {
  int n = str . length ( );
  unsigned int opsize = pow ( 2, n - 1 );
  for ( int counter = 0;
  counter < opsize;
  counter ++ ) {
    for ( int j = 0;
    j < n;
    j ++ ) {
      cout << str [ j ];
      if ( counter & ( 1 << j ) ) cout << " ";
    }
    cout << endl;
  }
}


NON_REPEATING_ELEMENT | int firstNonRepeating ( int arr [ ], int n ) {
  for ( int i = 0;
  i < n;
  i ++ ) {
    int j;
    for ( j = 0;
    j < n;
    j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break;
    if ( j == n ) return arr [ i ];
  }
  return - 1;
}


SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE | long long int calculateSum ( int n ) {
  long long int sum = 0;
  for ( int row = 0;
  row < n;
  row ++ ) {
    sum = sum + ( 1 << row );
  }
  return sum;
}


CHECK_TWO_STRINGS_K_ANAGRAMS_NOT | bool arekAnagrams ( string str1, string str2, int k ) {
  int n = str1 . length ( );
  if ( str2 . length ( ) != n ) return false;
  int count1 [ MAX_CHAR ] = {
    0 };
    int count2 [ MAX_CHAR ] = {
      0 };
      for ( int i = 0;
      i < n;
      i ++ ) count1 [ str1 [ i ] - 'a' ] ++;
      for ( int i = 0;
      i < n;
      i ++ ) count2 [ str2 [ i ] - 'a' ] ++;
      int count = 0;
      for ( int i = 0;
      i < MAX_CHAR;
      i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + abs ( count1 [ i ] - count2 [ i ] );
      return ( count <= k );
    }
    

LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS | int longestCommonSum ( bool arr1 [ ], bool arr2 [ ], int n ) {
  int maxLen = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int sum1 = 0, sum2 = 0;
    for ( int j = i;
    j < n;
    j ++ ) {
      sum1 += arr1 [ j ];
      sum2 += arr2 [ j ];
      if ( sum1 == sum2 ) {
        int len = j - i + 1;
        if ( len > maxLen ) maxLen = len;
      }
    }
  }
  return maxLen;
}


REMAINDER_7_LARGE_NUMBERS | int remainderWith7 ( string num ) {
  int series [ ] = {
    1, 3, 2, - 1, - 3, - 2 };
    int series_index = 0;
    int result = 0;
    for ( int i = num . size ( ) - 1;
    i >= 0;
    i -- ) {
      int digit = num [ i ] - '0';
      result += digit * series [ series_index ];
      series_index = ( series_index + 1 ) % 6;
      result %= 7;
    }
    if ( result < 0 ) result = ( result + 7 ) % 7;
    return result;
  }
  

LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C | bool prevPermutation ( string & str ) {
  int n = str . length ( ) - 1;
  int i = n;
  while ( i > 0 && str [ i - 1 ] <= str [ i ] ) i --;
  if ( i <= 0 ) return false;
  int j = i - 1;
  while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) j ++;
  swap ( str [ i - 1 ], str [ j ] );
  reverse ( str . begin ( ) + i, str . end ( ) );
  return true;
}


NUMBER_SUBSEQUENCES_FORM_AI_BJ_CK | int countSubsequences ( string s ) {
  int aCount = 0;
  int bCount = 0;
  int cCount = 0;
  for ( unsigned int i = 0;
  i < s . size ( );
  i ++ ) {
    if ( s [ i ] == 'a' ) aCount = ( 1 + 2 * aCount );
    else if ( s [ i ] == 'b' ) bCount = ( aCount + 2 * bCount );
    else if ( s [ i ] == 'c' ) cCount = ( bCount + 2 * cCount );
  }
  return cCount;
}


PROGRAM_PRINT_IDENTITY_MATRIX_1 | bool isIdentity ( int mat [ ] [ MAX ], int N ) {
  for ( int row = 0;
  row < N;
  row ++ ) {
    for ( int col = 0;
    col < N;
    col ++ ) {
      if ( row == col && mat [ row ] [ col ] != 1 ) return false;
      else if ( row != col && mat [ row ] [ col ] != 0 ) return false;
    }
  }
  return true;
}


MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1 | int maxDiff ( int arr [ ], int n ) {
  int result = 0;
  sort ( arr, arr + n );
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] );
    else i ++;
  }
  if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += abs ( arr [ n - 1 ] );
  return result;
}


PROGRAM_PRINT_SUM_GIVEN_NTH_TERM | int summingSeries ( long n ) {
  int S = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) S += i * i - ( i - 1 ) * ( i - 1 );
  return S;
}


PREFIX_SUM_2D_ARRAY | void prefixSum2D ( int a [ ] [ C ] ) {
  int psa [ R ] [ C ];
  psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ];
  for ( int i = 1;
  i < C;
  i ++ ) psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ];
  for ( int i = 0;
  i < R;
  i ++ ) psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ];
  for ( int i = 1;
  i < R;
  i ++ ) {
    for ( int j = 1;
    j < C;
    j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ];
  }
  for ( int i = 0;
  i < R;
  i ++ ) {
    for ( int j = 0;
    j < C;
    j ++ ) cout << psa [ i ] [ j ] << " ";
    cout << "\n";
  }
}


MAXIMUM_NUMBER_2X2_SQUARES_CAN_FIT_INSIDE_RIGHT_ISOSCELES_TRIANGLE | int numberOfSquares ( int base ) {
  base = ( base - 2 );
  base = base / 2;
  return base * ( base + 1 ) / 2;
}


GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1 | int countSubStr ( char str [ ] ) {
  int m = 0;
  for ( int i = 0;
  str [ i ] != '\0';
  i ++ ) {
    if ( str [ i ] == '1' ) m ++;
  }
  return m * ( m - 1 ) / 2;
}


CONVERTING_ONE_STRING_USING_APPEND_DELETE_LAST_OPERATIONS | bool isConvertible ( string str1, string str2, int k ) {
  if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true;
  int commonLength = 0;
  for ( int i = 0;
  i < min ( str1 . length ( ), str2 . length ( ) );
  i ++ ) {
    if ( str1 [ i ] == str2 [ i ] ) commonLength ++;
    else break;
  }
  if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true;
  return false;
}


FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2 | int getOddOccurrence ( int ar [ ], int ar_size ) {
  int res = 0;
  for ( int i = 0;
  i < ar_size;
  i ++ ) res = res ^ ar [ i ];
  return res;
}


SUM_MIDDLE_ROW_COLUMN_MATRIX | void middlesum ( int mat [ ] [ MAX ], int n ) {
  int row_sum = 0, col_sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) row_sum += mat [ n / 2 ] [ i ];
  cout << "Sum of middle row = " << row_sum << endl;
  for ( int i = 0;
  i < n;
  i ++ ) col_sum += mat [ i ] [ n / 2 ];
  cout << "Sum of middle column = " << col_sum;
}


K_TH_DISTINCT_OR_NON_REPEATING_ELEMENT_IN_AN_ARRAY | int printKDistinct ( int arr [ ], int n, int k ) {
  int dist_count = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int j;
    for ( j = 0;
    j < n;
    j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break;
    if ( j == n ) dist_count ++;
    if ( dist_count == k ) return arr [ i ];
  }
  return - 1;
}


MERGING_INTERVALS | void mergeIntervals ( Interval arr [ ], int n ) {
  sort ( arr, arr + n, mycomp );
  int index = 0;
  for ( int i = 1;
  i < n;
  i ++ ) {
    if ( arr [ index ] . e >= arr [ i ] . s ) {
      arr [ index ] . e = max ( arr [ index ] . e, arr [ i ] . e );
      arr [ index ] . s = min ( arr [ index ] . s, arr [ i ] . s );
    }
    else {
      arr [ index ] = arr [ i ];
      index ++;
    }
  }
  cout << "\n The Merged Intervals are: ";
  for ( int i = 0;
  i <= index;
  i ++ ) cout << "[" << arr [ i ] . s << ", " << arr [ i ] . e << "] ";
}


FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1 | int countSquares ( int a, int b ) {
  return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 );
}


LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS | void findFibSubset ( int arr [ ], int n ) {
  int max = * std :: max_element ( arr, arr + n );
  int a = 0, b = 1;
  unordered_set < int > hash;
  hash . insert ( a );
  hash . insert ( b );
  while ( b < max ) {
    int c = a + b;
    a = b;
    b = c;
    hash . insert ( b );
  }
  for ( int i = 0;
  i < n;
  i ++ ) if ( hash . find ( arr [ i ] ) != hash . end ( ) ) printf ( "%d ", arr [ i ] );
}


LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING | string lexicographicSubConcat ( string s ) {
  int n = s . length ( );
  int sub_count = n * ( n + 1 ) / 2;
  string arr [ sub_count ];
  int index = 0;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int len = 1;
  len <= n - i;
  len ++ ) arr [ index ++ ] = s . substr ( i, len );
  sort ( arr, arr + sub_count );
  string res = "";
  for ( int i = 0;
  i < sub_count;
  i ++ ) res += arr [ i ];
  return res;
}


COUNT_OPERATIONS_MAKE_STRINGAB_FREE | int abFree ( string s ) {
  int n = s . length ( );
  char char_array [ n + 1 ];
  strcpy ( char_array, s . c_str ( ) );
  int b_count = 0;
  int res = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( char_array [ n - i - 1 ] == 'a' ) {
      res = ( res + b_count );
      b_count = ( b_count * 2 );
    }
    else {
      b_count += 1;
    }
  }
  return res;
}


MAXIMUM_HEIGHT_OF_TRIANGULAR_ARRANGEMENT_OF_ARRAY_VALUES_1 | int MaximumHeight ( int a [ ], int n ) {
  return floor ( ( - 1 + sqrt ( 1 + ( 8 * n ) ) ) / 2 );
}


MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES | int maxvolume ( int s ) {
  int maxvalue = 0;
  for ( int i = 1;
  i <= s - 2;
  i ++ ) {
    for ( int j = 1;
    j <= s - 1;
    j ++ ) {
      int k = s - i - j;
      maxvalue = max ( maxvalue, i * j * k );
    }
  }
  return maxvalue;
}


PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION | void decToHexa ( int n ) {
  char hexaDeciNum [ 100 ];
  int i = 0;
  while ( n != 0 ) {
    int temp = 0;
    temp = n % 16;
    if ( temp < 10 ) {
      hexaDeciNum [ i ] = temp + 48;
      i ++;
    }
    else {
      hexaDeciNum [ i ] = temp + 55;
      i ++;
    }
    n = n / 16;
  }
  for ( int j = i - 1;
  j >= 0;
  j -- ) cout << hexaDeciNum [ j ];
}


SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELEMENT | void smallestSubsegment ( int a [ ], int n ) {
  unordered_map < int, int > left;
  unordered_map < int, int > count;
  int mx = 0;
  int mn, strindex;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int x = a [ i ];
    if ( count [ x ] == 0 ) {
      left [ x ] = i;
      count [ x ] = 1;
    }
    else count [ x ] ++;
    if ( count [ x ] > mx ) {
      mx = count [ x ];
      mn = i - left [ x ] + 1;
      strindex = left [ x ];
    }
    else if ( count [ x ] == mx && i - left [ x ] + 1 < mn ) {
      mn = i - left [ x ] + 1;
      strindex = left [ x ];
    }
  }
  for ( int i = strindex;
  i < strindex + mn;
  i ++ ) cout << a [ i ] << " ";
}


FIND_LAST_INDEX_CHARACTER_STRING_1 | int findLastIndex ( string & str, char x ) {
  for ( int i = str . length ( ) - 1;
  i >= 0;
  i -- ) if ( str [ i ] == x ) return i;
  return - 1;
}


RECAMANS_SEQUENCE | int recaman ( int n ) {
  int arr [ n ];
  arr [ 0 ] = 0;
  printf ( "%d, ", arr [ 0 ] );
  for ( int i = 1;
  i < n;
  i ++ ) {
    int curr = arr [ i - 1 ] - i;
    int j;
    for ( j = 0;
    j < i;
    j ++ ) {
      if ( ( arr [ j ] == curr ) || curr < 0 ) {
        curr = arr [ i - 1 ] + i;
        break;
      }
    }
    arr [ i ] = curr;
    printf ( "%d, ", arr [ i ] );
  }
}


C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER | char getSecondMostFreq ( string str ) {
  int count [ NO_OF_CHARS ] = {
    0 },
    i;
    for ( i = 0;
    str [ i ];
    i ++ ) ( count [ str [ i ] ] ) ++;
    int first = 0, second = 0;
    for ( i = 0;
    i < NO_OF_CHARS;
    i ++ ) {
      if ( count [ i ] > count [ first ] ) {
        second = first;
        first = i;
      }
      else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i;
    }
    return second;
  }
  

FIND_MAXIMUM_HEIGHT_PYRAMID_FROM_THE_GIVEN_ARRAY_OF_OBJECTS | int maxLevel ( int boxes [ ], int n ) {
  sort ( boxes, boxes + n );
  int ans = 1;
  int prev_width = boxes [ 0 ];
  int prev_count = 1;
  int curr_count = 0;
  int curr_width = 0;
  for ( int i = 1;
  i < n;
  i ++ ) {
    curr_width += boxes [ i ];
    curr_count += 1;
    if ( curr_width > prev_width && curr_count > prev_count ) {
      prev_width = curr_width;
      prev_count = curr_count;
      curr_count = 0;
      curr_width = 0;
      ans ++;
    }
  }
  return ans;
}


COUNTING_INVERSIONS | int getInvCount ( int arr [ ], int n ) {
  int inv_count = 0;
  for ( int i = 0;
  i < n - 1;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++;
  return inv_count;
}


SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS | void diagonalsquare ( int mat [ ] [ MAX ], int row, int column ) {
  cout << "Diagonal one : ";
  for ( int i = 0;
  i < row;
  i ++ ) {
    for ( int j = 0;
    j < column;
    j ++ ) if ( i == j ) cout << mat [ i ] [ j ] * mat [ i ] [ j ] << " ";
  }
  cout << " \n\nDiagonal two : ";
  for ( int i = 0;
  i < row;
  i ++ ) {
    for ( int j = 0;
    j < column;
    j ++ ) if ( i + j == column - 1 ) cout << mat [ i ] [ j ] * mat [ i ] [ j ] << "  ";
  }
}


ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX | int countCommon ( int mat [ ] [ MAX ], int n ) {
  int res = 0;
  for ( int i = 0;
  i < n;
  i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++;
  return res;
}


EULERIAN_NUMBER | int eulerian ( int n, int m ) {
  if ( m >= n || n == 0 ) return 0;
  if ( m == 0 ) return 1;
  return ( n - m ) * eulerian ( n - 1, m - 1 ) + ( m + 1 ) * eulerian ( n - 1, m );
}


EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS | bool squareRootExists ( int n, int p ) {
  n = n % p;
  for ( int x = 2;
  x < p;
  x ++ ) if ( ( x * x ) % p == n ) return true;
  return false;
}


COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3 | int numberOfPaths ( int m, int n ) {
  int path = 1;
  for ( int i = n;
  i < ( m + n - 1 );
  i ++ ) {
    path *= i;
    path /= ( i - n + 1 );
  }
  return path;
}


MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES | int maximumDifferenceSum ( int arr [ ], int N ) {
  int dp [ N ] [ 2 ];
  for ( int i = 0;
  i < N;
  i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0;
  for ( int i = 0;
  i < ( N - 1 );
  i ++ ) {
    dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ], dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) );
    dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ), dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) );
  }
  return max ( dp [ N - 1 ] [ 0 ], dp [ N - 1 ] [ 1 ] );
}


STERN_BROCOT_SEQUENCE | void SternSequenceFunc ( vector < int > & BrocotSequence, int n ) {
  for ( int i = 1;
  BrocotSequence . size ( ) < n;
  i ++ ) {
    int considered_element = BrocotSequence [ i ];
    int precedent = BrocotSequence [ i - 1 ];
    BrocotSequence . push_back ( considered_element + precedent );
    BrocotSequence . push_back ( considered_element );
  }
  for ( int i = 0;
  i < 15;
  ++ i ) cout << BrocotSequence [ i ] << " ";
}


NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N | int countDivisibleSubseq ( string str, int n ) {
  int len = str . length ( );
  int dp [ len ] [ n ];
  memset ( dp, 0, sizeof ( dp ) );
  dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] ++;
  for ( int i = 1;
  i < len;
  i ++ ) {
    dp [ i ] [ ( str [ i ] - '0' ) % n ] ++;
    for ( int j = 0;
    j < n;
    j ++ ) {
      dp [ i ] [ j ] += dp [ i - 1 ] [ j ];
      dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp [ i - 1 ] [ j ];
    }
  }
  return dp [ len - 1 ] [ 0 ];
}


HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING | int search ( int arr [ ], int n, int x ) {
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] == x ) return i;
  }
  return - 1;
}


COUNT_PAIRS_WITH_GIVEN_SUM_1 | int getPairsCount ( int arr [ ], int n, int sum ) {
  unordered_map < int, int > m;
  for ( int i = 0;
  i < n;
  i ++ ) m [ arr [ i ] ] ++;
  int twice_count = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    twice_count += m [ sum - arr [ i ] ];
    if ( sum - arr [ i ] == arr [ i ] ) twice_count --;
  }
  return twice_count / 2;
}


FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS | int minDist ( int arr [ ], int n, int x, int y ) {
  int i, j;
  int min_dist = INT_MAX;
  for ( i = 0;
  i < n;
  i ++ ) {
    for ( j = i + 1;
    j < n;
    j ++ ) {
      if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) && min_dist > abs ( i - j ) ) {
        min_dist = abs ( i - j );
      }
    }
  }
  return min_dist;
}


FIND_REPETITIVE_ELEMENT_1_N_1_2 | int findRepeating ( int arr [ ], int n ) {
  int res = 0;
  for ( int i = 0;
  i < n - 1;
  i ++ ) res = res ^ ( i + 1 ) ^ arr [ i ];
  res = res ^ arr [ n - 1 ];
  return res;
}


SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH_1 | INT_MAX int shortestPath ( int graph [ ] [ V ], int u, int v, int k ) {
  int sp [ V ] [ V ] [ k + 1 ];
  for ( int e = 0;
  e <= k;
  e ++ ) {
    for ( int i = 0;
    i < V;
    i ++ ) {
      for ( int j = 0;
      j < V;
      j ++ ) {
        sp [ i ] [ j ] [ e ] = INF;
        if ( e == 0 && i == j ) sp [ i ] [ j ] [ e ] = 0;
        if ( e == 1 && graph [ i ] [ j ] != INF ) sp [ i ] [ j ] [ e ] = graph [ i ] [ j ];
        if ( e > 1 ) {
          for ( int a = 0;
          a < V;
          a ++ ) {
            if ( graph [ i ] [ a ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ], graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] );
          }
        }
      }
    }
  }
  return sp [ u ] [ v ] [ k ];
}


LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS | void longest ( int a [ ], int n, int k ) {
  unordered_map < int, int > freq;
  int start = 0, end = 0, now = 0, l = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    freq [ a [ i ] ] ++;
    if ( freq [ a [ i ] ] == 1 ) now ++;
    while ( now > k ) {
      freq [ a [ l ] ] --;
      if ( freq [ a [ l ] ] == 0 ) now --;
      l ++;
    }
    if ( i - l + 1 >= end - start + 1 ) end = i, start = l;
  }
  for ( int i = start;
  i <= end;
  i ++ ) cout << a [ i ] << " ";
}


MAXIMUM_XOR_VALUE_MATRIX | int maxXOR ( int mat [ ] [ MAX ], int N ) {
  int r_xor, c_xor;
  int max_xor = 0;
  for ( int i = 0;
  i < N;
  i ++ ) {
    r_xor = 0, c_xor = 0;
    for ( int j = 0;
    j < N;
    j ++ ) {
      r_xor = r_xor ^ mat [ i ] [ j ];
      c_xor = c_xor ^ mat [ j ] [ i ];
    }
    if ( max_xor < max ( r_xor, c_xor ) ) max_xor = max ( r_xor, c_xor );
  }
  return max_xor;
}


LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED | int longestNull ( string str ) {
  vector < pair < char, int > > arr;
  arr . push_back ( {
    '@', - 1 }
    );
    int maxlen = 0;
    for ( int i = 0;
    i < str . length ( );
    ++ i ) {
      arr . push_back ( {
        str [ i ], i }
        );
        while ( arr . size ( ) >= 3 && arr [ arr . size ( ) - 3 ] . first == '1' && arr [ arr . size ( ) - 2 ] . first == '0' && arr [ arr . size ( ) - 1 ] . first == '0' ) {
          arr . pop_back ( );
          arr . pop_back ( );
          arr . pop_back ( );
        }
        int tmp = arr . back ( ) . second;
        maxlen = max ( maxlen, i - tmp );
      }
      return maxlen;
    }
    

LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARRAY | void alternateSubarray ( bool arr [ ], int n ) {
  int len [ n ];
  len [ n - 1 ] = 1;
  for ( int i = n - 2;
  i >= 0;
  -- i ) {
    if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1;
    else len [ i ] = 1;
  }
  for ( int i = 0;
  i < n;
  ++ i ) cout << len [ i ] << " ";
}


WILDCARD_CHARACTER_MATCHING | bool match ( char * first, char * second ) {
  if ( * first == '\0' && * second == '\0' ) return true;
  if ( * first == '*' && * ( first + 1 ) != '\0' && * second == '\0' ) return false;
  if ( * first == '?' || * first == * second ) return match ( first + 1, second + 1 );
  if ( * first == '*' ) return match ( first + 1, second ) || match ( first, second + 1 );
  return false;
}


FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N | void printFactorialNums ( int n ) {
  int fact = 1;
  int x = 2;
  while ( fact <= n ) {
    cout << fact << " ";
    fact = fact * x;
    x ++;
  }
}


FRIENDS_PAIRING_PROBLEM_2 | int countFriendsPairings ( int n ) {
  int a = 1, b = 2, c = 0;
  if ( n <= 2 ) {
    return n;
  }
  for ( int i = 3;
  i <= n;
  i ++ ) {
    c = b + ( i - 1 ) * a;
    a = b;
    b = c;
  }
  return c;
}


FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALLOWED | int maxArea ( bool mat [ R ] [ C ] ) {
  int hist [ R + 1 ] [ C + 1 ];
  for ( int i = 0;
  i < C;
  i ++ ) {
    hist [ 0 ] [ i ] = mat [ 0 ] [ i ];
    for ( int j = 1;
    j < R;
    j ++ ) hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 : hist [ j - 1 ] [ i ] + 1;
  }
  for ( int i = 0;
  i < R;
  i ++ ) {
    int count [ R + 1 ] = {
      0 };
      for ( int j = 0;
      j < C;
      j ++ ) count [ hist [ i ] [ j ] ] ++;
      int col_no = 0;
      for ( int j = R;
      j >= 0;
      j -- ) {
        if ( count [ j ] > 0 ) {
          for ( int k = 0;
          k < count [ j ];
          k ++ ) {
            hist [ i ] [ col_no ] = j;
            col_no ++;
          }
        }
      }
    }
    int curr_area, max_area = 0;
    for ( int i = 0;
    i < R;
    i ++ ) {
      for ( int j = 0;
      j < C;
      j ++ ) {
        curr_area = ( j + 1 ) * hist [ i ] [ j ];
        if ( curr_area > max_area ) max_area = curr_area;
      }
    }
    return max_area;
  }
  

SUM_SEQUENCE_2_22_222 | float sumOfSeries ( int n ) {
  return 0.0246 * ( pow ( 10, n ) - 1 - ( 9 * n ) );
}


PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT | void firstFit ( int blockSize [ ], int m, int processSize [ ], int n ) {
  int allocation [ n ];
  memset ( allocation, - 1, sizeof ( allocation ) );
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < m;
    j ++ ) {
      if ( blockSize [ j ] >= processSize [ i ] ) {
        allocation [ i ] = j;
        blockSize [ j ] -= processSize [ i ];
        break;
      }
    }
  }
  cout << "\nProcess No.\tProcess Size\tBlock no.\n";
  for ( int i = 0;
  i < n;
  i ++ ) {
    cout << " " << i + 1 << "\t\t" << processSize [ i ] << "\t\t";
    if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 1;
    else cout << "Not Allocated";
    cout << endl;
  }
}


CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER | bool isPower ( int x, long int y ) {
  if ( x == 1 ) return ( y == 1 );
  long int pow = 1;
  while ( pow < y ) pow *= x;
  return ( pow == y );
}


DIVIDE_LARGE_NUMBER_REPRESENTED_STRING | string longDivision ( string number, int divisor ) {
  string ans;
  int idx = 0;
  int temp = number [ idx ] - '0';
  while ( temp < divisor ) temp = temp * 10 + ( number [ ++ idx ] - '0' );
  while ( number . size ( ) > idx ) {
    ans += ( temp / divisor ) + '0';
    temp = ( temp % divisor ) * 10 + number [ ++ idx ] - '0';
  }
  if ( ans . length ( ) == 0 ) return "0";
  return ans;
}


FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S | void findMax ( int arr [ ] [ N ] ) {
  int row = 0, i, j;
  for ( i = 0, j = N - 1;
  i < N;
  i ++ ) {
    while ( arr [ i ] [ j ] == 1 && j >= 0 ) {
      row = i;
      j --;
    }
  }
  cout << "Row number = " << row + 1;
  cout << ", MaxCount = " << N - 1 - j;
}


MINIMUM_ROTATIONS_REQUIRED_GET_STRING | int findRotations ( string str ) {
  string tmp = str + str;
  int n = str . length ( );
  for ( int i = 1;
  i <= n;
  i ++ ) {
    string substring = tmp . substr ( i, str . size ( ) );
    if ( str == substring ) return i;
  }
  return n;
}


COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX | int numberOfPaths ( int m, int n ) {
  if ( m == 1 || n == 1 ) return 1;
  return numberOfPaths ( m - 1, n ) + numberOfPaths ( m, n - 1 );
}


N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_1 | int findNth ( int n ) {
  int count = 0;
  for ( int curr = 19;
  ;
  curr += 9 ) {
    int sum = 0;
    for ( int x = curr;
    x > 0;
    x = x / 10 ) sum = sum + x % 10;
    if ( sum == 10 ) count ++;
    if ( count == n ) return curr;
  }
  return - 1;
}


SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1 | int sumAtKthLevel ( string tree, int k, int & i, int level ) {
  if ( tree [ i ++ ] == '(' ) {
    if ( tree [ i ] == ')' ) return 0;
    int sum = 0;
    if ( level == k ) sum = tree [ i ] - '0';
    int leftsum = sumAtKthLevel ( tree, k, ++ i, level + 1 );
    int rightsum = sumAtKthLevel ( tree, k, ++ i, level + 1 );
    ++ i;
    return sum + leftsum + rightsum;
  }
}


COUNT_OFDIFFERENT_WAYS_EXPRESS_N_SUM_1_3_4 | int countWays ( int n ) {
  int DP [ n + 1 ];
  DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1;
  DP [ 3 ] = 2;
  for ( int i = 4;
  i <= n;
  i ++ ) DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ];
  return DP [ n ];
}


MAXIMUM_EQULIBRIUM_SUM_ARRAY | int findMaxSum ( int arr [ ], int n ) {
  int res = INT_MIN;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int prefix_sum = arr [ i ];
    for ( int j = 0;
    j < i;
    j ++ ) prefix_sum += arr [ j ];
    int suffix_sum = arr [ i ];
    for ( int j = n - 1;
    j > i;
    j -- ) suffix_sum += arr [ j ];
    if ( prefix_sum == suffix_sum ) res = max ( res, prefix_sum );
  }
  return res;
}


STEINS_ALGORITHM_FOR_FINDING_GCD_1 | int gcd ( int a, int b ) {
  if ( a == b ) return a;
  if ( a == 0 ) return b;
  if ( b == 0 ) return a;
  if ( ~ a & 1 ) {
    if ( b & 1 ) return gcd ( a >> 1, b );
    else return gcd ( a >> 1, b >> 1 ) << 1;
  }
  if ( ~ b & 1 ) return gcd ( a, b >> 1 );
  if ( a > b ) return gcd ( ( a - b ) >> 1, b );
  return gcd ( ( b - a ) >> 1, a );
}


PROGRAM_TO_FIND_THE_VOLUME_OF_A_TRIANGULAR_PRISM | float findVolume ( float l, float b, float h ) {
  float volume = ( l * b * h ) / 2;
  return volume;
}


FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1 | bool isRectangle ( const vector < vector < int > > & m ) {
  int rows = m . size ( );
  if ( rows == 0 ) return false;
  int columns = m [ 0 ] . size ( );
  for ( int y1 = 0;
  y1 < rows;
  y1 ++ ) for ( int x1 = 0;
  x1 < columns;
  x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1;
  y2 < rows;
  y2 ++ ) for ( int x2 = x1 + 1;
  x2 < columns;
  x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true;
  return false;
}


CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBER_OF_CHARACTERS | bool isPossible ( string str, int n ) {
  int len = str . length ( );
  if ( len >= n ) return true;
  return false;
}


CHECK_STAR_GRAPH | bool checkStar ( int mat [ ] [ size ] ) {
  int vertexD1 = 0, vertexDn_1 = 0;
  if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 );
  if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 );
  for ( int i = 0;
  i < size;
  i ++ ) {
    int degreeI = 0;
    for ( int j = 0;
    j < size;
    j ++ ) if ( mat [ i ] [ j ] ) degreeI ++;
    if ( degreeI == 1 ) vertexD1 ++;
    else if ( degreeI == size - 1 ) vertexDn_1 ++;
  }
  return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 );
}


ROOTS_OF_UNITY | void printRoots ( int n ) {
  double theta = M_PI * 2 / n;
  for ( int k = 0;
  k < n;
  k ++ ) {
    double real = cos ( k * theta );
    double img = sin ( k * theta );
    printf ( "%.6f", real );
    img >= 0 ? printf ( " + i " ) : printf ( " - i " );
    printf ( "%.6f\n", abs ( img ) );
  }
}


FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D | int findLargestd ( int S [ ], int n ) {
  bool found = false;
  sort ( S, S + n );
  for ( int i = n - 1;
  i >= 0;
  i -- ) {
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( i == j ) continue;
      for ( int k = j + 1;
      k < n;
      k ++ ) {
        if ( i == k ) continue;
        for ( int l = k + 1;
        l < n;
        l ++ ) {
          if ( i == l ) continue;
          if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) {
            found = true;
            return S [ i ];
          }
        }
      }
    }
  }
  if ( found == false ) return INT_MIN;
}


GIVEN_NUMBER_STRING_FIND_NUMBER_CONTIGUOUS_SUBSEQUENCES_RECURSIVELY_ADD_9_SET_2 | int count9s ( char number [ ] ) {
  int n = strlen ( number );
  int d [ 9 ];
  memset ( d, 0, sizeof ( d ) );
  d [ 0 ] = 1;
  int result = 0;
  int mod_sum = 0, continuous_zero = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( ! int ( number [ i ] - '0' ) ) continuous_zero ++;
    else continuous_zero = 0;
    mod_sum += int ( number [ i ] - '0' );
    mod_sum %= 9;
    result += d [ mod_sum ];
    d [ mod_sum ] ++;
    result -= continuous_zero;
  }
  return result;
}


LEXICOGRAPHICAL_MAXIMUM_SUBSTRING_STRING | string LexicographicalMaxString ( string str ) {
  string mx = "";
  for ( int i = 0;
  i < str . length ( );
  ++ i ) mx = max ( mx, str . substr ( i ) );
  return mx;
}


CHECK_TWO_GIVEN_SETS_DISJOINT_1 | bool areDisjoint ( int set1 [ ], int set2 [ ], int m, int n ) {
  sort ( set1, set1 + m );
  sort ( set2, set2 + n );
  int i = 0, j = 0;
  while ( i < m && j < n ) {
    if ( set1 [ i ] < set2 [ j ] ) i ++;
    else if ( set2 [ j ] < set1 [ i ] ) j ++;
    else return false;
  }
  return true;
}


EQUILIBRIUM_INDEX_OF_AN_ARRAY_1 | int equilibrium ( int arr [ ], int n ) {
  int sum = 0;
  int leftsum = 0;
  for ( int i = 0;
  i < n;
  ++ i ) sum += arr [ i ];
  for ( int i = 0;
  i < n;
  ++ i ) {
    sum -= arr [ i ];
    if ( leftsum == sum ) return i;
    leftsum += arr [ i ];
  }
  return - 1;
}


AREA_CIRCUMSCRIBED_CIRCLE_SQUARE | float areacircumscribed ( float a ) {
  return ( a * a * ( PI / 2 ) );
}


LONGEST_REPEATING_AND_NON_OVERLAPPING_SUBSTRING | string longestRepeatedSubstring ( string str ) {
  int n = str . length ( );
  int LCSRe [ n + 1 ] [ n + 1 ];
  memset ( LCSRe, 0, sizeof ( LCSRe ) );
  string res;
  int res_length = 0;
  int i, index = 0;
  for ( i = 1;
  i <= n;
  i ++ ) {
    for ( int j = i + 1;
    j <= n;
    j ++ ) {
      if ( str [ i - 1 ] == str [ j - 1 ] && LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) {
        LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1;
        if ( LCSRe [ i ] [ j ] > res_length ) {
          res_length = LCSRe [ i ] [ j ];
          index = max ( i, index );
        }
      }
      else LCSRe [ i ] [ j ] = 0;
    }
  }
  if ( res_length > 0 ) for ( i = index - res_length + 1;
  i <= index;
  i ++ ) res . push_back ( str [ i - 1 ] );
  return res;
}


HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION | ll mulmod ( ll a, ll b, ll mod ) {
  ll res = 0;
  a = a % mod;
  while ( b > 0 ) {
    if ( b % 2 == 1 ) res = ( res + a ) % mod;
    a = ( a * 2 ) % mod;
    b /= 2;
  }
  return res % mod;
}


PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1 | bool isProduct ( int arr [ ], int n, int x ) {
  if ( n < 2 ) return false;
  unordered_set < int > s;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] == 0 ) {
      if ( x == 0 ) return true;
      else continue;
    }
    if ( x % arr [ i ] == 0 ) {
      if ( s . find ( x / arr [ i ] ) != s . end ( ) ) return true;
      s . insert ( arr [ i ] );
    }
  }
  return false;
}


SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS | int kthgroupsum ( int k ) {
  int cur = ( k * ( k - 1 ) ) + 1;
  int sum = 0;
  while ( k -- ) {
    sum += cur;
    cur += 2;
  }
  return sum;
}


FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_1 | void findElements ( int arr [ ], int n ) {
  sort ( arr, arr + n );
  for ( int i = 0;
  i < n - 2;
  i ++ ) cout << arr [ i ] << " ";
}


MINIMUM_STEPS_TO_DELETE_A_STRING_AFTER_REPEATED_DELETION_OF_PALINDROME_SUBSTRINGS | int minStepToDeleteString ( string str ) {
  int N = str . length ( );
  int dp [ N + 1 ] [ N + 1 ];
  for ( int i = 0;
  i <= N;
  i ++ ) for ( int j = 0;
  j <= N;
  j ++ ) dp [ i ] [ j ] = 0;
  for ( int len = 1;
  len <= N;
  len ++ ) {
    for ( int i = 0, j = len - 1;
    j < N;
    i ++, j ++ ) {
      if ( len == 1 ) dp [ i ] [ j ] = 1;
      else {
        dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ];
        if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ], dp [ i ] [ j ] );
        for ( int K = i + 2;
        K <= j;
        K ++ ) if ( str [ i ] == str [ K ] ) dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ], dp [ i ] [ j ] );
      }
    }
  }
  return dp [ 0 ] [ N - 1 ];
}


CALCULATE_AREA_TETRAHEDRON | double vol_tetra ( int side ) {
  double volume = ( pow ( side, 3 ) / ( 6 * sqrt ( 2 ) ) );
  return volume;
}


SIEVE_OF_ATKIN | int SieveOfAtkin ( int limit ) {
  if ( limit > 2 ) cout << 2 << " ";
  if ( limit > 3 ) cout << 3 << " ";
  bool sieve [ limit ];
  for ( int i = 0;
  i < limit;
  i ++ ) sieve [ i ] = false;
  for ( int x = 1;
  x * x < limit;
  x ++ ) {
    for ( int y = 1;
    y * y < limit;
    y ++ ) {
      int n = ( 4 * x * x ) + ( y * y );
      if ( n <= limit && ( n % 12 == 1 || n % 12 == 5 ) ) sieve [ n ] ^= true;
      n = ( 3 * x * x ) + ( y * y );
      if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true;
      n = ( 3 * x * x ) - ( y * y );
      if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true;
    }
  }
  for ( int r = 5;
  r * r < limit;
  r ++ ) {
    if ( sieve [ r ] ) {
      for ( int i = r * r;
      i < limit;
      i += r * r ) sieve [ i ] = false;
    }
  }
  for ( int a = 5;
  a < limit;
  a ++ ) if ( sieve [ a ] ) cout << a << " ";
}


LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY | int lenghtOfLongestAP ( int set [ ], int n ) {
  if ( n <= 2 ) return n;
  int L [ n ] [ n ];
  int llap = 2;
  for ( int i = 0;
  i < n;
  i ++ ) L [ i ] [ n - 1 ] = 2;
  for ( int j = n - 2;
  j >= 1;
  j -- ) {
    int i = j - 1, k = j + 1;
    while ( i >= 0 && k <= n - 1 ) {
      if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++;
      else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) {
        L [ i ] [ j ] = 2, i --;
      }
      else {
        L [ i ] [ j ] = L [ j ] [ k ] + 1;
        llap = max ( llap, L [ i ] [ j ] );
        i --;
        k ++;
      }
    }
    while ( i >= 0 ) {
      L [ i ] [ j ] = 2;
      i --;
    }
  }
  return llap;
}


COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS_IMMEDIATE_RIGHT_SUB_GROUP_1 | int countGroups ( int position, int previous_sum, int length, char * num ) {
  if ( position == length ) return 1;
  if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ];
  dp [ position ] [ previous_sum ] = 0;
  int res = 0;
  int sum = 0;
  for ( int i = position;
  i < length;
  i ++ ) {
    sum += ( num [ i ] - '0' );
    if ( sum >= previous_sum ) res += countGroups ( i + 1, sum, length, num );
  }
  dp [ position ] [ previous_sum ] = res;
  return res;
}


LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS_1 | int longestCommonSum ( bool arr1 [ ], bool arr2 [ ], int n ) {
  int maxLen = 0;
  int preSum1 = 0, preSum2 = 0;
  int diff [ 2 * n + 1 ];
  memset ( diff, - 1, sizeof ( diff ) );
  for ( int i = 0;
  i < n;
  i ++ ) {
    preSum1 += arr1 [ i ];
    preSum2 += arr2 [ i ];
    int curr_diff = preSum1 - preSum2;
    int diffIndex = n + curr_diff;
    if ( curr_diff == 0 ) maxLen = i + 1;
    else if ( diff [ diffIndex ] == - 1 ) diff [ diffIndex ] = i;
    else {
      int len = i - diff [ diffIndex ];
      if ( len > maxLen ) maxLen = len;
    }
  }
  return maxLen;
}


PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS | void printFibonacciNumbers ( int n ) {
  int f1 = 0, f2 = 1, i;
  if ( n < 1 ) return;
  for ( i = 1;
  i <= n;
  i ++ ) {
    cout << f2 << " ";
    int next = f1 + f2;
    f1 = f2;
    f2 = next;
  }
}


LARGEST_SUM_CONTIGUOUS_SUBARRAY_3 | int maxSubArraySum ( int a [ ], int size ) {
  int max_so_far = INT_MIN, max_ending_here = 0, start = 0, end = 0, s = 0;
  for ( int i = 0;
  i < size;
  i ++ ) {
    max_ending_here += a [ i ];
    if ( max_so_far < max_ending_here ) {
      max_so_far = max_ending_here;
      start = s;
      end = i;
    }
    if ( max_ending_here < 0 ) {
      max_ending_here = 0;
      s = i + 1;
    }
  }
  cout << "Maximum contiguous sum is " << max_so_far << endl;
  cout << "Starting index " << start << endl << "Ending index " << end << endl;
}


FIND_EQUAL_POINT_STRING_BRACKETS | int findIndex ( string str ) {
  int len = str . length ( );
  int open [ len + 1 ], close [ len + 1 ];
  int index = - 1;
  memset ( open, 0, sizeof ( open ) );
  memset ( close, 0, sizeof ( close ) );
  open [ 0 ] = 0;
  close [ len ] = 0;
  if ( str [ 0 ] == '(' ) open [ 1 ] = 1;
  if ( str [ len - 1 ] == ')' ) close [ len - 1 ] = 1;
  for ( int i = 1;
  i < len;
  i ++ ) {
    if ( str [ i ] == '(' ) open [ i + 1 ] = open [ i ] + 1;
    else open [ i + 1 ] = open [ i ];
  }
  for ( int i = len - 2;
  i >= 0;
  i -- ) {
    if ( str [ i ] == ')' ) close [ i ] = close [ i + 1 ] + 1;
    else close [ i ] = close [ i + 1 ];
  }
  if ( open [ len ] == 0 ) return len;
  if ( close [ 0 ] == 0 ) return 0;
  for ( int i = 0;
  i <= len;
  i ++ ) if ( open [ i ] == close [ i ] ) index = i;
  return index;
}


COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1 | int countP ( int n, int k ) {
  int dp [ n + 1 ] [ k + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) dp [ i ] [ 0 ] = 0;
  for ( int i = 0;
  i <= k;
  i ++ ) dp [ 0 ] [ k ] = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) for ( int j = 1;
  j <= i;
  j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1;
  else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ];
  return dp [ n ] [ k ];
}


LONGEST_INCREASING_SUBSEQUENCE | int lis ( int arr [ ], int n ) {
  int max = 1;
  _lis ( arr, n, & max );
  return max;
}


FIND_REPEATED_CHARACTER_PRESENT_FIRST_STRING | int findRepeatFirstN2 ( char * s ) {
  int p = - 1, i, j;
  for ( i = 0;
  i < strlen ( s );
  i ++ ) {
    for ( j = i + 1;
    j < strlen ( s );
    j ++ ) {
      if ( s [ i ] == s [ j ] ) {
        p = i;
        break;
      }
    }
    if ( p != - 1 ) break;
  }
  return p;
}


K_TH_SMALLEST_ELEMENT_REMOVING_INTEGERS_NATURAL_NUMBERS | int ksmallest ( int arr [ ], int n, int k ) {
  int b [ MAX ];
  memset ( b, 0, sizeof b );
  for ( int i = 0;
  i < n;
  i ++ ) b [ arr [ i ] ] = 1;
  for ( int j = 1;
  j < MAX;
  j ++ ) {
    if ( b [ j ] != 1 ) k --;
    if ( ! k ) return j;
  }
}


CHECK_IF_STACK_ELEMENTS_ARE_PAIRWISE_CONSECUTIVE | bool pairWiseConsecutive ( stack < int > s ) {
  stack < int > aux;
  while ( ! s . empty ( ) ) {
    aux . push ( s . top ( ) );
    s . pop ( );
  }
  bool result = true;
  while ( aux . empty ( ) > 1 ) {
    int x = aux . top ( );
    aux . pop ( );
    int y = aux . top ( );
    aux . pop ( );
    if ( abs ( x - y ) != 1 ) result = false;
    s . push ( x );
    s . push ( y );
  }
  if ( aux . size ( ) == 1 ) s . push ( aux . top ( ) );
  return result;
}


BINARY_SEARCH_1 | int binarySearch ( int arr [ ], int l, int r, int x ) {
  while ( l <= r ) {
    int m = l + ( r - l ) / 2;
    if ( arr [ m ] == x ) return m;
    if ( arr [ m ] < x ) l = m + 1;
    else r = m - 1;
  }
  return - 1;
}


COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE | int findSubsequenceCount ( string S, string T ) {
  int m = T . length ( ), n = S . length ( );
  if ( m > n ) return 0;
  int mat [ m + 1 ] [ n + 1 ];
  for ( int i = 1;
  i <= m;
  i ++ ) mat [ i ] [ 0 ] = 0;
  for ( int j = 0;
  j <= n;
  j ++ ) mat [ 0 ] [ j ] = 1;
  for ( int i = 1;
  i <= m;
  i ++ ) {
    for ( int j = 1;
    j <= n;
    j ++ ) {
      if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ];
      else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ];
    }
  }
  return mat [ m ] [ n ];
}


SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE | void swap ( int * xp, int * yp ) {
  * xp = * xp ^ * yp;
  * yp = * xp ^ * yp;
  * xp = * xp ^ * yp;
}


POLICEMEN_CATCH_THIEVES | int policeThief ( char arr [ ], int n, int k ) {
  int res = 0;
  vector < int > thi;
  vector < int > pol;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] == 'P' ) pol . push_back ( i );
    else if ( arr [ i ] == 'T' ) thi . push_back ( i );
  }
  int l = 0, r = 0;
  while ( l < thi . size ( ) && r < pol . size ( ) ) {
    if ( abs ( thi [ l ] - pol [ r ] ) <= k ) {
      res ++;
      l ++;
      r ++;
    }
    else if ( thi [ l ] < pol [ r ] ) l ++;
    else r ++;
  }
  return res;
}


LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1 | int maxLen ( int arr [ ], int n ) {
  unordered_map < int, int > hM;
  int sum = 0;
  int max_len = 0;
  int ending_index = - 1;
  for ( int i = 0;
  i < n;
  i ++ ) arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    sum += arr [ i ];
    if ( sum == 0 ) {
      max_len = i + 1;
      ending_index = i;
    }
    if ( hM . find ( sum + n ) != hM . end ( ) ) {
      if ( max_len < i - hM [ sum + n ] ) {
        max_len = i - hM [ sum + n ];
        ending_index = i;
      }
    }
    else hM [ sum + n ] = i;
  }
  for ( int i = 0;
  i < n;
  i ++ ) arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1;
  printf ( "%d to %d\n", ending_index - max_len + 1, ending_index );
  return max_len;
}


MAXIMUM_DIFFERENCE_ZEROS_ONES_BINARY_STRING_SET_2_TIME | int findLength ( string str, int n ) {
  int current_sum = 0;
  int max_sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    current_sum += ( str [ i ] == '0' ? 1 : - 1 );
    if ( current_sum < 0 ) current_sum = 0;
    max_sum = max ( current_sum, max_sum );
  }
  return max_sum == 0 ? - 1 : max_sum;
}


MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY | int findLongestConseqSubseq ( int arr [ ], int n ) {
  unordered_set < int > S;
  for ( int i = 0;
  i < n;
  i ++ ) S . insert ( arr [ i ] );
  int ans = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( S . find ( arr [ i ] - 1 ) == S . end ( ) ) {
      int j = arr [ i ];
      while ( S . find ( j ) != S . end ( ) ) j ++;
      ans = max ( ans, j - arr [ i ] );
    }
  }
  return ans;
}


LEXICOGRAPHICALLY_NEXT_STRING | string nextWord ( string s ) {
  if ( s == "" ) return "a";
  int i = s . length ( ) - 1;
  while ( s [ i ] == 'z' && i >= 0 ) i --;
  if ( i == - 1 ) s = s + 'a';
  else s [ i ] ++;
  return s;
}


SCHEDULE_JOBS_SERVER_GETS_EQUAL_LOAD | int solve ( int a [ ], int b [ ], int n ) {
  int i;
  long long int s = 0;
  for ( i = 0;
  i < n;
  i ++ ) s += ( a [ i ] + b [ i ] );
  if ( n == 1 ) return a [ 0 ] + b [ 0 ];
  if ( s % n != 0 ) return - 1;
  int x = s / n;
  for ( i = 0;
  i < n;
  i ++ ) {
    if ( a [ i ] > x ) return - 1;
    if ( i > 0 ) {
      a [ i ] += b [ i - 1 ];
      b [ i - 1 ] = 0;
    }
    if ( a [ i ] == x ) continue;
    int y = a [ i ] + b [ i ];
    if ( i + 1 < n ) y += b [ i + 1 ];
    if ( y == x ) {
      a [ i ] = y;
      b [ i ] = b [ i + 1 ] = 0;
      continue;
    }
    if ( a [ i ] + b [ i ] == x ) {
      a [ i ] += b [ i ];
      b [ i ] = 0;
      continue;
    }
    if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) {
      a [ i ] += b [ i + 1 ];
      b [ i + 1 ] = 0;
      continue;
    }
    return - 1;
  }
  for ( i = 0;
  i < n;
  i ++ ) if ( b [ i ] != 0 ) return - 1;
  return x;
}


FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1 | string getMinNumberForPattern ( string seq ) {
  int n = seq . length ( );
  if ( n >= 9 ) return "-1";
  string result ( n + 1, ' ' );
  int count = 1;
  for ( int i = 0;
  i <= n;
  i ++ ) {
    if ( i == n || seq [ i ] == 'I' ) {
      for ( int j = i - 1;
      j >= - 1;
      j -- ) {
        result [ j + 1 ] = '0' + count ++;
        if ( j >= 0 && seq [ j ] == 'I' ) break;
      }
    }
  }
  return result;
}


SHUFFLE_2N_INTEGERS_FORMAT_A1_B1_A2_B2_A3_B3_BN_WITHOUT_USING_EXTRA_SPACE | void shuffleArray ( int a [ ], int n ) {
  for ( int i = 0, q = 1, k = n;
  i < n;
  i ++, k ++, q ++ ) for ( int j = k;
  j > i + q;
  j -- ) swap ( a [ j - 1 ], a [ j ] );
}


FIND_REPETITIVE_ELEMENT_1_N_1_1 | int findRepeating ( int arr [ ], int n ) {
  unordered_set < int > s;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( s . find ( arr [ i ] ) != s . end ( ) ) return arr [ i ];
    s . insert ( arr [ i ] );
  }
  return - 1;
}


C_PROGRAM_SUBTRACTION_MATICES | void multiply ( int A [ ] [ N ], int B [ ] [ N ], int C [ ] [ N ] ) {
  int i, j;
  for ( i = 0;
  i < N;
  i ++ ) for ( j = 0;
  j < N;
  j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ];
}


FIRST_NEGATIVE_INTEGER_EVERY_WINDOW_SIZE_K | void printFirstNegativeInteger ( int arr [ ], int n, int k ) {
  bool flag;
  for ( int i = 0;
  i < ( n - k + 1 );
  i ++ ) {
    flag = false;
    for ( int j = 0;
    j < k;
    j ++ ) {
      if ( arr [ i + j ] < 0 ) {
        cout << arr [ i + j ] << " ";
        flag = true;
        break;
      }
    }
    if ( ! flag ) cout << "0" << " ";
  }
}


NUMBER_FULL_BINARY_TREES_NODE_PRODUCT_CHILDREN | int numoffbt ( int arr [ ], int n ) {
  int maxvalue = INT_MIN, minvalue = INT_MAX;
  for ( int i = 0;
  i < n;
  i ++ ) {
    maxvalue = max ( maxvalue, arr [ i ] );
    minvalue = min ( minvalue, arr [ i ] );
  }
  int mark [ maxvalue + 2 ];
  int value [ maxvalue + 2 ];
  memset ( mark, 0, sizeof ( mark ) );
  memset ( value, 0, sizeof ( value ) );
  for ( int i = 0;
  i < n;
  i ++ ) {
    mark [ arr [ i ] ] = 1;
    value [ arr [ i ] ] = 1;
  }
  int ans = 0;
  for ( int i = minvalue;
  i <= maxvalue;
  i ++ ) {
    if ( mark [ i ] ) {
      for ( int j = i + i;
      j <= maxvalue && j / i <= i;
      j += i ) {
        if ( ! mark [ j ] ) continue;
        value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] );
        if ( i != j / i ) value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] );
      }
    }
    ans += value [ i ];
  }
  return ans;
}


TRIANGULAR_MATCHSTICK_NUMBER | int numberOfSticks ( int x ) {
  return ( 3 * x * ( x + 1 ) ) / 2;
}


K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS | void KMaxCombinations ( int A [ ], int B [ ], int N, int K ) {
  priority_queue < int > pq;
  for ( int i = 0;
  i < N;
  i ++ ) for ( int j = 0;
  j < N;
  j ++ ) pq . push ( A [ i ] + B [ j ] );
  int count = 0;
  while ( count < K ) {
    cout << pq . top ( ) << endl;
    pq . pop ( );
    count ++;
  }
}


CONSTRUCT_ARRAY_PAIR_SUM_ARRAY | void constructArr ( int arr [ ], int pair [ ], int n ) {
  arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2;
  for ( int i = 1;
  i < n;
  i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ];
}


CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER | bool checkCorrectOrNot ( string s ) {
  int count1 [ MAX_CHAR ] = {
    0 };
    int count2 [ MAX_CHAR ] = {
      0 };
      int n = s . length ( );
      if ( n == 1 ) return true;
      for ( int i = 0, j = n - 1;
      i < j;
      i ++, j -- ) {
        count1 [ s [ i ] - 'a' ] ++;
        count2 [ s [ j ] - 'a' ] ++;
      }
      for ( int i = 0;
      i < MAX_CHAR;
      i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false;
      return true;
    }
    

MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS | int getMinDiff ( int arr [ ], int n, int k ) {
  if ( n == 1 ) return 0;
  sort ( arr, arr + n );
  int ans = arr [ n - 1 ] - arr [ 0 ];
  int small = arr [ 0 ] + k;
  int big = arr [ n - 1 ] - k;
  if ( small > big ) swap ( small, big );
  for ( int i = 1;
  i < n - 1;
  i ++ ) {
    int subtract = arr [ i ] - k;
    int add = arr [ i ] + k;
    if ( subtract >= small || add <= big ) continue;
    if ( big - subtract <= add - small ) small = subtract;
    else big = add;
  }
  return min ( ans, big - small );
}


MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K | void pairs ( int arr [ ], int n, int k ) {
  int smallest = INT_MAX;
  int count = 0;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) {
    if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) {
      smallest = abs ( arr [ i ] + arr [ j ] - k );
      count = 1;
    }
    else if ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++;
  }
  cout << "Minimal Value = " << smallest << "\n";
  cout << "Total Pairs = " << count << "\n";
}


SIZE_SUBARRAY_MAXIMUM_SUM | int maxSubArraySum ( int a [ ], int size ) {
  int max_so_far = INT_MIN, max_ending_here = 0, start = 0, end = 0, s = 0;
  for ( int i = 0;
  i < size;
  i ++ ) {
    max_ending_here += a [ i ];
    if ( max_so_far < max_ending_here ) {
      max_so_far = max_ending_here;
      start = s;
      end = i;
    }
    if ( max_ending_here < 0 ) {
      max_ending_here = 0;
      s = i + 1;
    }
  }
  return ( end - start + 1 );
}


MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1 | int getMinSquares ( int n ) {
  int * dp = new int [ n + 1 ];
  dp [ 0 ] = 0;
  dp [ 1 ] = 1;
  dp [ 2 ] = 2;
  dp [ 3 ] = 3;
  for ( int i = 4;
  i <= n;
  i ++ ) {
    dp [ i ] = i;
    for ( int x = 1;
    x <= ceil ( sqrt ( i ) );
    x ++ ) {
      int temp = x * x;
      if ( temp > i ) break;
      else dp [ i ] = min ( dp [ i ], 1 + dp [ i - temp ] );
    }
  }
  int res = dp [ n ];
  delete [ ] dp;
  return res;
}


DIVISIBILITY_BY_7 | int isDivisibleBy7 ( int num ) {
  if ( num < 0 ) return isDivisibleBy7 ( - num );
  if ( num == 0 || num == 7 ) return 1;
  if ( num < 10 ) return 0;
  return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) );
}


POSITION_OF_RIGHTMOST_SET_BIT_2 | int Right_most_setbit ( int num ) {
  int pos = 1;
  for ( int i = 0;
  i < INT_SIZE;
  i ++ ) {
    if ( ! ( num & ( 1 << i ) ) ) pos ++;
    else break;
  }
  return pos;
}


EFFICIENT_WAY_TO_MULTIPLY_WITH_7 | long multiplyBySeven ( long n ) {
  return ( ( n << 3 ) - n );
}


NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS | uint_t snoob ( uint_t x ) {
  uint_t rightOne;
  uint_t nextHigherOneBit;
  uint_t rightOnesPattern;
  uint_t next = 0;
  if ( x ) {
    rightOne = x & - ( signed ) x;
    nextHigherOneBit = x + rightOne;
    rightOnesPattern = x ^ nextHigherOneBit;
    rightOnesPattern = ( rightOnesPattern ) / rightOne;
    rightOnesPattern >>= 2;
    next = nextHigherOneBit | rightOnesPattern;
  }
  return next;
}


CHANGE_ARRAY_PERMUTATION_NUMBERS_1_N | void makePermutation ( int a [ ], int n ) {
  unordered_map < int, int > count;
  for ( int i = 0;
  i < n;
  i ++ ) count [ a [ i ] ] ++;
  int next_missing = 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( count [ a [ i ] ] != 1 || a [ i ] > n || a [ i ] < 1 ) {
      count [ a [ i ] ] --;
      while ( count . find ( next_missing ) != count . end ( ) ) next_missing ++;
      a [ i ] = next_missing;
      count [ next_missing ] = 1;
    }
  }
}


MAXIMUM_AREA_QUADRILATERAL | double maxArea ( double a, double b, double c, double d ) {
  double semiperimeter = ( a + b + c + d ) / 2;
  return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) );
}


REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1 | void translate ( char * str ) {
  int len = strlen ( str );
  if ( len < 2 ) return;
  int i = 0;
  int j = 0;
  while ( j < len - 1 ) {
    if ( str [ j ] == 'A' && str [ j + 1 ] == 'B' ) {
      j = j + 2;
      str [ i ++ ] = 'C';
      continue;
    }
    str [ i ++ ] = str [ j ++ ];
  }
  if ( j == len - 1 ) str [ i ++ ] = str [ j ];
  str [ i ] = '';
}


FIND_POWER_POWER_MOD_PRIME | unsigned int Calculate ( unsigned int A, unsigned int B, unsigned int C, unsigned int M ) {
  unsigned int res, ans;
  res = power ( B, C, M - 1 );
  ans = power ( A, res, M );
  return ans;
}


CHECK_EXIST_TWO_ELEMENTS_ARRAY_WHOSE_SUM_EQUAL_SUM_REST_ARRAY | bool checkPair ( int arr [ ], int n ) {
  int sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) sum += arr [ i ];
  if ( sum % 2 != 0 ) return false;
  sum = sum / 2;
  unordered_set < int > s;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int val = sum - arr [ i ];
    if ( s . find ( val ) != s . end ( ) ) {
      printf ( "Pair elements are %d and %d\n", arr [ i ], val );
      return true;
    }
    s . insert ( arr [ i ] );
  }
  return false;
}


PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON | double surface_area_octahedron ( double side ) {
  return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) );
}


FIND_A_SPECIFIC_PAIR_IN_MATRIX | int findMaxValue ( int mat [ ] [ N ] ) {
  int maxValue = INT_MIN;
  for ( int a = 0;
  a < N - 1;
  a ++ ) for ( int b = 0;
  b < N - 1;
  b ++ ) for ( int d = a + 1;
  d < N;
  d ++ ) for ( int e = b + 1;
  e < N;
  e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ];
  return maxValue;
}


MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_OPERATORS_AND_NO_LOOPS | public : int multiply ( int x, int y ) {
  if ( y == 0 ) return 0;
  if ( y > 0 ) return ( x + multiply ( x, y - 1 ) );
  if ( y < 0 ) return - multiply ( x, - y );
}


FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1 | void findTriplets ( int arr [ ], int n ) {
  bool found = false;
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    unordered_set < int > s;
    for ( int j = i + 1;
    j < n;
    j ++ ) {
      int x = - ( arr [ i ] + arr [ j ] );
      if ( s . find ( x ) != s . end ( ) ) {
        printf ( "%d %d %d\n", x, arr [ i ], arr [ j ] );
        found = true;
      }
      else s . insert ( arr [ j ] );
    }
  }
  if ( found == false ) cout << " No Triplet Found" << endl;
}


FIND_MAXIMUM_VALUE_OF_SUM_IARRI_WITH_ONLY_ROTATIONS_ON_GIVEN_ARRAY_ALLOWED | int maxSum ( int arr [ ], int n ) {
  int arrSum = 0;
  int currVal = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    arrSum = arrSum + arr [ i ];
    currVal = currVal + ( i * arr [ i ] );
  }
  int maxVal = currVal;
  for ( int j = 1;
  j < n;
  j ++ ) {
    currVal = currVal + arrSum - n * arr [ n - j ];
    if ( currVal > maxVal ) maxVal = currVal;
  }
  return maxVal;
}


PROGRAM_FOR_SCALAR_MULTIPLICATION_OF_A_MATRIX | void scalarProductMat ( int mat [ ] [ N ], int k ) {
  for ( int i = 0;
  i < N;
  i ++ ) for ( int j = 0;
  j < N;
  j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] * k;
}


PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1 | void printSquares ( int n ) {
  int square = 0, odd = 1;
  for ( int x = 0;
  x < n;
  x ++ ) {
    cout << square << " ";
    square = square + odd;
    odd = odd + 2;
  }
}


NTH_PENTAGONAL_NUMBER | int pentagonalNum ( int n ) {
  return ( 3 * n * n - n ) / 2;
}


COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER | int numofArray ( int n, int m ) {
  int dp [ MAX ] [ MAX ];
  vector < int > di [ MAX ];
  vector < int > mu [ MAX ];
  memset ( dp, 0, sizeof dp );
  memset ( di, 0, sizeof di );
  memset ( mu, 0, sizeof mu );
  for ( int i = 1;
  i <= m;
  i ++ ) {
    for ( int j = 2 * i;
    j <= m;
    j += i ) {
      di [ j ] . push_back ( i );
      mu [ i ] . push_back ( j );
    }
    di [ i ] . push_back ( i );
  }
  for ( int i = 1;
  i <= m;
  i ++ ) dp [ 1 ] [ i ] = 1;
  for ( int i = 2;
  i <= n;
  i ++ ) {
    for ( int j = 1;
    j <= m;
    j ++ ) {
      dp [ i ] [ j ] = 0;
      for ( auto x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ];
      for ( auto x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ];
    }
  }
  int ans = 0;
  for ( int i = 1;
  i <= m;
  i ++ ) {
    ans += dp [ n ] [ i ];
    di [ i ] . clear ( );
    mu [ i ] . clear ( );
  }
  return ans;
}


0_1_KNAPSACK_PROBLEM_DP_10 | int knapSack ( int W, int wt [ ], int val [ ], int n ) {
  if ( n == 0 || W == 0 ) return 0;
  if ( wt [ n - 1 ] > W ) return knapSack ( W, wt, val, n - 1 );
  else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ], wt, val, n - 1 ), knapSack ( W, wt, val, n - 1 ) );
}


FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO | void findTriplets ( int arr [ ], int n ) {
  bool found = true;
  for ( int i = 0;
  i < n - 2;
  i ++ ) {
    for ( int j = i + 1;
    j < n - 1;
    j ++ ) {
      for ( int k = j + 1;
      k < n;
      k ++ ) {
        if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) {
          cout << arr [ i ] << " " << arr [ j ] << " " << arr [ k ] << endl;
          found = true;
        }
      }
    }
  }
  if ( found == false ) cout << " not exist " << endl;
}


COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME | int count ( int n ) {
  int table [ n + 1 ], i;
  for ( int j = 0;
  j < n + 1;
  j ++ ) table [ j ] = 0;
  table [ 0 ] = 1;
  for ( i = 3;
  i <= n;
  i ++ ) table [ i ] += table [ i - 3 ];
  for ( i = 5;
  i <= n;
  i ++ ) table [ i ] += table [ i - 5 ];
  for ( i = 10;
  i <= n;
  i ++ ) table [ i ] += table [ i - 10 ];
  return table [ n ];
}


MAXIMUM_SUM_ABSOLUTE_DIFFERENCE_ARRAY | int MaxSumDifference ( int a [ ], int n ) {
  vector < int > finalSequence;
  sort ( a, a + n );
  for ( int i = 0;
  i < n / 2;
  ++ i ) {
    finalSequence . push_back ( a [ i ] );
    finalSequence . push_back ( a [ n - i - 1 ] );
  }
  int MaximumSum = 0;
  for ( int i = 0;
  i < n - 1;
  ++ i ) {
    MaximumSum = MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] );
  }
  MaximumSum = MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] );
  return MaximumSum;
}


PROGRAM_FIND_MID_POINT_LINE | void midpoint ( int x1, int x2, int y1, int y2 ) {
  cout << ( float ) ( x1 + x2 ) / 2 << " , " << ( float ) ( y1 + y2 ) / 2;
}


ALTERNATIVE_SORTING | void alternateSort ( int arr [ ], int n ) {
  sort ( arr, arr + n );
  int i = 0, j = n - 1;
  while ( i < j ) {
    cout << arr [ j -- ] << " ";
    cout << arr [ i ++ ] << " ";
  }
  if ( n % 2 != 0 ) cout << arr [ i ];
}


NUMBER_SUBARRAYS_SUM_EXACTLY_EQUAL_K | int findSubarraySum ( int arr [ ], int n, int sum ) {
  unordered_map < int, int > prevSum;
  int res = 0;
  int currsum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    currsum += arr [ i ];
    if ( currsum == sum ) res ++;
    if ( prevSum . find ( currsum - sum ) != prevSum . end ( ) ) res += ( prevSum [ currsum - sum ] );
    prevSum [ currsum ] ++;
  }
  return res;
}


FIND_THE_ELEMENT_THAT_APPEARS_ONCE_IN_A_SORTED_ARRAY | void search ( int * arr, int low, int high ) {
  if ( low > high ) return;
  if ( low == high ) {
    printf ( "The required element is %d ", arr [ low ] );
    return;
  }
  int mid = ( low + high ) / 2;
  if ( mid % 2 == 0 ) {
    if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr, mid + 2, high );
    else search ( arr, low, mid );
  }
  else {
    if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr, mid + 1, high );
    else search ( arr, low, mid - 1 );
  }
}


FORM_SMALLEST_NUMBER_USING_ONE_SWAP_OPERATION | string smallestNumber ( string num ) {
  int n = num . size ( );
  int rightMin [ n ], right;
  rightMin [ n - 1 ] = - 1;
  right = n - 1;
  for ( int i = n - 2;
  i >= 1;
  i -- ) {
    if ( num [ i ] >= num [ right ] ) rightMin [ i ] = right;
    else {
      if ( num [ i ] == num [ i + 1 ] ) {
        rightMin [ i ] = right;
      }
      else {
        rightMin [ i ] = - 1;
        right = i;
      }
    }
  }
  int small = - 1;
  for ( int i = 1;
  i < n;
  i ++ ) if ( num [ i ] != '0' ) {
    if ( small == - 1 ) {
      if ( num [ i ] < num [ 0 ] ) small = i;
    }
    else if ( num [ i ] <= num [ small ] ) small = i;
  }
  if ( small != - 1 ) swap ( num [ 0 ], num [ small ] );
  else {
    for ( int i = 1;
    i < n;
    i ++ ) {
      if ( rightMin [ i ] != - 1 && num [ i ] != num [ rightMin [ i ] ] ) {
        swap ( num [ i ], num [ rightMin [ i ] ] );
        break;
      }
    }
  }
  return num;
}


PROGRAM_AREA_SQUARE | int areaSquare ( int side ) {
  int area = side * side;
  return area;
}


FIND_DAY_OF_THE_WEEK_FOR_A_GIVEN_DATE | int dayofweek ( int d, int m, int y ) {
  static int t [ ] = {
    0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };
    y -= m < 3;
    return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7;
  }
  

CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK | bool checkSorted ( int n, queue < int > & q ) {
  stack < int > st;
  int expected = 1;
  int fnt;
  while ( ! q . empty ( ) ) {
    fnt = q . front ( );
    q . pop ( );
    if ( fnt == expected ) expected ++;
    else {
      if ( st . empty ( ) ) {
        st . push ( fnt );
      }
      else if ( ! st . empty ( ) && st . top ( ) < fnt ) {
        return false;
      }
      else st . push ( fnt );
    }
    while ( ! st . empty ( ) && st . top ( ) == expected ) {
      st . pop ( );
      expected ++;
    }
  }
  if ( expected - 1 == n && st . empty ( ) ) return true;
  return false;
}


SORT_ARRAY_CONTAIN_1_N_VALUES | void sortit ( int arr [ ], int n ) {
  for ( int i = 0;
  i < n;
  i ++ ) {
    arr [ i ] = i + 1;
  }
}


LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1 | int lcsOf3 ( int i, int j, int k ) {
  if ( i == - 1 || j == - 1 || k == - 1 ) return 0;
  if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ];
  if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1, j - 1, k - 1 );
  else return dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1, j, k ), lcsOf3 ( i, j - 1, k ) ), lcsOf3 ( i, j, k - 1 ) );
}


LOWER_INSERTION_POINT | int LowerInsertionPoint ( int arr [ ], int n, int X ) {
  if ( X < arr [ 0 ] ) return 0;
  else if ( X > arr [ n - 1 ] ) return n;
  int lowerPnt = 0;
  int i = 1;
  while ( i < n && arr [ i ] < X ) {
    lowerPnt = i;
    i = i * 2;
  }
  while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++;
  return lowerPnt;
}


CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME | string constructPalin ( string str, int len ) {
  int i = 0, j = len - 1;
  for (;
  i < j;
  i ++, j -- ) {
    if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continue;
    else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) {
      str [ i ] = 'a';
      str [ j ] = 'a';
      continue;
    }
    else if ( str [ i ] == '*' ) {
      str [ i ] = str [ j ];
      continue;
    }
    else if ( str [ j ] == '*' ) {
      str [ j ] = str [ i ];
      continue;
    }
    cout << "Not Possible";
    return "";
  }
  return str;
}


SECTION_FORMULA_POINT_DIVIDES_LINE_GIVEN_RATIO | void section ( double x1, double x2, double y1, double y2, double m, double n ) {
  double x = ( ( n * x1 ) + ( m * x2 ) ) / ( m + n );
  double y = ( ( n * y1 ) + ( m * y2 ) ) / ( m + n );
  cout << "(" << x << ", ";
  cout << y << ")" << endl;
}


SQUARE_ROOT_NUMBER_USING_LOG | double squareRoot ( double n ) {
  return pow ( 2, 0.5 * log2 ( n ) );
}


MAXIMIZE_SUM_ARRII | int maxSum ( int arr [ ], int n ) {
  sort ( arr, arr + n );
  int sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) sum += ( arr [ i ] * i );
  return sum;
}


STRING_K_DISTINCT_CHARACTERS_NO_CHARACTERS_ADJACENT | string findString ( int n, int k ) {
  string res = "";
  for ( int i = 0;
  i < k;
  i ++ ) res = res + ( char ) ( 'a' + i );
  int count = 0;
  for ( int i = 0;
  i < n - k;
  i ++ ) {
    res = res + ( char ) ( 'a' + count );
    count ++;
    if ( count == k ) count = 0;
  }
  return res;
}


COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD | int countWords ( char str [ ], int len ) {
  int count = 1;
  if ( len == 1 ) return count;
  if ( str [ 0 ] == str [ 1 ] ) count *= 1;
  else count *= 2;
  for ( int j = 1;
  j < len - 1;
  j ++ ) {
    if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1;
    else if ( str [ j ] == str [ j - 1 ] || str [ j ] == str [ j + 1 ] || str [ j - 1 ] == str [ j + 1 ] ) count *= 2;
    else count *= 3;
  }
  if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1;
  else count *= 2;
  return count;
}


NUMBER_JUMP_REQUIRED_GIVEN_LENGTH_REACH_POINT_FORM_D_0_ORIGIN_2D_PLANE | int minJumps ( int a, int b, int d ) {
  int temp = a;
  a = min ( a, b );
  b = max ( temp, b );
  if ( d >= b ) return ( d + b - 1 ) / b;
  if ( d == 0 ) return 0;
  if ( d == a ) return 1;
  return 2;
}


SUM_FACTORS_NUMBER_1 | int sumofFactors ( int n ) {
  int res = 1;
  for ( int i = 2;
  i <= sqrt ( n );
  i ++ ) {
    int curr_sum = 1;
    int curr_term = 1;
    while ( n % i == 0 ) {
      n = n / i;
      curr_term *= i;
      curr_sum += curr_term;
    }
    res *= curr_sum;
  }
  if ( n >= 2 ) res *= ( 1 + n );
  return res;
}


DELETE_CONSECUTIVE_WORDS_SEQUENCE | int removeConsecutiveSame ( vector < string > v ) {
  int n = v . size ( );
  for ( int i = 0;
  i < n - 1;
  ) {
    if ( v [ i ] . compare ( v [ i + 1 ] ) == 0 ) {
      v . erase ( v . begin ( ) + i );
      v . erase ( v . begin ( ) + i );
      if ( i > 0 ) i --;
      n = n - 2;
    }
    else i ++;
  }
  return v . size ( );
}


COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S | int countStrings ( int n ) {
  int a [ n ], b [ n ];
  a [ 0 ] = b [ 0 ] = 1;
  for ( int i = 1;
  i < n;
  i ++ ) {
    a [ i ] = a [ i - 1 ] + b [ i - 1 ];
    b [ i ] = a [ i - 1 ];
  }
  return a [ n - 1 ] + b [ n - 1 ];
}


FIND_THE_MISSING_NUMBER | int getMissingNo ( int a [ ], int n ) {
  int total = ( n + 1 ) * ( n + 2 ) / 2;
  for ( int i = 0;
  i < n;
  i ++ ) total -= a [ i ];
  return total;
}


SQUARE_ROOT_OF_A_PERFECT_SQUARE | public : float squareRoot ( float n ) {
  float x = n;
  float y = 1;
  float e = 0.000001;
  while ( x - y > e ) {
    x = ( x + y ) / 2;
    y = n / x;
  }
  return x;
}


SUBSET_SUM_PROBLEM_OSUM_SPACE | bool isSubsetSum ( int arr [ ], int n, int sum ) {
  bool subset [ 2 ] [ sum + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) {
    for ( int j = 0;
    j <= sum;
    j ++ ) {
      if ( j == 0 ) subset [ i % 2 ] [ j ] = true;
      else if ( i == 0 ) subset [ i % 2 ] [ j ] = false;
      else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ];
      else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ];
    }
  }
  return subset [ n % 2 ] [ sum ];
}


MULTIPLICATIVE_INVERSE_UNDER_MODULO_M | int modInverse ( int a, int m ) {
  a = a % m;
  for ( int x = 1;
  x < m;
  x ++ ) if ( ( a * x ) % m == 1 ) return x;
}


COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW | int compute_average ( int a, int b ) {
  return ( a + b ) / 2;
}


REPRESENT_GIVEN_SET_POINTS_BEST_POSSIBLE_STRAIGHT_LINE | void bestApproximate ( int x [ ], int y [ ], int n ) {
  float m, c, sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    sum_x += x [ i ];
    sum_y += y [ i ];
    sum_xy += x [ i ] * y [ i ];
    sum_x2 += pow ( x [ i ], 2 );
  }
  m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x, 2 ) );
  c = ( sum_y - m * sum_x ) / n;
  cout << "m =" << m;
  cout << "\nc =" << c;
}


SPLIT_ARRAY_ADD_FIRST_PART_END | void splitArr ( int arr [ ], int n, int k ) {
  for ( int i = 0;
  i < k;
  i ++ ) {
    int x = arr [ 0 ];
    for ( int j = 0;
    j < n - 1;
    ++ j ) arr [ j ] = arr [ j + 1 ];
    arr [ n - 1 ] = x;
  }
}


MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY | int maxDiff ( int arr [ ], int n ) {
  int SubsetSum_1 = 0, SubsetSum_2 = 0;
  for ( int i = 0;
  i <= n - 1;
  i ++ ) {
    bool isSingleOccurance = true;
    for ( int j = i + 1;
    j <= n - 1;
    j ++ ) {
      if ( arr [ i ] == arr [ j ] ) {
        isSingleOccurance = false;
        arr [ i ] = arr [ j ] = 0;
        break;
      }
    }
    if ( isSingleOccurance ) {
      if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ];
      else SubsetSum_2 += arr [ i ];
    }
  }
  return abs ( SubsetSum_1 - SubsetSum_2 );
}


LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2 | int longLenSub ( int arr [ ], int n ) {
  unordered_map < int, int > um;
  int longLen = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int len = 0;
    if ( um . find ( arr [ i ] - 1 ) != um . end ( ) && len < um [ arr [ i ] - 1 ] ) len = um [ arr [ i ] - 1 ];
    if ( um . find ( arr [ i ] + 1 ) != um . end ( ) && len < um [ arr [ i ] + 1 ] ) len = um [ arr [ i ] + 1 ];
    um [ arr [ i ] ] = len + 1;
    if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i ] ];
  }
  return longLen;
}


LONGEST_REPEATED_SUBSEQUENCE_1 | string longestRepeatedSubSeq ( string str ) {
  int n = str . length ( );
  int dp [ n + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) for ( int j = 0;
  j <= n;
  j ++ ) dp [ i ] [ j ] = 0;
  for ( int i = 1;
  i <= n;
  i ++ ) for ( int j = 1;
  j <= n;
  j ++ ) if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ];
  else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ] );
  string res = "";
  int i = n, j = n;
  while ( i > 0 && j > 0 ) {
    if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) {
      res = res + str [ i - 1 ];
      i --;
      j --;
    }
    else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i --;
    else j --;
  }
  reverse ( res . begin ( ), res . end ( ) );
  return res;
}


FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY | void findRandomIndexOfMax ( int arr [ ], int n ) {
  unordered_map < int, int > freq;
  for ( int i = 0;
  i < n;
  i ++ ) freq [ arr [ i ] ] += 1;
  int max_element;
  int max_so_far = INT_MIN;
  for ( pair < int, int > p : freq ) {
    if ( p . second > max_so_far ) {
      max_so_far = p . second;
      max_element = p . first;
    }
  }
  int r = ( rand ( ) % max_so_far ) + 1;
  for ( int i = 0, count = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] == max_element ) count ++;
    if ( count == r ) {
      cout << "Element with maximum frequency present " "at index " << i << endl;
      break;
    }
  }
}


CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION | bool isPerfectSquare ( int n ) {
  for ( int sum = 0, i = 1;
  sum < n;
  i += 2 ) {
    sum += i;
    if ( sum == n ) return true;
  }
  return false;
}


N_BONACCI_NUMBERS_1 | void bonacciseries ( long n, int m ) {
  int a [ m ] = {
    0 };
    a [ n - 1 ] = 1;
    a [ n ] = 1;
    for ( int i = n + 1;
    i < m;
    i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ];
    for ( int i = 0;
    i < m;
    i ++ ) cout << a [ i ] << " ";
  }
  

COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1 | int countPairs ( int arr [ ], int n ) {
  unordered_map < int, int > mp;
  for ( int i = 0;
  i < n;
  i ++ ) mp [ arr [ i ] ] ++;
  int ans = 0;
  for ( auto it = mp . begin ( );
  it != mp . end ( );
  it ++ ) {
    int count = it -> second;
    ans += ( count * ( count - 1 ) ) / 2;
  }
  return ans;
}


SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER | void bitonicGenerator ( int arr [ ], int n ) {
  vector < int > evenArr;
  vector < int > oddArr;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( ! ( i % 2 ) ) evenArr . push_back ( arr [ i ] );
    else oddArr . push_back ( arr [ i ] );
  }
  sort ( evenArr . begin ( ), evenArr . end ( ) );
  sort ( oddArr . begin ( ), oddArr . end ( ), greater < int > ( ) );
  int i = 0;
  for ( int j = 0;
  j < evenArr . size ( );
  j ++ ) arr [ i ++ ] = evenArr [ j ];
  for ( int j = 0;
  j < oddArr . size ( );
  j ++ ) arr [ i ++ ] = oddArr [ j ];
}


DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT | int binomialCoeff ( int n, int k ) {
  if ( k == 0 || k == n ) return 1;
  return binomialCoeff ( n - 1, k - 1 ) + binomialCoeff ( n - 1, k );
}


WRITE_A_C_PROGRAM_TO_FIND_THE_PARITY_OF_AN_UNSIGNED_INTEGER | bool getParity ( unsigned int n ) {
  bool parity = 0;
  while ( n ) {
    parity = ! parity;
    n = n & ( n - 1 );
  }
  return parity;
}


CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7 | int isdivisible7 ( char num [ ] ) {
  int n = strlen ( num ), gSum;
  if ( n == 0 && num [ 0 ] == '\n' ) return 1;
  if ( n % 3 == 1 ) {
    strcat ( num, "00" );
    n += 2;
  }
  else if ( n % 3 == 2 ) {
    strcat ( num, "0" );
    n ++;
  }
  int i, GSum = 0, p = 1;
  for ( i = n - 1;
  i >= 0;
  i -- ) {
    int group = 0;
    group += num [ i -- ] - '0';
    group += ( num [ i -- ] - '0' ) * 10;
    group += ( num [ i ] - '0' ) * 100;
    gSum = gSum + group * p;
    p *= ( - 1 );
  }
  return ( gSum % 7 == 0 );
}


PRODUCT_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING | int productAtKthLevel ( string tree, int k ) {
  int level = - 1;
  int product = 1;
  int n = tree . length ( );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( tree [ i ] == '(' ) level ++;
    else if ( tree [ i ] == ')' ) level --;
    else {
      if ( level == k ) product *= ( tree [ i ] - '0' );
    }
  }
  return product;
}


CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD | bool isEven ( int n ) {
  return ( n % 2 == 0 );
}


COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS_IMMEDIATE_RIGHT_SUB_GROUP | int countGroups ( int position, int previous_sum, int length, char * num ) {
  if ( position == length ) return 1;
  int res = 0;
  int sum = 0;
  for ( int i = position;
  i < length;
  i ++ ) {
    sum += ( num [ i ] - '0' );
    if ( sum >= previous_sum ) res += countGroups ( i + 1, sum, length, num );
  }
  return res;
}


FIND_THE_ELEMENT_THAT_ODD_NUMBER_OF_TIMES_IN_OLOG_N_TIME | void search ( int * arr, int low, int high ) {
  if ( low > high ) return;
  if ( low == high ) {
    printf ( "The required element is %d ", arr [ low ] );
    return;
  }
  int mid = ( low + high ) / 2;
  if ( mid % 2 == 0 ) {
    if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr, mid + 2, high );
    else search ( arr, low, mid );
  }
  else {
    if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr, mid + 1, high );
    else search ( arr, low, mid - 1 );
  }
}


DELETE_CONSECUTIVE_WORDS_SEQUENCE_1 | int removeConsecutiveSame ( vector < string > v ) {
  stack < string > st;
  for ( int i = 0;
  i < v . size ( );
  i ++ ) {
    if ( st . empty ( ) ) st . push ( v [ i ] );
    else {
      string str = st . top ( );
      if ( str . compare ( v [ i ] ) == 0 ) st . pop ( );
      else st . push ( v [ i ] );
    }
  }
  return st . size ( );
}


MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2 | int minJumps ( int arr [ ], int n ) {
  int * jumps = new int [ n ];
  int min;
  jumps [ n - 1 ] = 0;
  for ( int i = n - 2;
  i >= 0;
  i -- ) {
    if ( arr [ i ] == 0 ) jumps [ i ] = INT_MAX;
    else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1;
    else {
      min = INT_MAX;
      for ( int j = i + 1;
      j < n && j <= arr [ i ] + i;
      j ++ ) {
        if ( min > jumps [ j ] ) min = jumps [ j ];
      }
      if ( min != INT_MAX ) jumps [ i ] = min + 1;
      else jumps [ i ] = min;
    }
  }
  return jumps [ 0 ];
}


PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS | double gcd ( double a, double b ) {
  if ( a < b ) return gcd ( b, a );
  if ( fabs ( b ) < 0.001 ) return a;
  else return ( gcd ( b, a - floor ( a / b ) * b ) );
}


MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE | int maxProfit ( int price [ ], int n ) {
  int * profit = new int [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) profit [ i ] = 0;
  int max_price = price [ n - 1 ];
  for ( int i = n - 2;
  i >= 0;
  i -- ) {
    if ( price [ i ] > max_price ) max_price = price [ i ];
    profit [ i ] = max ( profit [ i + 1 ], max_price - price [ i ] );
  }
  int min_price = price [ 0 ];
  for ( int i = 1;
  i < n;
  i ++ ) {
    if ( price [ i ] < min_price ) min_price = price [ i ];
    profit [ i ] = max ( profit [ i - 1 ], profit [ i ] + ( price [ i ] - min_price ) );
  }
  int result = profit [ n - 1 ];
  delete [ ] profit;
  return result;
}


COUNT_SET_BITS_IN_AN_INTEGER_1 | int countSetBits ( int n ) {
  if ( n == 0 ) return 0;
  else return ( n & 1 ) + countSetBits ( n >> 1 );
}


REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES | void reorder ( int arr [ ], int index [ ], int n ) {
  int temp [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) temp [ index [ i ] ] = arr [ i ];
  for ( int i = 0;
  i < n;
  i ++ ) {
    arr [ i ] = temp [ i ];
    index [ i ] = i;
  }
}


CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BINARY_SEARCH_TREE | bool canRepresentBST ( int pre [ ], int n ) {
  stack < int > s;
  int root = INT_MIN;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( pre [ i ] < root ) return false;
    while ( ! s . empty ( ) && s . top ( ) < pre [ i ] ) {
      root = s . top ( );
      s . pop ( );
    }
    s . push ( pre [ i ] );
  }
  return true;
}


FIND_REPETITIVE_ELEMENT_1_N_1_3 | int findRepeating ( int arr [ ], int n ) {
  int missingElement = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int element = arr [ abs ( arr [ i ] ) ];
    if ( element < 0 ) {
      missingElement = arr [ i ];
      break;
    }
    arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ];
  }
  return abs ( missingElement );
}


DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION_1 | int MatrixChainOrder ( int p [ ], int n ) {
  int m [ n ] [ n ];
  int i, j, k, L, q;
  for ( i = 1;
  i < n;
  i ++ ) m [ i ] [ i ] = 0;
  for ( L = 2;
  L < n;
  L ++ ) {
    for ( i = 1;
    i < n - L + 1;
    i ++ ) {
      j = i + L - 1;
      m [ i ] [ j ] = INT_MAX;
      for ( k = i;
      k <= j - 1;
      k ++ ) {
        q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ];
        if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q;
      }
    }
  }
  return m [ 1 ] [ n - 1 ];
}


COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE | int countIslands ( int mat [ ] [ N ] ) {
  int count = 0;
  for ( int i = 0;
  i < M;
  i ++ ) {
    for ( int j = 0;
    j < N;
    j ++ ) {
      if ( mat [ i ] [ j ] == 'X' ) {
        if ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && ( j == 0 || mat [ i ] [ j - 1 ] == 'O' ) ) count ++;
      }
    }
  }
  return count;
}


MINIMIZE_MAXAI_BJ_CK_MINAI_BJ_CK_THREE_DIFFERENT_SORTED_ARRAYS | int solve ( int A [ ], int B [ ], int C [ ], int i, int j, int k ) {
  int min_diff, current_diff, max_term;
  min_diff = abs ( max ( A [ i ], max ( B [ j ], C [ k ] ) ) - min ( A [ i ], min ( B [ j ], C [ k ] ) ) );
  while ( i != - 1 && j != - 1 && k != - 1 ) {
    current_diff = abs ( max ( A [ i ], max ( B [ j ], C [ k ] ) ) - min ( A [ i ], min ( B [ j ], C [ k ] ) ) );
    if ( current_diff < min_diff ) min_diff = current_diff;
    max_term = max ( A [ i ], max ( B [ j ], C [ k ] ) );
    if ( A [ i ] == max_term ) i -= 1;
    else if ( B [ j ] == max_term ) j -= 1;
    else k -= 1;
  }
  return min_diff;
}


ROOTS_QUADRATIC_EQUATION | void findRoots ( int a, int b, int c ) {
  if ( a == 0 ) {
    cout << "Invalid";
    return;
  }
  int d = b * b - 4 * a * c;
  double sqrt_val = sqrt ( abs ( d ) );
  if ( d > 0 ) {
    cout << "Roots are real and different \n";
    cout << ( double ) ( - b + sqrt_val ) / ( 2 * a ) << "\n" << ( double ) ( - b - sqrt_val ) / ( 2 * a );
  }
  else if ( d == 0 ) {
    cout << "Roots are real and same \n";
    cout << - ( double ) b / ( 2 * a );
  }
  else {
    cout << "Roots are complex \n";
    cout << - ( double ) b / ( 2 * a ) << " + i" << sqrt_val << "\n" << - ( double ) b / ( 2 * a ) << " - i" << sqrt_val;
  }
}


GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP | bool isMinHeap ( int level [ ], int n ) {
  for ( int i = ( n / 2 - 1 );
  i >= 0;
  i -- ) {
    if ( level [ i ] > level [ 2 * i + 1 ] ) return false;
    if ( 2 * i + 2 < n ) {
      if ( level [ i ] > level [ 2 * i + 2 ] ) return false;
    }
  }
  return true;
}


FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY | int findMin ( int arr [ ], int low, int high ) {
  if ( high < low ) return arr [ 0 ];
  if ( high == low ) return arr [ low ];
  int mid = low + ( high - low ) / 2;
  if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ];
  if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ];
  if ( arr [ high ] > arr [ mid ] ) return findMin ( arr, low, mid - 1 );
  return findMin ( arr, mid + 1, high );
}


SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTINCT_ADJACENT | int stringReduction ( string str ) {
  int n = str . length ( );
  int count [ 3 ] = {
    0 };
    for ( int i = 0;
    i < n;
    ++ i ) count [ str [ i ] - 'a' ] ++;
    if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) return n;
    if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) return 2;
    return 1;
  }
  

CHECK_LARGE_NUMBER_DIVISIBLE_3_NOT | int check ( string str ) {
  int n = str . length ( );
  int digitSum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) digitSum += ( str [ i ] - '0' );
  return ( digitSum % 3 == 0 );
}


COMPUTE_N_UNDER_MODULO_P | int modFact ( int n, int p ) {
  if ( n >= p ) return 0;
  int result = 1;
  for ( int i = 1;
  i <= n;
  i ++ ) result = ( result * i ) % p;
  return result;
}


POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS | bool isPresent ( string s, string q ) {
  int freq [ MAX_CHAR ] = {
    0 };
    for ( int i = 0;
    i < s . length ( );
    i ++ ) freq [ s [ i ] ] ++;
    for ( int i = 0;
    i < q . length ( );
    i ++ ) {
      freq [ q [ i ] ] --;
      if ( freq [ q [ i ] ] < 0 ) return false;
    }
    return true;
  }
  

NEXT_POWER_OF_2_1 | unsigned int nextPowerOf2 ( unsigned int n ) {
  unsigned int p = 1;
  if ( n && ! ( n & ( n - 1 ) ) ) return n;
  while ( p < n ) p <<= 1;
  return p;
}


REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1 | void reorder ( int arr [ ], int index [ ], int n ) {
  for ( int i = 0;
  i < n;
  i ++ ) {
    while ( index [ i ] != i ) {
      int oldTargetI = index [ index [ i ] ];
      char oldTargetE = arr [ index [ i ] ];
      arr [ index [ i ] ] = arr [ i ];
      index [ index [ i ] ] = index [ i ];
      index [ i ] = oldTargetI;
      arr [ i ] = oldTargetE;
    }
  }
}


UNBOUNDED_KNAPSACK_REPETITION_ITEMS_ALLOWED | int unboundedKnapsack ( int W, int n, int val [ ], int wt [ ] ) {
  int dp [ W + 1 ];
  memset ( dp, 0, sizeof dp );
  int ans = 0;
  for ( int i = 0;
  i <= W;
  i ++ ) for ( int j = 0;
  j < n;
  j ++ ) if ( wt [ j ] <= i ) dp [ i ] = max ( dp [ i ], dp [ i - wt [ j ] ] + val [ j ] );
  return dp [ W ];
}


PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX | bool isDiagonalMatrix ( int mat [ N ] [ N ] ) {
  for ( int i = 0;
  i < N;
  i ++ ) for ( int j = 0;
  j < N;
  j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false;
  return true;
}


MAXIMUM_REMOVAL_FROM_ARRAY_WHEN_REMOVAL_TIME_WAITING_TIME | int maxRemoval ( int arr [ ], int n ) {
  int count = 0;
  int cummulative_sum = 0;
  sort ( arr, arr + n );
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] >= cummulative_sum ) {
      count ++;
      cummulative_sum += arr [ i ];
    }
  }
  return count;
}


PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE | string censor ( string text, string word ) {
  vector < string > word_list;
  boost :: split ( word_list, text, boost :: is_any_of ( "\\ +" ) );
  string result = "";
  string stars = "";
  for ( int i = 0;
  i < word . size ( );
  i ++ ) stars += '*';
  int index = 0;
  for ( string i : word_list ) {
    if ( i . compare ( word ) == 0 ) {
      word_list [ index ] = stars;
    }
    index ++;
  }
  for ( string i : word_list ) {
    result += i + ' ';
  }
  return result;
}


COUNT_STRINGS_WITH_CONSECUTIVE_1S | int countStrings ( int n ) {
  int a [ n ], b [ n ];
  a [ 0 ] = b [ 0 ] = 1;
  for ( int i = 1;
  i < n;
  i ++ ) {
    a [ i ] = a [ i - 1 ] + b [ i - 1 ];
    b [ i ] = a [ i - 1 ];
  }
  return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ];
}


LENGTH_LONGEST_BALANCED_SUBSEQUENCE | int maxLength ( char s [ ], int n ) {
  int dp [ n ] [ n ];
  memset ( dp, 0, sizeof ( dp ) );
  for ( int i = 0;
  i < n - 1;
  i ++ ) if ( s [ i ] == '(' && s [ i + 1 ] == ')' ) dp [ i ] [ i + 1 ] = 2;
  for ( int l = 2;
  l < n;
  l ++ ) {
    for ( int i = 0, j = l;
    j < n;
    i ++, j ++ ) {
      if ( s [ i ] == '(' && s [ j ] == ')' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ];
      for ( int k = i;
      k < j;
      k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ], dp [ i ] [ k ] + dp [ k + 1 ] [ j ] );
    }
  }
  return dp [ 0 ] [ n - 1 ];
}


FIND_THE_POINT_WHERE_MAXIMUM_INTERVALS_OVERLAP | void findMaxGuests ( int arrl [ ], int exit [ ], int n ) {
  sort ( arrl, arrl + n );
  sort ( exit, exit + n );
  int guests_in = 1, max_guests = 1, time = arrl [ 0 ];
  int i = 1, j = 0;
  while ( i < n && j < n ) {
    if ( arrl [ i ] <= exit [ j ] ) {
      guests_in ++;
      if ( guests_in > max_guests ) {
        max_guests = guests_in;
        time = arrl [ i ];
      }
      i ++;
    }
    else {
      guests_in --;
      j ++;
    }
  }
  cout << "Maximum Number of Guests = " << max_guests << " at time " << time;
}


EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 | bool isMultipleOf10 ( int n ) {
  return ( n % 15 == 0 );
}


MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE | int maxSumPairWithDifferenceLessThanK ( int arr [ ], int N, int K ) {
  sort ( arr, arr + N );
  int dp [ N ];
  dp [ 0 ] = 0;
  for ( int i = 1;
  i < N;
  i ++ ) {
    dp [ i ] = dp [ i - 1 ];
    if ( arr [ i ] - arr [ i - 1 ] < K ) {
      if ( i >= 2 ) dp [ i ] = max ( dp [ i ], dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] );
      else dp [ i ] = max ( dp [ i ], arr [ i ] + arr [ i - 1 ] );
    }
  }
  return dp [ N - 1 ];
}


FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS | void kSmallestPair ( int arr1 [ ], int n1, int arr2 [ ], int n2, int k ) {
  if ( k > n1 * n2 ) {
    cout << "k pairs don't exist";
    return;
  }
  int index2 [ n1 ];
  memset ( index2, 0, sizeof ( index2 ) );
  while ( k > 0 ) {
    int min_sum = INT_MAX;
    int min_index = 0;
    for ( int i1 = 0;
    i1 < n1;
    i1 ++ ) {
      if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) {
        min_index = i1;
        min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ];
      }
    }
    cout << "(" << arr1 [ min_index ] << ", " << arr2 [ index2 [ min_index ] ] << ") ";
    index2 [ min_index ] ++;
    k --;
  }
}


FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1 | char first ( string str, int i = 0 ) {
  if ( str [ i ] == '\0' ) return 0;
  if ( isupper ( str [ i ] ) ) return str [ i ];
  return first ( str, i + 1 );
}


FIND_PAIRS_B_ARRAY_B_K | bool printPairs ( int arr [ ], int n, int k ) {
  bool isPairFound = true;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( i != j && arr [ i ] % arr [ j ] == k ) {
        cout << "(" << arr [ i ] << ", " << arr [ j ] << ")" << " ";
        isPairFound = true;
      }
    }
  }
  return isPairFound;
}


FIND_ARRANGEMENT_QUEUE_GIVEN_TIME | void solve ( int n, int t, string s ) {
  for ( int i = 0;
  i < t;
  i ++ ) for ( int j = 0;
  j < n - 1;
  j ++ ) if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) {
    char temp = s [ j ];
    s [ j ] = s [ j + 1 ];
    s [ j + 1 ] = temp;
    j ++;
  }
  cout << s;
}


SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS | void printSuperSeq ( string & a, string & b ) {
  int m = a . length ( ), n = b . length ( );
  int dp [ m + 1 ] [ n + 1 ];
  for ( int i = 0;
  i <= m;
  i ++ ) {
    for ( int j = 0;
    j <= n;
    j ++ ) {
      if ( ! i ) dp [ i ] [ j ] = j;
      else if ( ! j ) dp [ i ] [ j ] = i;
      else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ];
      else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] );
    }
  }
  int index = dp [ m ] [ n ];
  string res ( index + 1, '\0' );
  int i = m, j = n;
  while ( i > 0 && j > 0 ) {
    if ( a [ i - 1 ] == b [ j - 1 ] ) {
      res [ index - 1 ] = a [ i - 1 ];
      i --;
      j --;
      index --;
    }
    else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) {
      res [ index - 1 ] = a [ i - 1 ];
      i --;
      index --;
    }
    else {
      res [ index - 1 ] = b [ j - 1 ];
      j --;
      index --;
    }
  }
  while ( i > 0 ) {
    res [ index - 1 ] = a [ i - 1 ];
    i --;
    index --;
  }
  while ( j > 0 ) {
    res [ index - 1 ] = b [ j - 1 ];
    j --;
    index --;
  }
  cout << res;
}


COUNT_ROTATIONS_DIVISIBLE_8 | int countRotationsDivBy8 ( string n ) {
  int len = n . length ( );
  int count = 0;
  if ( len == 1 ) {
    int oneDigit = n [ 0 ] - '0';
    if ( oneDigit % 8 == 0 ) return 1;
    return 0;
  }
  if ( len == 2 ) {
    int first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' );
    int second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' );
    if ( first % 8 == 0 ) count ++;
    if ( second % 8 == 0 ) count ++;
    return count;
  }
  int threeDigit;
  for ( int i = 0;
  i < ( len - 2 );
  i ++ ) {
    threeDigit = ( n [ i ] - '0' ) * 100 + ( n [ i + 1 ] - '0' ) * 10 + ( n [ i + 2 ] - '0' );
    if ( threeDigit % 8 == 0 ) count ++;
  }
  threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' );
  if ( threeDigit % 8 == 0 ) count ++;
  threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ len - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' );
  if ( threeDigit % 8 == 0 ) count ++;
  return count;
}


LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED | int lcs ( int dp [ MAX ] [ MAX ] [ MAX ], int arr1 [ ], int n, int arr2 [ ], int m, int k ) {
  if ( k < 0 ) return - 1e7;
  if ( n < 0 || m < 0 ) return 0;
  int & ans = dp [ n ] [ m ] [ k ];
  if ( ans != - 1 ) return ans;
  ans = max ( lcs ( dp, arr1, n - 1, arr2, m, k ), lcs ( dp, arr1, n, arr2, m - 1, k ) );
  if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = max ( ans, 1 + lcs ( dp, arr1, n - 1, arr2, m - 1, k ) );
  ans = max ( ans, 1 + lcs ( dp, arr1, n - 1, arr2, m - 1, k - 1 ) );
  return ans;
}


CHECK_LINE_TOUCHES_INTERSECTS_CIRCLE | void checkCollision ( int a, int b, int c, int x, int y, int radius ) {
  int dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b );
  if ( radius == dist ) cout << "Touch" << endl;
  else if ( radius > dist ) cout << "Intersect" << endl;
  else cout << "Outside" << endl;
}


FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY | int maxSubarrayXOR ( int arr [ ], int n ) {
  int ans = INT_MIN;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int curr_xor = 0;
    for ( int j = i;
    j < n;
    j ++ ) {
      curr_xor = curr_xor ^ arr [ j ];
      ans = max ( ans, curr_xor );
    }
  }
  return ans;
}


SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH | INT_MAX int shortestPath ( int graph [ ] [ V ], int u, int v, int k ) {
  if ( k == 0 && u == v ) return 0;
  if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ];
  if ( k <= 0 ) return INF;
  int res = INF;
  for ( int i = 0;
  i < V;
  i ++ ) {
    if ( graph [ u ] [ i ] != INF && u != i && v != i ) {
      int rec_res = shortestPath ( graph, i, v, k - 1 );
      if ( rec_res != INF ) res = min ( res, graph [ u ] [ i ] + rec_res );
    }
  }
  return res;
}


FIND_SUBARRAY_WITH_GIVEN_SUM | int subArraySum ( int arr [ ], int n, int sum ) {
  int curr_sum, i, j;
  for ( i = 0;
  i < n;
  i ++ ) {
    curr_sum = arr [ i ];
    for ( j = i + 1;
    j <= n;
    j ++ ) {
      if ( curr_sum == sum ) {
        cout << "Sum found between indexes " << i << " and " << j - 1;
        return 1;
      }
      if ( curr_sum > sum || j == n ) break;
      curr_sum = curr_sum + arr [ j ];
    }
  }
  cout << "No subarray found";
  return 0;
}


K_TH_PRIME_FACTOR_GIVEN_NUMBER | int kPrimeFactor ( int n, int k ) {
  while ( n % 2 == 0 ) {
    k --;
    n = n / 2;
    if ( k == 0 ) return 2;
  }
  for ( int i = 3;
  i <= sqrt ( n );
  i = i + 2 ) {
    while ( n % i == 0 ) {
      if ( k == 1 ) return i;
      k --;
      n = n / i;
    }
  }
  if ( n > 2 && k == 1 ) return n;
  return - 1;
}


FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1 | int countRotations ( int arr [ ], int low, int high ) {
  if ( high < low ) return 0;
  if ( high == low ) return low;
  int mid = low + ( high - low ) / 2;
  if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 );
  if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid;
  if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr, low, mid - 1 );
  return countRotations ( arr, mid + 1, high );
}


COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW_1 | int compute_average ( int a, int b ) {
  return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 );
}


SORTING_USING_TRIVIAL_HASH_FUNCTION_1 | void sortUsingHash ( int a [ ], int n ) {
  int max = * std :: max_element ( a, a + n );
  int min = abs ( * std :: min_element ( a, a + n ) );
  int hashpos [ max + 1 ] = {
    0 };
    int hashneg [ min + 1 ] = {
      0 };
      for ( int i = 0;
      i < n;
      i ++ ) {
        if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1;
        else hashneg [ abs ( a [ i ] ) ] += 1;
      }
      for ( int i = min;
      i > 0;
      i -- ) {
        if ( hashneg [ i ] ) {
          for ( int j = 0;
          j < hashneg [ i ];
          j ++ ) {
            cout << ( - 1 ) * i << " ";
          }
        }
      }
      for ( int i = 0;
      i <= max;
      i ++ ) {
        if ( hashpos [ i ] ) {
          for ( int j = 0;
          j < hashpos [ i ];
          j ++ ) {
            cout << i << " ";
          }
        }
      }
    }
    

FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1 | void printRepeating ( int arr [ ], int size ) {
  int * count = new int [ sizeof ( int ) * ( size - 2 ) ];
  int i;
  cout << " Repeating elements are ";
  for ( i = 0;
  i < size;
  i ++ ) {
    if ( count [ arr [ i ] ] == 1 ) cout << arr [ i ] << " ";
    else count [ arr [ i ] ] ++;
  }
}


MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION | int getMinSteps ( int n ) {
  int table [ n + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) table [ i ] = n - i;
  for ( int i = n;
  i >= 1;
  i -- ) {
    if ( ! ( i % 2 ) ) table [ i / 2 ] = min ( table [ i ] + 1, table [ i / 2 ] );
    if ( ! ( i % 3 ) ) table [ i / 3 ] = min ( table [ i ] + 1, table [ i / 3 ] );
  }
  return table [ 1 ];
  

COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1 | int countDecodingDP ( char * digits, int n ) {
  int count [ n + 1 ];
  count [ 0 ] = 1;
  count [ 1 ] = 1;
  if ( digits [ 0 ] == '0' ) return 0;
  for ( int i = 2;
  i <= n;
  i ++ ) {
    count [ i ] = 0;
    if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ];
    if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) ) count [ i ] += count [ i - 2 ];
  }
  return count [ n ];
}


EULERS_FOUR_SQUARE_IDENTITY_1 | void checkEulerFourSquareIdentity ( int a, int b ) {
  int ab = a * b;
  bool flag = false;
  int i = 0;
  while ( i * i <= ab ) {
    int j = i;
    while ( i * i + j * j <= ab ) {
      int k = j;
      while ( i * i + j * j + k * k <= ab ) {
        double l = sqrt ( ab - ( i * i + j * j + k * k ) );
        if ( floor ( l ) == ceil ( l ) && l >= k ) {
          flag = true;
          cout << "i = " << i << "\n";
          cout << "j = " << j << "\n";
          cout << "k = " << k << "\n";
          cout << "l = " << ( int ) l << "\n";
          cout << "Product of " << a << " and " << b << " can be written as sum of squares" << " of i, j, k, l \n";
          cout << ab + " = " << i << "*" << i << " + " << j << "*" << j << " + " << k << "*" << k << " + " << ( int ) l << "*" << ( int ) l << "\n";
        }
        k += 1;
      }
      j += 1;
    }
    i += 1;
  }
  if ( flag == false ) {
    cout << "Solution doesn't exist!\n";
    return;
  }
}


COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K | int numOfIncSubseqOfSizeK ( int arr [ ], int n, int k ) {
  int dp [ k ] [ n ], sum = 0;
  memset ( dp, 0, sizeof ( dp ) );
  for ( int i = 0;
  i < n;
  i ++ ) dp [ 0 ] [ i ] = 1;
  for ( int l = 1;
  l < k;
  l ++ ) {
    for ( int i = l;
    i < n;
    i ++ ) {
      dp [ l ] [ i ] = 0;
      for ( int j = l - 1;
      j < i;
      j ++ ) {
        if ( arr [ j ] < arr [ i ] ) dp [ l ] [ i ] += dp [ l - 1 ] [ j ];
      }
    }
  }
  for ( int i = k - 1;
  i < n;
  i ++ ) sum += dp [ k - 1 ] [ i ];
  return sum;
}


KNAPSACK_PROBLEM_1 | int knapSack ( int W, int wt [ ], int val [ ], int n ) {
  int i, w;
  int K [ n + 1 ] [ W + 1 ];
  for ( i = 0;
  i <= n;
  i ++ ) {
    for ( w = 0;
    w <= W;
    w ++ ) {
      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0;
      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ], K [ i - 1 ] [ w ] );
      else K [ i ] [ w ] = K [ i - 1 ] [ w ];
    }
  }
  return K [ n ] [ W ];
}


PROGRAM_TO_PRINT_DOUBLE_HEADED_ARROW_PATTERN | void drawPattern ( int N ) {
  int n = N;
  int row = 1;
  int nst = 1;
  int nsp1 = n - 1;
  int nsp2 = - 1;
  int val1 = row;
  int val2 = 1;
  while ( row <= n ) {
    int csp1 = 1;
    while ( csp1 <= nsp1 ) {
      cout << " " << " ";
      csp1 = csp1 + 1;
    }
    int cst1 = 1;
    while ( cst1 <= nst ) {
      cout << val1 << " ";
      val1 = val1 - 1;
      cst1 = cst1 + 1;
    }
    int csp2 = 1;
    while ( csp2 <= nsp2 ) {
      cout << " " << " ";
      csp2 = csp2 + 1;
    }
    if ( row != 1 && row != n ) {
      int cst2 = 1;
      while ( cst2 <= nst ) {
        cout << val2 << " ";
        val2 = val2 + 1;
        cst2 = cst2 + 1;
      }
    }
    cout << endl;
    if ( row <= n / 2 ) {
      nst = nst + 1;
      nsp1 = nsp1 - 2;
      nsp2 = nsp2 + 2;
      val1 = row + 1;
      val2 = 1;
    }
    else {
      nst = nst - 1;
      nsp1 = nsp1 + 2;
      nsp2 = nsp2 - 2;
      val1 = n - row;
      val2 = 1;
    }
    row = row + 1;
  }
}


INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY | int findInteger ( int arr [ ], int n ) {
  unordered_map < int, int > hash;
  int maximum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] < 0 ) hash [ abs ( arr [ i ] ) ] -= 1;
    else hash [ arr [ i ] ] += 1;
  }
  for ( int i = 0;
  i < n;
  i ++ ) if ( hash [ arr [ i ] ] != 0 ) return arr [ i ];
  return - 1;
}


SPACE_OPTIMIZED_SOLUTION_LCS | int lcs ( string & X, string & Y ) {
  int m = X . length ( ), n = Y . length ( );
  int L [ 2 ] [ n + 1 ];
  bool bi;
  for ( int i = 0;
  i <= m;
  i ++ ) {
    bi = i & 1;
    for ( int j = 0;
    j <= n;
    j ++ ) {
      if ( i == 0 || j == 0 ) L [ bi ] [ j ] = 0;
      else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1;
      else L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ], L [ bi ] [ j - 1 ] );
    }
  }
  return L [ bi ] [ n ];
}


REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS | void psuedoBinary ( int n ) {
  while ( n > 0 ) {
    int temp = n, m = 0, p = 1;
    while ( temp ) {
      int rem = temp % 10;
      temp = temp / 10;
      if ( rem != 0 ) m += p;
      p *= 10;
    }
    cout << m << " ";
    n = n - m;
  }
}


FIND_NUMBER_CURRENCY_NOTES_SUM_UPTO_GIVEN_AMOUNT | void countCurrency ( int amount ) {
  int notes [ 9 ] = {
    2000, 500, 200, 100, 50, 20, 10, 5, 1 };
    int noteCounter [ 9 ] = {
      0 };
      for ( int i = 0;
      i < 9;
      i ++ ) {
        if ( amount >= notes [ i ] ) {
          noteCounter [ i ] = amount / notes [ i ];
          amount = amount - noteCounter [ i ] * notes [ i ];
        }
      }
      cout << "Currency Count ->" << endl;
      for ( int i = 0;
      i < 9;
      i ++ ) {
        if ( noteCounter [ i ] != 0 ) {
          cout << notes [ i ] << " : " << noteCounter [ i ] << endl;
        }
      }
    }
    

POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS | void rearrange ( int a [ ], int size ) {
  int positive = 0, negative = 1;
  while ( true ) {
    while ( positive < size && a [ positive ] >= 0 ) positive += 2;
    while ( negative < size && a [ negative ] <= 0 ) negative += 2;
    if ( positive < size && negative < size ) swap ( a [ positive ], a [ negative ] );
    else break;
  }
}


FIND_WHETHER_AN_ARRAY_IS_SUBSET_OF_ANOTHER_ARRAY_SET_1 | bool isSubset ( int arr1 [ ], int arr2 [ ], int m, int n ) {
  int i = 0;
  int j = 0;
  for ( i = 0;
  i < n;
  i ++ ) {
    for ( j = 0;
    j < m;
    j ++ ) {
      if ( arr2 [ i ] == arr1 [ j ] ) break;
    }
    if ( j == m ) return 0;
  }
  return 1;
}


GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM | bool pairInSortedRotated ( int arr [ ], int n, int x ) {
  int i;
  for ( i = 0;
  i < n - 1;
  i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break;
  int l = ( i + 1 ) % n;
  int r = i;
  while ( l != r ) {
    if ( arr [ l ] + arr [ r ] == x ) return true;
    if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n;
    else r = ( n + r - 1 ) % n;
  }
  return false;
}


PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR_1 | int getRemainder ( int num, int divisor ) {
  if ( divisor == 0 ) {
    cout << "Error: divisor can't be zero \n";
    return - 1;
  }
  if ( divisor < 0 ) divisor = - divisor;
  if ( num < 0 ) num = - num;
  int i = 1;
  int product = 0;
  while ( product <= num ) {
    product = divisor * i;
    i ++;
  }
  return num - ( product - divisor );
}


GNOME_SORT_A_STUPID_ONE | void gnomeSort ( int arr [ ], int n ) {
  int index = 0;
  while ( index < n ) {
    if ( index == 0 ) index ++;
    if ( arr [ index ] >= arr [ index - 1 ] ) index ++;
    else {
      swap ( arr [ index ], arr [ index - 1 ] );
      index --;
    }
  }
  return;
}


NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE | int numberofways ( string A, string B, int N, int M ) {
  vector < int > pos [ MAX ];
  for ( int i = 0;
  i < M;
  i ++ ) pos [ B [ i ] ] . push_back ( i + 1 );
  int dpl [ N + 2 ] [ M + 2 ];
  memset ( dpl, 0, sizeof ( dpl ) );
  for ( int i = 1;
  i <= N;
  i ++ ) {
    for ( int j = 1;
    j <= M;
    j ++ ) {
      if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1;
      else dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ], dpl [ i ] [ j - 1 ] );
    }
  }
  int LCS = dpl [ N ] [ M ];
  int dpr [ N + 2 ] [ M + 2 ];
  memset ( dpr, 0, sizeof ( dpr ) );
  for ( int i = N;
  i >= 1;
  i -- ) {
    for ( int j = M;
    j >= 1;
    j -- ) {
      if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1;
      else dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ], dpr [ i ] [ j + 1 ] );
    }
  }
  int ans = 0;
  for ( int i = 0;
  i <= N;
  i ++ ) {
    for ( int j = 0;
    j < MAX;
    j ++ ) {
      for ( auto x : pos [ j ] ) {
        if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) {
          ans ++;
          break;
        }
      }
    }
  }
  return ans;
}


MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS | int minProduct ( int arr [ ], int n, int k ) {
  priority_queue < int, vector < int >, greater < int > > pq;
  for ( int i = 0;
  i < n;
  i ++ ) pq . push ( arr [ i ] );
  int count = 0, ans = 1;
  while ( pq . empty ( ) == false && count < k ) {
    ans = ans * pq . top ( );
    pq . pop ( );
    count ++;
  }
  return ans;
}


FIND_UNIQUE_ELEMENTS_MATRIX | int unique ( int mat [ R ] [ C ], int n, int m ) {
  int maximum = 0, flag = 0;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = 0;
  j < m;
  j ++ ) if ( maximum < mat [ i ] [ j ] ) maximum = mat [ i ] [ j ];
  int b [ maximum + 1 ] = {
    0 };
    for ( int i = 0;
    i < n;
    i ++ ) for ( int j = 0;
    j < m;
    j ++ ) b [ mat [ i ] [ j ] ] ++;
    for ( int i = 1;
    i <= maximum;
    i ++ ) if ( b [ i ] == 1 ) cout << i << " ";
    flag = 1;
    if ( ! flag ) {
      cout << "No unique element in the matrix";
    }
  }
  

LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS_ONE | int longestSubseqWithDiffOne ( int arr [ ], int n ) {
  int dp [ n ];
  for ( int i = 0;
  i < n;
  i ++ ) dp [ i ] = 1;
  for ( int i = 1;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < i;
    j ++ ) {
      if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = max ( dp [ i ], dp [ j ] + 1 );
    }
  }
  int result = 1;
  for ( int i = 0;
  i < n;
  i ++ ) if ( result < dp [ i ] ) result = dp [ i ];
  return result;
}


C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES | string repeat ( string s, int n ) {
  string s1 = s;
  for ( int i = 1;
  i < n;
  i ++ ) s += s1;
  return s;
}


SEARCHING_FOR_PATTERNS_SET_1_NAIVE_PATTERN_SEARCHING | void search ( char * pat, char * txt ) {
  int M = strlen ( pat );
  int N = strlen ( txt );
  for ( int i = 0;
  i <= N - M;
  i ++ ) {
    int j;
    for ( j = 0;
    j < M;
    j ++ ) if ( txt [ i + j ] != pat [ j ] ) break;
    if ( j == M ) cout << "Pattern found at index " << i << endl;
  }
}


COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES | int countwalks ( int graph [ ] [ V ], int u, int v, int k ) {
  if ( k == 0 && u == v ) return 1;
  if ( k == 1 && graph [ u ] [ v ] ) return 1;
  if ( k <= 0 ) return 0;
  int count = 0;
  for ( int i = 0;
  i < V;
  i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph, i, v, k - 1 );
  return count;
}


COUNT_DIVISIBLE_PAIRS_ARRAY | int countDivisibles ( int arr [ ], int n ) {
  int res = 0;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++;
  return res;
}


PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC | bool isSymmetric ( int mat [ ] [ MAX ], int N ) {
  for ( int i = 0;
  i < N;
  i ++ ) for ( int j = 0;
  j < N;
  j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false;
  return true;
}


COUNT_PALINDROME_SUB_STRINGS_STRING | int CountPS ( char str [ ], int n ) {
  int dp [ n ] [ n ];
  memset ( dp, 0, sizeof ( dp ) );
  bool P [ n ] [ n ];
  memset ( P, false, sizeof ( P ) );
  for ( int i = 0;
  i < n;
  i ++ ) P [ i ] [ i ] = true;
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    if ( str [ i ] == str [ i + 1 ] ) {
      P [ i ] [ i + 1 ] = true;
      dp [ i ] [ i + 1 ] = 1;
    }
  }
  for ( int gap = 2;
  gap < n;
  gap ++ ) {
    for ( int i = 0;
    i < n - gap;
    i ++ ) {
      int j = gap + i;
      if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true;
      if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ];
      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ];
    }
  }
  return dp [ 0 ] [ n - 1 ];
}


WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED | int countWays ( int arr [ ], int m, int N ) {
  int count [ N + 1 ];
  memset ( count, 0, sizeof ( count ) );
  count [ 0 ] = 1;
  for ( int i = 1;
  i <= N;
  i ++ ) for ( int j = 0;
  j < m;
  j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ];
  return count [ N ];
}


MINIMUM_NUMBER_OF_OPERATIONS_TO_MOVE_ALL_UPPERCASE_CHARACTERS_BEFORE_ALL_LOWER_CASE_CHARACTERS | int minOperations ( string str, int n ) {
  int i, lastUpper = - 1, firstLower = - 1;
  for ( i = n - 1;
  i >= 0;
  i -- ) {
    if ( isupper ( str [ i ] ) ) {
      lastUpper = i;
      break;
    }
  }
  for ( i = 0;
  i < n;
  i ++ ) {
    if ( islower ( str [ i ] ) ) {
      firstLower = i;
      break;
    }
  }
  if ( lastUpper == - 1 || firstLower == - 1 ) return 0;
  int countUpper = 0;
  for ( i = firstLower;
  i < n;
  i ++ ) {
    if ( isupper ( str [ i ] ) ) {
      countUpper ++;
    }
  }
  int countLower = 0;
  for ( i = 0;
  i < lastUpper;
  i ++ ) {
    if ( islower ( str [ i ] ) ) {
      countLower ++;
    }
  }
  return min ( countLower, countUpper );
}


PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM | void spiralPrint ( int m, int n, int a [ R ] [ C ] ) {
  int i, k = 0, l = 0;
  while ( k < m && l < n ) {
    for ( i = l;
    i < n;
    ++ i ) {
      cout << a [ k ] [ i ] << " ";
    }
    k ++;
    for ( i = k;
    i < m;
    ++ i ) {
      cout << a [ i ] [ n - 1 ] << " ";
    }
    n --;
    if ( k < m ) {
      for ( i = n - 1;
      i >= l;
      -- i ) {
        cout << a [ m - 1 ] [ i ] << " ";
      }
      m --;
    }
    if ( l < n ) {
      for ( i = m - 1;
      i >= k;
      -- i ) {
        cout << a [ i ] [ l ] << " ";
      }
      l ++;
    }
  }
}


FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT | void findTriplets ( int x ) {
  vector < int > fact;
  unordered_set < int > factors;
  for ( int i = 2;
  i <= sqrt ( x );
  i ++ ) {
    if ( x % i == 0 ) {
      fact . push_back ( i );
      if ( x / i != i ) fact . push_back ( x / i );
      factors . insert ( i );
      factors . insert ( x / i );
    }
  }
  bool found = false;
  int k = fact . size ( );
  for ( int i = 0;
  i < k;
  i ++ ) {
    int a = fact [ i ];
    for ( int j = 0;
    j < k;
    j ++ ) {
      int b = fact [ j ];
      if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) {
        cout << a << " " << b << " " << ( x / ( a * b ) );
        found = true;
        break;
      }
    }
    if ( found ) break;
  }
  if ( ! found ) cout << "-1";
}


SUM_TWO_LARGE_NUMBERS_1 | string findSum ( string str1, string str2 ) {
  if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1, str2 );
  string str = "";
  int n1 = str1 . length ( ), n2 = str2 . length ( );
  int diff = n2 - n1;
  int carry = 0;
  for ( int i = n1 - 1;
  i >= 0;
  i -- ) {
    int sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i + diff ] - '0' ) + carry );
    str . push_back ( sum % 10 + '0' );
    carry = sum / 10;
  }
  for ( int i = n2 - n1 - 1;
  i >= 0;
  i -- ) {
    int sum = ( ( str2 [ i ] - '0' ) + carry );
    str . push_back ( sum % 10 + '0' );
    carry = sum / 10;
  }
  if ( carry ) str . push_back ( carry + '0' );
  reverse ( str . begin ( ), str . end ( ) );
  return str;
}


COCKTAIL_SORT | void CocktailSort ( int a [ ], int n ) {
  bool swapped = true;
  int start = 0;
  int end = n - 1;
  while ( swapped ) {
    swapped = false;
    for ( int i = start;
    i < end;
    ++ i ) {
      if ( a [ i ] > a [ i + 1 ] ) {
        swap ( a [ i ], a [ i + 1 ] );
        swapped = true;
      }
    }
    if ( ! swapped ) break;
    swapped = false;
    -- end;
    for ( int i = end - 1;
    i >= start;
    -- i ) {
      if ( a [ i ] > a [ i + 1 ] ) {
        swap ( a [ i ], a [ i + 1 ] );
        swapped = true;
      }
    }
    ++ start;
  }
}


COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION_1 | int countDer ( int n ) {
  int der [ n + 1 ];
  der [ 0 ] = 1;
  der [ 1 ] = 0;
  der [ 2 ] = 1;
  for ( int i = 3;
  i <= n;
  ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] );
  return der [ n ];
}


MAXIMUM_PRODUCT_SUBARRAY_ADDED_NEGATIVE_PRODUCT_CASE | int findMaxProduct ( int arr [ ], int n ) {
  int i;
  int ans = INT_MIN;
  int maxval = 1;
  int minval = 1;
  int prevMax;
  for ( i = 0;
  i < n;
  i ++ ) {
    if ( arr [ i ] > 0 ) {
      maxval = maxval * arr [ i ];
      minval = min ( 1, minval * arr [ i ] );
    }
    else if ( arr [ i ] == 0 ) {
      minval = 1;
      maxval = 0;
    }
    else if ( arr [ i ] < 0 ) {
      prevMax = maxval;
      maxval = minval * arr [ i ];
      minval = prevMax * arr [ i ];
    }
    ans = max ( ans, maxval );
    if ( maxval <= 0 ) {
      maxval = 1;
    }
  }
  return ans;
}


REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_ODD | void assign ( int a [ ], int n ) {
  sort ( a, a + n );
  int ans [ n ];
  int p = 0, q = n - 1;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ];
    else ans [ i ] = a [ p ++ ];
  }
  for ( int i = 0;
  i < n;
  i ++ ) cout << ans [ i ] << " ";
}


FRIENDS_PAIRING_PROBLEM | int countFriendsPairings ( int n ) {
  int dp [ n + 1 ];
  for ( int i = 0;
  i <= n;
  i ++ ) {
    if ( i <= 2 ) dp [ i ] = i;
    else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ];
  }
  return dp [ n ];
}


PRIME_NUMBERS | bool isPrime ( int n ) {
  if ( n <= 1 ) return false;
  for ( int i = 2;
  i < n;
  i ++ ) if ( n % i == 0 ) return false;
  return true;
}


PROBABILITY_REACHING_POINT_2_3_STEPS_TIME | float find_prob ( int N, float P ) {
  double dp [ N + 1 ];
  dp [ 0 ] = 1;
  dp [ 1 ] = 0;
  dp [ 2 ] = P;
  dp [ 3 ] = 1 - P;
  for ( int i = 4;
  i <= N;
  ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ];
  return dp [ N ];
}


SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1 | int smallest ( int x, int y, int z ) {
  if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z;
  return ( ! ( x / z ) ) ? x : z;
}


COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX | void printCommonElements ( int mat [ M ] [ N ] ) {
  unordered_map < int, int > mp;
  for ( int j = 0;
  j < N;
  j ++ ) mp [ mat [ 0 ] [ j ] ] = 1;
  for ( int i = 1;
  i < M;
  i ++ ) {
    for ( int j = 0;
    j < N;
    j ++ ) {
      if ( mp [ mat [ i ] [ j ] ] == i ) {
        mp [ mat [ i ] [ j ] ] = i + 1;
        if ( i == M - 1 ) cout << mat [ i ] [ j ] << " ";
      }
    }
  }
}


DETECTING_NEGATIVE_CYCLE_USING_FLOYD_WARSHALL | bool negCyclefloydWarshall ( int graph [ ] [ V ] ) {
  int dist [ V ] [ V ], i, j, k;
  for ( i = 0;
  i < V;
  i ++ ) for ( j = 0;
  j < V;
  j ++ ) dist [ i ] [ j ] = graph [ i ] [ j ];
  for ( k = 0;
  k < V;
  k ++ ) {
    for ( i = 0;
    i < V;
    i ++ ) {
      for ( j = 0;
      j < V;
      j ++ ) {
        if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ];
      }
    }
  }
  for ( int i = 0;
  i < V;
  i ++ ) if ( dist [ i ] [ i ] < 0 ) return true;
  return false;
}


PROGRAM_SORT_STRING_DESCENDING_ORDER | void sortString ( string & str ) {
  int charCount [ MAX_CHAR ] = {
    0 };
    for ( int i = 0;
    i < str . length ( );
    i ++ ) charCount [ str [ i ] - 'a' ] ++;
    for ( int i = MAX_CHAR - 1;
    i >= 0;
    i -- ) for ( int j = 0;
    j < charCount [ i ];
    j ++ ) cout << ( char ) ( 'a' + i );
  }
  

COUNT_PAIRS_WITH_GIVEN_SUM | int getPairsCount ( int arr [ ], int n, int sum ) {
  int count = 0;
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = i + 1;
  j < n;
  j ++ ) if ( arr [ i ] + arr [ j ] == sum ) count ++;
  return count;
}


SUM_SERIES_12_32_52_2N_12_1 | int sumOfSeries ( int n ) {
  return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3;
}


MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER | int maxdiff ( int arr [ ], int n ) {
  unordered_map < int, int > freq;
  for ( int i = 0;
  i < n;
  i ++ ) freq [ arr [ i ] ] ++;
  int ans = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) ans = max ( ans, freq [ arr [ i ] ] - freq [ arr [ j ] ] );
      else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ) ans = max ( ans, freq [ arr [ j ] ] - freq [ arr [ i ] ] );
    }
  }
  return ans;
}


SHIFT_MATRIX_ELEMENTS_K | void shiftMatrixByK ( int mat [ N ] [ N ], int k ) {
  if ( k > N ) {
    cout << "shifting is not possible" << endl;
    return;
  }
  int j = 0;
  while ( j < N ) {
    for ( int i = k;
    i < N;
    i ++ ) cout << mat [ j ] [ i ] << " ";
    for ( int i = 0;
    i < k;
    i ++ ) cout << mat [ j ] [ i ] << " ";
    cout << endl;
    j ++;
  }
}


MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX | void maxMin ( int arr [ ] [ MAX ], int n ) {
  int min = INT_MAX;
  int max = INT_MIN;
  for ( int i = 0;
  i < n;
  i ++ ) {
    for ( int j = 0;
    j <= n / 2;
    j ++ ) {
      if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) {
        if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ];
        if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ];
      }
      else {
        if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ];
        if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ];
      }
    }
  }
  cout << "Maximum = " << max;
  << ", Minimum = " << min;
}


FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1 | int findGreatest ( int arr [ ], int n ) {
  unordered_map < int, int > m;
  for ( int i = 0;
  i < n;
  i ++ ) m [ arr [ i ] ] ++;
  sort ( arr, arr + n );
  for ( int i = n - 1;
  i > 1;
  i -- ) {
    for ( int j = 0;
    j < i && arr [ j ] <= sqrt ( arr [ i ] );
    j ++ ) {
      if ( arr [ i ] % arr [ j ] == 0 ) {
        int result = arr [ i ] / arr [ j ];
        if ( result != arr [ j ] && m [ result ] > 0 ) return arr [ i ];
        else if ( result == arr [ j ] && m [ result ] > 1 ) return arr [ i ];
      }
    }
  }
  return - 1;
}


0_1_KNAPSACK_PROBLEM_DP_10_1 | int knapSack ( int W, int wt [ ], int val [ ], int n ) {
  int i, w;
  int K [ n + 1 ] [ W + 1 ];
  for ( i = 0;
  i <= n;
  i ++ ) {
    for ( w = 0;
    w <= W;
    w ++ ) {
      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0;
      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ], K [ i - 1 ] [ w ] );
      else K [ i ] [ w ] = K [ i - 1 ] [ w ];
    }
  }
  return K [ n ] [ W ];
}


PROGRAM_DECIMAL_OCTAL_CONVERSION | void decToOctal ( int n ) {
  int octalNum [ 100 ];
  int i = 0;
  while ( n != 0 ) {
    octalNum [ i ] = n % 8;
    n = n / 8;
    i ++;
  }
  for ( int j = i - 1;
  j >= 0;
  j -- ) cout << octalNum [ j ];
}


SUBSEQUENCES_SIZE_THREE_ARRAY_WHOSE_SUM_DIVISIBLE_M_1 | int countSubSeq ( int A [ ], int N, int M ) {
  int ans = 0;
  int h [ M ] = {
    0 };
    for ( int i = 0;
    i < N;
    i ++ ) {
      A [ i ] = A [ i ] % M;
      h [ A [ i ] ] ++;
    }
    for ( int i = 0;
    i < M;
    i ++ ) {
      for ( int j = i;
      j < M;
      j ++ ) {
        int rem = ( M - ( i + j ) % M ) % M;
        if ( rem < j ) continue;
        if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6;
        else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2;
        else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2;
        else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2;
        else ans = ans + h [ i ] * h [ j ] * h [ rem ];
      }
    }
    return ans;
  }
  

COUNT_FIBONACCI_NUMBERS_GIVEN_RANGE_LOG_TIME | int countFibs ( int low, int high ) {
  int f1 = 0, f2 = 1, f3 = 1;
  int result = 0;
  while ( f1 <= high ) {
    if ( f1 >= low ) result ++;
    f1 = f2;
    f2 = f3;
    f3 = f1 + f2;
  }
  return result;
}


FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1 | bool isPowerOfFour ( unsigned int n ) {
  int count = 0;
  if ( n && ! ( n & ( n - 1 ) ) ) {
    while ( n > 1 ) {
      n >>= 1;
      count += 1;
    }
    return ( count % 2 == 0 ) ? 1 : 0;
  }
  return 0;
}


FIND_SUM_EVEN_FACTORS_NUMBER | int sumofFactors ( int n ) {
  if ( n % 2 != 0 ) return 0;
  int res = 1;
  for ( int i = 2;
  i <= sqrt ( n );
  i ++ ) {
    int count = 0, curr_sum = 1, curr_term = 1;
    while ( n % i == 0 ) {
      count ++;
      n = n / i;
      if ( i == 2 && count == 1 ) curr_sum = 0;
      curr_term *= i;
      curr_sum += curr_term;
    }
    res *= curr_sum;
  }
  if ( n >= 2 ) res *= ( 1 + n );
  return res;
}


FIND_SUM_NON_REPEATING_DISTINCT_ELEMENTS_ARRAY | int findSum ( int arr [ ], int n ) {
  int sum = 0;
  unordered_set < int > s;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( s . find ( arr [ i ] ) == s . end ( ) ) {
      sum += arr [ i ];
      s . insert ( arr [ i ] );
    }
  }
  return sum;
}


DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING_1 | int minPalPartion ( char * str ) {
  int n = strlen ( str );
  int C [ n ];
  bool P [ n ] [ n ];
  int i, j, k, L;
  for ( i = 0;
  i < n;
  i ++ ) {
    P [ i ] [ i ] = true;
  }
  for ( L = 2;
  L <= n;
  L ++ ) {
    for ( i = 0;
    i < n - L + 1;
    i ++ ) {
      j = i + L - 1;
      if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ] );
      else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1 ];
    }
  }
  for ( i = 0;
  i < n;
  i ++ ) {
    if ( P [ 0 ] [ i ] == true ) C [ i ] = 0;
    else {
      C [ i ] = INT_MAX;
      for ( j = 0;
      j < i;
      j ++ ) {
        if ( P [ j + 1 ] [ i ] == true && 1 + C [ j ] < C [ i ] ) C [ i ] = 1 + C [ j ];
      }
    }
  }
  return C [ n - 1 ];
}


MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION | int minInitialPoints ( int points [ ] [ C ] ) {
  int dp [ R ] [ C ];
  int m = R, n = C;
  dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 : abs ( points [ m - 1 ] [ n - 1 ] ) + 1;
  for ( int i = m - 2;
  i >= 0;
  i -- ) dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ], 1 );
  for ( int j = n - 2;
  j >= 0;
  j -- ) dp [ m - 1 ] [ j ] = max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ], 1 );
  for ( int i = m - 2;
  i >= 0;
  i -- ) {
    for ( int j = n - 2;
    j >= 0;
    j -- ) {
      int min_points_on_exit = min ( dp [ i + 1 ] [ j ], dp [ i ] [ j + 1 ] );
      dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ], 1 );
    }
  }
  return dp [ 0 ] [ 0 ];
}


COUNT_OF_PAIRS_SATISFYING_THE_GIVEN_CONDITION | int countPair ( int a, int b ) {
  string s = to_string ( b );
  int i;
  for ( i = 0;
  i < s . length ( );
  i ++ ) {
    if ( s [ i ] != '9' ) break;
  }
  int result;
  if ( i == s . length ( ) ) result = a * s . length ( );
  else result = a * ( s . length ( ) - 1 );
  return result;
}


SURVIVAL | void survival ( int S, int N, int M ) {
  if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) || M > N ) cout << "No\n";
  else {
    int days = ( M * S ) / N;
    if ( ( ( M * S ) % N ) != 0 ) days ++;
    cout << "Yes " << days << endl;
  }
}


INTERLEAVE_FIRST_HALF_QUEUE_SECOND_HALF | void interLeaveQueue ( queue < int > & q ) {
  if ( q . size ( ) % 2 != 0 ) cout << "Input even number of integers." << endl;
  stack < int > s;
  int halfSize = q . size ( ) / 2;
  for ( int i = 0;
  i < halfSize;
  i ++ ) {
    s . push ( q . front ( ) );
    q . pop ( );
  }
  while ( ! s . empty ( ) ) {
    q . push ( s . top ( ) );
    s . pop ( );
  }
  for ( int i = 0;
  i < halfSize;
  i ++ ) {
    q . push ( q . front ( ) );
    q . pop ( );
  }
  for ( int i = 0;
  i < halfSize;
  i ++ ) {
    s . push ( q . front ( ) );
    q . pop ( );
  }
  while ( ! s . empty ( ) ) {
    q . push ( s . top ( ) );
    s . pop ( );
    q . push ( q . front ( ) );
    q . pop ( );
  }
}


INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_1 | int findInteger ( int arr [ ], int n ) {
  int neg = 0, pos = 0;
  int sum = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    sum += arr [ i ];
    if ( arr [ i ] < 0 ) neg ++;
    else pos ++;
  }
  return ( sum / abs ( neg - pos ) );
}


FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS | int evenSum ( int n ) {
  int C [ n + 1 ] [ n + 1 ];
  int i, j;
  for ( i = 0;
  i <= n;
  i ++ ) {
    for ( j = 0;
    j <= min ( i, n );
    j ++ ) {
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1;
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ];
    }
  }
  int sum = 0;
  for ( int i = 0;
  i <= n;
  i += 2 ) sum += C [ n ] [ i ];
  return sum;
}


DELANNOY_NUMBER | int dealnnoy ( int n, int m ) {
  if ( m == 0 || n == 0 ) return 1;
  return dealnnoy ( m - 1, n ) + dealnnoy ( m - 1, n - 1 ) + dealnnoy ( m, n - 1 );
}


FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM | int maxLen ( int arr [ ], int n ) {
  int max_len = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int curr_sum = 0;
    for ( int j = i;
    j < n;
    j ++ ) {
      curr_sum += arr [ j ];
      if ( curr_sum == 0 ) max_len = max ( max_len, j - i + 1 );
    }
  }
  return max_len;
}


NEXT_POWER_OF_2 | unsigned int nextPowerOf2 ( unsigned int n ) {
  unsigned count = 0;
  if ( n && ! ( n & ( n - 1 ) ) ) return n;
  while ( n != 0 ) {
    n >>= 1;
    count += 1;
  }
  return 1 << count;
}


LONGEST_GEOMETRIC_PROGRESSION | int lenOfLongestGP ( int set [ ], int n ) {
  if ( n < 2 ) return n;
  if ( n == 2 ) return ( set [ 1 ] % set [ 0 ] == 0 );
  sort ( set, set + n );
  int L [ n ] [ n ];
  int llgp = 1;
  for ( int i = 0;
  i < n;
  ++ i ) if ( set [ n - 1 ] % set [ i ] == 0 ) L [ i ] [ n - 1 ] = 2;
  else L [ i ] [ n - 1 ] = 1;
  for ( int j = n - 2;
  j >= 1;
  -- j ) {
    int i = j - 1, k = j + 1;
    while ( i >= 0 && k <= n - 1 ) {
      if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) ++ k;
      else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) {
        if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2;
        else L [ i ] [ j ] = 1;
        -- i;
      }
      else {
        L [ i ] [ j ] = L [ j ] [ k ] + 1;
        if ( L [ i ] [ j ] > llgp ) llgp = L [ i ] [ j ];
        -- i;
        ++ k;
      }
    }
    while ( i >= 0 ) {
      if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2;
      else L [ i ] [ j ] = 1;
      -- i;
    }
  }
  return llgp;
}


DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH | int minCost ( int cost [ R ] [ C ], int m, int n ) {
  int i, j;
  int tc [ R ] [ C ];
  tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ];
  for ( i = 1;
  i <= m;
  i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ];
  for ( j = 1;
  j <= n;
  j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ];
  for ( i = 1;
  i <= m;
  i ++ ) for ( j = 1;
  j <= n;
  j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ], tc [ i - 1 ] [ j ], tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ];
  return tc [ m ] [ n ];
}


PROGRAM_DISTANCE_TWO_POINTS_EARTH | long double distance ( long double lat1, long double long1, long double lat2, long double long2 ) {
  lat1 = toRadians ( lat1 );
  long1 = toRadians ( long1 );
  lat2 = toRadians ( lat2 );
  long2 = toRadians ( long2 );
  long double dlong = long2 - long1;
  long double dlat = lat2 - lat1;
  long double ans = pow ( sin ( dlat / 2 ), 2 ) + cos ( lat1 ) * cos ( lat2 ) * pow ( sin ( dlong / 2 ), 2 );
  ans = 2 * asin ( sqrt ( ans ) );
  long double R = 6371;
  ans = ans * R;
  return ans;
}


BIN_PACKING_PROBLEM_MINIMIZE_NUMBER_OF_USED_BINS | int nextFit ( int weight [ ], int n, int c ) {
  int res = 0, bin_rem = c;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( weight [ i ] > bin_rem ) {
      res ++;
      bin_rem = c - weight [ i ];
    }
    else bin_rem -= weight [ i ];
  }
  return res;
}


FIND_SUBARRAY_WITH_GIVEN_SUM_1 | int subArraySum ( int arr [ ], int n, int sum ) {
  int curr_sum = arr [ 0 ], start = 0, i;
  for ( i = 1;
  i <= n;
  i ++ ) {
    while ( curr_sum > sum && start < i - 1 ) {
      curr_sum = curr_sum - arr [ start ];
      start ++;
    }
    if ( curr_sum == sum ) {
      cout << "Sum found between indexes " << start << " and " << i - 1;
      return 1;
    }
    if ( i < n ) curr_sum = curr_sum + arr [ i ];
  }
  cout << "No subarray found";
  return 0;
}


SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1 | int KnapSack ( int val [ ], int wt [ ], int n, int W ) {
  int dp [ W + 1 ];
  memset ( dp, 0, sizeof ( dp ) );
  for ( int i = 0;
  i < n;
  i ++ ) for ( int j = W;
  j >= wt [ i ];
  j -- ) dp [ j ] = max ( dp [ j ], val [ i ] + dp [ j - wt [ i ] ] );
  return dp [ W ];
}


FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X | long long int yMod ( long long int y, long long int x ) {
  if ( log2 ( y ) < x ) return y;
  if ( x > 63 ) return y;
  return ( y % ( 1 << x ) );
}


SUM_SERIES_23_45_67_89_UPTO_N_TERMS | double seriesSum ( int n ) {
  int i = 1;
  double res = 0.0;
  bool sign = true;
  while ( n > 0 ) {
    n --;
    if ( sign ) {
      sign = ! sign;
      res = res + ( double ) ++ i / ++ i;
    }
    else {
      sign = ! sign;
      res = res - ( double ) ++ i / ++ i;
    }
  }
  return res;
}


LENGTH_LONGEST_STRICT_BITONIC_SUBSEQUENCE | int longLenStrictBitonicSub ( int arr [ ], int n ) {
  unordered_map < int, int > inc, dcr;
  int len_inc [ n ], len_dcr [ n ];
  int longLen = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    int len = 0;
    if ( inc . find ( arr [ i ] - 1 ) != inc . end ( ) ) len = inc [ arr [ i ] - 1 ];
    inc [ arr [ i ] ] = len_inc [ i ] = len + 1;
  }
  for ( int i = n - 1;
  i >= 0;
  i -- ) {
    int len = 0;
    if ( dcr . find ( arr [ i ] - 1 ) != dcr . end ( ) ) len = dcr [ arr [ i ] - 1 ];
    dcr [ arr [ i ] ] = len_dcr [ i ] = len + 1;
  }
  for ( int i = 0;
  i < n;
  i ++ ) if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1;
  return longLen;
}


MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY | int maxDistance ( int arr [ ], int n ) {
  unordered_map < int, int > mp;
  int max_dist = 0;
  for ( int i = 0;
  i < n;
  i ++ ) {
    if ( mp . find ( arr [ i ] ) == mp . end ( ) ) mp [ arr [ i ] ] = i;
    else max_dist = max ( max_dist, i - mp [ arr [ i ] ] );
  }
  return max_dist;
}


FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1 | bool isRectangle ( const vector < vector < int > > & matrix ) {
  int rows = matrix . size ( );
  if ( rows == 0 ) return false;
  int columns = matrix [ 0 ] . size ( );
  unordered_map < int, unordered_set < int > > table;
  for ( int i = 0;
  i < rows;
  ++ i ) {
    for ( int j = 0;
    j < columns - 1;
    ++ j ) {
      for ( int k = j + 1;
      k < columns;
      ++ k ) {
        if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) {
          if ( table . find ( j ) != table . end ( ) && table [ j ] . find ( k ) != table [ j ] . end ( ) ) return true;
          table [ j ] . insert ( k );
        }
      }
    }
  }
  return false;
}


COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS | int numofsubset ( int arr [ ], int n ) {
  sort ( arr, arr + n );
  int count = 1;
  for ( int i = 0;
  i < n - 1;
  i ++ ) {
    if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++;
  }
  return count;
}


LARGEST_SUM_CONTIGUOUS_SUBARRAY | int maxSubArraySum ( int a [ ], int size ) {
  int max_so_far = INT_MIN, max_ending_here = 0;
  for ( int i = 0;
  i < size;
  i ++ ) {
    max_ending_here = max_ending_here + a [ i ];
    if ( max_so_far < max_ending_here ) max_so_far = max_ending_here;
    if ( max_ending_here < 0 ) max_ending_here = 0;
  }
  return max_so_far;
}


PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR_2 | int getRemainder ( int num, int divisor ) {
  while ( num >= divisor ) num -= divisor;
  return num;
}


CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT | bool check ( string str ) {
  int n = str . length ( );
  if ( n == 0 ) return false;
  if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 4 == 0 );
  int last = str [ n - 1 ] - '0';
  int second_last = str [ n - 2 ] - '0';
  return ( ( second_last * 10 + last ) % 4 == 0 );
}


FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1 | int getSingle ( int arr [ ], int n ) {
  int result = 0;
  int x, sum;
  for ( int i = 0;
  i < INT_SIZE;
  i ++ ) {
    sum = 0;
    x = ( 1 << i );
    for ( int j = 0;
    j < n;
    j ++ ) {
      if ( arr [ j ] & x ) sum ++;
    }
    if ( sum % 3 ) result |= x;
  }
  return result;
}


NUMBER_RECTANGLES_NM_GRID | int rectCount ( int n, int m ) {
  return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4;
}


MAXIMUM_POINTS_INTERSECTION_N_CIRCLES | int intersection ( int n ) {
  return n * ( n - 1 );
}


