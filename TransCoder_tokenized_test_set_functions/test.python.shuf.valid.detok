PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2 | def printDistinct ( arr, n ) :
INDENT s = dict ( );

for i in range ( n ) :
INDENT if ( arr [ i ] not in s . keys ( ) ) :
INDENT s [ arr [ i ] ] = arr [ i ];

print ( arr [ i ], end = " " );

DEDENT DEDENT DEDENT

CHECK_ROWS_MATRIX_CIRCULAR_ROTATIONS | def isPermutedMatrix ( mat, n ) :
INDENT str_cat = ""
for i in range ( n ) :
INDENT str_cat = str_cat + "-" + str ( mat [ 0 ] [ i ] )
DEDENT str_cat = str_cat + str_cat
for i in range ( 1, n ) :
INDENT curr_str = ""
for j in range ( n ) :
INDENT curr_str = curr_str + "-" + str ( mat [ i ] [ j ] )
DEDENT if ( str_cat . find ( curr_str ) ) :
INDENT return True
DEDENT DEDENT return False
DEDENT

SUM_PAIRWISE_PRODUCTS | def findSum ( n ) :
INDENT sm = 0
for i in range ( 1, n + 1 ) :
INDENT for j in range ( i, n + 1 ) :
INDENT sm = sm + i * j
DEDENT DEDENT return sm
DEDENT

SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION | def printSorted ( a, b, c ) :
INDENT get_max = max ( a, max ( b, c ) )
get_min = - max ( - a, max ( - b, - c ) )
get_mid = ( a + b + c ) - ( get_max + get_min )
print ( get_min, " ", get_mid, " ", get_max )
DEDENT

PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_2 | def factorial ( n ) :
INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )
DEDENT

FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2 | def find_extra_element_index ( arrA, arrB ) :
INDENT extra_element = sum ( arrA ) - sum ( arrB )
return arrA . index ( extra_element )
DEDENT

SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THEM_1 | def printSubsequences ( arr, n ) :
INDENT opsize = math . pow ( 2, n )
for counter in range ( 1, ( int ) ( opsize ) ) :
INDENT for j in range ( 0, n ) :
INDENT if ( counter & ( 1 << j ) ) :
INDENT print ( arr [ j ], end = " " )
DEDENT DEDENT print ( )
DEDENT DEDENT

N_BONACCI_NUMBERS | def bonacciseries ( n, m ) :
INDENT a = [ 0 ] * m
a [ n - 1 ] = 1
for i in range ( n, m ) :
INDENT for j in range ( i - n, i ) :
INDENT a [ i ] = a [ i ] + a [ j ]
DEDENT DEDENT for i in range ( 0, m ) :
INDENT print ( a [ i ], end = " " )
DEDENT DEDENT

LOWER_CASE_UPPER_CASE_INTERESTING_FACT | def to_upper ( string ) :
INDENT for i in range ( len ( string ) ) :
INDENT if ( 'a' <= string [ i ] <= 'z' ) :
INDENT string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( 'a' ) + ord ( 'A' ) ) + string [ i + 1 : ] )
DEDENT DEDENT return string;

DEDENT

PRINT_BRACKET_NUMBER | def printBracketNumber ( exp, n ) :
INDENT left_bnum = 1
right_bnum = list ( )
for i in range ( n ) :
INDENT if exp [ i ] == '(' :
INDENT print ( left_bnum, end = " " )
right_bnum . append ( left_bnum )
left_bnum += 1
DEDENT elif exp [ i ] == ')' :
INDENT print ( right_bnum [ - 1 ], end = " " )
right_bnum . pop ( )
DEDENT DEDENT DEDENT

MAXIMUM_PRODUCT_OF_4_ADJACENT_ELEMENTS_IN_MATRIX | def FindMaxProduct ( arr, n ) :
INDENT max = 0
for i in range ( n ) :
INDENT for j in range ( n ) :
INDENT if ( ( j - 3 ) >= 0 ) :
INDENT result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] )
if ( max < result ) :
INDENT max = result
DEDENT DEDENT if ( ( i - 3 ) >= 0 ) :
INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] )
if ( max < result ) :
INDENT max = result
DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 3 ) >= 0 ) :
INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] )
if ( max < result ) :
INDENT max = result
DEDENT DEDENT DEDENT DEDENT return max
DEDENT

LONGEST_SUBARRAY_SUM_DIVISIBLE_K | def longSubarrWthSumDivByK ( arr, n, k ) :
INDENT um = {
  i : 0 for i in range ( 8 ) }
  
  mod_arr = [ 0 for i in range ( n ) ]
  max = 0
  curr_sum = 0
  for i in range ( n ) :
  INDENT curr_sum += arr [ i ]
  mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k
  DEDENT for i in range ( n ) :
  INDENT if ( mod_arr [ i ] == 0 ) :
  INDENT max = i + 1
  DEDENT elif ( mod_arr [ i ] in um ) :
  INDENT um [ mod_arr [ i ] ] = i
  DEDENT else :
  INDENT if ( max < ( i - um [ mod_arr [ i ] ] ) ) :
  INDENT max = i - um [ mod_arr [ i ] ]
  DEDENT DEDENT DEDENT return max
  DEDENT

CAESAR_CIPHER | def encrypt ( text, s ) :
INDENT result = ""
for i in range ( len ( text ) ) :
INDENT char = text [ i ]
if ( char . isupper ( ) ) :
INDENT result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 )
DEDENT else :
INDENT result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 )
DEDENT DEDENT return result
DEDENT

SUBARRAYS_DISTINCT_ELEMENTS | def sumoflength ( arr, n ) :
INDENT s = [ ]
j = 0
ans = 0
for i in range ( n ) :
INDENT while ( j < n and ( arr [ j ] not in s ) ) :
INDENT s . append ( arr [ j ] )
j += 1
DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) //2
s.remove(arr[i])
DEDENTreturnans
DEDENT


K_TH_ELEMENT_TWO_SORTED_ARRAYS | def kth ( arr1, arr2, m, n, k ) :
INDENT sorted1 = [ 0 ] * ( m + n )
i = 0
j = 0
d = 0
while ( i < m and j < n ) :
INDENT if ( arr1 [ i ] < arr2 [ j ] ) :
INDENT sorted1 [ d ] = arr1 [ i ]
i += 1
DEDENT else :
INDENT sorted1 [ d ] = arr2 [ j ]
j += 1
DEDENT d += 1
DEDENT while ( i < m ) :
INDENT sorted1 [ d ] = arr1 [ i ]
d += 1
i += 1
DEDENT while ( j < n ) :
INDENT sorted1 [ d ] = arr2 [ j ]
d += 1
j += 1
DEDENT return sorted1 [ k - 1 ]
DEDENT

REMOVE_CONSECUTIVE_DUPLICATES_STRING | def removeDuplicates ( S ) :
INDENT n = len ( S )
if ( n < 2 ) :
INDENT return
DEDENT j = 0
for i in range ( n ) :
INDENT if ( S [ j ] != S [ i ] ) :
INDENT j += 1
S [ j ] = S [ i ]
DEDENT DEDENT j += 1
S = S [ : j ]
return S
DEDENT

MAJORITY_ELEMENT | def findMajority ( arr, n ) :
INDENT maxCount = 0;

index = - 1
for i in range ( n ) :
INDENT count = 0
for j in range ( n ) :
INDENT if ( arr [ i ] == arr [ j ] ) :
INDENT count += 1
DEDENT DEDENT if ( count > maxCount ) :
INDENT maxCount = count
index = i
DEDENT DEDENT if ( maxCount > n //2):
INDENTprint(arr[index])
DEDENTelse:
INDENTprint("No Majority Element")
DEDENTDEDENT


FUNCTION_COPY_STRING_ITERATIVE_RECURSIVE_1 | def myCopy ( s1, s2, index ) :
INDENT s2 [ index ] = s1 [ index ];

if ( index == len ( s1 ) - 1 ) :
INDENT return;

DEDENT myCopy ( s1, s2, index + 1 );

DEDENT

COUNT_NUMBER_OF_WAYS_TO_COVER_A_DISTANCE_1 | def printCountDP ( dist ) :
INDENT count = [ 0 ] * ( dist + 1 )
count [ 0 ] = 1
count [ 1 ] = 1
count [ 2 ] = 2
for i in range ( 3, dist + 1 ) :
INDENT count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] )
DEDENT return count [ dist ];

DEDENT

DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B | def discreteLogarithm ( a, b, m ) :
INDENT n = int ( math . sqrt ( m ) + 1 );

an = 1;

for i in range ( n ) :
INDENT an = ( an * a ) % m;

DEDENT value = [ 0 ] * m;

cur = an;

for i in range ( 1, n + 1 ) :
INDENT if ( value [ cur ] == 0 ) :
INDENT value [ cur ] = i;

DEDENT cur = ( cur * an ) % m;

DEDENT cur = b;

for i in range ( n + 1 ) :
INDENT if ( value [ cur ] > 0 ) :
INDENT ans = value [ cur ] * n - i;

if ( ans < m ) :
INDENT return ans;

DEDENT DEDENT cur = ( cur * a ) % m;

DEDENT return - 1;

DEDENT

CHANGE_BITS_CAN_MADE_ONE_FLIP_1 | def isOneFlip ( str ) :
INDENT sum = 0
n = len ( str )
for i in range ( 0, n ) :
INDENT sum += int ( str [ i ] ) - int ( '0' )
DEDENT return ( sum == n - 1 or sum == 1 )
DEDENT

FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY | def findPair ( arr, n ) :
INDENT found = False
for i in range ( 0, n ) :
INDENT for j in range ( i + 1, n ) :
INDENT for k in range ( 0, n ) :
INDENT if ( arr [ i ] + arr [ j ] == arr [ k ] ) :
INDENT print ( arr [ i ], arr [ j ] )
found = True
DEDENT DEDENT DEDENT DEDENT if ( found == False ) :
INDENT print ( "Not exist" )
DEDENT DEDENT

MODULAR_MULTIPLICATIVE_INVERSE_1_N | def modularInverse ( n, prime ) :
INDENT dp = [ 0 ] * ( n + 1 )
dp [ 0 ] = dp [ 1 ] = 1
for i in range ( 2, n + 1 ) :
INDENT dp [ i ] = dp [ prime % i ] * ( prime - prime //i)%prime
DEDENTforiinrange(1,n+1):
INDENTprint(dp[i],end=" ")
DEDENTDEDENT


SHUFFLE_2N_INTEGERS_FORMAT_A1_B1_A2_B2_A3_B3_BN_WITHOUT_USING_EXTRA_SPACE_1 | def shufleArray ( a, f, l ) :
INDENT if ( l > f ) :
INDENT return
DEDENT if ( l - f == 1 ) :
INDENT return
DEDENT mid = int ( ( f + l ) / 2 )
temp = mid + 1
mmid = int ( ( f + mid ) / 2 )
for i in range ( mmid + 1, mid + 1 ) :
INDENT ( a [ i ], a [ temp ] ) = ( a [ temp ], a [ i ] )
temp += 1
DEDENT shufleArray ( a, f, mid )
shufleArray ( a, mid + 1, l )
DEDENT

N_TH_ROOT_NUMBER | def nthRoot ( A, N ) :
INDENT xPre = random . randint ( 1, 101 ) % 10
eps = 0.001
delX = 2147483647
xK = 0.0
while ( delX > eps ) :
INDENT xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre, N - 1 ) ) / N
delX = abs ( xK - xPre )
xPre = xK;

DEDENT return xK
DEDENT

NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS | def waysToArrange ( N, K, k ) :
INDENT C = np . zeros ( ( N + 1, N + 1 ) )
for i in range ( N + 1 ) :
INDENT for j in range ( i + 1 ) :
INDENT if ( j == 0 or j == i ) :
INDENT C [ i ] [ j ] = 1
DEDENT else :
INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] )
DEDENT DEDENT DEDENT dp = np . zeros ( ( K + 1 ) )
count = 0
dp [ 0 ] = 1
for i in range ( K ) :
INDENT dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] )
count += k [ i ]
DEDENT return dp [ K ]
DEDENT

TEMPLE_OFFERINGS | def offeringNumber ( n, templeHeight ) :
INDENT sum = 0
for i in range ( n ) :
INDENT left = 0
right = 0
for j in range ( i - 1, - 1, - 1 ) :
INDENT if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) :
INDENT left += 1
DEDENT else :
INDENT break
DEDENT DEDENT for j in range ( i + 1, n ) :
INDENT if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) :
INDENT right += 1
DEDENT else :
INDENT break
DEDENT DEDENT sum += max ( right, left ) + 1
DEDENT return sum
DEDENT

CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS | def HalfDiagonalSums ( mat, n ) :
INDENT diag1_left = 0
diag1_right = 0
diag2_left = 0
diag2_right = 0
i = 0
j = n - 1
while i < n :
INDENT if ( i < n //2):
INDENTdiag1_left+=mat[i][i]
diag2_left+=mat[j][i]
DEDENTelif(i>n//2):
INDENTdiag1_right+=mat[i][i]
diag2_right+=mat[j][i]
DEDENTi+=1
j-=1
DEDENTreturn(diag1_left==diag2_rightanddiag2_right==diag2_leftanddiag1_right==diag2_leftanddiag2_right==mat[n//2][n//2])
DEDENT


COUNT_FACTORIAL_NUMBERS_IN_A_GIVEN_RANGE | def countFact ( low, high ) :
INDENT fact = 1
x = 1
while ( fact < low ) :
INDENT fact = fact * x
x += 1
DEDENT res = 0
while ( fact <= high ) :
INDENT res += 1
fact = fact * x
x += 1
DEDENT return res
DEDENT

PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1 | def reverseStr ( str ) :
INDENT n = len ( str )
i, j = 0, n - 1
while i < j :
INDENT str [ i ], str [ j ] = str [ j ], str [ i ]
i += 1
j -= 1
DEDENT DEDENT

FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY | def minAdjustmentCost ( A, n, target ) :
INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ]
for j in range ( M + 1 ) :
INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] )
DEDENT for i in range ( 1, n ) :
INDENT for j in range ( M + 1 ) :
INDENT dp [ i ] [ j ] = 100000000
for k in range ( max ( j - target, 0 ), min ( M, j + target ) + 1 ) :
INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ], dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) )
DEDENT DEDENT DEDENT res = 10000000
for j in range ( M + 1 ) :
INDENT res = min ( res, dp [ n - 1 ] [ j ] )
DEDENT return res
DEDENT

COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ | def find ( n, k ) :
INDENT if ( n + 1 >= k ) :
INDENT return ( k - 1 )
DEDENT else :
INDENT return ( 2 * n + 1 - k )
DEDENT DEDENT

MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1 | def minimumflip ( mat, n ) :
INDENT flip = 0
for i in range ( n ) :
INDENT for j in range ( i ) :
INDENT if mat [ i ] [ j ] != mat [ j ] [ i ] :
INDENT flip += 1
DEDENT DEDENT DEDENT return flip
DEDENT

NTH_PALINDROME_K_DIGITS | def nthPalindrome ( n, k ) :
INDENT if ( k & 1 ) :
INDENT temp = k //2
DEDENTelse:
INDENTtemp=k//2-1
DEDENTpalindrome=10**temp
palindrome=palindrome+n-1
print(palindrome,end="")
if(k&1):
INDENTpalindrome=palindrome//10
DEDENTwhile(palindrome):
INDENTprint(palindrome%10,end="")
palindrome=palindrome//10
DEDENTDEDENT


DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1 | def lis ( arr ) :
INDENT n = len ( arr )
lis = [ 1 ] * n
for i in range ( 1, n ) :
INDENT for j in range ( 0, i ) :
INDENT if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 :
INDENT lis [ i ] = lis [ j ] + 1
DEDENT DEDENT DEDENT maximum = 0
for i in range ( n ) :
INDENT maximum = max ( maximum, lis [ i ] )
DEDENT return maximum
DEDENT

PATH_MAXIMUM_AVERAGE_VALUE | def maxAverageOfPath ( cost, N ) :
INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ]
dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ]
for i in range ( 1, N ) :
INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ]
DEDENT for j in range ( 1, N ) :
INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ]
DEDENT for i in range ( 1, N ) :
INDENT for j in range ( 1, N ) :
INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ]
DEDENT DEDENT return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 )
DEDENT

PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING | def count ( s, c ) :
INDENT res = 0
for i in range ( len ( s ) ) :
INDENT if ( s [ i ] == c ) :
INDENT res = res + 1
DEDENT DEDENT return res
DEDENT

KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY | def kthSmallest ( arr, n, k ) :
INDENT arr . sort ( )
return arr [ k - 1 ]
DEDENT

CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE | def convertOpposite ( str ) :
INDENT ln = len ( str )
for i in range ( ln ) :
INDENT if str [ i ] >= 'a' and str [ i ] <= 'z' :
INDENT str [ i ] = chr ( ord ( str [ i ] ) - 32 )
DEDENT elif str [ i ] >= 'A' and str [ i ] <= 'Z' :
INDENT str [ i ] = chr ( ord ( str [ i ] ) + 32 )
DEDENT DEDENT DEDENT

SUM_SERIES_555555_N_TERMS | def sumOfSeries ( n ) :
INDENT return ( int ) ( 0.6172 * ( pow ( 10, n ) - 1 ) - 0.55 * n )
DEDENT

DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION | def MatrixChainOrder ( p, i, j ) :
INDENT if i == j :
INDENT return 0
DEDENT _min = sys . maxsize
for k in range ( i, j ) :
INDENT count = ( MatrixChainOrder ( p, i, k ) + MatrixChainOrder ( p, k + 1, j ) + p [ i - 1 ] * p [ k ] * p [ j ] )
if count < _min :
INDENT _min = count;

DEDENT DEDENT return _min;

DEDENT

COUNT_SET_BITS_IN_AN_INTEGER_3 | def countSetBits ( n ) :
INDENT if ( n == 0 ) :
INDENT return 0
DEDENT else :
INDENT return 1 + countSetBits ( n & ( n - 1 ) )
DEDENT DEDENT

MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMPLETE_ARRAY_SORTED | def printUnsorted ( arr, n ) :
INDENT e = n - 1
for s in range ( 0, n - 1 ) :
INDENT if arr [ s ] > arr [ s + 1 ] :
INDENT break
DEDENT DEDENT if s == n - 1 :
INDENT print ( "The complete array is sorted" )
exit ( )
DEDENT e = n - 1
while e > 0 :
INDENT if arr [ e ] < arr [ e - 1 ] :
INDENT break
DEDENT e -= 1
DEDENT max = arr [ s ]
min = arr [ s ]
for i in range ( s + 1, e + 1 ) :
INDENT if arr [ i ] > max :
INDENT max = arr [ i ]
DEDENT if arr [ i ] < min :
INDENT min = arr [ i ]
DEDENT DEDENT for i in range ( s ) :
INDENT if arr [ i ] > min :
INDENT s = i
break
DEDENT DEDENT i = n - 1
while i >= e + 1 :
INDENT if arr [ i ] < max :
INDENT e = i
break
DEDENT i -= 1
DEDENT print ( "The unsorted subarray which makes the given array" )
print ( "sorted lies between the indexes %d and %d" % ( s, e ) )
DEDENT

STEINS_ALGORITHM_FOR_FINDING_GCD | def gcd ( a, b ) :
INDENT if ( a == 0 ) :
INDENT return b
DEDENT if ( b == 0 ) :
INDENT return a
DEDENT k = 0
while ( ( ( a | b ) & 1 ) == 0 ) :
INDENT a = a >> 1
b = b >> 1
k = k + 1
DEDENT while ( ( a & 1 ) == 0 ) :
INDENT a = a >> 1
DEDENT while ( b != 0 ) :
INDENT while ( ( b & 1 ) == 0 ) :
INDENT b = b >> 1
DEDENT if ( a > b ) :
INDENT temp = a
a = b
b = temp
DEDENT b = ( b - a )
DEDENT return ( a << k )
DEDENT

HEXAGONAL_NUMBER | def hexagonalNum ( n ) :
INDENT return n * ( 2 * n - 1 )
DEDENT

GOOGLE_CASE_GIVEN_SENTENCE | def convert ( s ) :
INDENT n = len ( s )
s1 = ""
s1 = s1 + s [ 0 ] . lower ( )
i = 1
while i < n :
INDENT if ( s [ i ] == ' ' and i <= n ) :
INDENT s1 = s1 + " " + ( s [ i + 1 ] ) . lower ( )
i = i + 1
DEDENT else :
INDENT s1 = s1 + ( s [ i ] ) . upper ( )
DEDENT i = i + 1
DEDENT return s1
DEDENT

FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE | def maxHamming ( arr, n ) :
INDENT brr = [ 0 ] * ( 2 * n + 1 )
for i in range ( n ) :
INDENT brr [ i ] = arr [ i ]
DEDENT for i in range ( n ) :
INDENT brr [ n + i ] = arr [ i ]
DEDENT maxHam = 0
for i in range ( 1, n ) :
INDENT currHam = 0
k = 0
for j in range ( i, i + n ) :
INDENT if brr [ j ] != arr [ k ] :
INDENT currHam += 1
k = k + 1
DEDENT DEDENT if currHam == n :
INDENT return n
DEDENT maxHam = max ( maxHam, currHam )
DEDENT return maxHam
DEDENT

GIVEN_A_NUMBER_N_GENERATE_BIT_PATTERNS_FROM_0_TO_2N_1_SO_THAT_SUCCESSIVE_PATTERNS_DIFFER_BY_ONE_BIT | def generateGrayarr ( n ) :
INDENT if ( n <= 0 ) :
INDENT return
DEDENT arr = list ( )
arr . append ( "0" )
arr . append ( "1" )
i = 2
j = 0
while ( True ) :
INDENT if i >= 1 << n :
INDENT break
DEDENT for j in range ( i - 1, - 1, - 1 ) :
INDENT arr . append ( arr [ j ] )
DEDENT for j in range ( i ) :
INDENT arr [ j ] = "0" + arr [ j ]
DEDENT for j in range ( i, 2 * i ) :
INDENT arr [ j ] = "1" + arr [ j ]
DEDENT i = i << 1
DEDENT for i in range ( len ( arr ) ) :
INDENT print ( arr [ i ] )
DEDENT DEDENT

MINIMUM_SWAPS_REQUIRED_BRING_ELEMENTS_LESS_EQUAL_K_TOGETHER | def minSwap ( arr, n, k ) :
INDENT count = 0
for i in range ( 0, n ) :
INDENT if ( arr [ i ] <= k ) :
INDENT count = count + 1
DEDENT DEDENT bad = 0
for i in range ( 0, count ) :
INDENT if ( arr [ i ] > k ) :
INDENT bad = bad + 1
DEDENT DEDENT ans = bad
j = count
for i in range ( 0, n ) :
INDENT if ( j == n ) :
INDENT break
DEDENT if ( arr [ i ] > k ) :
INDENT bad = bad - 1
DEDENT if ( arr [ j ] > k ) :
INDENT bad = bad + 1
DEDENT ans = min ( ans, bad )
j = j + 1
DEDENT return ans
DEDENT

FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO | def fib ( n ) :
INDENT if n < 6 :
INDENT return f [ n ]
DEDENT t = 5
fn = 5
while t < n :
INDENT fn = round ( fn * PHI )
t += 1
DEDENT return fn
DEDENT

SORTING_ARRAY_REVERSE_AROUND_MIDDLE | def ifPossible ( arr, n ) :
INDENT cp = [ 0 ] * n
cp = arr
cp . sort ( )
for i in range ( 0, n ) :
INDENT if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

COUNT_ROTATIONS_DIVISIBLE_4 | def countRotations ( n ) :
INDENT l = len ( n )
if ( l == 1 ) :
INDENT oneDigit = ( int ) ( n [ 0 ] )
if ( oneDigit % 4 == 0 ) :
INDENT return 1
DEDENT return 0
DEDENT count = 0
for i in range ( 0, l - 1 ) :
INDENT twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] )
if ( twoDigit % 4 == 0 ) :
INDENT count = count + 1
DEDENT DEDENT twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] )
if ( twoDigit % 4 == 0 ) :
INDENT count = count + 1
DEDENT return count
DEDENT

N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2 | def findNth ( n ) :
INDENT nthElement = 19 + ( n - 1 ) * 9
outliersCount = int ( math . log10 ( nthElement ) ) - 1
nthElement += 9 * outliersCount
return nthElement
DEDENT

PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1 | def isPrime ( n ) :
INDENT if ( n <= 1 ) :
INDENT return False
DEDENT if ( n <= 3 ) :
INDENT return True
DEDENT if ( n % 2 == 0 or n % 3 == 0 ) :
INDENT return False
DEDENT i = 5
while ( i * i <= n ) :
INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) :
INDENT return False
DEDENT i = i + 6
DEDENT return True
DEDENT

MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1 | def subset ( arr, n ) :
INDENT mp = {
  i : 0 for i in range ( 10 ) }
  
  for i in range ( n ) :
  INDENT mp [ arr [ i ] ] += 1
  DEDENT res = 0
  for key, value in mp . items ( ) :
  INDENT res = max ( res, value )
  DEDENT return res
  DEDENT

RECAMANS_SEQUENCE_1 | def recaman ( n ) :
INDENT if ( n <= 0 ) :
INDENT return
DEDENT print ( 0, ",", end = '' )
s = set ( [ ] )
s . add ( 0 )
prev = 0
for i in range ( 1, n ) :
INDENT curr = prev - i
if ( curr < 0 or curr in s ) :
INDENT curr = prev + i
DEDENT s . add ( curr )
print ( curr, ",", end = '' )
prev = curr
DEDENT DEDENT

GENERATE_ROTATIONS_GIVEN_STRING_1 | def printRotatedString ( string ) :
INDENT n = len ( string )
temp = string + string
for i in range ( n ) :
INDENT for j in range ( n ) :
INDENT print ( temp [ i + j ], end = "" )
DEDENT print ( )
DEDENT DEDENT

FITTING_SHELVES_PROBLEM | def minSpacePreferLarge ( w, m, n ) :
INDENT num_m = 0
num_n = 0
rem = w
p = 0
q = 0
r = 0
while ( w >= n ) :
INDENT p = w / m
r = w % m
if ( r <= rem ) :
INDENT num_m = p
num_n = q
rem = r
DEDENT q += 1
w -= n
DEDENT print ( str ( int ( num_m ) ) + " " + str ( num_n ) + " " + str ( rem ) )
DEDENT

COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1 | def countStr ( n ) :
INDENT return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) //2))
DEDENT


DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER | def isDvisibleBy12 ( num ) :
INDENT if ( len ( num ) >= 3 ) :
INDENT d1 = int ( num [ len ( num ) - 1 ] );

if ( d1 % 2 != 0 ) :
INDENT return False
DEDENT d2 = int ( num [ len ( num ) - 2 ] )
sum = 0
for i in range ( 0, len ( num ) ) :
INDENT sum += int ( num [ i ] )
DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 )
DEDENT else :
INDENT number = int ( num )
return ( number % 12 == 0 )
DEDENT DEDENT

DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1 | def maxProd ( n ) :
INDENT if ( n == 2 or n == 3 ) :
INDENT return ( n - 1 )
DEDENT res = 1
while ( n > 4 ) :
INDENT n -= 3;

res *= 3;

DEDENT return ( n * res )
DEDENT

RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS | def maxProduct ( arr, n ) :
INDENT if ( n < 2 ) :
INDENT print ( "No pairs exists" )
return
DEDENT a = arr [ 0 ];
b = arr [ 1 ]
for i in range ( 0, n ) :
INDENT for j in range ( i + 1, n ) :
INDENT if ( arr [ i ] * arr [ j ] > a * b ) :
INDENT a = arr [ i ];
b = arr [ j ]
DEDENT DEDENT DEDENT print ( "Max product pair is {", a, ",", b, "}", sep = "" )
DEDENT

SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2 | def findSum ( n ) :
INDENT n -= 1
sum = 0
sum += ( n * ( n + 1 ) ) / 2
sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6
return int ( sum )
DEDENT

PRINT_MATRIX_ANTISPIRAL_FORM | def antiSpiralTraversal ( m, n, a ) :
INDENT k = 0
l = 0
stk = [ ]
while ( k <= m and l <= n ) :
INDENT for i in range ( l, n + 1 ) :
INDENT stk . append ( a [ k ] [ i ] )
DEDENT k += 1
for i in range ( k, m + 1 ) :
INDENT stk . append ( a [ i ] [ n ] )
DEDENT n -= 1
if ( k <= m ) :
INDENT for i in range ( n, l - 1, - 1 ) :
INDENT stk . append ( a [ m ] [ i ] )
DEDENT m -= 1
DEDENT if ( l <= n ) :
INDENT for i in range ( m, k - 1, - 1 ) :
INDENT stk . append ( a [ i ] [ l ] )
DEDENT l += 1
DEDENT DEDENT while len ( stk ) != 0 :
INDENT print ( str ( stk [ - 1 ] ), end = " " )
stk . pop ( )
DEDENT DEDENT

DICE_THROW_PROBLEM_1 | def findWays ( f, d, s ) :
INDENT mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ]
mem [ 0 ] [ 0 ] = 1
for i in range ( 1, d + 1 ) :
INDENT for j in range ( 1, s + 1 ) :
INDENT mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ]
if j - f - 1 >= 0 :
INDENT mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ]
DEDENT DEDENT DEDENT return mem [ d ] [ s ]
DEDENT

WRITE_A_C_PROGRAM_TO_CALCULATE_POWXN | def power ( x, y ) :
INDENT if ( y == 0 ) : return 1
elif ( int ( y % 2 ) == 0 ) :
INDENT return ( power ( x, int ( y / 2 ) ) * power ( x, int ( y / 2 ) ) )
DEDENT else :
INDENT return ( x * power ( x, int ( y / 2 ) ) * power ( x, int ( y / 2 ) ) )
DEDENT DEDENT

SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING | def findSubString ( str ) :
INDENT n = len ( str )
dist_count = len ( set ( [ x for x in str ] ) )
count, start, start_index, min_len = 0, 0, - 1, 9999999999
curr_count = defaultdict ( lambda : 0 )
for j in range ( n ) :
INDENT curr_count [ str [ j ] ] += 1
if curr_count [ str [ j ] ] == 1 :
INDENT count += 1
DEDENT if count == dist_count :
INDENT while curr_count [ str [ start ] ] > 1 :
INDENT if curr_count [ str [ start ] ] > 1 :
INDENT curr_count [ str [ start ] ] -= 1
DEDENT start += 1
DEDENT len_window = j - start + 1
if min_len > len_window :
INDENT min_len = len_window
start_index = start
DEDENT DEDENT DEDENT return str [ start_index : start_index + min_len ]
DEDENT

CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFERENCES_IS_MINIMUM | def solve ( i, par, a, n, k, current_ans ) :
INDENT if ( par > k ) :
INDENT return 0
DEDENT global ans
if ( par == k and i == n - 1 ) :
INDENT ans = min ( ans, current_ans )
return 0
DEDENT for j in range ( i + 1, n ) :
INDENT solve ( j, par + 1, a, n, k, current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) )
DEDENT DEDENT

PROGRAM_FIND_SMALLEST_LARGEST_WORD_STRING | def minMaxLengthWords ( inp ) :
INDENT length = len ( inp )
si = ei = 0
min_length = length
min_start_index = max_length = max_start_index = 0
while ei <= length :
INDENT if ( ei < length ) and ( inp [ ei ] != " " ) :
INDENT ei += 1
DEDENT else :
INDENT curr_length = ei - si
if curr_length < min_length :
INDENT min_length = curr_length
min_start_index = si
DEDENT if curr_length > max_length :
INDENT max_length = curr_length
max_start_index = si
DEDENT ei += 1
si = ei
DEDENT DEDENT minWord = inp [ min_start_index : min_start_index + min_length ]
maxWord = inp [ max_start_index : max_length ]
print ( "Minimum length word: ", minWord )
print ( "Maximum length word: ", maxWord )
DEDENT

CHECK_VALID_SEQUENCE_DIVISIBLE_M_1 | def isPossible ( n, index, modulo, M, arr, dp ) :
INDENT modulo = ( ( modulo % M ) + M ) % M
if ( index == n ) :
INDENT if ( modulo == 0 ) :
INDENT return 1
DEDENT return 0
DEDENT if ( dp [ index ] [ modulo ] != - 1 ) :
INDENT return dp [ index ] [ modulo ]
DEDENT placeAdd = isPossible ( n, index + 1, modulo + arr [ index ], M, arr, dp )
placeMinus = isPossible ( n, index + 1, modulo - arr [ index ], M, arr, dp )
res = bool ( placeAdd or placeMinus )
dp [ index ] [ modulo ] = res
return res
DEDENT

MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY | def minOperation ( arr, n ) :
INDENT Hash = defaultdict ( lambda : 0 )
for i in range ( 0, n ) :
INDENT Hash [ arr [ i ] ] += 1
DEDENT max_count = 0
for i in Hash :
INDENT if max_count < Hash [ i ] :
INDENT max_count = Hash [ i ]
DEDENT DEDENT return n - max_count
DEDENT

HYPERCUBE_GRAPH | def power ( n ) :
INDENT if n == 1 :
INDENT return 2
DEDENT return 2 * power ( n - 1 )
DEDENT

PROGRAM_FIND_CORRELATION_COEFFICIENT | def correlationCoefficient ( X, Y, n ) :
INDENT sum_X = 0
sum_Y = 0
sum_XY = 0
squareSum_X = 0
squareSum_Y = 0
i = 0
while i < n :
INDENT sum_X = sum_X + X [ i ]
sum_Y = sum_Y + Y [ i ]
sum_XY = sum_XY + X [ i ] * Y [ i ]
squareSum_X = squareSum_X + X [ i ] * X [ i ]
squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ]
i = i + 1
DEDENT corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) /
INDENT ( float ) ( math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) )
DEDENT return corr
DEDENT

COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING | def countPS ( str ) :
INDENT N = len ( str )
cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ]
for i in range ( N ) :
INDENT cps [ i ] [ i ] = 1
DEDENT for L in range ( 2, N + 1 ) :
INDENT for i in range ( N ) :
INDENT k = L + i - 1
if ( k < N ) :
INDENT if ( str [ i ] == str [ k ] ) :
INDENT cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 )
DEDENT else :
INDENT cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] )
DEDENT DEDENT DEDENT DEDENT return cps [ 0 ] [ N - 1 ]
DEDENT

SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1 | def nextPowerOf2 ( n ) :
INDENT p = 1
if ( n and not ( n & ( n - 1 ) ) ) :
INDENT return n
DEDENT while ( p < n ) :
INDENT p <<= 1
DEDENT return p;

DEDENT

FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B | def computeLastDigit ( A, B ) :
INDENT variable = 1
if ( A == B ) :
INDENT return 1
DEDENT elif ( ( B - A ) >= 5 ) :
INDENT return 0
DEDENT else :
INDENT for i in range ( A + 1, B + 1 ) :
INDENT variable = ( variable * ( i % 10 ) ) % 10
DEDENT return variable % 10
DEDENT DEDENT

NUMBER_SUBSTRINGS_DIVISIBLE_4_STRING_INTEGERS | def countDivisbleby4 ( s ) :
INDENT n = len ( s )
count = 0;

for i in range ( 0, n, 1 ) :
INDENT if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) :
INDENT count += 1
DEDENT DEDENT for i in range ( 0, n - 1, 1 ) :
INDENT h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) )
if ( h % 4 == 0 ) :
INDENT count = count + i + 1
DEDENT DEDENT return count
DEDENT

DECODE_MEDIAN_STRING_ORIGINAL_STRING | def decodeMedianString ( s ) :
INDENT l = len ( s )
s1 = ""
if ( l % 2 == 0 ) :
INDENT isEven = True
DEDENT else :
INDENT isEven = False
DEDENT for i in range ( 0, l, 2 ) :
INDENT if ( isEven ) :
INDENT s1 = s [ i ] + s1
s1 += s [ i + 1 ]
DEDENT else :
INDENT if ( l - i > 1 ) :
INDENT s1 += s [ i ]
s1 = s [ i + 1 ] + s1
DEDENT else :
INDENT s1 += s [ i ]
DEDENT DEDENT DEDENT return s1
DEDENT

NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS_IN_RANGE_M_TO_N | def maximumNumberDistinctPrimeRange ( m, n ) :
INDENT factorCount = [ 0 ] * ( n + 1 )
prime = [ False ] * ( n + 1 )
for i in range ( n + 1 ) :
INDENT factorCount [ i ] = 0
prime [ i ] = True
DEDENT for i in range ( 2, n + 1 ) :
INDENT if ( prime [ i ] == True ) :
INDENT factorCount [ i ] = 1
for j in range ( i * 2, n + 1, i ) :
INDENT factorCount [ j ] += 1
prime [ j ] = False
DEDENT DEDENT DEDENT max = factorCount [ m ]
num = m
for i in range ( m, n + 1 ) :
INDENT if ( factorCount [ i ] > max ) :
INDENT max = factorCount [ i ]
num = i
DEDENT DEDENT return num
DEDENT

NUMBER_EQUAL_PAIRS_STRING | def countPairs ( s ) :
INDENT cnt = [ 0 for i in range ( 0, MAX ) ]
for i in range ( len ( s ) ) :
INDENT cnt [ ord ( s [ i ] ) - 97 ] += 1
DEDENT ans = 0
for i in range ( 0, MAX ) :
INDENT ans += cnt [ i ] * cnt [ i ]
DEDENT return ans
DEDENT

COUNT_NUMBER_WAYS_REACH_DESTINATION_MAZE | def countPaths ( maze ) :
INDENT if ( maze [ 0 ] [ 0 ] == - 1 ) :
INDENT return 0
DEDENT for i in range ( R ) :
INDENT if ( maze [ i ] [ 0 ] == 0 ) :
INDENT maze [ i ] [ 0 ] = 1
DEDENT else :
INDENT break
DEDENT DEDENT for i in range ( 1, C, 1 ) :
INDENT if ( maze [ 0 ] [ i ] == 0 ) :
INDENT maze [ 0 ] [ i ] = 1
DEDENT else :
INDENT break
DEDENT DEDENT for i in range ( 1, R, 1 ) :
INDENT for j in range ( 1, C, 1 ) :
INDENT if ( maze [ i ] [ j ] == - 1 ) :
INDENT continue
DEDENT if ( maze [ i - 1 ] [ j ] > 0 ) :
INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] )
DEDENT if ( maze [ i ] [ j - 1 ] > 0 ) :
INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] )
DEDENT DEDENT DEDENT if ( maze [ R - 1 ] [ C - 1 ] > 0 ) :
INDENT return maze [ R - 1 ] [ C - 1 ]
DEDENT else :
INDENT return 0
DEDENT DEDENT

FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS | def maxSum ( stack1, stack2, stack3, n1, n2, n3 ) :
INDENT sum1, sum2, sum3 = 0, 0, 0
for i in range ( n1 ) :
INDENT sum1 += stack1 [ i ]
DEDENT for i in range ( n2 ) :
INDENT sum2 += stack2 [ i ]
DEDENT for i in range ( n3 ) :
INDENT sum3 += stack3 [ i ]
DEDENT top1, top2, top3 = 0, 0, 0
ans = 0
while ( 1 ) :
INDENT if ( top1 == n1 or top2 == n2 or top3 == n3 ) :
INDENT return 0
DEDENT if ( sum1 == sum2 and sum2 == sum3 ) :
INDENT return sum1
DEDENT if ( sum1 >= sum2 and sum1 >= sum3 ) :
INDENT sum1 -= stack1 [ top1 ]
top1 = top1 + 1
DEDENT elif ( sum2 >= sum3 and sum2 >= sum3 ) :
INDENT sum2 -= stack2 [ top2 ]
top2 = top2 + 1
DEDENT elif ( sum3 >= sum2 and sum3 >= sum1 ) :
INDENT sum3 -= stack3 [ top3 ]
top3 = top3 + 1
DEDENT DEDENT DEDENT

MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS | def maxSum ( arr, N, k ) :
INDENT MS = [ 0 for i in range ( N ) ]
MS [ N - 1 ] = arr [ N - 1 ]
for i in range ( N - 2, - 1, - 1 ) :
INDENT if ( i + k + 1 >= N ) :
INDENT MS [ i ] = max ( arr [ i ], MS [ i + 1 ] )
DEDENT else :
INDENT MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ], MS [ i + 1 ] )
DEDENT DEDENT return MS [ 0 ]
DEDENT

CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1 | def isEven ( n ) :
INDENT return ( not ( n & 1 ) )
DEDENT

SORT_ARRAY_TWO_HALVES_SORTED | def mergeTwoHalf ( A, n ) :
INDENT A . sort ( )
DEDENT

PYTHAGOREAN_QUADRUPLE | def pythagorean_quadruple ( a, b, c, d ) :
INDENT sum = a * a + b * b + c * c;

if ( d * d == sum ) :
INDENT return True
DEDENT else :
INDENT return False
DEDENT DEDENT

FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN_ARRAY | def printMaxOfMin ( arr, n ) :
INDENT for k in range ( 1, n + 1 ) :
INDENT maxOfMin = INT_MIN;

for i in range ( n - k + 1 ) :
INDENT min = arr [ i ]
for j in range ( k ) :
INDENT if ( arr [ i + j ] < min ) :
INDENT min = arr [ i + j ]
DEDENT DEDENT if ( min > maxOfMin ) :
INDENT maxOfMin = min
DEDENT DEDENT print ( maxOfMin, end = " " )
DEDENT DEDENT

COUNT_SUM_OF_DIGITS_IN_NUMBERS_FROM_1_TO_N | def sumOfDigitsFrom1ToN ( n ) :
INDENT if ( n < 10 ) :
INDENT return ( n * ( n + 1 ) / 2 )
DEDENT d = ( int ) ( math . log10 ( n ) )
a = [ 0 ] * ( d + 1 )
a [ 0 ] = 0
a [ 1 ] = 45
for i in range ( 2, d + 1 ) :
INDENT a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( math . ceil ( math . pow ( 10, i - 1 ) ) )
DEDENT p = ( int ) ( math . ceil ( math . pow ( 10, d ) ) )
msd = n //p
return(int)(msd*a[d]+(msd*(msd-1)//2)*p+msd*(1+n%p)+sumOfDigitsFrom1ToN(n%p))
DEDENT


RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1 | def breakSum ( n ) :
INDENT dp = [ 0 ] * ( n + 1 )
dp [ 0 ] = 0
dp [ 1 ] = 1
for i in range ( 2, n + 1 ) :
INDENT dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ], i );

DEDENT return dp [ n ]
DEDENT

FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N | def findRepeatingElement ( arr, low, high ) :
INDENT if low > high :
INDENT return - 1
DEDENT mid = ( low + high ) / 2
if ( arr [ mid ] != mid + 1 ) :
INDENT if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) :
INDENT return mid
DEDENT return findRepeatingElement ( arr, low, mid - 1 )
DEDENT return findRepeatingElement ( arr, mid + 1, high )
DEDENT

COUNT_SUBARRAYS_EQUAL_NUMBER_1S_0S_1 | def countSubarrWithEqualZeroAndOne ( arr, n ) :
INDENT mp = dict ( )
Sum = 0
count = 0
for i in range ( n ) :
INDENT if ( arr [ i ] == 0 ) :
INDENT arr [ i ] = - 1
DEDENT Sum += arr [ i ]
if ( Sum == 0 ) :
INDENT count += 1
DEDENT if ( Sum in mp . keys ( ) ) :
INDENT count += mp [ Sum ]
DEDENT mp [ Sum ] = mp . get ( Sum, 0 ) + 1
DEDENT return count
DEDENT

UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1 | def printIntersection ( arr1, arr2, m, n ) :
INDENT i, j = 0, 0
while i < m and j < n :
INDENT if arr1 [ i ] < arr2 [ j ] :
INDENT i += 1
DEDENT elif arr2 [ j ] < arr1 [ i ] :
INDENT j += 1
DEDENT else :
INDENT print ( arr2 [ j ] )
j += 1
i += 1
DEDENT DEDENT DEDENT

COUNT_ALL_INCREASING_SUBSEQUENCES | def countSub ( arr, n ) :
INDENT count = [ 0 for i in range ( 10 ) ]
for i in range ( n ) :
INDENT for j in range ( arr [ i ] - 1, - 1, - 1 ) :
INDENT count [ arr [ i ] ] += count [ j ]
DEDENT count [ arr [ i ] ] += 1
DEDENT result = 0
for i in range ( 10 ) :
INDENT result += count [ i ]
DEDENT return result
DEDENT

SMALLEST_NUMBER_SUM_DIGITS_N_DIVISIBLE_10N | def digitsNum ( N ) :
INDENT if ( N == 0 ) :
INDENT print ( "0", end = "" )
DEDENT if ( N % 9 != 0 ) :
INDENT print ( N % 9, end = "" )
DEDENT for i in range ( 1, int ( N / 9 ) + 1 ) :
INDENT print ( "9", end = "" )
DEDENT for i in range ( 1, N + 1 ) :
INDENT print ( "0", end = "" )
DEDENT print ( )
DEDENT

FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_1 | def getOddOccurrence ( arr, size ) :
INDENT Hash = dict ( )
for i in range ( size ) :
INDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ], 0 ) + 1;

DEDENT for i in Hash :
INDENT if ( Hash [ i ] % 2 != 0 ) :
INDENT return i
DEDENT DEDENT return - 1
DEDENT

CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE | def isChangeable ( notes, n ) :
INDENT fiveCount = 0
tenCount = 0
for i in range ( n ) :
INDENT if ( notes [ i ] == 5 ) :
INDENT fiveCount += 1
DEDENT elif ( notes [ i ] == 10 ) :
INDENT if ( fiveCount > 0 ) :
INDENT fiveCount -= 1
tenCount += 1
DEDENT else :
INDENT return 0
DEDENT DEDENT else :
INDENT if ( fiveCount > 0 and tenCount > 0 ) :
INDENT fiveCount -= 1
tenCount -= 1
DEDENT elif ( fiveCount >= 3 ) :
INDENT fiveCount -= 3
DEDENT else :
INDENT return 0
DEDENT DEDENT DEDENT return 1
DEDENT

MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION | def minMaxValues ( arr, n, m ) :
INDENT sum = 0
INF = 1000000000
MAX = 50
for i in range ( 0, ( n + m ) ) :
INDENT sum += arr [ i ]
arr [ i ] += 50
DEDENT dp = [ [ 0 for x in range ( MAX * MAX + 1 ) ] for y in range ( MAX + 1 ) ]
dp [ 0 ] [ 0 ] = 1
for i in range ( 0, ( n + m ) ) :
INDENT for k in range ( min ( n, i + 1 ), 0, - 1 ) :
INDENT for j in range ( 0, MAX * MAX + 1 ) :
INDENT if ( dp [ k - 1 ] [ j ] ) :
INDENT dp [ k ] [ j + arr [ i ] ] = 1
DEDENT DEDENT DEDENT DEDENT max_value = - 1 * INF
min_value = INF
for i in range ( 0, MAX * MAX + 1 ) :
INDENT if ( dp [ n ] [ i ] ) :
INDENT temp = i - 50 * n
max_value = max ( max_value, temp * ( sum - temp ) )
min_value = min ( min_value, temp * ( sum - temp ) )
DEDENT DEDENT print ( "Maximum Value: {}\nMinimum Value: {}" . format ( max_value, min_value ) )
DEDENT

MULTIPLY_AN_INTEGER_WITH_3_5 | def multiplyWith3Point5 ( x ) :
INDENT return ( x << 1 ) + x + ( x >> 1 )
DEDENT

MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VALUES | def minCells ( mat, m, n ) :
INDENT dp = [ [ MAX for i in range ( n ) ] for i in range ( m ) ]
dp [ 0 ] [ 0 ] = 1
for i in range ( m ) :
INDENT for j in range ( n ) :
INDENT if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) :
INDENT dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1
DEDENT if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) :
INDENT dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1
DEDENT DEDENT DEDENT if ( dp [ m - 1 ] [ n - 1 ] != MAX ) :
INDENT return dp [ m - 1 ] [ n - 1 ]
DEDENT return - 1
DEDENT

FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY | def findExtra ( arr1, arr2, n ) :
INDENT for i in range ( 0, n ) :
INDENT if ( arr1 [ i ] != arr2 [ i ] ) :
INDENT return i
DEDENT DEDENT return n
DEDENT

CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING | def findSum ( str1 ) :
INDENT temp = ""
Sum = 0
for ch in str1 :
INDENT if ( ch . isdigit ( ) ) :
INDENT temp += ch
DEDENT else :
INDENT Sum += int ( temp )
temp = "0"
DEDENT DEDENT return Sum + int ( temp )
DEDENT

CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED | def checkReverse ( arr, n ) :
INDENT temp = [ 0 ] * n
for i in range ( n ) :
INDENT temp [ i ] = arr [ i ]
DEDENT temp . sort ( )
for front in range ( n ) :
INDENT if temp [ front ] != arr [ front ] :
INDENT break
DEDENT DEDENT for back in range ( n - 1, - 1, - 1 ) :
INDENT if temp [ back ] != arr [ back ] :
INDENT break
DEDENT DEDENT if front >= back :
INDENT return True
DEDENT while front != back :
INDENT front += 1
if arr [ front - 1 ] < arr [ front ] :
INDENT return False
DEDENT DEDENT return True
DEDENT

GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER | def evaluate ( n ) :
INDENT if ( n == 1 or n == 2 ) :
INDENT print ( "No Pythagoras" + " Triplet exists" );

DEDENT elif ( n % 2 == 0 ) :
INDENT var = n * n / 4;

print ( "Pythagoras Triplets" + " exist i.e. ", end = "" );

print ( int ( n ), " ", int ( var - 1 ), " ", int ( var + 1 ) );

DEDENT elif ( n % 2 != 0 ) :
INDENT var = n * n + 1;

print ( "Pythagoras Triplets " + "exist i.e. ", end = "" );

print ( int ( n ), " ", int ( var / 2 - 1 ), " ", int ( var / 2 ) );

DEDENT DEDENT

PETERSON_GRAPH | def findthepath ( S, v ) :
INDENT result [ 0 ] = v
for i in range ( 1, len ( S ) ) :
INDENT if ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) ] or adj [ ord ( S [ i ] ) - ord ( 'A' ) ] [ v ] ) :
INDENT v = ord ( S [ i ] ) - ord ( 'A' )
DEDENT elif ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) + 5 ] or adj [ ord ( S [ i ] ) - ord ( 'A' ) + 5 ] [ v ] ) :
INDENT v = ord ( S [ i ] ) - ord ( 'A' ) + 5
DEDENT else :
INDENT return False
DEDENT result . append ( v )
DEDENT return True
DEDENT

COUNT_NUMBER_OF_SOLUTIONS_OF_X2_1_MOD_P_IN_GIVEN_RANGE | def findCountOfSolutions ( n, p ) :
INDENT ans = 0;

for x in range ( 1, p ) :
INDENT if ( ( x * x ) % p == 1 ) :
INDENT last = x + p * ( n / p );

if ( last > n ) :
INDENT last -= p;

DEDENT ans += ( ( last - x ) / p + 1 );

DEDENT DEDENT return int ( ans );

DEDENT

JUMP_SEARCH | def jumpSearch ( arr, x, n ) :
INDENT step = math . sqrt ( n )
prev = 0
while arr [ int ( min ( step, n ) - 1 ) ] < x :
INDENT prev = step
step += math . sqrt ( n )
if prev >= n :
INDENT return - 1
DEDENT DEDENT while arr [ int ( prev ) ] < x :
INDENT prev += 1
if prev == min ( step, n ) :
INDENT return - 1
DEDENT DEDENT if arr [ int ( prev ) ] == x :
INDENT return prev
DEDENT return - 1
DEDENT

FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE | def PrintMinNumberForPattern ( arr ) :
INDENT curr_max = 0
last_entry = 0
i = 0
while i < len ( arr ) :
INDENT noOfNextD = 0
if arr [ i ] == "I" :
INDENT j = i + 1
while j < len ( arr ) and arr [ j ] == "D" :
INDENT noOfNextD += 1
j += 1
DEDENT if i == 0 :
INDENT curr_max = noOfNextD + 2
last_entry += 1
print ( "", last_entry, end = "" )
print ( "", curr_max, end = "" )
last_entry = curr_max
DEDENT else :
INDENT curr_max += noOfNextD + 1
last_entry = curr_max
print ( "", last_entry, end = "" )
DEDENT for k in range ( noOfNextD ) :
INDENT last_entry -= 1
print ( "", last_entry, end = "" )
i += 1
DEDENT DEDENT elif arr [ i ] == "D" :
INDENT if i == 0 :
INDENT j = i + 1
while j < len ( arr ) and arr [ j ] == "D" :
INDENT noOfNextD += 1
j += 1
DEDENT curr_max = noOfNextD + 2
print ( "", curr_max, curr_max - 1, end = "" )
last_entry = curr_max - 1
DEDENT else :
INDENT print ( "", last_entry - 1, end = "" )
last_entry -= 1
DEDENT DEDENT i += 1
DEDENT print ( )
DEDENT

GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8 | def isSubSeqDivisible ( st ) :
INDENT l = len ( st )
arr = [ 0 ] * l
for i in range ( 0, l ) :
INDENT for j in range ( i, l ) :
INDENT for k in range ( j, l ) :
INDENT if ( arr [ i ] % 8 == 0 ) :
INDENT return True
DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) :
INDENT return True
DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) :
INDENT return True
DEDENT DEDENT DEDENT DEDENT return False
DEDENT

PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES | def fib ( n ) :
INDENT a = 0
b = 1
if ( n >= 0 ) :
INDENT print ( a, end = ' ' )
DEDENT if ( n >= 1 ) :
INDENT print ( b, end = ' ' )
DEDENT for i in range ( 2, n + 1 ) :
INDENT c = a + b
print ( c, end = ' ' )
a = b
b = c
DEDENT DEDENT

INTERCHANGE_ELEMENTS_OF_FIRST_AND_LAST_ROWS_IN_MATRIX | def interchangeFirstLast ( mat, n, m ) :
INDENT rows = n
for i in range ( n ) :
INDENT t = mat [ 0 ] [ i ]
mat [ 0 ] [ i ] = mat [ rows - 1 ] [ i ]
mat [ rows - 1 ] [ i ] = t
DEDENT DEDENT

SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS | def findSum ( n ) :
INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]
for i in range ( n ) :
INDENT for j in range ( n ) :
INDENT arr [ i ] [ j ] = abs ( i - j )
DEDENT DEDENT sum = 0
for i in range ( n ) :
INDENT for j in range ( n ) :
INDENT sum += arr [ i ] [ j ]
DEDENT DEDENT return sum
DEDENT

FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASING_AND_THEN_DECREASING | def findMaximum ( arr, low, high ) :
INDENT max = arr [ low ]
i = low
for i in range ( high + 1 ) :
INDENT if arr [ i ] > max :
INDENT max = arr [ i ]
DEDENT DEDENT return max
DEDENT

PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1 | def isScalarMatrix ( mat ) :
INDENT for i in range ( 0, N ) :
INDENT for j in range ( 0, N ) :
INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) :
INDENT return False
DEDENT DEDENT DEDENT for i in range ( 0, N - 1 ) :
INDENT if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

STOOGE_SORT | def stoogesort ( arr, l, h ) :
INDENT if l >= h :
INDENT return
DEDENT if arr [ l ] > arr [ h ] :
INDENT t = arr [ l ]
arr [ l ] = arr [ h ]
arr [ h ] = t
DEDENT if h - l + 1 > 2 :
INDENT t = ( int ) ( ( h - l + 1 ) / 3 )
stoogesort ( arr, l, ( h - t ) )
stoogesort ( arr, l + t, ( h ) )
stoogesort ( arr, l, ( h - t ) )
DEDENT DEDENT

DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE | def eggDrop ( n, k ) :
INDENT if ( k == 1 or k == 0 ) :
INDENT return k
DEDENT if ( n == 1 ) :
INDENT return k
DEDENT min = sys . maxsize
for x in range ( 1, k + 1 ) :
INDENT res = max ( eggDrop ( n - 1, x - 1 ), eggDrop ( n, k - x ) )
if ( res < min ) :
INDENT min = res
DEDENT DEDENT return min + 1
DEDENT

DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M | def numberofways ( n, m ) :
INDENT dp = np . zeros ( ( n + 2, n + 2 ) )
dp [ 0 ] [ n + 1 ] = 1
for k in range ( n, m - 1, - 1 ) :
INDENT for i in range ( n + 1 ) :
INDENT dp [ i ] [ k ] = dp [ i ] [ k + 1 ]
if ( i - k >= 0 ) :
INDENT dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] )
DEDENT DEDENT DEDENT return dp [ n ] [ m ]
DEDENT

BUBBLE_SORT | def bubbleSort ( arr ) :
INDENT n = len ( arr )
for i in range ( n ) :
INDENT for j in range ( 0, n - i - 1 ) :
INDENT if arr [ j ] > arr [ j + 1 ] :
INDENT arr [ j ], arr [ j + 1 ] = arr [ j + 1 ], arr [ j ]
DEDENT DEDENT DEDENT DEDENT

GENERATE_ROTATIONS_GIVEN_STRING | def printRotatedString ( str ) :
INDENT lenn = len ( str )
temp = [ 0 ] * ( lenn )
for i in range ( lenn ) :
INDENT j = i
k = 0
while ( j < len ( str ) ) :
INDENT temp [ k ] = str [ j ]
k += 1
j += 1
DEDENT j = 0
while ( j < i ) :
INDENT temp [ k ] = str [ j ]
j += 1
k += 1
DEDENT print ( * temp, sep = "" )
DEDENT DEDENT

MID_POINT_LINE_GENERATION_ALGORITHM | def midPoint ( X1, Y1, X2, Y2 ) :
INDENT dx = X2 - X1
dy = Y2 - Y1
d = dy - ( dx / 2 )
x = X1
y = Y1
print ( x, ",", y, "\n" )
while ( x < X2 ) :
INDENT x = x + 1
if ( d < 0 ) :
INDENT d = d + dy
DEDENT else :
INDENT d = d + ( dy - dx )
y = y + 1
DEDENT print ( x, ",", y, "\n" )
DEDENT DEDENT

FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA | def parabola ( a, b, c ) :
INDENT print ( "Vertex: (", ( - b / ( 2 * a ) ), ", ", ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ), ")", sep = "" )
print ( "Focus: (", ( - b / ( 2 * a ) ), ", ", ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ), ")", sep = "" )
print ( "Directrix: y=", c - ( ( b * b ) + 1 ) * 4 * a, sep = "" )
DEDENT

TRIANGULAR_NUMBERS | def isTriangular ( num ) :
INDENT if ( num < 0 ) :
INDENT return False
DEDENT sum, n = 0, 1
while ( sum <= num ) :
INDENT sum = sum + n
if ( sum == num ) :
INDENT return True
DEDENT n += 1
DEDENT return False
DEDENT

PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES | def findMaximumPieces ( n ) :
INDENT return int ( 1 + n * ( n + 1 ) / 2 )
DEDENT

MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION | def minTimeForWritingChars ( N, insrt, remov, cpy ) :
INDENT if N == 0 :
INDENT return 0
DEDENT if N == 1 :
INDENT return insrt
DEDENT dp = [ 0 ] * ( N + 1 )
for i in range ( 1, N + 1 ) :
INDENT if i % 2 == 0 :
INDENT dp [ i ] = min ( dp [ i - 1 ] + insrt, dp [ i //2]+cpy)
DEDENTelse:
INDENTdp[i]=min(dp[i-1]+insrt,dp[(i+1)//2]+cpy+remov)
DEDENTDEDENTreturndp[N]
DEDENT


SEARCHING_ARRAY_ADJACENT_DIFFER_K | def search ( arr, n, x, k ) :
INDENT i = 0
while ( i < n ) :
INDENT if ( arr [ i ] == x ) :
INDENT return i
DEDENT i = i + max ( 1, int ( abs ( arr [ i ] - x ) / k ) )
DEDENT print ( "number is not present!" )
return - 1
DEDENT

FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY | def maxProduct ( arr, n ) :
INDENT if n < 3 :
INDENT return - 1
DEDENT max_product = - ( sys . maxsize - 1 )
for i in range ( 0, n - 2 ) :
INDENT for j in range ( i + 1, n - 1 ) :
INDENT for k in range ( j + 1, n ) :
INDENT max_product = max ( max_product, arr [ i ] * arr [ j ] * arr [ k ] )
DEDENT DEDENT DEDENT return max_product
DEDENT

LONGEST_PALINDROME_SUBSEQUENCE_SPACE | def lps ( s ) :
INDENT n = len ( s )
a = [ 0 ] * n
for i in range ( n - 1, - 1, - 1 ) :
INDENT back_up = 0
for j in range ( i, n ) :
INDENT if j == i :
INDENT a [ j ] = 1
DEDENT elif s [ i ] == s [ j ] :
INDENT temp = a [ j ]
a [ j ] = back_up + 2
back_up = temp
DEDENT else :
INDENT back_up = a [ j ]
a [ j ] = max ( a [ j - 1 ], a [ j ] )
DEDENT DEDENT DEDENT return a [ n - 1 ]
DEDENT

CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1 | def checkCorrectOrNot ( s ) :
INDENT global MAX_CHAR
count = [ 0 ] * MAX_CHAR
n = len ( s )
if n == 1 :
INDENT return true
DEDENT i = 0;
j = n - 1
while i < j :
INDENT count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1
count [ ord ( s [ j ] ) - ord ( 'a' ) ] -= 1
i += 1;
j -= 1
DEDENT for i in range ( MAX_CHAR ) :
INDENT if count [ i ] != 0 :
INDENT return False
DEDENT DEDENT return True
DEDENT

EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION | def exponentiation ( bas, exp ) :
INDENT if ( exp == 0 ) :
INDENT return 1;

DEDENT if ( exp == 1 ) :
INDENT return bas % N;

DEDENT t = exponentiation ( bas, int ( exp / 2 ) );

t = ( t * t ) % N;

if ( exp % 2 == 0 ) :
INDENT return t;

DEDENT else :
INDENT return ( ( bas % N ) * t ) % N;

DEDENT DEDENT

REMOVE_MINIMUM_NUMBER_ELEMENTS_NO_COMMON_ELEMENT_EXIST_ARRAY | def minRemove ( a, b, n, m ) :
INDENT countA = dict ( )
countB = dict ( )
for i in range ( n ) :
INDENT countA [ a [ i ] ] = countA . get ( a [ i ], 0 ) + 1
DEDENT for i in range ( n ) :
INDENT countB [ b [ i ] ] = countB . get ( b [ i ], 0 ) + 1
DEDENT res = 0
for x in countA :
INDENT if x in countB . keys ( ) :
INDENT res += min ( countA [ x ], countB [ x ] )
DEDENT DEDENT return res
DEDENT

FIND_A_FIXED_POINT_IN_A_GIVEN_ARRAY | def linearSearch ( arr, n ) :
INDENT for i in range ( n ) :
INDENT if arr [ i ] is i :
INDENT return i
DEDENT DEDENT return - 1
DEDENT

ADD_1_TO_A_GIVEN_NUMBER | def addOne ( x ) :
INDENT m = 1;

while ( x & m ) :
INDENT x = x ^ m
m <<= 1
DEDENT x = x ^ m
return x
DEDENT

HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES | def height ( N ) :
INDENT return math . ceil ( math . log2 ( N + 1 ) ) - 1
DEDENT

MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY | def minJumps ( arr, l, h ) :
INDENT if ( h == l ) :
INDENT return 0
DEDENT if ( arr [ l ] == 0 ) :
INDENT return float ( 'inf' )
DEDENT min = float ( 'inf' )
for i in range ( l + 1, h + 1 ) :
INDENT if ( i < l + arr [ l ] + 1 ) :
INDENT jumps = minJumps ( arr, i, h )
if ( jumps != float ( 'inf' ) and jumps + 1 < min ) :
INDENT min = jumps + 1
DEDENT DEDENT DEDENT return min
DEDENT

PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2 | def fib ( n ) :
INDENT if ( n == 0 ) :
INDENT return 0
DEDENT if ( n == 1 or n == 2 ) :
INDENT f [ n ] = 1
return ( f [ n ] )
DEDENT if ( f [ n ] ) :
INDENT return f [ n ]
DEDENT if ( n & 1 ) :
INDENT k = ( n + 1 ) //2
DEDENTelse:
INDENTk=n//2
DEDENTif((n&1)):
INDENTf[n]=(fib(k)*fib(k)+fib(k-1)*fib(k-1))
DEDENTelse:
INDENTf[n]=(2*fib(k-1)+fib(k))*fib(k)
DEDENTreturnf[n]
DEDENT


DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING | def decode ( Str ) :
INDENT integerstack = [ ]
stringstack = [ ]
temp = ""
result = ""
for i in range ( len ( Str ) ) :
INDENT count = 0
if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :
INDENT while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :
INDENT count = count * 10 + ord ( Str [ i ] ) - ord ( '0' )
i += 1
DEDENT i -= 1
integerstack . append ( count )
DEDENT elif ( Str [ i ] == ']' ) :
INDENT temp = ""
count = 0
if ( len ( integerstack ) != 0 ) :
INDENT count = integerstack [ - 1 ]
integerstack . pop ( )
DEDENT while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) :
INDENT temp = stringstack [ - 1 ] + temp
stringstack . pop ( )
DEDENT if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) :
INDENT stringstack . pop ( )
DEDENT for j in range ( count ) :
INDENT result = result + temp
DEDENT for j in range ( len ( result ) ) :
INDENT stringstack . append ( result [ j ] )
DEDENT result = ""
DEDENT elif ( Str [ i ] == '[' ) :
INDENT if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) :
INDENT stringstack . append ( Str [ i ] )
DEDENT else :
INDENT stringstack . append ( Str [ i ] )
integerstack . append ( 1 )
DEDENT DEDENT else :
INDENT stringstack . append ( Str [ i ] )
DEDENT DEDENT while len ( stringstack ) != 0 :
INDENT result = stringstack [ - 1 ] + result
stringstack . pop ( )
DEDENT return result
DEDENT

HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP | def isHeap ( arr, i, n ) :
INDENT if i > int ( ( n - 2 ) / 2 ) :
INDENT return True
DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr, 2 * i + 1, n ) and isHeap ( arr, 2 * i + 2, n ) ) :
INDENT return True
DEDENT return False
DEDENT

HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1 | def isHeap ( arr, n ) :
INDENT for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) :
INDENT if arr [ 2 * i + 1 ] > arr [ i ] :
INDENT return False
DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND | def calcAngle ( h, m ) :
INDENT if ( h < 0 or m < 0 or h > 12 or m > 60 ) :
INDENT print ( 'Wrong input' )
DEDENT if ( h == 12 ) :
INDENT h = 0
DEDENT if ( m == 60 ) :
INDENT m = 0
DEDENT hour_angle = 0.5 * ( h * 60 + m )
minute_angle = 6 * m
angle = abs ( hour_angle - minute_angle )
angle = min ( 360 - angle, angle )
return angle
DEDENT

CONVERTING_DECIMAL_NUMBER_LYING_BETWEEN_1_TO_3999_TO_ROMAN_NUMERALS | def printRoman ( number ) :
INDENT num = [ 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000 ]
sym = [ "I", "IV", "V", "IX", "X", "XL", "L", "XC", "C", "CD", "D", "CM", "M" ]
i = 12
while number :
INDENT div = number //num[i]
number%=num[i]
whilediv:
INDENTprint(sym[i],end="")
div-=1
DEDENTi-=1
DEDENTDEDENT


SORTING_USING_TRIVIAL_HASH_FUNCTION | def sortUsingHash ( a, n ) :
INDENT Max = max ( a )
Hash = [ 0 ] * ( Max + 1 )
for i in range ( 0, n ) :
INDENT Hash [ a [ i ] ] += 1
DEDENT for i in range ( 0, Max + 1 ) :
INDENT if Hash [ i ] != 0 :
INDENT for j in range ( 0, Hash [ i ] ) :
INDENT print ( i, end = " " )
DEDENT DEDENT DEDENT DEDENT

SUM_PAIRWISE_PRODUCTS_2 | def findSum ( n ) :
INDENT return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24
DEDENT

ENTRINGER_NUMBER | def zigzag ( n, k ) :
INDENT if ( n == 0 and k == 0 ) :
INDENT return 1
DEDENT if ( k == 0 ) :
INDENT return 0
DEDENT return zigzag ( n, k - 1 ) + zigzag ( n - 1, n - k );

DEDENT

MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY_2 | def minSum ( a, n ) :
INDENT a = sorted ( a )
num1, num2 = 0, 0
for i in range ( n ) :
INDENT if i % 2 == 0 :
INDENT num1 = num1 * 10 + a [ i ]
DEDENT else :
INDENT num2 = num2 * 10 + a [ i ]
DEDENT DEDENT return num2 + num1
DEDENT

SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K | def subarrayDivisibleByK ( arr, n, k ) :
INDENT mp = [ 0 ] * 1000
s = 0;
e = 0;
maxs = 0;
maxe = 0;

mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1;

for i in range ( 1, n ) :
INDENT mod = arr [ i ] % k
while ( mp [ k - mod ] != 0 or ( mod == 0 and mp [ mod ] != 0 ) ) :
INDENT mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1
s = s + 1
DEDENT mp [ mod ] = mp [ mod ] + 1
e = e + 1
if ( ( e - s ) > ( maxe - maxs ) ) :
INDENT maxe = e
maxs = s
DEDENT DEDENT print ( "The maximum size is {} and the " . format ( ( maxe - maxs + 1 ) ) ) for i in range ( maxs, maxe + 1 ) :
INDENT print ( "{} " . format ( arr [ i ] ), end = "" )
DEDENT DEDENT

MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_K_TIMES | def maxProfit ( prices, n, k ) :
INDENT profit = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n ) ]
for i in range ( 1, n ) :
INDENT for j in range ( 1, k + 1 ) :
INDENT max_so_far = 0
for l in range ( i ) :
INDENT max_so_far = max ( max_so_far, prices [ i ] - prices [ l ] + profit [ l ] [ j - 1 ] )
DEDENT profit [ i ] [ j ] = max ( profit [ i - 1 ] [ j ], max_so_far )
DEDENT DEDENT return profit [ n - 1 ] [ k ]
DEDENT

MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED | def minValue ( A, B, n ) :
INDENT sorted ( A )
sorted ( B )
result = 0
for i in range ( n ) :
INDENT result += ( A [ i ] * B [ n - i - 1 ] )
DEDENT return result
DEDENT

FIND_MAXIMUM_ELEMENT_ROW_MATRIX | def maxelement ( arr ) :
INDENT no_of_rows = len ( arr )
no_of_column = len ( arr [ 0 ] )
for i in range ( no_of_rows ) :
INDENT max1 = 0
for j in range ( no_of_column ) :
INDENT if arr [ i ] [ j ] > max1 :
INDENT max1 = arr [ i ] [ j ]
DEDENT DEDENT print ( max1 )
DEDENT DEDENT

ROUND_OFF_NUMBER_GIVEN_NUMBER_SIGNIFICANT_DIGITS | def Round_off ( N, n ) :
INDENT b = N
c = floor ( N )
i = 0;

while ( b >= 1 ) :
INDENT b = b / 10
i = i + 1
DEDENT d = n - i
b = N
b = b * pow ( 10, d )
e = b + 0.5
if ( float ( e ) == float ( ceil ( b ) ) ) :
INDENT f = ( ceil ( b ) )
h = f - 2
if ( h % 2 != 0 ) :
INDENT e = e - 1
DEDENT DEDENT j = floor ( e )
m = pow ( 10, d )
j = j / m
print ( "The number after rounding-off is", j )
DEDENT

CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT | def checkPoint ( radius, x, y, percent, startAngle ) :
INDENT endAngle = 360 / percent + startAngle
polarradius = math . sqrt ( x * x + y * y )
Angle = math . atan ( y / x )
if ( Angle >= startAngle and Angle <= endAngle and polarradius < radius ) :
INDENT print ( "Point (", x, ",", y, ") " "exist in the circle sector" )
DEDENT else :
INDENT print ( "Point (", x, ",", y, ") " "does not exist in the circle sector" )
DEDENT DEDENT

NUMBER_IS_DIVISIBLE_BY_29_OR_NOT | def isDivisible ( n ) :
INDENT while ( int ( n / 100 ) ) :
INDENT last_digit = int ( n % 10 )
n = int ( n / 10 )
n += last_digit * 3
DEDENT return ( n % 29 == 0 )
DEDENT

PRINT_ALL_DISTINCT_CHARACTERS_OF_A_STRING_IN_ORDER_3_METHODS | def printDistinct ( str ) :
INDENT count = [ 0 ] * NO_OF_CHARS
for i in range ( len ( str ) ) :
INDENT if ( str [ i ] != ' ' ) :
INDENT count [ ord ( str [ i ] ) ] += 1
DEDENT DEDENT n = i
for i in range ( n ) :
INDENT if ( count [ ord ( str [ i ] ) ] == 1 ) :
INDENT print ( str [ i ], end = "" )
DEDENT DEDENT DEDENT

PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE | def recursiveReverse ( str ) :
INDENT stack = [ ]
for i in range ( len ( str ) ) :
INDENT stack . append ( str [ i ] )
DEDENT for i in range ( len ( str ) ) :
INDENT str [ i ] = stack . pop ( )
DEDENT DEDENT

PAINTING_FENCE_ALGORITHM | def countWays ( n, k ) :
INDENT total = k
mod = 1000000007
same, diff = 0, k
for i in range ( 2, n + 1 ) :
INDENT same = diff
diff = total * ( k - 1 )
diff = diff % mod
total = ( same + diff ) % mod
DEDENT return total
DEDENT

COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME | def CountSubString ( Str, n ) :
INDENT ans = ( n * ( n + 1 ) ) //2
a_index=0
b_index=0
c_index=0
foriinrange(n):
INDENTif(Str[i]=='a'):
INDENTa_index=i+1
ans-=min(b_index,c_index)
DEDENTelif(Str[i]=='b'):
INDENTb_index=i+1
ans-=min(a_index,c_index)
DEDENTelse:
INDENTc_index=i+1
ans-=min(a_index,b_index)
DEDENTDEDENTreturnans
DEDENT


CALCULATING_FACTORIALS_USING_STIRLING_APPROXIMATION | def stirlingFactorial ( n ) :
INDENT if ( n == 1 ) :
INDENT return 1;

DEDENT e = 2.71;

z = ( math . sqrt ( 2 * 3.14 * n ) * math . pow ( ( n / e ), n ) );

return math . floor ( z );

DEDENT

LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRAY | def lexSmallest ( a, n ) :
INDENT a . sort ( reverse = True )
answer = ""
for i in range ( n ) :
INDENT answer += a [ i ]
DEDENT return answer
DEDENT

PRODUCT_MAXIMUM_FIRST_ARRAY_MINIMUM_SECOND | def minmaxProduct ( arr1, arr2, n1, n2 ) :
INDENT arr1 . sort ( )
arr2 . sort ( )
return arr1 [ n1 - 1 ] * arr2 [ 0 ]
DEDENT

FIND_IF_THERE_IS_A_SUBARRAY_WITH_0_SUM | def subArrayExists ( arr, n ) :
INDENT s = set ( )
sum = 0
for i in range ( n ) :
INDENT sum += arr [ i ]
if sum == 0 or sum in s :
INDENT return True
DEDENT s . add ( sum )
DEDENT return False
DEDENT

MINIMUM_PRODUCT_SUBSET_ARRAY | def minProductSubset ( a, n ) :
INDENT if ( n == 1 ) :
INDENT return a [ 0 ]
DEDENT max_neg = float ( '-inf' )
min_pos = float ( 'inf' )
count_neg = 0
count_zero = 0
prod = 1
for i in range ( 0, n ) :
INDENT if ( a [ i ] == 0 ) :
INDENT count_zero = count_zero + 1
continue
DEDENT if ( a [ i ] < 0 ) :
INDENT count_neg = count_neg + 1
max_neg = max ( max_neg, a [ i ] )
DEDENT if ( a [ i ] > 0 ) :
INDENT min_pos = min ( min_pos, a [ i ] )
DEDENT prod = prod * a [ i ]
DEDENT if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) :
INDENT return 0;

DEDENT if ( count_neg == 0 ) :
INDENT return min_pos
DEDENT if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) :
INDENT prod = int ( prod / max_neg )
DEDENT return prod;

DEDENT

NUMBER_NODES_TWO_VERTICES_ACYCLIC_GRAPH_DISJOINT_UNION_METHOD | def totalNodes ( adjac, n, x, y ) :
INDENT visited = [ 0 ] * ( n + 1 )
p = [ None ] * n
q = queue . Queue ( )
q . put ( x )
visited [ x ] = True
m = None
while ( not q . empty ( ) ) :
INDENT m = q . get ( )
for i in range ( len ( adjac [ m ] ) ) :
INDENT h = adjac [ m ] [ i ]
if ( not visited [ h ] ) :
INDENT visited [ h ] = True
p [ h ] = m
q . put ( h )
DEDENT DEDENT DEDENT count = 0
i = p [ y ]
while ( i != x ) :
INDENT count += 1
i = p [ i ]
DEDENT return count
DEDENT

PRINTING_STRING_PLUS_PATTERN_MATRIX | def carveCross ( str ) :
INDENT n = len ( str )
if ( n % 2 == 0 ) :
INDENT print ( "Not possible. Please enter ", "odd length string.\n" )
DEDENT else :
INDENT arr = [ [ False for x in range ( max ) ] for y in range ( max ) ]
m = n //2
foriinrange(n):
INDENTforjinrange(n):
INDENTarr[i][j]='X'
DEDENTDEDENTforiinrange(n):
INDENTarr[i][m]=str[i]
DEDENTforiinrange(n):
INDENTarr[m][i]=str[i]
DEDENTforiinrange(n):
INDENTforjinrange(n):
INDENTprint(arr[i][j],end=" ")
DEDENTprint()
DEDENTDEDENTDEDENT


NEXT_GREATER_FREQUENCY_ELEMENT | def NFG ( a, n ) :
INDENT if ( n <= 0 ) :
INDENT print ( "List empty" )
return [ ]
DEDENT stack = [ 0 ] * n
freq = {
}

for i in a :
INDENT freq [ a [ i ] ] = 0
DEDENT for i in a :
INDENT freq [ a [ i ] ] += 1
DEDENT res = [ 0 ] * n
top = - 1
top += 1
stack [ top ] = 0
for i in range ( 1, n ) :
INDENT if ( freq [ a [ stack [ top ] ] ] > freq [ a [ i ] ] ) :
INDENT top += 1
stack [ top ] = i
DEDENT else :
INDENT while ( top > - 1 and freq [ a [ stack [ top ] ] ] < freq [ a [ i ] ] ) :
INDENT res [ stack [ top ] ] = a [ i ]
top -= 1
DEDENT top += 1
stack [ top ] = i
DEDENT DEDENT while ( top > - 1 ) :
INDENT res [ stack [ top ] ] = - 1
top -= 1
DEDENT return res
DEDENT

CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1 | def checkReverse ( arr, n ) :
INDENT if ( n == 1 ) :
INDENT return True
DEDENT i = 1
for i in range ( 1, n ) :
INDENT if arr [ i - 1 ] < arr [ i ] :
INDENT if ( i == n ) :
INDENT return True
DEDENT DEDENT DEDENT j = i
while ( arr [ j ] < arr [ j - 1 ] ) :
INDENT if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) :
INDENT return False
DEDENT j += 1
DEDENT if ( j == n ) :
INDENT return True
DEDENT k = j
if ( arr [ k ] < arr [ i - 1 ] ) :
INDENT return False
DEDENT while ( k > 1 and k < n ) :
INDENT if ( arr [ k ] < arr [ k - 1 ] ) :
INDENT return False
DEDENT k += 1
DEDENT return True
DEDENT

FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2 | def findTriplets ( arr, n ) :
INDENT found = False
arr . sort ( )
for i in range ( 0, n - 1 ) :
INDENT l = i + 1
r = n - 1
x = arr [ i ]
while ( l < r ) :
INDENT if ( x + arr [ l ] + arr [ r ] == 0 ) :
INDENT print ( x, arr [ l ], arr [ r ] )
l += 1
r -= 1
found = True
DEDENT elif ( x + arr [ l ] + arr [ r ] < 0 ) :
INDENT l += 1
DEDENT else :
INDENT r -= 1
DEDENT DEDENT DEDENT if ( found == False ) :
INDENT print ( " No Triplet Found" )
DEDENT DEDENT

FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS | def findElements ( arr, n ) :
INDENT for i in range ( n ) :
INDENT count = 0
for j in range ( 0, n ) :
INDENT if arr [ j ] > arr [ i ] :
INDENT count = count + 1
DEDENT DEDENT if count >= 2 :
INDENT print ( arr [ i ], end = " " )
DEDENT DEDENT DEDENT

POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1 | def printArray ( a, n ) :
INDENT for i in a :
INDENT print ( i, end = " " )
DEDENT print ( )
DEDENT

FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE | def minRadius ( k, x, y, n ) :
INDENT dis = [ 0 ] * n
for i in range ( 0, n ) :
INDENT dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ]
DEDENT dis . sort ( )
return dis [ k - 1 ]
DEDENT

COUNT_SUBARRAYS_EQUAL_NUMBER_1S_0S | def countSubarrWithEqualZeroAndOne ( arr, n ) :
INDENT um = dict ( )
curr_sum = 0
for i in range ( n ) :
INDENT curr_sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] )
if um . get ( curr_sum ) :
INDENT um [ curr_sum ] += 1
DEDENT else :
INDENT um [ curr_sum ] = 1
DEDENT DEDENT count = 0
for itr in um :
INDENT if um [ itr ] > 1 :
INDENT count += ( ( um [ itr ] * int ( um [ itr ] - 1 ) ) / 2 )
DEDENT DEDENT if um . get ( 0 ) :
INDENT count += um [ 0 ]
DEDENT return int ( count )
DEDENT

MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS | def find ( list1, list2 ) :
INDENT res = [ ]
max_possible_sum = len ( list1 ) + len ( list2 ) - 2
for sum in range ( max_possible_sum + 1 ) :
INDENT for i in range ( sum + 1 ) :
INDENT if ( i < len ( list1 ) and ( sum - i ) < len ( list2 ) and list1 [ i ] == list2 [ sum - i ] ) :
INDENT res . append ( list1 [ i ] )
DEDENT DEDENT if ( len ( res ) > 0 ) :
INDENT break
DEDENT DEDENT for i in range ( len ( res ) ) :
INDENT print ( res [ i ], end = " " )
DEDENT DEDENT

CHECK_IF_A_NUMBER_IS_JUMBLED_OR_NOT | def checkJumbled ( num ) :
INDENT if ( num / 10 == 0 ) :
INDENT return True
DEDENT while ( num != 0 ) :
INDENT if ( num / 10 == 0 ) :
INDENT return True
DEDENT digit1 = num % 10
digit2 = ( num / 10 ) % 10
if ( abs ( digit2 - digit1 ) > 1 ) :
INDENT return False
DEDENT num = num / 10
DEDENT return True
DEDENT

CEILING_IN_A_SORTED_ARRAY_1 | def ceilSearch ( arr, low, high, x ) :
INDENT if x <= arr [ low ] :
INDENT return low
DEDENT if x > arr [ high ] :
INDENT return - 1
DEDENT mid = ( low + high ) / 2;

if arr [ mid ] == x :
INDENT return mid
DEDENT elif arr [ mid ] < x :
INDENT if mid + 1 <= high and x <= arr [ mid + 1 ] :
INDENT return mid + 1
DEDENT else :
INDENT return ceilSearch ( arr, mid + 1, high, x )
DEDENT DEDENT else :
INDENT if mid - 1 >= low and x > arr [ mid - 1 ] :
INDENT return mid
DEDENT else :
INDENT return ceilSearch ( arr, low, mid - 1, x )
DEDENT DEDENT DEDENT

GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2 | def largestPower ( n, p ) :
INDENT x = 0
while n :
INDENT n /= p
x += n
DEDENT return x
DEDENT

MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY | def maxSum ( arr, n ) :
INDENT res = - sys . maxsize
for i in range ( 0, n ) :
INDENT curr_sum = 0
for j in range ( 0, n ) :
INDENT index = int ( ( i + j ) % n )
curr_sum += j * arr [ index ]
DEDENT res = max ( res, curr_sum )
DEDENT return res
DEDENT

MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1 | def smallestSubWithSum ( arr, n, x ) :
INDENT curr_sum = 0;

min_len = n + 1;

start = 0;

end = 0;

while ( end < n ) :
INDENT while ( curr_sum <= x and end < n ) :
INDENT if ( curr_sum <= 0 and x > 0 ) :
INDENT start = end;

curr_sum = 0;

DEDENT curr_sum += arr [ end ];

end += 1;

DEDENT while ( curr_sum > x and start < n ) :
INDENT if ( end - start < min_len ) :
INDENT min_len = end - start;

DEDENT curr_sum -= arr [ start ];

start += 1;

DEDENT DEDENT return min_len;

DEDENT

LEXICOGRAPHICALLY_SMALLEST_STRING_WHOSE_HAMMING_DISTANCE_GIVEN_STRING_EXACTLY_K | def findString ( str, n, k ) :
INDENT if ( k == 0 ) :
INDENT print ( str )
return
DEDENT str2 = str
p = 0
for i in range ( 0, n, 1 ) :
INDENT if ( str2 [ i ] != 'a' ) :
INDENT str2 = str2 . replace ( str2 [ i ], 'a' )
p += 1
if ( p == k ) :
INDENT break
DEDENT DEDENT DEDENT if ( p < k ) :
INDENT i = n - 1
while ( i >= 0 ) :
INDENT if ( str [ i ] == 'a' ) :
INDENT str2 = str2 . replace ( str2 [ i ], 'b' )
p += 1
DEDENT if ( p == k ) :
INDENT break
DEDENT i -= 1
DEDENT DEDENT print ( str2 )
DEDENT

SUBSET_SUM_DIVISIBLE_M | def modularSum ( arr, n, m ) :
INDENT if ( n > m ) :
INDENT return True
DEDENT DP = [ False for i in range ( m ) ]
for i in range ( n ) :
INDENT if ( DP [ 0 ] ) :
INDENT return True
DEDENT temp = [ False for i in range ( m ) ]
for j in range ( m ) :
INDENT if ( DP [ j ] == True ) :
INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) :
INDENT temp [ ( j + arr [ i ] ) % m ] = True
DEDENT DEDENT DEDENT for j in range ( m ) :
INDENT if ( temp [ j ] ) :
INDENT DP [ j ] = True
DEDENT DEDENT DP [ arr [ i ] % m ] = True
DEDENT return DP [ 0 ]
DEDENT

FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1 | def evenbinomialCoeffSum ( n ) :
INDENT return ( 1 << ( n - 1 ) )
DEDENT

EVEN_FIBONACCI_NUMBERS_SUM | def evenFibSum ( limit ) :
INDENT if ( limit < 2 ) :
INDENT return 0
DEDENT ef1 = 0
ef2 = 2
sm = ef1 + ef2
while ( ef2 <= limit ) :
INDENT ef3 = 4 * ef2 + ef1
if ( ef3 > limit ) :
INDENT break
DEDENT ef1 = ef2
ef2 = ef3
sm = sm + ef2
DEDENT return sm
DEDENT

MAKING_ELEMENTS_OF_TWO_ARRAYS_SAME_WITH_MINIMUM_INCREMENTDECREMENT | def MinOperation ( a, b, n ) :
INDENT a . sort ( reverse = False )
b . sort ( reverse = False )
result = 0
for i in range ( 0, n, 1 ) :
INDENT if ( a [ i ] > b [ i ] ) :
INDENT result = result + abs ( a [ i ] - b [ i ] )
DEDENT elif ( a [ i ] < b [ i ] ) :
INDENT result = result + abs ( a [ i ] - b [ i ] )
DEDENT DEDENT return result
DEDENT

REQUIRED_MINIMUM_DIGITS_REMOVE_NUMBER_MAKE_PERFECT_SQUARE | def perfectSquare ( s ) :
INDENT n = len ( s )
ans = - 1
num = ""
for i in range ( 1, ( 1 << n ) ) :
INDENT str = ""
for j in range ( 0, n ) :
INDENT if ( ( i >> j ) & 1 ) :
INDENT str = str + s [ j ]
DEDENT DEDENT if ( str [ 0 ] != '0' ) :
INDENT temp = 0;

for j in range ( 0, len ( str ) ) :
INDENT temp = ( temp * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) )
DEDENT k = int ( math . sqrt ( temp ) )
if ( k * k == temp ) :
INDENT if ( ans < len ( str ) ) :
INDENT ans = len ( str )
num = str
DEDENT DEDENT DEDENT DEDENT if ( ans == - 1 ) :
INDENT return ans
DEDENT else :
INDENT print ( "{} " . format ( num ), end = "" )
return n - ans
DEDENT DEDENT

COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS | def countWords ( stri, n ) :
INDENT m = dict ( )
for i in range ( n ) :
INDENT m [ stri [ i ] ] = m . get ( stri [ i ], 0 ) + 1
DEDENT res = 0
for i in m . values ( ) :
INDENT if i == 2 :
INDENT res += 1
DEDENT DEDENT return res
DEDENT

COUNT_SET_BITS_IN_AN_INTEGER_4 | def countSetBitsRec ( num ) :
INDENT nibble = 0;

if ( 0 == num ) :
INDENT return num_to_bits [ 0 ];

DEDENT nibble = num & 0xf;

return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 );

DEDENT

MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX | def maxCost ( mat, N ) :
INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ]
dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ]
for i in range ( 1, N ) :
INDENT dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ]
DEDENT for i in range ( 1, N ) :
INDENT for j in range ( 1, min ( i + 1, N ) ) :
INDENT dp [ i ] [ j ] = mat [ i ] [ j ] + \
INDENT max ( dp [ i - 1 ] [ j - 1 ], dp [ i - 1 ] [ j ] )
DEDENT DEDENT DEDENT result = 0
for i in range ( N ) :
INDENT if ( result < dp [ N - 1 ] [ i ] ) :
INDENT result = dp [ N - 1 ] [ i ]
DEDENT DEDENT return result
DEDENT

PERFECT_REVERSIBLE_STRING | def isReversible ( str ) :
INDENT i = 0;
j = len ( str ) - 1;

while ( i < j ) :
INDENT if ( str [ i ] != str [ j ] ) :
INDENT return False;

DEDENT i += 1;

j -= 1;

DEDENT return True;

DEDENT

FIND_SUM_ODD_FACTORS_NUMBER | def sumofoddFactors ( n ) :
INDENT res = 1
while n % 2 == 0 :
INDENT n = n //2
DEDENTforiinrange(3,int(math.sqrt(n)+1)):
INDENTcount=0
curr_sum=1
curr_term=1
whilen%i==0:
INDENTcount+=1
n=n//i
curr_term*=i
curr_sum+=curr_term
DEDENTres*=curr_sum
DEDENTifn>=2:
INDENTres*=(1+n)
DEDENTreturnres
DEDENT


MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM | def maxSum ( mat, n ) :
INDENT if n == 1 :
INDENT return mat [ 0 ] [ 0 ]
DEDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]
maxSum = INT_MIN
for j in range ( n ) :
INDENT dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ]
DEDENT for i in range ( n - 2, - 1, - 1 ) :
INDENT for j in range ( n ) :
INDENT maxi = INT_MIN
if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) ) :
INDENT maxi = dp [ i + 1 ] [ j - 1 ]
DEDENT if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) ) :
INDENT maxi = dp [ i + 1 ] [ j + 1 ]
DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + maxi
DEDENT DEDENT for j in range ( n ) :
INDENT if ( maxSum < dp [ 0 ] [ j ] ) :
INDENT maxSum = dp [ 0 ] [ j ]
DEDENT DEDENT return maxSum
DEDENT

COUNT_DIGITS_FACTORIAL_SET_1 | def findDigits ( n ) :
INDENT if ( n < 0 ) :
INDENT return 0;

DEDENT if ( n <= 1 ) :
INDENT return 1;

DEDENT digits = 0;

for i in range ( 2, n + 1 ) :
INDENT digits += math . log10 ( i );

DEDENT return math . floor ( digits ) + 1;

DEDENT

FIND_UNCOMMON_CHARACTERS_TWO_STRINGS | def findAndPrintUncommonChars ( str1, str2 ) :
INDENT present = [ 0 ] * MAX_CHAR
for i in range ( 0, MAX_CHAR ) :
INDENT present [ i ] = 0
DEDENT l1 = len ( str1 )
l2 = len ( str2 )
for i in range ( 0, l1 ) :
INDENT present [ ord ( str1 [ i ] ) - ord ( 'a' ) ] = 1
DEDENT for i in range ( 0, l2 ) :
INDENT if ( present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == - 1 ) :
INDENT present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = - 1
DEDENT else :
INDENT present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = 2
DEDENT DEDENT for i in range ( 0, MAX_CHAR ) :
INDENT if ( present [ i ] == 1 or present [ i ] == 2 ) :
INDENT print ( chr ( i + ord ( 'a' ) ), end = " " )
DEDENT DEDENT DEDENT

SQUARE_ROOT_OF_AN_INTEGER_1 | def floorSqrt ( x ) :
INDENT if ( x == 0 or x == 1 ) :
INDENT return x
DEDENT start = 1
end = x
while ( start <= end ) :
INDENT mid = ( start + end ) //2
if(mid*mid==x):
INDENTreturnmid
DEDENTif(mid*mid<x):
INDENTstart=mid+1
ans=mid
DEDENTelse:
INDENTend=mid-1
DEDENTDEDENTreturnans
DEDENT


CHECK_POSSIBLE_PATH_2D_MATRIX | def isPath ( arr ) :
INDENT arr [ 0 ] [ 0 ] = 1
for i in range ( 1, row ) :
INDENT if ( arr [ i ] [ 0 ] != - 1 ) :
INDENT arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ]
DEDENT DEDENT for j in range ( 1, col ) :
INDENT if ( arr [ 0 ] [ j ] != - 1 ) :
INDENT arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ]
DEDENT DEDENT for i in range ( 1, row ) :
INDENT for j in range ( 1, col ) :
INDENT if ( arr [ i ] [ j ] != - 1 ) :
INDENT arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ], arr [ i - 1 ] [ j ] )
DEDENT DEDENT DEDENT return ( arr [ row - 1 ] [ col - 1 ] == 1 )
DEDENT

NEWMAN_CONWAY_SEQUENCE_1 | def sequence ( n ) :
INDENT f = array . array ( 'i', [ 0, 1, 1 ] )
for i in range ( 3, n + 1 ) :
INDENT r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]
f . append ( r );

DEDENT return r
DEDENT

PRINT_WORDS_STRING_REVERSE_ORDER | def wordReverse ( str ) :
INDENT i = len ( str ) - 1
start = end = i + 1
result = ''
while i >= 0 :
INDENT if str [ i ] == ' ' :
INDENT start = i + 1
while start != end :
INDENT result += str [ start ]
start += 1
DEDENT result += ' '
end = i
DEDENT i -= 1
DEDENT start = 0
while start != end :
INDENT result += str [ start ]
start += 1
DEDENT return result
DEDENT

FIND_NUMBER_ENDLESS_POINTS | def countEndless ( input_mat, n ) :
INDENT row = np . zeros ( ( n, n ) )
col = np . zeros ( ( n, n ) )
for j in range ( n ) :
INDENT isEndless = 1
for i in range ( n - 1, - 1, - 1 ) :
INDENT if ( input_mat [ i ] [ j ] == 0 ) :
INDENT isEndless = 0
DEDENT col [ i ] [ j ] = isEndless
DEDENT DEDENT for i in range ( n ) :
INDENT isEndless = 1
for j in range ( n - 1, - 1, - 1 ) :
INDENT if ( input_mat [ i ] [ j ] == 0 ) :
INDENT isEndless = 0
DEDENT row [ i ] [ j ] = isEndless
DEDENT DEDENT ans = 0
for i in range ( n ) :
INDENT for j in range ( 1, n ) :
INDENT if ( row [ i ] [ j ] and col [ i ] [ j ] ) :
INDENT ans += 1
DEDENT DEDENT DEDENT return ans
DEDENT

CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER | def check ( s1, s2 ) :
INDENT n = len ( s1 )
m = len ( s2 )
dp = ( [ [ False for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] )
dp [ 0 ] [ 0 ] = True
for i in range ( len ( s1 ) ) :
INDENT for j in range ( len ( s2 ) + 1 ) :
INDENT if ( dp [ i ] [ j ] ) :
INDENT if ( ( j < len ( s2 ) and ( s1 [ i ] . upper ( ) == s2 [ j ] ) ) ) :
INDENT dp [ i + 1 ] [ j + 1 ] = True
DEDENT if ( s1 [ i ] . isupper ( ) == False ) :
INDENT dp [ i + 1 ] [ j ] = True
DEDENT DEDENT DEDENT DEDENT return ( dp [ n ] [ m ] )
DEDENT

CALCULATE_VOLUME_DODECAHEDRON | def vol_of_dodecahedron ( side ) :
INDENT return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) ) / 4 ) * ( math . pow ( side, 3 ) ) )
DEDENT

PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11 | def remainder ( st ) :
INDENT ln = len ( st )
rem = 0
for i in range ( 0, ln ) :
INDENT num = rem * 10 + ( int ) ( st [ i ] )
rem = num % 11
DEDENT return rem
DEDENT

SORT_STRING_CHARACTERS | def sortString ( str ) :
INDENT str = '' . join ( sorted ( str ) )
print ( str )
DEDENT

BIRTHDAY_PARADOX | def find ( p ) :
INDENT return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) );

DEDENT

CHECK_LINE_PASSES_ORIGIN | def checkOrigin ( x1, y1, x2, y2 ) :
INDENT return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) )
DEDENT

FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2 | def findElements ( arr, n ) :
INDENT first = - sys . maxsize
second = - sys . maxsize
for i in range ( 0, n ) :
INDENT if ( arr [ i ] > first ) :
INDENT second = first
first = arr [ i ]
DEDENT elif ( arr [ i ] > second ) :
INDENT second = arr [ i ]
DEDENT DEDENT for i in range ( 0, n ) :
INDENT if ( arr [ i ] < second ) :
INDENT print ( arr [ i ], end = " " )
DEDENT DEDENT DEDENT

MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED_1 | def minSum ( ar, n ) :
INDENT if ( n <= 4 ) :
INDENT return min ( ar )
DEDENT sum = [ 0 for i in range ( n ) ]
sum [ 0 ] = ar [ 0 ]
sum [ 1 ] = ar [ 1 ]
sum [ 2 ] = ar [ 2 ]
sum [ 3 ] = ar [ 3 ]
for i in range ( 4, n ) :
INDENT sum [ i ] = ar [ i ] + min ( sum [ i - 4 : i ] )
DEDENT return min ( sum [ n - 4 : n ] )
DEDENT

CEILING_IN_A_SORTED_ARRAY | def ceilSearch ( arr, low, high, x ) :
INDENT if x <= arr [ low ] :
INDENT return low
DEDENT i = low
for i in range ( high ) :
INDENT if arr [ i ] == x :
INDENT return i
DEDENT if arr [ i ] < x and arr [ i + 1 ] >= x :
INDENT return i + 1
DEDENT DEDENT return - 1
DEDENT

SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE_1 | def swap ( xp, yp ) :
INDENT if ( xp [ 0 ] == yp [ 0 ] ) :
INDENT return
DEDENT xp [ 0 ] = xp [ 0 ] + yp [ 0 ]
yp [ 0 ] = xp [ 0 ] - yp [ 0 ]
xp [ 0 ] = xp [ 0 ] - yp [ 0 ]
DEDENT

MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_ANAGRAM_WITHOUT_DELETION_OF_CHARACTER | def countManipulations ( s1, s2 ) :
INDENT count = 0
char_count = [ 0 ] * 26
for i in range ( 26 ) :
INDENT char_count [ i ] = 0
DEDENT for i in range ( len ( s1 ) ) :
INDENT char_count [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1
DEDENT for i in range ( len ( s2 ) ) :
INDENT char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] -= 1
if ( char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] < 0 ) :
INDENT count += 1
DEDENT DEDENT return count
DEDENT

CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS | def flipsPossible ( a, n ) :
INDENT count_odd = 0;
count_even = 0;

for i in range ( n ) :
INDENT if ( a [ i ] & 1 ) :
INDENT count_odd += 1;

DEDENT else :
INDENT count_even += 1;

DEDENT DEDENT if ( count_odd % 2 and count_even % 2 ) :
INDENT return False;

DEDENT else :
INDENT return True;

DEDENT DEDENT

CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL | def substringConversions ( s, k, b ) :
INDENT l = len ( s );

for i in range ( l ) :
INDENT if ( ( i + k ) < l + 1 ) :
INDENT sub = s [ i : i + k ];

sum, counter = 0, 0;

for i in range ( len ( sub ) - 1, - 1, - 1 ) :
INDENT sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b, counter ) );

counter += 1;

DEDENT print ( sum, end = " " );

DEDENT DEDENT DEDENT

FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN_ARE_1_IN_A_BOOLEAN_MATRIX | def find ( arr ) :
INDENT n = len ( arr )
i = 0
j = n - 1
res = - 1
while i < n and j >= 0 :
INDENT if arr [ i ] [ j ] == 0 :
INDENT while j >= 0 and ( arr [ i ] [ j ] == 0 or i == j ) :
INDENT j -= 1
DEDENT if j == - 1 :
INDENT res = i
break
DEDENT else : i += 1
DEDENT else :
INDENT while i < n and ( arr [ i ] [ j ] == 1 or i == j ) :
INDENT i += 1
DEDENT if i == n :
INDENT res = j
break
DEDENT else : j -= 1
DEDENT DEDENT if res == - 1 :
INDENT return res
DEDENT for i in range ( 0, n ) :
INDENT if res != i and arr [ i ] [ res ] != 1 :
INDENT return - 1
DEDENT DEDENT for j in range ( 0, j ) :
INDENT if res != j and arr [ res ] [ j ] != 0 :
INDENT return - 1;

DEDENT DEDENT return res;

DEDENT

NUMBER_ORDERED_PAIRS_AI_AJ_0 | def countPairs ( a, n ) :
INDENT count = 0
for i in range ( 0, n ) :
INDENT for j in range ( i + 1, n ) :
INDENT if ( a [ i ] & a [ j ] ) == 0 :
INDENT count += 2
DEDENT DEDENT DEDENT return count
DEDENT

CIRCLE_LATTICE_POINTS | def countLattice ( r ) :
INDENT if ( r <= 0 ) :
INDENT return 0
DEDENT result = 4
for x in range ( 1, r ) :
INDENT ySquare = r * r - x * x
y = int ( math . sqrt ( ySquare ) )
if ( y * y == ySquare ) :
INDENT result += 4
DEDENT DEDENT return result
DEDENT

MINIMUM_CHARACTERS_ADDED_FRONT_MAKE_STRING_PALINDROME | def ispalindrome ( s ) :
INDENT l = len ( s )
i = 0
j = l - 1
while i <= j :
INDENT if ( s [ i ] != s [ j ] ) :
INDENT return False
DEDENT i += 1
j -= 1
DEDENT return True
DEDENT

K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SEQUENCE | def find ( a, b, k, n1, n2 ) :
INDENT s = set ( )
for i in range ( n2 ) :
INDENT s . add ( b [ i ] )
DEDENT missing = 0
for i in range ( n1 ) :
INDENT if a [ i ] not in s :
INDENT missing += 1
DEDENT if missing == k :
INDENT return a [ i ]
DEDENT DEDENT return - 1
DEDENT

PROGRAM_CHECK_ISBN | def isValidISBN ( isbn ) :
INDENT if len ( isbn ) != 10 :
INDENT return False
DEDENT _sum = 0
for i in range ( 9 ) :
INDENT if 0 <= int ( isbn [ i ] ) <= 9 :
INDENT _sum += int ( isbn [ i ] ) * ( 10 - i )
DEDENT else :
INDENT return False
DEDENT DEDENT if ( isbn [ 9 ] != 'X' and 0 <= int ( isbn [ 9 ] ) <= 9 ) :
INDENT return False
DEDENT _sum += 10 if isbn [ 9 ] == 'X' else int ( isbn [ 9 ] )
return ( _sum % 11 == 0 )
DEDENT

COUNT_WAYS_INCREASE_LCS_LENGTH_TWO_STRINGS_ONE | def waysToIncreaseLCSBy1 ( str1, str2 ) :
INDENT m = len ( str1 )
n = len ( str2 )
position = [ [ ] for i in range ( M ) ]
for i in range ( 1, n + 1, 1 ) :
INDENT position [ ord ( str2 [ i - 1 ] ) - 97 ] . append ( i )
DEDENT lcsl = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ]
lcsr = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ]
for i in range ( 1, m + 1, 1 ) :
INDENT for j in range ( 1, n + 1, 1 ) :
INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) :
INDENT lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ]
DEDENT else :
INDENT lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ], lcsl [ i ] [ j - 1 ] )
DEDENT DEDENT DEDENT for i in range ( m, 0, - 1 ) :
INDENT for j in range ( n, 0, - 1 ) :
INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) :
INDENT lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ]
DEDENT else :
INDENT lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ], lcsr [ i ] [ j + 1 ] )
DEDENT DEDENT DEDENT ways = 0
for i in range ( 0, m + 1, 1 ) :
INDENT for C in range ( 0, 26, 1 ) :
INDENT for j in range ( 0, len ( position [ C ] ), 1 ) :
INDENT p = position [ C ] [ j ]
if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) :
INDENT ways += 1
DEDENT DEDENT DEDENT DEDENT return ways
DEDENT

DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1 | def eggDrop ( n, k ) :
INDENT eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ]
for i in range ( 1, n + 1 ) :
INDENT eggFloor [ i ] [ 1 ] = 1
eggFloor [ i ] [ 0 ] = 0
DEDENT for j in range ( 1, k + 1 ) :
INDENT eggFloor [ 1 ] [ j ] = j
DEDENT for i in range ( 2, n + 1 ) :
INDENT for j in range ( 2, k + 1 ) :
INDENT eggFloor [ i ] [ j ] = INT_MAX
for x in range ( 1, j + 1 ) :
INDENT res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ], eggFloor [ i ] [ j - x ] )
if res < eggFloor [ i ] [ j ] :
INDENT eggFloor [ i ] [ j ] = res
DEDENT DEDENT DEDENT DEDENT return eggFloor [ n ] [ k ]
DEDENT

WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS | def CountWays ( n ) :
INDENT table = [ 0 ] * ( n + 1 )
table [ 0 ] = 1
for i in range ( 1, n ) :
INDENT for j in range ( i, n + 1 ) :
INDENT table [ j ] += table [ j - i ]
DEDENT DEDENT return table [ n ]
DEDENT

PROGRAM_SUM_COSX_SERIES | def cosXSertiesSum ( x, n ) :
INDENT x = x * ( PI / 180.0 );

res = 1;

sign = 1;

fact = 1;

pow = 1;

for i in range ( 1, 5 ) :
INDENT sign = sign * - 1;

fact = fact * ( 2 * i - 1 ) * ( 2 * i );

pow = pow * x * x;

res = res + sign * pow / fact;

DEDENT return res;

DEDENT

UNIQUE_CELLS_BINARY_MATRIX | def countUnique ( mat, n, m ) :
INDENT rowsum = [ 0 ] * n;

colsum = [ 0 ] * m;

for i in range ( n ) :
INDENT for j in range ( m ) :
INDENT if ( mat [ i ] [ j ] != 0 ) :
INDENT rowsum [ i ] += 1;

colsum [ j ] += 1;

DEDENT DEDENT DEDENT uniquecount = 0;

for i in range ( n ) :
INDENT for j in range ( m ) :
INDENT if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) :
INDENT uniquecount += 1;

DEDENT DEDENT DEDENT return uniquecount;

DEDENT

GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS | def findMin ( V ) :
INDENT deno = [ 1, 2, 5, 10, 20, 50, 100, 500, 1000 ]
n = len ( deno )
ans = [ ]
i = n - 1
while ( i >= 0 ) :
INDENT while ( V >= deno [ i ] ) :
INDENT V -= deno [ i ]
ans . append ( deno [ i ] )
DEDENT i -= 1
DEDENT for i in range ( len ( ans ) ) :
INDENT print ( ans [ i ], end = " " )
DEDENT DEDENT

CHECK_INTEGER_OVERFLOW_MULTIPLICATION | def isOverflow ( a, b ) :
INDENT if ( a == 0 or b == 0 ) :
INDENT return False
DEDENT result = a * b
if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) :
INDENT result = 0
DEDENT if ( a == ( result //b)):
INDENTprint(result//b)
returnFalse
DEDENTelse:
INDENTreturnTrue
DEDENTDEDENT


DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_1 | def findDiff ( arr, n ) :
INDENT mp = defaultdict ( lambda : 0 )
for i in range ( n ) :
INDENT mp [ arr [ i ] ] += 1
DEDENT max_count = 0;
min_count = n
for key, values in mp . items ( ) :
INDENT max_count = max ( max_count, values )
min_count = min ( min_count, values )
DEDENT return max_count - min_count
DEDENT

COMPOSITE_NUMBER | def isComposite ( n ) :
INDENT if ( n <= 1 ) :
INDENT return False
DEDENT if ( n <= 3 ) :
INDENT return False
DEDENT if ( n % 2 == 0 or n % 3 == 0 ) :
INDENT return True
DEDENT i = 5
while ( i * i <= n ) :
INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) :
INDENT return True
DEDENT i = i + 6
DEDENT return False
DEDENT

LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS | def findLIS ( A, n ) :
INDENT hash = dict ( )
LIS_size, LIS_index = 1, 0
hash [ A [ 0 ] ] = 1
for i in range ( 1, n ) :
INDENT if A [ i ] - 1 not in hash :
INDENT hash [ A [ i ] - 1 ] = 0
DEDENT hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1
if LIS_size < hash [ A [ i ] ] :
INDENT LIS_size = hash [ A [ i ] ]
LIS_index = A [ i ]
DEDENT DEDENT print ( "LIS_size =", LIS_size )
print ( "LIS : ", end = "" )
start = LIS_index - LIS_size + 1
while start <= LIS_index :
INDENT print ( start, end = " " )
start += 1
DEDENT DEDENT

COUNT_SET_BITS_IN_AN_INTEGER_2 | def countSetBits ( n ) :
INDENT count = 0
while ( n ) :
INDENT n &= ( n - 1 )
count += 1
DEDENT return count
DEDENT

FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD | def findPairs ( arr, n ) :
Hash = {
}

for i in range ( n - 1 ) :
INDENT for j in range ( i + 1, n ) :
sum = arr [ i ] + arr [ j ]
if sum in Hash . keys ( ) :
INDENT prev = Hash . get ( sum )
print ( str ( prev ) + " and (%d, %d)" % ( arr [ i ], arr [ j ] ) )
return True
DEDENT else :
INDENT Hash [ sum ] = ( arr [ i ], arr [ j ] )
DEDENT DEDENT

COUNT_OBTUSE_ANGLES_CIRCLE_K_EQUIDISTANT_POINTS_2_GIVEN_POINTS | def countObtuseAngles ( a, b, k ) :
INDENT c1 = ( b - a ) - 1
c2 = ( k - b ) + ( a - 1 )
if ( c1 == c2 ) :
INDENT return 0
DEDENT return min ( c1, c2 )
DEDENT

NUMBER_TRIANGLES_N_MOVES_1 | def numberOfTriangles ( n ) :
INDENT ans = 2 * ( pow ( 3, n ) ) - 1;

return ans;

DEDENT

FIND_A_REPEATING_AND_A_MISSING_NUMBER | def printTwoElements ( arr, size ) :
INDENT for i in range ( size ) :
INDENT if arr [ abs ( arr [ i ] ) - 1 ] > 0 :
INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ]
DEDENT else :
INDENT print ( "The repeating element is", abs ( arr [ i ] ) )
DEDENT DEDENT for i in range ( size ) :
INDENT if arr [ i ] > 0 :
INDENT print ( "and the missing element is", i + 1 )
DEDENT DEDENT DEDENT

MINIMUM_DIFFERENCE_BETWEEN_GROUPS_OF_SIZE_TWO | def calculate ( a, n ) :
INDENT a . sort ( );

s = [ ];

i = 0;

j = n - 1;

while ( i < j ) :
INDENT s . append ( ( a [ i ] + a [ j ] ) );

i += 1;

j -= 1;

DEDENT mini = min ( s );

maxi = max ( s );

return abs ( maxi - mini );

DEDENT

FIND_PERIMETER_CYLINDER | def perimeter ( diameter, height ) :
INDENT return 2 * ( diameter + height )
DEDENT

MAGICAL_INDICES_ARRAY | def solve ( A, n ) :
INDENT cnt = 0
parent = [ None ] * ( n + 1 )
vis = [ None ] * ( n + 1 )
for i in range ( 0, n + 1 ) :
INDENT parent [ i ] = - 1
vis [ i ] = 0
DEDENT for i in range ( 0, n ) :
INDENT j = i
if ( parent [ j ] == - 1 ) :
INDENT while ( parent [ j ] == - 1 ) :
INDENT parent [ j ] = i
j = ( j + A [ j ] + 1 ) % n
DEDENT if ( parent [ j ] == i ) :
INDENT while ( vis [ j ] == 0 ) :
INDENT vis [ j ] = 1
cnt = cnt + 1
j = ( j + A [ j ] + 1 ) % n
DEDENT DEDENT DEDENT DEDENT return cnt
DEDENT

FIND_A_FIXED_POINT_IN_A_GIVEN_ARRAY_1 | def binarySearch ( arr, low, high ) :
INDENT if high >= low :
INDENT mid = ( low + high ) //2
DEDENTifmidisarr[mid]:
INDENTreturnmid
DEDENTifmid>arr[mid]:
INDENTreturnbinarySearch(arr,(mid+1),high)
DEDENTelse:
INDENTreturnbinarySearch(arr,low,(mid-1))
DEDENTreturn-1
DEDENT


FIND_SIZE_OF_THE_LARGEST_FORMED_BY_ALL_ONES_IN_A_BINARY_MATRIX | def findLargestPlus ( mat ) :
INDENT left = [ [ 0 for x in range ( N ) ] for y in range ( N ) ]
right = [ [ 0 for x in range ( N ) ] for y in range ( N ) ]
top = [ [ 0 for x in range ( N ) ] for y in range ( N ) ]
bottom = [ [ 0 for x in range ( N ) ] for y in range ( N ) ]
for i in range ( N ) :
INDENT top [ 0 ] [ i ] = mat [ 0 ] [ i ]
bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ]
left [ i ] [ 0 ] = mat [ i ] [ 0 ]
right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ]
DEDENT for i in range ( N ) :
INDENT for j in range ( 1, N ) :
INDENT if ( mat [ i ] [ j ] == 1 ) :
INDENT left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1
DEDENT else :
INDENT left [ i ] [ j ] = 0
DEDENT if ( mat [ j ] [ i ] == 1 ) :
INDENT top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1
DEDENT else :
INDENT top [ j ] [ i ] = 0
DEDENT j = N - 1 - j
if ( mat [ j ] [ i ] == 1 ) :
INDENT bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1
DEDENT else :
INDENT bottom [ j ] [ i ] = 0
DEDENT if ( mat [ i ] [ j ] == 1 ) :
INDENT right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1
DEDENT else :
INDENT right [ i ] [ j ] = 0
DEDENT j = N - 1 - j
DEDENT DEDENT n = 0
for i in range ( N ) :
INDENT for j in range ( N ) :
INDENT l = min ( min ( top [ i ] [ j ], bottom [ i ] [ j ] ), min ( left [ i ] [ j ], right [ i ] [ j ] ) )
if ( l > n ) :
INDENT n = l
DEDENT DEDENT DEDENT if ( n ) :
INDENT return 4 * ( n - 1 ) + 1
DEDENT return 0
DEDENT

LEVEL_NODE_TREE_SOURCE_NODE_USING_BFS | def printLevels ( graph, V, x ) :
INDENT level = [ None ] * V
marked = [ False ] * V
que = queue . Queue ( )
que . put ( x )
level [ x ] = 0
marked [ x ] = True
while ( not que . empty ( ) ) :
INDENT x = que . get ( )
for i in range ( len ( graph [ x ] ) ) :
INDENT b = graph [ x ] [ i ]
if ( not marked [ b ] ) :
INDENT que . put ( b )
level [ b ] = level [ x ] + 1
marked [ b ] = True
DEDENT DEDENT DEDENT print ( "Nodes", " ", "Level" )
for i in range ( V ) :
INDENT print ( " ", i, " --> ", level [ i ] )
DEDENT DEDENT

FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I_3 | def squareRoot ( n, p ) :
INDENT n = n % p
for x in range ( 2, p ) :
INDENT if ( ( x * x ) % p == n ) :
INDENT print ( "Square root is ", x )
return
DEDENT DEDENT print ( "Square root doesn't exist" )
DEDENT

CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE | def areConsecutive ( arr, n ) :
INDENT if ( n < 1 ) :
INDENT return False
DEDENT Min = min ( arr )
Max = max ( arr )
if ( Max - Min + 1 == n ) :
INDENT visited = [ False for i in range ( n ) ]
for i in range ( n ) :
INDENT if ( visited [ arr [ i ] - Min ] != False ) :
INDENT return False
DEDENT visited [ arr [ i ] - Min ] = True
DEDENT return True
DEDENT return False
DEDENT

SMALLEST_SUBSET_SUM_GREATER_ELEMENTS | def minElements ( arr, n ) :
INDENT halfSum = 0
for i in range ( n ) :
INDENT halfSum = halfSum + arr [ i ]
DEDENT halfSum = int ( halfSum / 2 )
arr . sort ( reverse = True )
res = 0
curr_sum = 0
for i in range ( n ) :
INDENT curr_sum += arr [ i ]
res += 1
if curr_sum > halfSum :
INDENT return res
DEDENT DEDENT return res
DEDENT

SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1 | def calculateSum ( n ) :
INDENT sum = 0
sum = 1 << n;

return ( sum - 1 )
DEDENT

SWAP_TWO_NIBBLES_BYTE | def swapNibbles ( x ) :
INDENT return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )
DEDENT

CHECK_CHARACTERS_GIVEN_STRING_CAN_REARRANGED_FORM_PALINDROME_1 | def canFormPalindrome ( strr ) :
INDENT listt = [ ]
for i in range ( len ( strr ) ) :
INDENT if ( strr [ i ] in listt ) :
INDENT listt . remove ( strr [ i ] )
DEDENT else :
INDENT listt . append ( strr [ i ] )
DEDENT DEDENT if ( len ( strr ) % 2 == 0 and len ( listt ) == 0 or \ ( len ( strr ) % 2 == 1 and len ( listt ) == 1 ) ) :
INDENT return True
DEDENT else :
INDENT return False
DEDENT DEDENT

WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER | def countWays ( s ) :
INDENT count = [ 0 ] * 26;

for x in s :
INDENT count [ ord ( x ) - ord ( 'a' ) ] = ( count [ ord ( x ) - ord ( 'a' ) ] ) + 1;

DEDENT count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] = 1;

ans = 1;

for i in range ( 26 ) :
INDENT if ( count [ i ] != 0 ) :
INDENT ans *= count [ i ];

DEDENT DEDENT return ans;

DEDENT

ENTRINGER_NUMBER_1 | def zigzag ( n, k ) :
INDENT dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ]
dp [ 0 ] [ 0 ] = 1
for i in range ( 1, n + 1 ) :
INDENT dp [ i ] [ 0 ] = 0
DEDENT for i in range ( 1, n + 1 ) :
INDENT for j in range ( 1, k + 1 ) :
INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] )
DEDENT DEDENT return dp [ n ] [ k ]
DEDENT

COUNT_PAIRS_DIFFERENCE_EQUAL_K | def countPairsWithDiffK ( arr, n, k ) :
INDENT count = 0
for i in range ( 0, n ) :
INDENT for j in range ( i + 1, n ) :
INDENT if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k :
INDENT count += 1
DEDENT DEDENT DEDENT return count
DEDENT

EXPECTATION_EXPECTED_VALUE_ARRAY | def calc_Expectation ( a, n ) :
INDENT prb = 1 / n
sum = 0
for i in range ( 0, n ) :
INDENT sum += ( a [ i ] * prb )
DEDENT return float ( sum )
DEDENT

GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE | def printGrouped ( string ) :
INDENT n = len ( string )
count = [ 0 ] * MAX_CHAR
for i in range ( n ) :
INDENT count [ ord ( string [ i ] ) - ord ( "a" ) ] += 1
DEDENT for i in range ( n ) :
INDENT while count [ ord ( string [ i ] ) - ord ( "a" ) ] :
INDENT print ( string [ i ], end = "" )
count [ ord ( string [ i ] ) - ord ( "a" ) ] -= 1
DEDENT count [ ord ( string [ i ] ) - ord ( "a" ) ] = 0
DEDENT DEDENT

MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION | def printMaxSum ( arr, n ) :
INDENT dp = [ 0 for i in range ( n ) ]
for i in range ( n ) :
INDENT dp [ i ] = arr [ i ]
maxi = 0
for j in range ( 1, int ( ( i + 1 ) * * 0.5 ) + 1 ) :
INDENT if ( ( i + 1 ) % j == 0 and ( i + 1 ) != j ) :
INDENT if ( dp [ j - 1 ] > maxi ) :
INDENT maxi = dp [ j - 1 ]
DEDENT if ( dp [ ( i + 1 ) //j-1]>maxiandj!=1):
INDENTmaxi=dp[(i+1)//j-1]
DEDENTDEDENTDEDENTdp[i]+=maxi
DEDENTforiinrange(n):
INDENTprint(dp[i],end=' ')
DEDENTDEDENT


PROGRAM_CIRCUMFERENCE_PARALLELOGRAM | def circumferenceparallelogram ( a, b ) :
INDENT return ( ( 2 * a ) + ( 2 * b ) )
DEDENT

COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2 | def numberOfPaths ( p, q ) :
INDENT dp = [ 1 for i in range ( q ) ]
for i in range ( p - 1 ) :
INDENT for j in range ( 1, q ) :
INDENT dp [ j ] += dp [ j - 1 ]
DEDENT DEDENT return dp [ q - 1 ]
DEDENT

REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM | def remAnagram ( str1, str2 ) :
INDENT count1 = [ 0 ] * CHARS
count2 = [ 0 ] * CHARS
i = 0
while i < len ( str1 ) :
INDENT count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1
i += 1
DEDENT i = 0
while i < len ( str2 ) :
INDENT count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1
i += 1
DEDENT result = 0
for i in range ( 26 ) :
INDENT result += abs ( count1 [ i ] - count2 [ i ] )
DEDENT return result
DEDENT

SUM_DIVISORS_1_N_1 | def divisorSum ( n ) :
INDENT sum = 0
for i in range ( 1, n + 1 ) :
INDENT sum += int ( n / i ) * i
DEDENT return int ( sum )
DEDENT

FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_STRING | def maxSubsequenceSubstring ( x, y, n, m ) :
INDENT dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ]
for i in range ( 1, m + 1 ) :
INDENT for j in range ( 1, n + 1 ) :
INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) :
INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]
DEDENT else :
INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ]
DEDENT DEDENT DEDENT ans = 0
for i in range ( 1, m + 1 ) :
INDENT ans = max ( ans, dp [ i ] [ n ] )
DEDENT return ans
DEDENT

SUM_FAI_AJ_PAIRS_ARRAY_N_INTEGERS | def sum ( a, n ) :
INDENT cnt = dict ( )
ans = 0
pre_sum = 0
for i in range ( n ) :
INDENT ans += ( i * a [ i ] ) - pre_sum
pre_sum += a [ i ]
if ( a [ i ] - 1 ) in cnt :
INDENT ans -= cnt [ a [ i ] - 1 ]
DEDENT if ( a [ i ] + 1 ) in cnt :
INDENT ans += cnt [ a [ i ] + 1 ]
DEDENT if a [ i ] not in cnt :
INDENT cnt [ a [ i ] ] = 0
DEDENT cnt [ a [ i ] ] += 1
DEDENT return ans
DEDENT

BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER | def bin ( n ) :
INDENT if n > 1 :
INDENT bin ( n //2)
DEDENTprint(n%2,end="")
DEDENT


KNAPSACK_PROBLEM | def knapSack ( W, wt, val, n ) :
INDENT if n == 0 or W == 0 :
INDENT return 0
DEDENT if ( wt [ n - 1 ] > W ) :
INDENT return knapSack ( W, wt, val, n - 1 )
DEDENT else :
INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ], wt, val, n - 1 ), knapSack ( W, wt, val, n - 1 ) )
DEDENT DEDENT

DOUBLE_FACTORIAL_1 | def doublefactorial ( n ) :
INDENT res = 1;

for i in range ( n, - 1, - 2 ) :
INDENT if ( i == 0 or i == 1 ) :
INDENT return res;

DEDENT else :
INDENT res *= i;

DEDENT DEDENT DEDENT

COUNT_DIGITS_FACTORIAL_SET_2 | def findDigits ( n ) :
INDENT if ( n < 0 ) :
INDENT return 0;

DEDENT if ( n <= 1 ) :
INDENT return 1;

DEDENT x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) );

return math . floor ( x ) + 1;

DEDENT

DELANNOY_NUMBER_1 | def dealnnoy ( n, m ) :
INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ]
for i in range ( m ) :
INDENT dp [ 0 ] [ i ] = 1
DEDENT for i in range ( 1, m + 1 ) :
INDENT dp [ i ] [ 0 ] = 1
DEDENT for i in range ( 1, m + 1 ) :
INDENT for j in range ( 1, n + 1 ) :
INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ];

DEDENT DEDENT return dp [ m ] [ n ]
DEDENT

FIND_THE_MISSING_NUMBER_2 | def getMissingNo ( a, n ) :
INDENT x1 = a [ 0 ]
x2 = 1
for i in range ( 1, n ) :
INDENT x1 = x1 ^ a [ i ]
DEDENT for i in range ( 2, n + 2 ) :
INDENT x2 = x2 ^ i
DEDENT return x1 ^ x2
DEDENT

FIND_NUMBER_OF_TRIANGLES_POSSIBLE | def findnumberofTriangles ( arr ) :
INDENT n = len ( arr )
arr . sort ( )
count = 0
for i in range ( 0, n - 2 ) :
INDENT k = i + 2
for j in range ( i + 1, n ) :
INDENT while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) :
INDENT k += 1
DEDENT if ( k > j ) :
INDENT count += k - j - 1
DEDENT DEDENT DEDENT return count
DEDENT

NUMBER_TRIANGLES_N_MOVES | def numberOfTriangles ( n ) :
INDENT answer = [ None ] * ( n + 1 );

answer [ 0 ] = 1;

i = 1
while i <= n :
INDENT answer [ i ] = answer [ i - 1 ] * 3 + 2;

i = i + 1
DEDENT return answer [ n ];

DEDENT

CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX | def areSumSame ( a, n, m ) :
INDENT sum1 = 0
sum2 = 0
for i in range ( 0, n ) :
INDENT sum1 = 0
sum2 = 0
for j in range ( 0, m ) :
INDENT sum1 += a [ i ] [ j ]
sum2 += a [ j ] [ i ]
DEDENT if ( sum1 == sum2 ) :
INDENT return 1
DEDENT DEDENT return 0
DEDENT

WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TWO | def isPowerOfTwo ( n ) :
INDENT if ( n == 0 ) :
INDENT return False
DEDENT while ( n != 1 ) :
INDENT if ( n % 2 != 0 ) :
INDENT return False
DEDENT n = n //2
DEDENTreturnTrue
DEDENT


PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS | def amendSentence ( string ) :
INDENT string = list ( string )
for i in range ( len ( string ) ) :
INDENT if string [ i ] >= 'A' and string [ i ] <= 'Z' :
INDENT string [ i ] = chr ( ord ( string [ i ] ) + 32 )
if i != 0 :
INDENT print ( " ", end = "" )
DEDENT print ( string [ i ], end = "" )
DEDENT else :
INDENT print ( string [ i ], end = "" )
DEDENT DEDENT DEDENT

CHECK_DIVISIBILITY_BINARY_STRING_2K | def isDivisible ( str, k ) :
INDENT n = len ( str )
c = 0
for i in range ( 0, k ) :
INDENT if ( str [ n - i - 1 ] == '0' ) :
INDENT c += 1
DEDENT DEDENT return ( c == k )
DEDENT

SUBSEQUENCES_SIZE_THREE_ARRAY_WHOSE_SUM_DIVISIBLE_M | def coutSubSeq ( A, N, M ) :
INDENT sum = 0
ans = 0
for i in range ( 0, N ) :
INDENT for j in range ( i + 1, N ) :
INDENT for k in range ( j + 1, N ) :
INDENT sum = A [ i ] + A [ j ] + A [ k ]
if ( sum % M == 0 ) :
INDENT ans = ans + 1
DEDENT DEDENT DEDENT DEDENT return ans
DEDENT

LONGEST_CONSECUTIVE_SUBSEQUENCE | def findLongestConseqSubseq ( arr, n ) :
INDENT s = Set ( )
ans = 0
for ele in arr :
INDENT s . add ( ele )
DEDENT for i in range ( n ) :
INDENT if ( arr [ i ] - 1 ) not in s :
INDENT j = arr [ i ]
while ( j in s ) :
INDENT j += 1
DEDENT ans = max ( ans, j - arr [ i ] )
DEDENT DEDENT return ans
DEDENT

FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME_1 | def findIndex ( n ) :
INDENT fibo = 2.078087 * math . log ( n ) + 1.672276
return round ( fibo )
DEDENT

LARGEST_DIVISIBLE_PAIRS_SUBSET | def largestSubset ( a, n ) :
INDENT a . sort ( )
dp = [ 0 for i in range ( n ) ]
dp [ n - 1 ] = 1;

for i in range ( n - 2, - 1, - 1 ) :
INDENT mxm = 0;

for j in range ( i + 1, n ) :
INDENT if a [ j ] % a [ i ] == 0 :
INDENT mxm = max ( mxm, dp [ j ] )
DEDENT DEDENT dp [ i ] = 1 + mxm
DEDENT return max ( dp )
DEDENT

FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2 | def isPowerOfFour ( n ) :
INDENT return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0xAAAAAAAA ) );

DEDENT

COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLUTION | def nCrModp ( n, r, p ) :
INDENT C = [ 0 for i in range ( r + 1 ) ]
C [ 0 ] = 1
for i in range ( 1, n + 1 ) :
INDENT for j in range ( min ( i, r ), 0, - 1 ) :
INDENT C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p
DEDENT DEDENT return C [ r ]
DEDENT

ROUND_THE_GIVEN_NUMBER_TO_NEAREST_MULTIPLE_OF_10 | def round ( n ) :
INDENT a = ( n //10)*10
b=a+10
return(bifn-a>b-nelsea)
DEDENT


SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING_ORDER_1 | def twoWaySort ( arr, n ) :
INDENT for i in range ( 0, n ) :
INDENT if ( arr [ i ] & 1 ) :
INDENT arr [ i ] *= - 1
DEDENT DEDENT arr . sort ( )
for i in range ( 0, n ) :
INDENT if ( arr [ i ] & 1 ) :
INDENT arr [ i ] *= - 1
DEDENT DEDENT DEDENT

POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS | def pointClip ( XY, n, Xmin, Ymin, Xmax, Ymax ) :
INDENT print ( "Point inside the viewing pane:" )
for i in range ( n ) :
INDENT if ( ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ] <= Xmax ) ) :
INDENT if ( ( XY [ i ] [ 1 ] >= Ymin ) and ( XY [ i ] [ 1 ] <= Ymax ) ) :
INDENT print ( "[", XY [ i ] [ 0 ], ", ", XY [ i ] [ 1 ], "]", sep = "", end = " " )
DEDENT DEDENT DEDENT print ( "\n\nPoint outside the viewing pane:" )
for i in range ( n ) :
INDENT if ( ( XY [ i ] [ 0 ] < Xmin ) or ( XY [ i ] [ 0 ] > Xmax ) ) :
INDENT print ( "[", XY [ i ] [ 0 ], ", ", XY [ i ] [ 1 ], "]", sep = "", end = " " )
DEDENT if ( ( XY [ i ] [ 1 ] < Ymin ) or ( XY [ i ] [ 1 ] > Ymax ) ) :
INDENT print ( "[", XY [ i ] [ 0 ], ", ", XY [ i ] [ 1 ], "]", sep = "", end = " " )
DEDENT DEDENT DEDENT

WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS | def countTransformation ( a, b ) :
INDENT n = len ( a )
m = len ( b )
if m == 0 :
INDENT return 1
DEDENT dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ]
for i in range ( m ) :
INDENT for j in range ( i, n ) :
INDENT if i == 0 :
INDENT if j == 0 :
INDENT if a [ j ] == b [ i ] :
INDENT dp [ i ] [ j ] = 1
DEDENT else :
INDENT dp [ i ] [ j ] = 0
DEDENT DEDENT elif a [ j ] == b [ i ] :
INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1
DEDENT else :
INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ]
DEDENT DEDENT else :
INDENT if a [ j ] == b [ i ] :
INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] )
DEDENT else :
INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ]
DEDENT DEDENT DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ]
DEDENT

FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS | def relativeComplement ( arr1, arr2, n, m ) :
INDENT i = 0
j = 0
while ( i < n and j < m ) :
INDENT if ( arr1 [ i ] < arr2 [ j ] ) :
INDENT print ( arr1 [ i ], " ", end = "" )
i += 1
DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) :
INDENT j += 1
DEDENT elif ( arr1 [ i ] == arr2 [ j ] ) :
INDENT i += 1
j += 1
DEDENT DEDENT while ( i < n ) :
INDENT print ( arr1 [ i ], " ", end = "" )
DEDENT DEDENT

COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY | def countPairs ( arr, n ) :
INDENT ans = 0
for i in range ( 0, n ) :
INDENT for j in range ( i + 1, n ) :
INDENT if ( arr [ i ] == arr [ j ] ) :
INDENT ans += 1
DEDENT DEDENT DEDENT return ans
DEDENT

GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT | def findSymPairs ( arr, row ) :
INDENT hM = dict ( )
for i in range ( row ) :
INDENT first = arr [ i ] [ 0 ]
sec = arr [ i ] [ 1 ]
if ( sec in hM . keys ( ) and hM [ sec ] == first ) :
INDENT print ( "(", sec, ",", first, ")" )
DEDENT else :
INDENT hM [ first ] = sec
DEDENT DEDENT DEDENT

COUNT_SUBSEQUENCES_PRODUCT_LESS_K | def productSubSeqCount ( arr, k ) :
INDENT n = len ( arr )
dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ]
for i in range ( 1, k + 1 ) :
INDENT for j in range ( 1, n + 1 ) :
INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ]
if arr [ j - 1 ] <= i and arr [ j - 1 ] > 0 :
INDENT dp [ i ] [ j ] += dp [ i //arr[j-1]][j-1]+1
DEDENTDEDENTDEDENTreturndp[k][n]
DEDENT


REARRANGE_ARRAY_ARRI_ARRJ_EVEN_ARRI | def rearrangeArr ( arr, n ) :
INDENT evenPos = int ( n / 2 )
oddPos = n - evenPos
tempArr = np . empty ( n, dtype = object )
for i in range ( 0, n ) :
INDENT tempArr [ i ] = arr [ i ]
DEDENT tempArr . sort ( )
j = oddPos - 1
for i in range ( 0, n, 2 ) :
INDENT arr [ i ] = tempArr [ j ]
j = j - 1
DEDENT j = oddPos
for i in range ( 1, n, 2 ) :
INDENT arr [ i ] = tempArr [ j ]
j = j + 1
DEDENT for i in range ( 0, n ) :
INDENT print ( arr [ i ], end = ' ' )
DEDENT DEDENT

MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK | def minRotation ( input, unlock_code ) :
INDENT rotation = 0;

while ( input > 0 or unlock_code > 0 ) :
INDENT input_digit = input % 10;

code_digit = unlock_code % 10;

rotation += min ( abs ( input_digit - code_digit ), 10 - abs ( input_digit - code_digit ) );

input = int ( input / 10 );

unlock_code = int ( unlock_code / 10 );

DEDENT return rotation;

DEDENT

REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES | def arrangeString ( str1, x, y ) :
INDENT count_0 = 0
count_1 = 0
n = len ( str1 )
for i in range ( n ) :
INDENT if str1 [ i ] == '0' :
INDENT count_0 += 1
DEDENT else :
INDENT count_1 += 1
DEDENT DEDENT while count_0 > 0 or count_1 > 0 :
INDENT for i in range ( 0, x ) :
INDENT if count_0 > 0 :
INDENT print ( "0", end = "" )
count_0 -= 1
DEDENT DEDENT for j in range ( 0, y ) :
INDENT if count_1 > 0 :
INDENT print ( "1", end = "" )
count_1 -= 1
DEDENT DEDENT DEDENT DEDENT

DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE | def maxSumIS ( arr, n ) :
INDENT max = 0
msis = [ 0 for x in range ( n ) ]
for i in range ( n ) :
INDENT msis [ i ] = arr [ i ]
DEDENT for i in range ( 1, n ) :
INDENT for j in range ( i ) :
INDENT if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) :
INDENT msis [ i ] = msis [ j ] + arr [ i ]
DEDENT DEDENT DEDENT for i in range ( n ) :
INDENT if max < msis [ i ] :
INDENT max = msis [ i ]
DEDENT DEDENT return max
DEDENT

NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES | def countRect ( n ) :
INDENT ans = 0
for length in range ( 1, int ( math . sqrt ( n ) ) + 1 ) :
INDENT height = length
while ( height * length <= n ) :
INDENT ans += 1
height += 1
DEDENT DEDENT return ans
DEDENT

PROGRAM_TO_PRINT_TETRAHEDRAL_NUMBERS_UPTO_NTH_TERM | def printSeries ( n ) :
INDENT for i in range ( 1, n + 1 ) :
INDENT num = i * ( i + 1 ) * ( i + 2 ) //6
print(num,end=' ')
DEDENTDEDENT


PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX | def transpose ( A, B ) :
INDENT for i in range ( N ) :
INDENT for j in range ( N ) :
INDENT B [ i ] [ j ] = A [ j ] [ i ]
DEDENT DEDENT DEDENT

PROGRAM_DECIMAL_BINARY_CONVERSION_1 | def decToBinary ( n ) :
INDENT for i in range ( 31, - 1, - 1 ) :
INDENT k = n >> i;

if ( k & 1 ) :
INDENT print ( "1", end = "" );

DEDENT else :
INDENT print ( "0", end = "" );

DEDENT DEDENT DEDENT

REARRANGE_ARRAY_ORDER_SMALLEST_LARGEST_2ND_SMALLEST_2ND_LARGEST | def rearrangeArray ( arr, n ) :
INDENT arr . sort ( )
tempArr = [ 0 ] * ( n + 1 )
ArrIndex = 0
i = 0
j = n - 1
while ( i <= n //2orj>n//2):
INDENTtempArr[ArrIndex]=arr[i]
ArrIndex=ArrIndex+1
tempArr[ArrIndex]=arr[j]
ArrIndex=ArrIndex+1
i=i+1
j=j-1
DEDENTforiinrange(0,n):
INDENTarr[i]=tempArr[i]
DEDENTDEDENT


SUM_AREA_RECTANGLES_POSSIBLE_ARRAY | def MaxTotalRectangleArea ( a, n ) :
INDENT a . sort ( reverse = True )
sum = 0
flag = False
len = 0
i = 0
while ( i < n - 1 ) :
INDENT if ( i != 0 ) :
INDENT i = i + 1
DEDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) :
INDENT flag = True
len = a [ i + 1 ]
i = i + 1
DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) :
INDENT sum = sum + a [ i + 1 ] * len
flag = False
i = i + 1
DEDENT DEDENT return sum
DEDENT

GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1 | def countSubStr ( st, n ) :
INDENT res = 0
for i in range ( 0, n ) :
INDENT if ( st [ i ] == '1' ) :
INDENT for j in range ( i + 1, n ) :
INDENT if ( st [ j ] == '1' ) :
INDENT res = res + 1
DEDENT DEDENT DEDENT DEDENT return res
DEDENT

DYNAMIC_PROGRAMMING_SET_31_OPTIMAL_STRATEGY_FOR_A_GAME | def optimalStrategyOfGame ( arr, n ) :
INDENT table = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]
for gap in range ( n ) :
INDENT for j in range ( gap, n ) :
INDENT i = j - gap
x = 0
if ( ( i + 2 ) <= j ) :
INDENT x = table [ i + 2 ] [ j ]
DEDENT y = 0
if ( ( i + 1 ) <= ( j - 1 ) ) :
INDENT y = table [ i + 1 ] [ j - 1 ]
DEDENT z = 0
if ( i <= ( j - 2 ) ) :
INDENT z = table [ i ] [ j - 2 ]
DEDENT table [ i ] [ j ] = max ( arr [ i ] + min ( x, y ), arr [ j ] + min ( y, z ) )
DEDENT DEDENT return table [ 0 ] [ n - 1 ]
DEDENT

REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S | def replace ( s, c1, c2 ) :
INDENT l = len ( s )
for i in range ( l ) :
INDENT if ( s [ i ] == c1 ) :
INDENT s = s [ 0 : i ] + c2 + s [ i + 1 : ]
DEDENT elif ( s [ i ] == c2 ) :
INDENT s = s [ 0 : i ] + c1 + s [ i + 1 : ]
DEDENT DEDENT return s
DEDENT

FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1 | def maxLen ( arr ) :
INDENT hash_map = {
}

max_len = 0
curr_sum = 0
for i in range ( len ( arr ) ) :
INDENT curr_sum += arr [ i ]
if arr [ i ] is 0 and max_len is 0 :
INDENT max_len = 1
DEDENT if curr_sum is 0 :
INDENT max_len = i + 1
DEDENT if curr_sum in hash_map :
INDENT max_len = max ( max_len, i - hash_map [ curr_sum ] )
DEDENT else :
INDENT hash_map [ curr_sum ] = i
DEDENT DEDENT return max_len
DEDENT

PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1 | def summingSeries ( n ) :
INDENT return math . pow ( n, 2 )
DEDENT

RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY | def recSearch ( arr, l, r, x ) :
INDENT if r < l :
INDENT return - 1
DEDENT if arr [ l ] == x :
INDENT return l
DEDENT if arr [ r ] == x :
INDENT return r
DEDENT return recSearch ( arr, l + 1, r - 1, x )
DEDENT

PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN | def printPath ( str ) :
INDENT i = 0
curX = 0
curY = 0
while ( i < len ( str ) ) :
INDENT nextX = int ( ( ord ( str [ i ] ) - ord ( 'A' ) ) / 5 )
nextY = ( ord ( str [ i ] ) - ord ( 'B' ) + 1 ) % 5
while ( curX > nextX ) :
INDENT print ( "Move Up" )
curX -= 1
DEDENT while ( curY > nextY ) :
INDENT print ( "Move Left" )
curY -= 1
DEDENT while ( curX < nextX ) :
INDENT print ( "Move Down" )
curX += 1
DEDENT while ( curY < nextY ) :
INDENT print ( "Move Right" )
curY += 1
DEDENT print ( "Press OK" )
i += 1
DEDENT DEDENT

COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX | def count ( n, x ) :
INDENT cnt = 0
for i in range ( 1, n + 1 ) :
INDENT if i <= x :
INDENT if x //i<=nandx%i==0:
INDENTcnt+=1
DEDENTDEDENTDEDENTreturncnt
DEDENT


PROGRAM_FIND_LINE_PASSING_2_POINTS | def lineFromPoints ( P, Q ) :
INDENT a = Q [ 1 ] - P [ 1 ]
b = P [ 0 ] - Q [ 0 ]
c = a * ( P [ 0 ] ) + b * ( P [ 1 ] )
if ( b < 0 ) :
INDENT print ( "The line passing through points P and Q is:", a, "x ", b, "y = ", c, "\n" )
DEDENT else :
INDENT print ( "The line passing through points P and Q is: ", a, "x + ", b, "y = ", c, "\n" )
DEDENT DEDENT

REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT | def solve ( dp, a, low, high, turn ) :
INDENT if ( low == high ) :
INDENT return a [ low ] * turn
DEDENT if ( dp [ low ] [ high ] != 0 ) :
INDENT return dp [ low ] [ high ]
DEDENT dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp, a, low + 1, high, turn + 1 ), a [ high ] * turn + solve ( dp, a, low, high - 1, turn + 1 ) );

return dp [ low ] [ high ]
DEDENT

CHECK_GRAPHS_CYCLE_ODD_LENGTH | def containsOdd ( G, src ) :
INDENT global V
colorArr = [ - 1 ] * V
colorArr [ src ] = 1
q = queue . Queue ( )
q . put ( src )
while ( not q . empty ( ) ) :
INDENT u = q . get ( )
if ( G [ u ] [ u ] == 1 ) :
INDENT return True
DEDENT for v in range ( V ) :
INDENT if ( G [ u ] [ v ] and colorArr [ v ] == - 1 ) :
INDENT colorArr [ v ] = 1 - colorArr [ u ]
q . put ( v )
DEDENT elif ( G [ u ] [ v ] and colorArr [ v ] == colorArr [ u ] ) :
INDENT return True
DEDENT DEDENT DEDENT return False
DEDENT

SUM_SERIES_ALTERNATE_SIGNED_SQUARES_AP | def seiresSum ( n, a ) :
INDENT res = 0
for i in range ( 0, 2 * n ) :
INDENT if ( i % 2 == 0 ) :
INDENT res += a [ i ] * a [ i ]
DEDENT else :
INDENT res -= a [ i ] * a [ i ]
DEDENT DEDENT return res
DEDENT

PROGRAM_DECIMAL_BINARY_CONVERSION | def decToBinary ( n ) :
INDENT binaryNum = [ 0 ] * n;

i = 0;

while ( n > 0 ) :
INDENT binaryNum [ i ] = n % 2;

n = int ( n / 2 );

i += 1;

DEDENT for j in range ( i - 1, - 1, - 1 ) :
INDENT print ( binaryNum [ j ], end = "" );

DEDENT DEDENT

LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY_INDEX | def longestAlternating ( arr, n ) :
INDENT count = [ None ] * n
count [ n - 1 ] = 1
i = n - 2
while i >= 0 :
INDENT if ( arr [ i ] * arr [ i + 1 ] < 0 ) :
INDENT count [ i ] = count [ i + 1 ] + 1
DEDENT else :
INDENT count [ i ] = 1;

DEDENT i = i - 1
DEDENT i = 0
while i < n :
INDENT print ( count [ i ], end = " " )
i = i + 1
DEDENT DEDENT

FIND_STRING_LEXICOGRAPHIC_ORDER_GIVEN_TWO_STRINGS | def lexNext ( s, n ) :
INDENT for i in range ( n - 1, - 1, - 1 ) :
INDENT if s [ i ] != 'z' :
INDENT k = ord ( s [ i ] )
s [ i ] = chr ( k + 1 )
return '' . join ( s )
DEDENT s [ i ] = 'a'
DEDENT DEDENT

NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE | def getNumStrictMonotone ( ln ) :
INDENT DP = [ [ 0 ] * DP_s for _ in range ( ln ) ]
for i in range ( DP_s ) :
INDENT DP [ 0 ] [ i ] = i + 1
DEDENT for i in range ( 1, ln ) :
INDENT for j in range ( 1, DP_s ) :
INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ]
DEDENT DEDENT return DP [ ln - 1 ] [ DP_s - 1 ]
DEDENT

PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES | def constructTree ( n, d, h ) :
INDENT if d == 1 :
INDENT if n == 2 and h == 1 :
INDENT print ( "1 2" )
return 0
DEDENT print ( "-1" )
return 0
DEDENT if d > 2 * h :
INDENT print ( "-1" )
return 0
DEDENT for i in range ( 1, h + 1 ) :
INDENT print ( i, " ", i + 1 )
DEDENT if d > h :
INDENT print ( 1, "  ", h + 2 )
for i in range ( h + 2, d + 1 ) :
INDENT print ( i, " ", i + 1 )
DEDENT DEDENT for i in range ( d + 1, n ) :
INDENT k = 1
if d == h :
INDENT k = 2
DEDENT print ( k, " ", i + 1 )
DEDENT DEDENT

MINIMAL_OPERATIONS_MAKE_NUMBER_MAGICAL | def calculate ( s ) :
INDENT ans = 6
for i in range ( 10 ) :
INDENT for j in range ( 10 ) :
INDENT for k in range ( 10 ) :
INDENT for l in range ( 10 ) :
INDENT for m in range ( 10 ) :
INDENT for n in range ( 10 ) :
INDENT if ( i + j + k == l + m + n ) :
INDENT c = 0
if ( i != ord ( s [ 0 ] ) - ord ( '0' ) ) :
INDENT c += 1
DEDENT if ( j != ord ( s [ 1 ] ) - ord ( '0' ) ) :
INDENT c += 1
DEDENT if ( k != ord ( s [ 2 ] ) - ord ( '0' ) ) :
INDENT c += 1
DEDENT if ( l != ord ( s [ 3 ] ) - ord ( '0' ) ) :
INDENT c += 1
DEDENT if ( m != ord ( s [ 4 ] ) - ord ( '0' ) ) :
INDENT c += 1
DEDENT if ( n != ord ( s [ 5 ] ) - ord ( '0' ) ) :
INDENT c += 1
DEDENT if ( c < ans ) :
INDENT ans = c
DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans
DEDENT

FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE | def find3Numbers ( A, arr_size, sum ) :
INDENT for i in range ( 0, arr_size - 2 ) :
INDENT for j in range ( i + 1, arr_size - 1 ) :
INDENT for k in range ( j + 1, arr_size ) :
INDENT if A [ i ] + A [ j ] + A [ k ] == sum :
INDENT print ( "Triplet is", A [ i ], ", ", A [ j ], ", ", A [ k ] )
return True
DEDENT DEDENT DEDENT DEDENT return False
DEDENT

AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_IN_IT | def getArea ( a ) :
INDENT area = ( math . pi * a * a ) / 4
return area
DEDENT

GIVEN_TWO_UNSORTED_ARRAYS_FIND_PAIRS_WHOSE_SUM_X_1 | def findPairs ( arr1, arr2, n, m, x ) :
INDENT s = set ( )
for i in range ( 0, n ) :
INDENT s . add ( arr1 [ i ] )
DEDENT for j in range ( 0, m ) :
INDENT if ( ( x - arr2 [ j ] ) in s ) :
INDENT print ( ( x - arr2 [ j ] ), '', arr2 [ j ] )
DEDENT DEDENT DEDENT

QUICK_WAY_CHECK_CHARACTERS_STRING | def allCharactersSame ( s ) :
INDENT n = len ( s )
for i in range ( 1, n ) :
INDENT if s [ i ] != s [ 0 ] :
INDENT return False
DEDENT DEDENT return True
DEDENT

REARRANGE_ARRAY_ARRI | def fix ( A, len ) :
INDENT for i in range ( 0, len ) :
INDENT if ( A [ i ] != - 1 and A [ i ] != i ) :
INDENT x = A [ i ];

while ( A [ x ] != - 1 and A [ x ] != x ) :
INDENT y = A [ x ]
A [ x ] = x
x = y
DEDENT A [ x ] = x;

if ( A [ i ] != i ) :
INDENT A [ i ] = - 1;

DEDENT DEDENT DEDENT DEDENT

PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS | def isProduct ( arr, n, x ) :
INDENT for i in arr :
INDENT for j in arr :
INDENT if i * j == x :
INDENT return True
DEDENT DEDENT DEDENT return False
DEDENT

SORT_GIVEN_STRING_USING_CHARACTER_SEARCH | def sortString ( str, n ) :
INDENT new_str = ""
for i in range ( ord ( 'a' ), ord ( 'z' ) + 1 ) :
INDENT for j in range ( n ) :
INDENT if ( str [ j ] == chr ( i ) ) :
INDENT new_str += str [ j ]
DEDENT DEDENT DEDENT return new_str
DEDENT

COUNT_OF_OCCURRENCES_OF_A_101_PATTERN_IN_A_STRING | def countPattern ( s ) :
INDENT length = len ( s )
oneSeen = False
count = 0
for i in range ( length ) :
INDENT if ( s [ i ] == '1' and oneSeen ) :
INDENT if ( s [ i - 1 ] == '0' ) :
INDENT count += 1
DEDENT DEDENT if ( s [ i ] == '1' and oneSeen == 0 ) :
INDENT oneSeen = True
DEDENT if ( s [ i ] != '0' and s [ i ] != '1' ) :
INDENT oneSeen = False
DEDENT DEDENT return count
DEDENT

C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE | def rotate ( arr, n ) :
INDENT x = arr [ n - 1 ]
for i in range ( n - 1, 0, - 1 ) :
INDENT arr [ i ] = arr [ i - 1 ];

DEDENT arr [ 0 ] = x;

DEDENT

QUEUE_BASED_APPROACH_FOR_FIRST_NON_REPEATING_CHARACTER_IN_A_STREAM | def firstnonrepeating ( Str ) :
INDENT global MAX_CHAR
q = Queue ( )
charCount = [ 0 ] * MAX_CHAR
for i in range ( len ( Str ) ) :
INDENT q . put ( Str [ i ] )
charCount [ ord ( Str [ i ] ) - ord ( 'a' ) ] += 1
while ( not q . empty ( ) ) :
INDENT if ( charCount [ ord ( q . queue [ 0 ] ) - ord ( 'a' ) ] > 1 ) :
INDENT q . get ( )
DEDENT else :
INDENT print ( q . queue [ 0 ], end = " " )
break
DEDENT DEDENT if ( q . empty ( ) ) :
INDENT print ( - 1, end = " " )
DEDENT DEDENT print ( )
DEDENT

CHECK_LARGE_NUMBER_DIVISIBLE_6_NOT | def check ( st ) :
INDENT n = len ( st )
if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) :
INDENT return False
DEDENT digitSum = 0
for i in range ( 0, n ) :
INDENT digitSum = digitSum + ( int ) ( st [ i ] )
DEDENT return ( digitSum % 3 == 0 )
DEDENT

MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N | def getMinSquares ( n ) :
INDENT if n <= 3 :
INDENT return n;

DEDENT res = n
for x in range ( 1, n + 1 ) :
INDENT temp = x * x;

if temp > n :
INDENT break
DEDENT else :
INDENT res = min ( res, 1 + getMinSquares ( n - temp ) )
DEDENT DEDENT return res;

DEDENT

OVERLAPPING_SUM_TWO_ARRAY | def findSum ( A, B, n ) :
INDENT Hash = defaultdict ( lambda : 0 )
for i in range ( 0, n ) :
INDENT Hash [ A [ i ] ] += 1
Hash [ B [ i ] ] += 1
DEDENT Sum = 0
for x in Hash :
INDENT if Hash [ x ] == 1 :
INDENT Sum += x
DEDENT DEDENT return Sum
DEDENT

MOBILE_NUMERIC_KEYPAD_PROBLEM | def getCount ( keypad, n ) :
INDENT if ( not keypad or n <= 0 ) :
INDENT return 0
DEDENT if ( n == 1 ) :
INDENT return 10
DEDENT odd = [ 0 ] * 10
even = [ 0 ] * 10
i = 0
j = 0
useOdd = 0
totalCount = 0
for i in range ( 10 ) :
INDENT odd [ i ] = 1
DEDENT for j in range ( 2, n + 1 ) :
INDENT useOdd = 1 - useOdd
if ( useOdd == 1 ) :
INDENT even [ 0 ] = odd [ 0 ] + odd [ 8 ]
even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ]
even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ]
even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ]
even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ]
even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ]
even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ]
even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ]
even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ]
even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ]
DEDENT else :
INDENT odd [ 0 ] = even [ 0 ] + even [ 8 ]
odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ]
odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ]
odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ]
odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ]
odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ]
odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ]
odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ]
odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ]
odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ]
DEDENT DEDENT totalCount = 0
if ( useOdd == 1 ) :
INDENT for i in range ( 10 ) :
INDENT totalCount += even [ i ]
DEDENT DEDENT else :
INDENT for i in range ( 10 ) :
INDENT totalCount += odd [ i ]
DEDENT DEDENT return totalCount
DEDENT

FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY | def findLarger ( arr, n ) :
INDENT x = sorted ( arr )
for i in range ( n / 2, n ) :
INDENT print ( x [ i ] ),
DEDENT DEDENT

SUM_BINOMIAL_COEFFICIENTS | def binomialCoeffSum ( n ) :
INDENT C = [ [ 0 ] * ( n + 2 ) for i in range ( 0, n + 2 ) ]
for i in range ( 0, n + 1 ) :
INDENT for j in range ( 0, min ( i, n ) + 1 ) :
INDENT if ( j == 0 or j == i ) :
INDENT C [ i ] [ j ] = 1
DEDENT else :
INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]
DEDENT DEDENT DEDENT sum = 0
for i in range ( 0, n + 1 ) :
INDENT sum += C [ n ] [ i ]
DEDENT return sum
DEDENT

FIND_COMMON_ELEMENT_ROWS_ROW_WISE_SORTED_MATRIX_1 | def findCommon ( mat ) :
INDENT global M
global N
cnt = dict ( )
cnt = defaultdict ( lambda : 0, cnt )
i = 0
j = 0
while ( i < M ) :
INDENT cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1
j = 1
while ( j < N ) :
INDENT if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) :
INDENT cnt [ mat [ i ] [ j ] ] = cnt [ mat [ i ] [ j ] ] + 1
DEDENT j = j + 1
DEDENT i = i + 1
DEDENT for ele in cnt :
INDENT if ( cnt [ ele ] == M ) :
INDENT return ele
DEDENT DEDENT return - 1
DEDENT

SIEVE_ERATOSTHENES_0N_TIME_COMPLEXITY | def manipulated_seive ( N ) :
INDENT isprime [ 0 ] = isprime [ 1 ] = False
for i in range ( 2, N ) :
INDENT if isprime [ i ] == True :
INDENT prime . append ( i )
SPF [ i ] = i
DEDENT j = 0
while ( j < len ( prime ) and i * prime [ j ] < N and prime [ j ] <= SPF [ i ] ) :
INDENT isprime [ i * prime [ j ] ] = False
SPF [ i * prime [ j ] ] = prime [ j ]
j += 1
DEDENT DEDENT DEDENT

COUNT_SORTED_ROWS_MATRIX | def sortedCount ( mat, r, c ) :
INDENT result = 0
for i in range ( r ) :
INDENT j = 0
for j in range ( c - 1 ) :
INDENT if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] :
INDENT break
DEDENT DEDENT if j == c - 2 :
INDENT result += 1
DEDENT DEDENT for i in range ( 0, r ) :
INDENT j = 0
for j in range ( c - 1, 0, - 1 ) :
INDENT if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] :
INDENT break
DEDENT DEDENT if c > 1 and j == 1 :
INDENT result += 1
DEDENT DEDENT return result
DEDENT

NUMBER_WAYS_NODE_MAKE_LOOP_SIZE_K_UNDIRECTED_COMPLETE_CONNECTED_GRAPH_N_NODES | def numOfways ( n, k ) :
INDENT p = 1
if ( k % 2 ) :
INDENT p = - 1
DEDENT return ( pow ( n - 1, k ) + p * ( n - 1 ) ) / n
DEDENT

DICE_THROW_PROBLEM | def findWays ( m, n, x ) :
INDENT table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ]
for j in range ( 1, min ( m + 1, x + 1 ) ) :
INDENT table [ 1 ] [ j ] = 1
DEDENT for i in range ( 2, n + 1 ) :
INDENT for j in range ( 1, x + 1 ) :
INDENT for k in range ( 1, min ( m + 1, j ) ) :
INDENT table [ i ] [ j ] += table [ i - 1 ] [ j - k ]
DEDENT DEDENT DEDENT return table [ - 1 ] [ - 1 ]
DEDENT

MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2 | def getLevenstein ( inpt ) :
INDENT revInput = inpt [ : : - 1 ]
n = len ( inpt )
dp = [ [ - 1 for _ in range ( n + 1 ) ] for __ in range ( n + 1 ) ]
for i in range ( n + 1 ) :
INDENT dp [ 0 ] [ i ] = i
dp [ i ] [ 0 ] = i
DEDENT for i in range ( 1, n + 1 ) :
INDENT for j in range ( 1, n + 1 ) :
INDENT if inpt [ i - 1 ] == revInput [ j - 1 ] :
INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]
DEDENT else :
INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] )
DEDENT DEDENT DEDENT res = INT_MAX
i, j = n, 0
while i >= 0 :
INDENT res = min ( res, dp [ i ] [ j ] )
if i < n :
INDENT res = min ( res, dp [ i + 1 ] [ j ] )
DEDENT if i > 0 :
INDENT res = min ( res, dp [ i - 1 ] [ j ] )
DEDENT i -= 1
j += 1
DEDENT return res
DEDENT

DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM | def countParenth ( symb, oper, n ) :
INDENT F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]
T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]
for i in range ( n ) :
INDENT if symb [ i ] == 'F' :
INDENT F [ i ] [ i ] = 1
DEDENT else :
INDENT F [ i ] [ i ] = 0
DEDENT if symb [ i ] == 'T' :
INDENT T [ i ] [ i ] = 1
DEDENT else :
INDENT T [ i ] [ i ] = 0
DEDENT DEDENT for gap in range ( 1, n ) :
INDENT i = 0
for j in range ( gap, n ) :
INDENT T [ i ] [ j ] = F [ i ] [ j ] = 0
for g in range ( gap ) :
INDENT k = i + g
tik = T [ i ] [ k ] + F [ i ] [ k ];

tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ];

if oper [ k ] == '&' :
INDENT T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]
F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )
DEDENT if oper [ k ] == '|' :
INDENT F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]
T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )
DEDENT if oper [ k ] == '^' :
INDENT T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )
F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )
DEDENT DEDENT i += 1
DEDENT DEDENT return T [ 0 ] [ n - 1 ]
DEDENT

PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE_1 | def Circumference ( l, w ) :
INDENT return ( 2 * ( l + w ) )
DEDENT

THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1 | def thirdLargest ( arr, arr_size ) :
INDENT if ( arr_size < 3 ) :
INDENT print ( " Invalid Input " )
return
DEDENT first = arr [ 0 ]
second = - sys . maxsize
third = - sys . maxsize
for i in range ( 1, arr_size ) :
INDENT if ( arr [ i ] > first ) :
INDENT third = second
second = first
first = arr [ i ]
DEDENT elif ( arr [ i ] > second ) :
INDENT third = second
second = arr [ i ]
DEDENT elif ( arr [ i ] > third ) :
INDENT third = arr [ i ]
DEDENT DEDENT print ( "The third Largest", "element is", third )
DEDENT

MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE | def findMinRooms ( slots, n, m ) :
INDENT counts = [ 0 ] * m;

for i in range ( n ) :
INDENT for j in range ( m ) :
INDENT if ( slots [ i ] [ j ] == '1' ) :
INDENT counts [ j ] += 1;

DEDENT DEDENT DEDENT return max ( counts );

DEDENT

DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM | def isSubsetSum ( set, n, sum ) :
INDENT if ( sum == 0 ) :
INDENT return True
DEDENT if ( n == 0 and sum != 0 ) :
INDENT return False
DEDENT if ( set [ n - 1 ] > sum ) :
INDENT return isSubsetSum ( set, n - 1, sum );

DEDENT return isSubsetSum ( set, n - 1, sum ) or isSubsetSum ( set, n - 1, sum - set [ n - 1 ] )
DEDENT

COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS | def chordCnt ( A ) :
INDENT n = 2 * A
dpArray = [ 0 ] * ( n + 1 )
dpArray [ 0 ] = 1
dpArray [ 2 ] = 1
for i in range ( 4, n + 1, 2 ) :
INDENT for j in range ( 0, i - 1, 2 ) :
INDENT dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] )
DEDENT DEDENT return int ( dpArray [ n ] )
DEDENT

BREAK_NUMBER_THREE_PARTS_1 | def count_of_ways ( n ) :
INDENT count = 0
count = ( n + 1 ) * ( n + 2 ) //2
returncount
DEDENT


PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6 | def greatest ( s ) :
INDENT n = len ( s )
a = [ 0 for i in range ( n ) ]
Sum = 0
for i in range ( n ) :
INDENT a [ i ] = ord ( s [ i ] ) - ord ( '0' )
Sum += a [ i ]
DEDENT if ( a [ n - 1 ] % 2 ) :
INDENT if ( a [ n - 2 ] % 2 != 0 or ( Sum - a [ n - 1 ] ) % 3 != 0 ) :
INDENT print ( "-1" )
DEDENT else :
INDENT print ( n )
DEDENT DEDENT else :
INDENT re = Sum % 3
dell = - 1
flag = 0
for i in range ( n - 1 ) :
INDENT if ( ( a [ i ] ) % 3 == re ) :
INDENT if ( a [ i + 1 ] > a [ i ] ) :
INDENT dell = i
flag = 1
break
DEDENT else :
INDENT dell = i
DEDENT DEDENT DEDENT if ( flag == 0 ) :
INDENT if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) :
INDENT dell = n - 1
DEDENT DEDENT if ( dell == - 1 ) :
INDENT print ( "-1" )
DEDENT else :
INDENT print ( dell + 1 )
DEDENT DEDENT DEDENT

MAXIMUM_HEIGHT_OF_TRIANGULAR_ARRANGEMENT_OF_ARRAY_VALUES | def MaximumHeight ( a, n ) :
INDENT result = 1
for i in range ( 1, n ) :
INDENT y = ( i * ( i + 1 ) ) / 2
if ( y < n ) :
INDENT result = i
DEDENT else :
INDENT break
DEDENT DEDENT return result
DEDENT

SQUARED_TRIANGULAR_NUMBER_SUM_CUBES | def findS ( s ) :
INDENT _sum = 0
n = 1
while ( _sum < s ) :
INDENT _sum += n * n * n
n += 1
DEDENT n -= 1
if _sum == s :
INDENT return n
DEDENT return - 1
DEDENT

EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING | def evaluateBoolExpr ( s ) :
INDENT n = len ( s )
for i in range ( 0, n - 2, 2 ) :
INDENT if ( s [ i + 1 ] == "A" ) :
INDENT if ( s [ i + 2 ] == "0" or s [ i ] == "0" ) :
INDENT s [ i + 2 ] = "0"
DEDENT else :
INDENT s [ i + 2 ] = "1"
DEDENT DEDENT elif ( s [ i + 1 ] == "B" ) :
INDENT if ( s [ i + 2 ] == "1" or s [ i ] == "1" ) :
INDENT s [ i + 2 ] = "1"
DEDENT else :
INDENT s [ i + 2 ] = "0"
DEDENT DEDENT else :
INDENT if ( s [ i + 2 ] == s [ i ] ) :
INDENT s [ i + 2 ] = "0"
DEDENT else :
INDENT s [ i + 2 ] = "1"
DEDENT DEDENT DEDENT return ord ( s [ n - 1 ] ) - ord ( "0" )
DEDENT

PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT | def assignValue ( a, b, x ) :
INDENT arr = [ a, b ]
return ( arr [ x ] )
DEDENT

MINIMUM_SUM_SQUARES_CHARACTERS_COUNTS_GIVEN_STRING_REMOVING_K_CHARACTERS | def minStringValue ( str, k ) :
INDENT l = len ( str )
if ( k >= l ) :
INDENT return 0
DEDENT frequency = [ 0 ] * MAX_CHAR
for i in range ( 0, l ) :
INDENT frequency [ ord ( str [ i ] ) - 97 ] += 1
DEDENT q = PriorityQueue ( )
for i in range ( 0, MAX_CHAR ) :
INDENT q . put ( - frequency [ i ] )
DEDENT while ( k > 0 ) :
INDENT temp = q . get ( )
temp = temp + 1
q . put ( temp, temp )
k = k - 1
DEDENT result = 0;

while not q . empty ( ) :
INDENT temp = q . get ( )
temp = temp * ( - 1 )
result += temp * temp
DEDENT return result
DEDENT

MAJORITY_ELEMENT_1 | def findMajority ( arr, size ) :
INDENT m = {
}

for i in range ( size ) :
INDENT if arr [ i ] in m :
INDENT m [ arr [ i ] ] += 1
DEDENT else :
INDENT m [ arr [ i ] ] = 1
DEDENT DEDENT count = 0
for key in m :
INDENT if m [ key ] > size / 2 :
INDENT count = 1
print ( "Majority found :-", key )
break
DEDENT DEDENT if ( count == 0 ) :
INDENT print ( "No Majority element" )
DEDENT DEDENT

LARGEST_SUBSET_GRAPH_VERTICES_EDGES_2_COLORS | def subsetGraph ( C ) :
INDENT global N
vertices = set ( )
for i in range ( N ) :
INDENT vertices . add ( i )
DEDENT while ( len ( vertices ) != 0 ) :
INDENT if ( len ( vertices ) == 1 ) :
INDENT return 1
DEDENT someone_removed = False
for x in vertices :
INDENT values = set ( )
for y in vertices :
INDENT if ( y != x ) :
INDENT values . add ( C [ x ] [ y ] )
DEDENT DEDENT if ( len ( values ) == 1 ) :
INDENT vertices . remove ( x )
someone_removed = True
break
DEDENT DEDENT if ( not someone_removed ) :
INDENT break
DEDENT DEDENT return len ( vertices )
DEDENT

FLOOR_IN_A_SORTED_ARRAY_1 | def floorSearch ( arr, low, high, x ) :
INDENT if ( low > high ) :
INDENT return - 1
DEDENT if ( x >= arr [ high ] ) :
INDENT return high
DEDENT mid = int ( ( low + high ) / 2 )
if ( arr [ mid ] == x ) :
INDENT return mid
DEDENT if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) :
INDENT return mid - 1
DEDENT if ( x < arr [ mid ] ) :
INDENT return floorSearch ( arr, low, mid - 1, x )
DEDENT return floorSearch ( arr, mid + 1, high, x )
DEDENT

LONGEST_PREFIX_ALSO_SUFFIX_1 | def longestPrefixSuffix ( s ) :
INDENT n = len ( s )
lps = [ 0 ] * n
l = 0
i = 1
while ( i < n ) :
INDENT if ( s [ i ] == s [ l ] ) :
INDENT l = l + 1
lps [ i ] = l
i = i + 1
DEDENT else :
INDENT if ( l != 0 ) :
INDENT l = lps [ l - 1 ]
DEDENT else :
INDENT lps [ i ] = 0
i = i + 1
DEDENT DEDENT DEDENT res = lps [ n - 1 ]
if ( res > n / 2 ) :
INDENT return n //2
DEDENTelse:
INDENTreturnres
DEDENTDEDENT


COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS | def countP ( n, k ) :
INDENT if ( n == 0 or k == 0 or k > n ) :
INDENT return 0
DEDENT if ( k == 1 or k == n ) :
INDENT return 1
DEDENT return ( k * countP ( n - 1, k ) + countP ( n - 1, k - 1 ) )
DEDENT

C_PROGRAM_FACTORIAL_NUMBER_2 | def factorial ( n ) :
INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )
DEDENT

FIND_REPEATED_CHARACTER_PRESENT_FIRST_STRING_1 | def findRepeatFirst ( s ) :
INDENT p = - 1
hash = [ 0 for i in range ( MAX_CHAR ) ]
pos = [ 0 for i in range ( MAX_CHAR ) ]
for i in range ( len ( s ) ) :
INDENT k = ord ( s [ i ] )
if ( hash [ k ] == 0 ) :
INDENT hash [ k ] += 1
pos [ k ] = i
DEDENT elif ( hash [ k ] == 1 ) :
INDENT hash [ k ] += 1
DEDENT DEDENT for i in range ( MAX_CHAR ) :
INDENT if ( hash [ i ] == 2 ) :
INDENT if ( p == - 1 ) :
INDENT p = pos [ i ]
DEDENT elif ( p > pos [ i ] ) :
INDENT p = pos [ i ]
DEDENT DEDENT DEDENT return p
DEDENT

NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS | def numberOfPermWithKInversion ( N, K ) :
INDENT if ( N == 0 ) : return 0
if ( K == 0 ) : return 1
if ( memo [ N ] [ K ] != 0 ) :
INDENT return memo [ N ] [ K ]
DEDENT sum = 0
for i in range ( K + 1 ) :
INDENT if ( i <= N - 1 ) :
INDENT sum += numberOfPermWithKInversion ( N - 1, K - i )
DEDENT DEDENT memo [ N ] [ K ] = sum
return sum
DEDENT

K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY | def kthLargestSum ( arr, n, k ) :
INDENT sum = [ ]
sum . append ( 0 )
sum . append ( arr [ 0 ] )
for i in range ( 2, n + 1 ) :
INDENT sum . append ( sum [ i - 1 ] + arr [ i - 1 ] )
DEDENT Q = [ ]
heapq . heapify ( Q )
for i in range ( 1, n + 1 ) :
INDENT for j in range ( i, n + 1 ) :
INDENT x = sum [ j ] - sum [ i - 1 ]
if len ( Q ) < k :
INDENT heapq . heappush ( Q, x )
DEDENT else :
INDENT if Q [ 0 ] < x :
INDENT heapq . heappop ( Q )
heapq . heappush ( Q, x )
DEDENT DEDENT DEDENT DEDENT return Q [ 0 ]
DEDENT

FIND_THE_LARGEST_THREE_ELEMENTS_IN_AN_ARRAY | def find3largest ( arr, n ) :
INDENT arr = sorted ( arr )
check = 0
count = 1
for i in range ( 1, n + 1 ) :
INDENT if ( count < 4 ) :
INDENT if ( check != arr [ n - i ] ) :
INDENT print ( arr [ n - i ], end = " " )
check = arr [ n - i ]
count += 1
DEDENT DEDENT else :
INDENT break
DEDENT DEDENT DEDENT

MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE | def maxLower ( str ) :
INDENT n = len ( str )
i = 0
for i in range ( n ) :
INDENT if str [ i ] >= 'A' and str [ i ] <= 'Z' :
INDENT i += 1
break
DEDENT DEDENT maxCount = 0
count = [ ]
for j in range ( MAX_CHAR ) :
INDENT count . append ( 0 )
DEDENT for j in range ( i, n ) :
INDENT if str [ j ] >= 'A' and str [ j ] <= 'Z' :
INDENT currCount = 0
for k in range ( MAX_CHAR ) :
INDENT if count [ k ] > 0 :
INDENT currCount += 1
DEDENT DEDENT maxCount = max ( maxCount, currCount )
for y in count :
INDENT y = 0
DEDENT DEDENT if str [ j ] >= 'a' and str [ j ] <= 'z' :
INDENT count [ ord ( str [ j ] ) - ord ( 'a' ) ] += 1
DEDENT DEDENT return maxCount
DEDENT

CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH_ONE_VARIATION_ALLOWED | def isValidString ( str ) :
INDENT freq = [ 0 ] * CHARS
for i in range ( len ( str ) ) :
INDENT freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1
DEDENT freq1 = 0
count_freq1 = 0
for i in range ( CHARS ) :
INDENT if ( freq [ i ] != 0 ) :
INDENT freq1 = freq [ i ]
count_freq1 = 1
break
DEDENT DEDENT freq2 = 0
count_freq2 = 0
for j in range ( i + 1, CHARS ) :
INDENT if ( freq [ j ] != 0 ) :
INDENT if ( freq [ j ] == freq1 ) :
INDENT count_freq1 += 1
DEDENT else :
INDENT count_freq2 = 1
freq2 = freq [ j ]
break
DEDENT DEDENT DEDENT for k in range ( j + 1, CHARS ) :
INDENT if ( freq [ k ] != 0 ) :
INDENT if ( freq [ k ] == freq1 ) :
INDENT count_freq1 += 1
DEDENT if ( freq [ k ] == freq2 ) :
INDENT count_freq2 += 1
DEDENT else :
INDENT return False
DEDENT DEDENT if ( count_freq1 > 1 and count_freq2 > 1 ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY | def largestSumOfAverages ( A, K ) :
INDENT n = len ( A );

pre_sum = [ 0 ] * ( n + 1 );

pre_sum [ 0 ] = 0;

for i in range ( n ) :
INDENT pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ];

DEDENT dp = [ 0 ] * n;

sum = 0;

for i in range ( n ) :
INDENT dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i );

DEDENT for k in range ( K - 1 ) :
INDENT for i in range ( n ) :
INDENT for j in range ( i + 1, n ) :
INDENT dp [ i ] = max ( dp [ i ], ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] );

DEDENT DEDENT DEDENT return int ( dp [ 0 ] );

DEDENT

FIND_SUBARRAY_WITH_GIVEN_SUM_IN_ARRAY_OF_INTEGERS | def subArraySum ( arr, n, Sum ) :
INDENT Map = {
}

curr_sum = 0
for i in range ( 0, n ) :
INDENT curr_sum = curr_sum + arr [ i ]
if curr_sum == Sum :
INDENT print ( "Sum found between indexes 0 to", i )
return
DEDENT if ( curr_sum - Sum ) in Map :
INDENT print ( "Sum found between indexes", \ Map [ curr_sum - Sum ] + 1, "to", i )
return
DEDENT Map [ curr_sum ] = i
DEDENT print ( "No subarray with given sum exists" )
DEDENT

REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX | def minRemovalsDP ( arr, n ) :
INDENT longest_start = - 1;

longest_end = 0;

for start in range ( n ) :
INDENT min = sys . maxsize;

max = - sys . maxsize;

for end in range ( start, n ) :
INDENT val = arr [ end ];

if ( val < min ) :
INDENT min = val;

DEDENT if ( val > max ) :
INDENT max = val;

DEDENT if ( 2 * min <= max ) :
INDENT break;

DEDENT if ( end - start > longest_end - longest_start or longest_start == - 1 ) :
INDENT longest_start = start;

longest_end = end;

DEDENT DEDENT DEDENT if ( longest_start == - 1 ) :
INDENT return n;

DEDENT return ( n - ( longest_end - longest_start + 1 ) );

DEDENT

FIND_THE_MISSING_NUMBER_1 | def getMissingNo ( a, n ) :
INDENT i, total = 0, 1
for i in range ( 2, n + 2 ) :
INDENT total += i
total -= a [ i - 2 ]
DEDENT return total
DEDENT

SIEVE_SUNDARAM_PRINT_PRIMES_SMALLER_N | def SieveOfSundaram ( n ) :
INDENT nNew = int ( ( n - 2 ) / 2 );

marked = [ 0 ] * ( nNew + 1 );

for i in range ( 1, nNew + 1 ) :
INDENT j = i;

while ( ( i + j + 2 * i * j ) <= nNew ) :
INDENT marked [ i + j + 2 * i * j ] = 1;

j += 1;

DEDENT DEDENT if ( n > 2 ) :
INDENT print ( 2, end = " " );

DEDENT for i in range ( 1, nNew + 1 ) :
INDENT if ( marked [ i ] == 0 ) :
INDENT print ( ( 2 * i + 1 ), end = " " );

DEDENT DEDENT DEDENT

MAXIMUM_PRODUCT_SUBSET_ARRAY | def maxProductSubset ( a, n ) :
INDENT if n == 1 :
INDENT return a [ 0 ]
DEDENT max_neg = - 999999999999
count_neg = 0
count_zero = 0
prod = 1
for i in range ( n ) :
INDENT if a [ i ] == 0 :
INDENT count_zero += 1
continue
DEDENT if a [ i ] < 0 :
INDENT count_neg += 1
max_neg = max ( max_neg, a [ i ] )
DEDENT prod = prod * a [ i ]
DEDENT if count_zero == n :
INDENT return 0
DEDENT if count_neg & 1 :
INDENT if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) :
INDENT return 0
DEDENT prod = int ( prod / max_neg )
DEDENT return prod
DEDENT

FIND_THE_NEAREST_SMALLER_NUMBERS_ON_LEFT_SIDE_IN_AN_ARRAY | def printPrevSmaller ( arr, n ) :
INDENT print ( "_, ", end = "" )
for i in range ( 1, n ) :
INDENT for j in range ( i - 1, - 2, - 1 ) :
INDENT if ( arr [ j ] < arr [ i ] ) :
INDENT print ( arr [ j ], ", ", end = "" )
break
DEDENT DEDENT if ( j == - 1 ) :
INDENT print ( "_, ", end = "" )
DEDENT DEDENT DEDENT

FIND_NUMBER_PAIRS_ARRAY_XOR_0_1 | def calculate ( a ) :
INDENT maximum = max ( a )
frequency = [ 0 for x in range ( maximum + 1 ) ]
for i in a :
INDENT frequency [ i ] += 1
DEDENT answer = 0
for i in frequency :
INDENT answer = answer + i * ( i - 1 ) //2
DEDENTreturnanswer
DEDENT


SUM_BINOMIAL_COEFFICIENTS_1 | def binomialCoeffSum ( n ) :
INDENT return ( 1 << n );

DEDENT

MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1 | def maxSumPairWithDifferenceLessThanK ( arr, N, k ) :
INDENT maxSum = 0;

arr . sort ( );

i = N - 1;

while ( i >= 0 ) :
INDENT if ( arr [ i ] - arr [ i - 1 ] < k ) :
INDENT maxSum += arr [ i ];

maxSum += arr [ i - 1 ];

i -= 1;

DEDENT i -= 1;

DEDENT return maxSum;

DEDENT

KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT | def printkthnode ( adj, wt, n, k ) :
INDENT for i in range ( n ) :
INDENT adj [ i ] . sort ( )
DEDENT for i in range ( n ) :
INDENT if ( len ( adj [ i ] ) >= k ) :
INDENT print ( adj [ i ] [ len ( adj [ i ] ) - k ] [ 1 ], end = " " )
DEDENT else :
INDENT print ( "-1", end = " " )
DEDENT DEDENT DEDENT

SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM | def KnapSack ( val, wt, n, W ) :
INDENT mat = [ [ 0 for i in range ( W + 1 ) ] for i in range ( 2 ) ]
i = 0
while i < n :
INDENT j = 0
if i % 2 == 0 :
INDENT while j < W :
INDENT j += 1
if wt [ i ] <= j :
INDENT mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ], mat [ 0 ] [ j ] )
DEDENT else :
INDENT mat [ 1 ] [ j ] = mat [ 0 ] [ j ]
DEDENT DEDENT DEDENT else :
INDENT while j < W :
INDENT j += 1
if wt [ i ] <= j :
INDENT mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ], mat [ 1 ] [ j ] )
DEDENT else :
INDENT mat [ 0 ] [ j ] = mat [ 1 ] [ j ]
DEDENT DEDENT DEDENT i += 1
DEDENT if n % 2 == 0 :
INDENT return mat [ 0 ] [ W ]
DEDENT else :
INDENT return mat [ 1 ] [ W ]
DEDENT DEDENT

BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1 | def bin ( n ) :
INDENT if ( n > 1 ) :
INDENT bin ( n >> 1 )
DEDENT print ( n & 1, end = "" )
DEDENT

PRIME_FACTORS_BIG_NUMBER | def factorize ( n ) :
INDENT count = 0;

while ( ( n % 2 > 0 ) == False ) :
INDENT n >>= 1;

count += 1;

DEDENT if ( count > 0 ) :
INDENT print ( 2, count );

DEDENT for i in range ( 3, int ( math . sqrt ( n ) ) + 1 ) :
INDENT count = 0;

while ( n % i == 0 ) :
INDENT count += 1;

n = int ( n / i );

DEDENT if ( count > 0 ) :
INDENT print ( i, count );

DEDENT i += 2;

DEDENT if ( n > 2 ) :
INDENT print ( n, 1 );

DEDENT DEDENT

COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1 | def countSubstringWithEqualEnds ( s ) :
INDENT result = 0;

n = len ( s );

count = [ 0 ] * MAX_CHAR;

for i in range ( n ) :
INDENT count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1;

DEDENT for i in range ( MAX_CHAR ) :
INDENT result += ( count [ i ] * ( count [ i ] + 1 ) / 2 );

DEDENT return result;

DEDENT

LONGEST_PALINDROME_SUBSTRING_SET_1 | def printSubStr ( st, low, high ) :
INDENT sys . stdout . write ( st [ low : high + 1 ] )
sys . stdout . flush ( )
return ''
DEDENT

FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTERS_OF_ANOTHER_STRING | def findSubString ( string, pat ) :
INDENT len1 = len ( string )
len2 = len ( pat )
if len1 < len2 :
INDENT print ( "No such window exists" )
return ""
DEDENT hash_pat = [ 0 ] * no_of_chars
hash_str = [ 0 ] * no_of_chars
for i in range ( 0, len2 ) :
INDENT hash_pat [ ord ( pat [ i ] ) ] += 1
DEDENT start, start_index, min_len = 0, - 1, float ( 'inf' )
count = 0
for j in range ( 0, len1 ) :
INDENT hash_str [ ord ( string [ j ] ) ] += 1
if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) :
INDENT count += 1
DEDENT if count == len2 :
INDENT while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) :
INDENT if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) :
INDENT hash_str [ ord ( string [ start ] ) ] -= 1
DEDENT start += 1
DEDENT len_window = j - start + 1
if min_len > len_window :
INDENT min_len = len_window
start_index = start
DEDENT DEDENT DEDENT if start_index == - 1 :
INDENT print ( "No such window exists" )
return ""
DEDENT return string [ start_index : start_index + min_len ]
DEDENT

MARKOV_MATRIX | def checkMarkov ( m ) :
INDENT for i in range ( 0, len ( m ) ) :
INDENT sm = 0
for j in range ( 0, len ( m [ i ] ) ) :
INDENT sm = sm + m [ i ] [ j ]
DEDENT if ( sm != 1 ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

LEAF_NODES_PREORDER_BINARY_SEARCH_TREE | def leafNode ( preorder, n ) :
INDENT s = [ ]
i = 0
for j in range ( 1, n ) :
INDENT found = False
if preorder [ i ] > preorder [ j ] :
INDENT s . append ( preorder [ i ] )
DEDENT else :
INDENT while len ( s ) != 0 :
INDENT if preorder [ j ] > s [ - 1 ] :
INDENT s . pop ( - 1 )
found = True
DEDENT else :
INDENT break
DEDENT DEDENT DEDENT if found :
INDENT print ( preorder [ i ], end = " " )
DEDENT i += 1
DEDENT print ( preorder [ n - 1 ] )
DEDENT

SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N | def nextPowerOf2 ( n ) :
INDENT count = 0;

if ( n and not ( n & ( n - 1 ) ) ) :
INDENT return n
DEDENT while ( n != 0 ) :
INDENT n >>= 1
count += 1
DEDENT return 1 << count;

DEDENT

PROGRAM_CHECK_WATER_TANK_OVERFLOWS_N_SOLID_BALLS_DIPPED_WATER_TANK | def overflow ( H, r, h, N, R ) :
INDENT tank_cap = 3.14 * r * r * H
water_vol = 3.14 * r * r * h
balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R
vol = water_vol + balls_vol
if vol > tank_cap :
INDENT print ( "Overflow" )
DEDENT else :
INDENT print ( "Not in overflow state" )
DEDENT DEDENT

SMALLEST_DERANGEMENT_SEQUENCE | def generate_derangement ( N ) :
INDENT S = [ 0 ] * ( N + 1 )
for i in range ( 1, N + 1 ) :
INDENT S [ i ] = i
DEDENT D = [ 0 ] * ( N + 1 )
for i in range ( 1, N + 1, 2 ) :
INDENT if i == N :
INDENT D [ N ] = S [ N - 1 ]
D [ N - 1 ] = S [ N ]
DEDENT else :
INDENT D [ i ] = i + 1
D [ i + 1 ] = i
DEDENT DEDENT for i in range ( 1, N + 1 ) :
INDENT print ( D [ i ], end = " " )
DEDENT print ( )
DEDENT

MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE | def lis ( arr, n ) :
INDENT mpis = [ 0 ] * ( n )
for i in range ( n ) :
INDENT mpis [ i ] = arr [ i ]
DEDENT for i in range ( 1, n ) :
INDENT for j in range ( i ) :
INDENT if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) :
INDENT mpis [ i ] = mpis [ j ] * arr [ i ]
DEDENT DEDENT DEDENT return max ( mpis )
DEDENT

CHANGE_BITS_CAN_MADE_ONE_FLIP | def canMakeAllSame ( str ) :
INDENT zeros = 0
ones = 0
for i in range ( 0, len ( str ) ) :
INDENT ch = str [ i ];

if ( ch == '0' ) :
INDENT zeros = zeros + 1
DEDENT else :
INDENT ones = ones + 1
DEDENT DEDENT return ( zeros == 1 or ones == 1 );

DEDENT

FIND_NUMBER_PAIRS_ARRAY_XOR_0 | def calculate ( a ) :
INDENT a . sort ( )
count = 1
answer = 0
for i in range ( 1, len ( a ) ) :
INDENT if a [ i ] == a [ i - 1 ] :
INDENT count += 1
DEDENT else :
INDENT answer = answer + count * ( count - 1 ) //2
count=1
DEDENTDEDENTanswer=answer+count*(count-1)//2
returnanswer
DEDENT


FIND_ROOT_TREE_CHILDREN_ID_SUM_EVERY_NODE_GIVEN | def findRoot ( arr, n ) :
INDENT root = 0
for i in range ( n ) :
INDENT root += ( arr [ i ] [ 0 ] - arr [ i ] [ 1 ] )
DEDENT return root
DEDENT

BINARY_SEARCH | def binarySearch ( arr, l, r, x ) :
INDENT if r >= l :
INDENT mid = l + ( r - l ) //2
ifarr[mid]==x:
INDENTreturnmid
DEDENTelifarr[mid]>x:
INDENTreturnbinarySearch(arr,l,mid-1,x)
DEDENTelse:
INDENTreturnbinarySearch(arr,mid+1,r,x)
DEDENTDEDENTelse:
INDENTreturn-1
DEDENTDEDENT


FIBONACCI_MODULO_P | def findMinZero ( p ) :
INDENT first = 1
second = 1
number = 2
next = 1
while ( next ) :
INDENT next = ( first + second ) % p
first = second
second = next
number = number + 1
DEDENT return number
DEDENT

K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY | def kLargest ( arr, k ) :
INDENT arr . sort ( reverse = True )
for i in range ( k ) :
INDENT print ( arr [ i ], end = " " )
DEDENT DEDENT

C_PROGRAM_FIND_AREA_CIRCLE | def findArea ( r ) :
INDENT PI = 3.142
return PI * ( r * r );

DEDENT

SUM_TWO_LARGE_NUMBERS | def findSum ( str1, str2 ) :
INDENT if ( len ( str1 ) > len ( str2 ) ) :
INDENT t = str1;

str1 = str2;

str2 = t;

DEDENT str = "";

n1 = len ( str1 );

n2 = len ( str2 );

str1 = str1 [ : : - 1 ];

str2 = str2 [ : : - 1 ];

carry = 0;

for i in range ( n1 ) :
INDENT sum = ( ( ord ( str1 [ i ] ) - 48 ) + ( ( ord ( str2 [ i ] ) - 48 ) + carry ) );

str += chr ( sum % 10 + 48 );

carry = int ( sum / 10 );

DEDENT for i in range ( n1, n2 ) :
INDENT sum = ( ( ord ( str2 [ i ] ) - 48 ) + carry );

str += chr ( sum % 10 + 48 );

carry = ( int ) ( sum / 10 );

DEDENT if ( carry ) :
INDENT str += chr ( carry + 48 );

DEDENT str = str [ : : - 1 ];

return str;

DEDENT

ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE | def solveQuery ( start, end, arr ) :
INDENT frequency = dict ( )
for i in range ( start, end + 1 ) :
INDENT if arr [ i ] in frequency . keys ( ) :
INDENT frequency [ arr [ i ] ] += 1
DEDENT else :
INDENT frequency [ arr [ i ] ] = 1
DEDENT DEDENT count = 0
for x in frequency :
INDENT if x == frequency [ x ] :
INDENT count += 1
DEDENT DEDENT return count
DEDENT

COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS | def countSubstringWithEqualEnds ( s ) :
INDENT result = 0;

n = len ( s );

for i in range ( n ) :
INDENT for j in range ( i, n ) :
INDENT if ( s [ i ] == s [ j ] ) :
INDENT result = result + 1
DEDENT DEDENT DEDENT return result
DEDENT

DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM | def maxTasks ( high, low, n ) :
INDENT if ( n <= 0 ) :
INDENT return 0
DEDENT return max ( high [ n - 1 ] + maxTasks ( high, low, ( n - 2 ) ), low [ n - 1 ] + maxTasks ( high, low, ( n - 1 ) ) );

DEDENT

MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX | def maxRowDiff ( mat, m, n ) :
INDENT rowSum = [ 0 ] * m
for i in range ( 0, m ) :
INDENT sum = 0
for j in range ( 0, n ) :
INDENT sum += mat [ i ] [ j ]
DEDENT rowSum [ i ] = sum
DEDENT max_diff = rowSum [ 1 ] - rowSum [ 0 ]
min_element = rowSum [ 0 ]
for i in range ( 1, m ) :
INDENT if ( rowSum [ i ] - min_element > max_diff ) :
INDENT max_diff = rowSum [ i ] - min_element
DEDENT if ( rowSum [ i ] < min_element ) :
INDENT min_element = rowSum [ i ]
DEDENT DEDENT return max_diff
DEDENT

PAPER_CUT_MINIMUM_NUMBER_SQUARES | def minimumSquare ( a, b ) :
INDENT result = 0
rem = 0
if ( a < b ) :
INDENT a, b = b, a
DEDENT while ( b > 0 ) :
INDENT result += int ( a / b )
rem = int ( a % b )
a = b
b = rem
DEDENT return result
DEDENT

SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_ELEMENTS_IS_1 | def search ( arr, n, x ) :
INDENT i = 0
while ( i < n ) :
INDENT if ( arr [ i ] == x ) :
INDENT return i
DEDENT i = i + abs ( arr [ i ] - x )
DEDENT print ( "number is not present!" )
return - 1
DEDENT

PANGRAM_CHECKING | def checkPangram ( s ) :
INDENT List = [ ]
for i in range ( 26 ) :
INDENT List . append ( False )
DEDENT for c in s . lower ( ) :
INDENT if not c == " " :
INDENT List [ ord ( c ) - ord ( 'a' ) ] = True
DEDENT DEDENT for ch in List :
INDENT if ch == False :
INDENT return False
DEDENT DEDENT return True
DEDENT

PRINT_SHORTEST_COMMON_SUPERSEQUENCE | def printShortestSuperSeq ( x, y ) :
INDENT m = len ( x )
n = len ( y )
dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]
for i in range ( m + 1 ) :
INDENT for j in range ( n + 1 ) :
INDENT if i == 0 :
INDENT dp [ i ] [ j ] = j
DEDENT elif j == 0 :
INDENT dp [ i ] [ j ] = i
DEDENT elif x [ i - 1 ] == y [ j - 1 ] :
INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]
DEDENT else :
INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ], dp [ i ] [ j - 1 ] )
DEDENT DEDENT DEDENT index = dp [ m ] [ n ]
string = ""
i = m
j = n
while i > 0 and j > 0 :
INDENT if x [ i - 1 ] == y [ j - 1 ] :
INDENT string += x [ i - 1 ]
i -= 1
j -= 1
index -= 1
DEDENT elif dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] :
INDENT string += y [ j - 1 ]
j -= 1
index -= 1
DEDENT else :
INDENT string += x [ i - 1 ]
i -= 1
index -= 1
DEDENT DEDENT while i > 0 :
INDENT string += x [ i - 1 ]
i -= 1
index -= 1
DEDENT while j > 0 :
INDENT string += y [ j - 1 ]
j -= 1
index -= 1
DEDENT string = list ( string )
string . reverse ( )
return '' . join ( string )
DEDENT

FIND_PAIR_MAXIMUM_GCD_ARRAY_1 | def findMaxGCD ( arr, n ) :
INDENT high = 0
for i in range ( 0, n ) :
INDENT high = max ( high, arr [ i ] )
DEDENT count = [ 0 ] * ( high + 1 )
for i in range ( 0, n ) :
INDENT count [ arr [ i ] ] += 1
DEDENT counter = 0
for i in range ( high, 0, - 1 ) :
INDENT j = i
while ( j <= high ) :
INDENT if ( count [ j ] > 0 ) :
INDENT counter += count [ j ]
DEDENT j += i
if ( counter == 2 ) :
INDENT return i
DEDENT DEDENT counter = 0
DEDENT DEDENT

PROGRAM_CALCULATE_AREA_OCTAGON | def areaOctagon ( side ) :
INDENT return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side )
DEDENT

FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_1 | def findExtra ( arr1, arr2, n ) :
INDENT index = n
left = 0
right = n - 1
while ( left <= right ) :
INDENT mid = ( int ) ( ( left + right ) / 2 )
if ( arr2 [ mid ] == arr1 [ mid ] ) :
INDENT left = mid + 1
DEDENT else :
INDENT index = mid
right = mid - 1
DEDENT DEDENT return index
DEDENT

NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL_TO_VALUE_1 | def nobleInteger ( arr ) :
INDENT arr . sort ( )
n = len ( arr )
for i in range ( n - 1 ) :
INDENT if arr [ i ] == arr [ i + 1 ] :
INDENT continue
DEDENT if arr [ i ] == n - i - 1 :
INDENT return arr [ i ]
DEDENT DEDENT if arr [ n - 1 ] == 0 :
INDENT return arr [ n - 1 ]
DEDENT return - 1
DEDENT

MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_ISOSCELES_TRIANGLE | def maxSquare ( b, m ) :
INDENT return ( b / m - 1 ) * ( b / m ) / 2
DEDENT

HOW_TO_COMPUTE_MOD_OF_A_BIG_NUMBER | def mod ( num, a ) :
INDENT res = 0
for i in range ( 0, len ( num ) ) :
INDENT res = ( res * 10 + int ( num [ i ] ) ) % a;

DEDENT return res
DEDENT

LONGEST_COMMON_SUBSTRING_1 | def lcs ( i, j, count ) :
INDENT if ( i == 0 or j == 0 ) :
INDENT return count
DEDENT if ( X [ i - 1 ] == Y [ j - 1 ] ) :
INDENT count = lcs ( i - 1, j - 1, count + 1 )
DEDENT count = max ( count, max ( lcs ( i, j - 1, 0 ), lcs ( i - 1, j, 0 ) ) )
return count
DEDENT

FIND_PATTERNS_101_GIVEN_STRING | def patternCount ( str ) :
INDENT last = str [ 0 ]
i = 1;
counter = 0
while ( i < len ( str ) ) :
INDENT if ( str [ i ] == '0' and last == '1' ) :
INDENT while ( str [ i ] == '0' ) :
INDENT i += 1
if ( str [ i ] == '1' ) :
INDENT counter += 1
DEDENT DEDENT DEDENT last = str [ i ]
i += 1
DEDENT return counter
DEDENT

LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE | def longOddEvenIncSeq ( arr, n ) :
INDENT lioes = list ( )
maxLen = 0
for i in range ( n ) :
INDENT lioes . append ( 1 )
DEDENT i = 1
for i in range ( n ) :
INDENT for j in range ( i ) :
INDENT if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) :
INDENT lioes [ i ] = lioes [ j ] + 1
DEDENT DEDENT DEDENT for i in range ( n ) :
INDENT if maxLen < lioes [ i ] :
INDENT maxLen = lioes [ i ]
DEDENT DEDENT return maxLen
DEDENT

COUNT_NUMBER_OF_SUBSTRINGS_WITH_EXACTLY_K_DISTINCT_CHARACTERS | def countkDist ( str1, k ) :
INDENT n = len ( str1 )
res = 0
cnt = [ 0 ] * 27
for i in range ( 0, n ) :
INDENT dist_count = 0
cnt = [ 0 ] * 27
for j in range ( i, n ) :
INDENT if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) :
INDENT dist_count += 1
DEDENT cnt [ ord ( str1 [ j ] ) - 97 ] += 1
if ( dist_count == k ) :
INDENT res += 1
DEDENT if ( dist_count > k ) :
INDENT break
DEDENT DEDENT DEDENT return res
DEDENT

C_PROGRAM_FACTORIAL_NUMBER_1 | def factorial ( n ) :
INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 );

DEDENT

K_MAXIMUM_SUMS_NON_OVERLAPPING_CONTIGUOUS_SUB_ARRAYS | def kmax ( arr, k, n ) :
INDENT for c in range ( k ) :
INDENT max_so_far = - float ( "inf" )
max_here = 0
start = 0
end = 0
s = 0
for i in range ( n ) :
INDENT max_here += arr [ i ]
if ( max_so_far < max_here ) :
INDENT max_so_far = max_here
start = s
end = i
DEDENT if ( max_here < 0 ) :
INDENT max_here = 0
s = i + 1
DEDENT DEDENT print ( "Maximum non-overlapping sub-array sum", c + 1, ": ", max_so_far, ", starting index: ", start, ", ending index: ", end, ".", sep = "" )
for l in range ( start, end + 1 ) :
INDENT arr [ l ] = - float ( "inf" )
DEDENT DEDENT print ( )
DEDENT

DISTANCE_NEAREST_CELL_1_BINARY_MATRIX | def printDistance ( mat ) :
INDENT global N, M
ans = [ [ None ] * M for i in range ( N ) ]
for i in range ( N ) :
INDENT for j in range ( M ) :
INDENT ans [ i ] [ j ] = 999999999999
DEDENT DEDENT for i in range ( N ) :
INDENT for j in range ( M ) :
INDENT for k in range ( N ) :
INDENT for l in range ( M ) :
INDENT if ( mat [ k ] [ l ] == 1 ) :
INDENT ans [ i ] [ j ] = min ( ans [ i ] [ j ], abs ( i - k ) + abs ( j - l ) )
DEDENT DEDENT DEDENT DEDENT DEDENT for i in range ( N ) :
INDENT for j in range ( M ) :
INDENT print ( ans [ i ] [ j ], end = " " )
DEDENT print ( )
DEDENT DEDENT

MINIMUM_NUMBER_OF_BRACKET_REVERSALS_NEEDED_TO_MAKE_AN_EXPRESSION_BALANCED | def countMinReversals ( expr ) :
INDENT lenn = len ( expr )
if ( lenn % 2 ) :
INDENT return - 1
DEDENT s = [ ]
for i in range ( lenn ) :
INDENT if ( expr [ i ] == '' and len ( s ) ) :
INDENT if ( s [ 0 ] == '' ) :
INDENT s . pop ( 0 )
DEDENT else :
INDENT s . insert ( 0, expr [ i ] )
DEDENT DEDENT else :
INDENT s . insert ( 0, expr [ i ] )
DEDENT DEDENT red_len = len ( s )
n = 0
while ( len ( s ) and s [ 0 ] == '' ) :
INDENT s . pop ( 0 )
n += 1
DEDENT return ( red_len //2+n%2)
DEDENT


FIRST_NEGATIVE_INTEGER_EVERY_WINDOW_SIZE_K_1 | def printFirstNegativeInteger ( arr, n, k ) :
INDENT Di = deque ( )
for i in range ( k ) :
INDENT if ( arr [ i ] < 0 ) :
INDENT Di . append ( i );

DEDENT DEDENT for i in range ( k, n ) :
INDENT if ( not Di ) :
INDENT print ( 0, end = ' ' )
DEDENT else :
INDENT print ( arr [ Di [ 0 ] ], end = ' ' );

DEDENT while Di and Di [ 0 ] <= ( i - k ) :
INDENT Di . popleft ( )
DEDENT if ( arr [ i ] < 0 ) :
INDENT Di . append ( i );

DEDENT DEDENT if not Di :
INDENT print ( 0 )
DEDENT else :
INDENT print ( arr [ Di [ 0 ] ], end = " " )
DEDENT DEDENT

MAGIC_SQUARE | def generateSquare ( n ) :
INDENT magicSquare = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]
i = n / 2
j = n - 1
num = 1
while num <= ( n * n ) :
INDENT if i == - 1 and j == n :
INDENT j = n - 2
i = 0
DEDENT else :
INDENT if j == n :
INDENT j = 0
DEDENT if i < 0 :
INDENT i = n - 1
DEDENT DEDENT if magicSquare [ int ( i ) ] [ int ( j ) ] :
INDENT j = j - 2
i = i + 1
continue
DEDENT else :
INDENT magicSquare [ int ( i ) ] [ int ( j ) ] = num
num = num + 1
DEDENT j = j + 1
i = i - 1
DEDENT print ( "Magic Squre for n =", n )
print ( "Sum of each row or column", n * ( n * n + 1 ) / 2, "\n" )
for i in range ( 0, n ) :
INDENT for j in range ( 0, n ) :
INDENT print ( '%2d ' % ( magicSquare [ i ] [ j ] ), end = '' )
if j == n - 1 :
INDENT print ( )
DEDENT DEDENT DEDENT DEDENT

PROGRAM_BINOMIAL_COEFFICIENTS_TABLE | def printbinomial ( max ) :
INDENT for m in range ( max + 1 ) :
INDENT print ( '% 2d' % m, end = ' ' )
binom = 1
for x in range ( m + 1 ) :
INDENT if m != 0 and x != 0 :
INDENT binom = binom * ( m - x + 1 ) / x
DEDENT print ( '% 4d' % binom, end = ' ' )
DEDENT print ( "\n", end = '' )
DEDENT DEDENT

CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION | def findMinX ( num, rem, k ) :
INDENT x = 1;

while ( True ) :
INDENT j = 0;

while ( j < k ) :
INDENT if ( x % num [ j ] != rem [ j ] ) :
INDENT break;

DEDENT j += 1;

DEDENT if ( j == k ) :
INDENT return x;

DEDENT x += 1;

DEDENT DEDENT

MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_AXIS | def findmin ( p, n ) :
INDENT a, b, c, d = 0, 0, 0, 0
for i in range ( n ) :
INDENT if ( p [ i ] [ 0 ] <= 0 ) :
INDENT a += 1
DEDENT elif ( p [ i ] [ 0 ] >= 0 ) :
INDENT b += 1
DEDENT if ( p [ i ] [ 1 ] >= 0 ) :
INDENT c += 1
DEDENT elif ( p [ i ] [ 1 ] <= 0 ) :
INDENT d += 1
DEDENT DEDENT return min ( [ a, b, c, d ] )
DEDENT

REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE | def translate ( st ) :
INDENT for i in range ( 1, len ( st ) ) :
INDENT if ( st [ i - 1 ] == 'A' and st [ i ] == 'B' ) :
INDENT st [ i - 1 ] = 'C'
for j in range ( i, len ( st ) - 1 ) :
INDENT st [ j ] = st [ j + 1 ]
DEDENT st [ len ( st ) - 1 ] = ' '
DEDENT DEDENT return
DEDENT

PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY | def printPairs ( arr, n ) :
INDENT v = [ ]
for i in range ( n ) :
INDENT for j in range ( i + 1, n ) :
INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) :
INDENT v . append ( abs ( arr [ i ] ) )
DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) :
INDENT return;

DEDENT v . sort ( )
for i in range ( len ( v ) ) :
INDENT print ( - v [ i ], "", v [ i ], end = " " )
DEDENT DEDENT

NON_REPEATING_ELEMENT_1 | def firstNonRepeating ( arr, n ) :
INDENT mp = defaultdict ( lambda : 0 )
for i in range ( n ) :
INDENT mp [ arr [ i ] ] += 1
DEDENT for i in range ( n ) :
INDENT if mp [ arr [ i ] ] == 1 :
INDENT return arr [ i ]
DEDENT DEDENT return - 1
DEDENT

PRINT_FIBONACCI_SERIES_REVERSE_ORDER | def reverseFibonacci ( n ) :
INDENT a = [ 0 ] * n
a [ 0 ] = 0
a [ 1 ] = 1
for i in range ( 2, n ) :
INDENT a [ i ] = a [ i - 2 ] + a [ i - 1 ]
DEDENT for i in range ( n - 1, - 1, - 1 ) :
INDENT print ( a [ i ], end = " " )
DEDENT DEDENT

FIND_MINIMUM_DIFFERENCE_PAIR_1 | def findMinDiff ( arr, n ) :
INDENT arr = sorted ( arr )
diff = 10 * * 20
for i in range ( n - 1 ) :
INDENT if arr [ i + 1 ] - arr [ i ] < diff :
INDENT diff = arr [ i + 1 ] - arr [ i ]
DEDENT DEDENT return diff
DEDENT

MINIMUM_NUMBER_PLATFORMS_REQUIRED_RAILWAYBUS_STATION | def findPlatform ( arr, dep, n ) :
INDENT arr . sort ( )
dep . sort ( )
plat_needed = 1
result = 1
i = 1
j = 0
while ( i < n and j < n ) :
INDENT if ( arr [ i ] < dep [ j ] ) :
INDENT plat_needed += 1
i += 1
if ( plat_needed > result ) :
INDENT result = plat_needed
DEDENT DEDENT else :
INDENT plat_needed -= 1
j += 1
DEDENT DEDENT return result
DEDENT

MULTIPLICATIVE_INVERSE_UNDER_MODULO_M_1 | def modInverse ( a, m ) :
INDENT m0 = m
y = 0
x = 1
if ( m == 1 ) :
INDENT return 0
DEDENT while ( a > 1 ) :
INDENT q = a //m
t=m
m=a%m
a=t
t=y
y=x-q*y
x=t
DEDENTif(x<0):
INDENTx=x+m0
DEDENTreturnx
DEDENT


NUMBER_N_DIGIT_STEPPING_NUMBERS | def answer ( n ) :
INDENT dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ];

if ( n == 1 ) :
INDENT return 10;

DEDENT for j in range ( 10 ) :
INDENT dp [ 1 ] [ j ] = 1;

DEDENT for i in range ( 2, n + 1 ) :
INDENT for j in range ( 10 ) :
INDENT if ( j == 0 ) :
INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ];

DEDENT elif ( j == 9 ) :
INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ];

DEDENT else :
INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] );

DEDENT DEDENT DEDENT sum = 0;

for j in range ( 1, 10 ) :
INDENT sum = sum + dp [ n ] [ j ];

DEDENT return sum;

DEDENT

CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X | def fill0X ( m, n ) :
INDENT i, k, l = 0, 0, 0
r = m
c = n
a = [ [ None ] * n for i in range ( m ) ]
x = 'X'
while k < m and l < n :
INDENT for i in range ( l, n ) :
INDENT a [ k ] [ i ] = x
DEDENT k += 1
for i in range ( k, m ) :
INDENT a [ i ] [ n - 1 ] = x
DEDENT n -= 1
if k < m :
INDENT for i in range ( n - 1, l - 1, - 1 ) :
INDENT a [ m - 1 ] [ i ] = x
DEDENT m -= 1
DEDENT if l < n :
INDENT for i in range ( m - 1, k - 1, - 1 ) :
INDENT a [ i ] [ l ] = x
DEDENT l += 1
DEDENT x = 'X' if x == '0' else '0'
DEDENT for i in range ( r ) :
INDENT for j in range ( c ) :
INDENT print ( a [ i ] [ j ], end = " " )
DEDENT print ( )
DEDENT DEDENT

FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY | def findSubarraySum ( arr, n ) :
INDENT res = 0
m = dict ( )
for i in range ( n ) :
INDENT Sum = 0
for j in range ( i, n ) :
INDENT Sum += arr [ j ]
m [ Sum ] = m . get ( Sum, 0 ) + 1
DEDENT DEDENT for x in m :
INDENT if m [ x ] == 1 :
INDENT res += x
DEDENT DEDENT return res
DEDENT

REVERSE_A_STRING_USING_RECURSION | def reverse ( string ) :
INDENT if len ( string ) == 0 :
INDENT return
DEDENT temp = string [ 0 ]
reverse ( string [ 1 : ] )
print ( temp, end = '' )
DEDENT

PRINTING_ITEMS_01_KNAPSACK | def printknapSack ( W, wt, val, n ) :
INDENT K = [ [ 0 for w in range ( W + 1 ) ] for i in range ( n + 1 ) ]
for i in range ( n + 1 ) :
INDENT for w in range ( W + 1 ) :
INDENT if i == 0 or w == 0 :
INDENT K [ i ] [ w ] = 0
DEDENT elif wt [ i - 1 ] <= w :
INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ], K [ i - 1 ] [ w ] )
DEDENT else :
INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ]
DEDENT DEDENT DEDENT res = K [ n ] [ W ]
print ( res )
w = W
for i in range ( n, 0, - 1 ) :
INDENT if res <= 0 :
INDENT break
DEDENT if res == K [ i - 1 ] [ w ] :
INDENT continue
DEDENT else :
INDENT print ( wt [ i - 1 ] )
res = res - val [ i - 1 ]
w = w - wt [ i - 1 ]
DEDENT DEDENT DEDENT

FIND_LARGEST_PRIME_FACTOR_NUMBER | def maxPrimeFactors ( n ) :
INDENT maxPrime = - 1
while n % 2 == 0 :
INDENT maxPrime = 2
n >>= 1
DEDENT for i in range ( 3, int ( math . sqrt ( n ) ) + 1, 2 ) :
INDENT while n % i == 0 :
INDENT maxPrime = i
n = n / i
DEDENT DEDENT if n > 2 :
INDENT maxPrime = n
DEDENT return int ( maxPrime )
DEDENT

FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT | def findElement ( arr, n ) :
INDENT leftMax = [ None ] * n
leftMax [ 0 ] = float ( '-inf' )
for i in range ( 1, n ) :
INDENT leftMax [ i ] = max ( leftMax [ i - 1 ], arr [ i - 1 ] )
DEDENT rightMin = float ( 'inf' )
for i in range ( n - 1, - 1, - 1 ) :
INDENT if leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] :
INDENT return i
DEDENT rightMin = min ( rightMin, arr [ i ] )
DEDENT return - 1
DEDENT

COMMON_CHARACTERS_N_STRINGS | def commonCharacters ( strings, n ) :
INDENT prim = [ True ] * MAX_CHAR
for i in range ( n ) :
INDENT sec = [ False ] * MAX_CHAR
for j in range ( len ( strings [ i ] ) ) :
INDENT if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] ) :
INDENT sec [ ord ( strings [ i ] [ j ] ) - ord ( 'a' ) ] = True
DEDENT DEDENT for i in range ( MAX_CHAR ) :
INDENT prim [ i ] = sec [ i ]
DEDENT DEDENT for i in range ( 26 ) :
INDENT if ( prim [ i ] ) :
INDENT print ( "%c " % ( i + ord ( 'a' ) ), end = "" )
DEDENT DEDENT DEDENT

MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING | def minimalSteps ( s, n ) :
INDENT dp = [ INT_MAX for i in range ( n ) ]
s1 = ""
s2 = ""
dp [ 0 ] = 1
s1 += s [ 0 ]
for i in range ( 1, n ) :
INDENT s1 += s [ i ]
s2 = s [ i + 1 : i + 1 + i + 1 ]
dp [ i ] = min ( dp [ i ], dp [ i - 1 ] + 1 )
if ( s1 == s2 ) :
INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1, dp [ i * 2 + 1 ] )
DEDENT DEDENT return dp [ n - 1 ]
DEDENT

SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_1 | def findSum ( n ) :
INDENT sum = 0
for i in range ( n ) :
INDENT sum += i * ( n - i )
DEDENT return 2 * sum
DEDENT

FIND_FREQUENCY_EVEN_ODD_NUMBERS_MATRIX | def freq ( ar, m, n ) :
INDENT even = 0
odd = 0
for i in range ( m ) :
INDENT for j in range ( n ) :
INDENT if ( ( ar [ i ] [ j ] % 2 ) == 0 ) :
INDENT even += 1
DEDENT else :
INDENT odd += 1
DEDENT DEDENT DEDENT print ( " Frequency of odd number =", odd )
print ( " Frequency of even number =", even )
DEDENT

COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS | def countSubarrays ( arr, n ) :
INDENT difference = 0
ans = 0
hash_positive = [ 0 ] * ( n + 1 )
hash_negative = [ 0 ] * ( n + 1 )
hash_positive [ 0 ] = 1
for i in range ( n ) :
INDENT if ( arr [ i ] & 1 == 1 ) :
INDENT difference = difference + 1
DEDENT else :
INDENT difference = difference - 1
DEDENT if ( difference < 0 ) :
INDENT ans += hash_negative [ - difference ]
hash_negative [ - difference ] = hash_negative [ - difference ] + 1
DEDENT else :
INDENT ans += hash_positive [ difference ]
hash_positive [ difference ] = hash_positive [ difference ] + 1
DEDENT DEDENT return ans
DEDENT

PASCAL_TRIANGLE_1 | def printPascal ( n ) :
INDENT for line in range ( 1, n + 1 ) :
INDENT C = 1;

for i in range ( 1, line + 1 ) :
INDENT print ( C, end = " " );

C = int ( C * ( line - i ) / i );

DEDENT print ( "" );

DEDENT DEDENT

NUMBER_OF_TRIANGLES_IN_A_PLANE_IF_NO_MORE_THAN_TWO_POINTS_ARE_COLLINEAR | def countNumberOfTriangles ( n ) :
INDENT return ( n * ( n - 1 ) * ( n - 2 ) //6)
DEDENT


MERGE_TWO_SORTED_ARRAYS_O1_EXTRA_SPACE | def merge ( ar1, ar2, m, n ) :
INDENT for i in range ( n - 1, - 1, - 1 ) :
INDENT last = ar1 [ m - 1 ]
j = m - 2
while ( j >= 0 and ar1 [ j ] > ar2 [ i ] ) :
INDENT ar1 [ j + 1 ] = ar1 [ j ]
j -= 1
DEDENT if ( j != m - 2 or last > ar2 [ i ] ) :
INDENT ar1 [ j + 1 ] = ar2 [ i ]
ar2 [ i ] = last
DEDENT DEDENT DEDENT

NEWMAN_SHANKS_WILLIAMS_PRIME | def nswp ( n ) :
INDENT if n == 0 or n == 1 :
INDENT return 1
DEDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 )
DEDENT

SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS | def smallest ( x, y, z ) :
INDENT c = 0
while ( x and y and z ) :
INDENT x = x - 1
y = y - 1
z = z - 1
c = c + 1
DEDENT return c
DEDENT

COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X | def countPairs ( arr1, arr2, m, n, x ) :
INDENT count = 0
for i in range ( m ) :
INDENT for j in range ( n ) :
INDENT if arr1 [ i ] + arr2 [ j ] == x :
INDENT count = count + 1
DEDENT DEDENT DEDENT return count
DEDENT

SORT_ARRAY_APPLYING_GIVEN_EQUATION | def sortArray ( arr, n, A, B, C ) :
INDENT for i in range ( n ) :
INDENT arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i ] + C )
DEDENT index = - ( sys . maxsize - 1 )
maximum = - ( sys . maxsize - 1 )
for i in range ( n ) :
INDENT if maximum < arr [ i ] :
INDENT index = i
maximum = arr [ i ]
DEDENT DEDENT i = 0;
j = n - 1;

new_arr = [ 0 ] * n
k = 0
while i < index and j > index :
INDENT if arr [ i ] < arr [ j ] :
INDENT new_arr [ k ] = arr [ i ]
k += 1
i += 1
DEDENT else :
INDENT new_arr [ k ] = arr [ j ]
k += 1
j -= 1
DEDENT DEDENT while i < index :
INDENT new_arr [ k ] = arr [ i ]
k += 1
i += 1
DEDENT while j > index :
INDENT new_arr [ k ] = arr [ j ]
k += 1
j -= 1
new_arr [ n - 1 ] = maximum
DEDENT for i in range ( n ) :
INDENT arr [ i ] = new_arr [ i ]
DEDENT DEDENT

PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON | def findArea ( a ) :
INDENT area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a ) / 4
return area
DEDENT

MAXIMIZE_SUM_CONSECUTIVE_DIFFERENCES_CIRCULAR_ARRAY | def maxSum ( arr, n ) :
INDENT sum = 0
arr . sort ( )
for i in range ( 0, int ( n / 2 ) ) :
INDENT sum -= ( 2 * arr [ i ] )
sum += ( 2 * arr [ n - i - 1 ] )
DEDENT return sum
DEDENT

COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES | def countarray ( n, k, x ) :
INDENT dp = list ( )
dp . append ( 0 )
dp . append ( 1 )
i = 2
while i < n :
INDENT dp . append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] )
i = i + 1
DEDENT return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 1 ] )
DEDENT

SUM_SERIES_12_32_52_2N_12 | def sumOfSeries ( n ) :
INDENT sum = 0
for i in range ( 1, n + 1 ) :
INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 )
DEDENT return sum
DEDENT

FIND_THE_NEAREST_SMALLER_NUMBERS_ON_LEFT_SIDE_IN_AN_ARRAY_1 | def printPrevSmaller ( arr, n ) :
INDENT S = list ( )
for i in range ( n ) :
INDENT while ( len ( S ) > 0 and S [ - 1 ] >= arr [ i ] ) :
INDENT S . pop ( )
DEDENT if ( len ( S ) == 0 ) :
INDENT print ( "_, ", end = "" )
DEDENT else :
INDENT print ( S [ - 1 ], end = ", " )
DEDENT S . append ( arr [ i ] )
DEDENT DEDENT

FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1 | def CountTriangles ( A ) :
INDENT n = len ( A );

A . sort ( );

count = 0;

for i in range ( n - 1, 0, - 1 ) :
INDENT l = 0;

r = i - 1;

while ( l < r ) :
INDENT if ( A [ l ] + A [ r ] > A [ i ] ) :
INDENT count += r - l;

r -= 1;

DEDENT else :
INDENT l += 1;

DEDENT DEDENT DEDENT print ( "No of possible solutions: ", count );

DEDENT

MAXIMUM_GAMES_PLAYED_WINNER | def maxGameByWinner ( N ) :
INDENT dp = [ 0 for i in range ( N ) ]
dp [ 0 ] = 1
dp [ 1 ] = 2
i = 1
while dp [ i ] <= N :
INDENT i = i + 1
dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]
DEDENT return ( i - 1 )
DEDENT

NUMBER_OF_SUBSTRINGS_WITH_ODD_DECIMAL_VALUE_IN_A_BINARY_STRING | def countSubstr ( s ) :
INDENT n = len ( s )
auxArr = [ 0 for i in range ( n ) ]
if ( s [ 0 ] == '1' ) :
INDENT auxArr [ 0 ] = 1
DEDENT for i in range ( 0, n ) :
INDENT if ( s [ i ] == '1' ) :
INDENT auxArr [ i ] = auxArr [ i - 1 ] + 1
DEDENT else :
INDENT auxArr [ i ] = auxArr [ i - 1 ]
DEDENT DEDENT count = 0
for i in range ( n - 1, - 1, - 1 ) :
INDENT if ( s [ i ] == '1' ) :
INDENT count += auxArr [ i ]
DEDENT DEDENT return count
DEDENT

ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY_1 | def countNum ( arr, n ) :
INDENT s = dict ( )
count, maxm, minm = 0, - 10 * * 9, 10 * * 9
for i in range ( n ) :
INDENT s [ arr [ i ] ] = 1
if ( arr [ i ] < minm ) :
INDENT minm = arr [ i ]
DEDENT if ( arr [ i ] > maxm ) :
INDENT maxm = arr [ i ]
DEDENT DEDENT for i in range ( minm, maxm + 1 ) :
INDENT if i not in s . keys ( ) :
INDENT count += 1
DEDENT DEDENT return count
DEDENT

WRITE_A_C_PROGRAM_TO_CALCULATE_POWXN_1 | def power ( x, y ) :
INDENT if ( y == 0 ) : return 1
temp = power ( x, int ( y / 2 ) )
if ( y % 2 == 0 ) :
INDENT return temp * temp
DEDENT else :
INDENT if ( y > 0 ) : return x * temp * temp
else : return ( temp * temp ) / x
DEDENT DEDENT

N_TH_TERM_SERIES_2_12_36_80_150 | def nthTerm ( n ) :
INDENT return ( n * n ) + ( n * n * n )
DEDENT

FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES | def getOddOccurrence ( arr, arr_size ) :
INDENT for i in range ( 0, arr_size ) :
INDENT count = 0
for j in range ( 0, arr_size ) :
INDENT if arr [ i ] == arr [ j ] :
INDENT count += 1
DEDENT DEDENT if ( count % 2 != 0 ) :
INDENT return arr [ i ]
DEDENT DEDENT return - 1
DEDENT

EFFICIENT_METHOD_2S_COMPLEMENT_BINARY_STRING | def findTwoscomplement ( str ) :
INDENT n = len ( str )
i = n - 1
while ( i >= 0 ) :
INDENT if ( str [ i ] == '1' ) :
INDENT break
DEDENT i -= 1
DEDENT if ( i == - 1 ) :
INDENT return '1' + str
DEDENT k = i - 1
while ( k >= 0 ) :
INDENT if ( str [ k ] == '1' ) :
INDENT str = list ( str )
str [ k ] = '0'
str = '' . join ( str )
DEDENT else :
INDENT str = list ( str )
str [ k ] = '1'
str = '' . join ( str )
DEDENT k -= 1
DEDENT return str
DEDENT

PAPER_CUT_MINIMUM_NUMBER_SQUARES_SET_2 | def minimumSquare ( m, n ) :
INDENT vertical_min = 10000000000
horizontal_min = 10000000000
if m == n :
INDENT return 1
DEDENT if dp [ m ] [ n ] != 0 :
INDENT return dp [ m ] [ n ]
DEDENT for i in range ( 1, m //2+1):
INDENThorizontal_min=min(minimumSquare(i,n)+minimumSquare(m-i,n),horizontal_min)
DEDENTforjinrange(1,n//2+1):
INDENTvertical_min=min(minimumSquare(m,j)+minimumSquare(m,n-j),vertical_min)
DEDENTdp[m][n]=min(vertical_min,horizontal_min)
returndp[m][n]
DEDENT


MINIMIZE_ABSOLUTE_DIFFERENCE_SUM_TWO_SUBSETS | def subsetDifference ( n ) :
INDENT s = int ( n * ( n + 1 ) / 2 )
if n % 4 == 0 :
INDENT print ( "First subset sum = ", int ( s / 2 ) )
print ( "Second subset sum = ", int ( s / 2 ) )
print ( "Difference = ", 0 )
DEDENT else :
INDENT if n % 4 == 1 or n % 4 == 2 :
INDENT print ( "First subset sum = ", int ( s / 2 ) )
print ( "Second subset sum = ", int ( s / 2 ) + 1 )
print ( "Difference = ", 1 )
DEDENT else :
INDENT print ( "First subset sum = ", int ( s / 2 ) )
print ( "Second subset sum = ", int ( s / 2 ) )
print ( "Difference = ", 0 )
DEDENT DEDENT DEDENT

PROGRAM_CALCULATE_VOLUME_ELLIPSOID | def volumeOfEllipsoid ( r1, r2, r3 ) :
INDENT return 1.33 * math . pi * r1 * r2 * r3
DEDENT

DYNAMIC_PROGRAMMING_SET_13_CUTTING_A_ROD | def cutRod ( price, n ) :
INDENT val = [ 0 for x in range ( n + 1 ) ]
val [ 0 ] = 0
for i in range ( 1, n + 1 ) :
INDENT max_val = INT_MIN
for j in range ( i ) :
INDENT max_val = max ( max_val, price [ j ] + val [ i - j - 1 ] )
DEDENT val [ i ] = max_val
DEDENT return val [ n ]
DEDENT

RECURSIVE_INSERTION_SORT | def insertionSortRecursive ( arr, n ) :
INDENT if n <= 1 :
INDENT return
DEDENT insertionSortRecursive ( arr, n - 1 )
last = arr [ n - 1 ]
j = n - 2
while ( j >= 0 and arr [ j ] > last ) :
INDENT arr [ j + 1 ] = arr [ j ]
j = j - 1
DEDENT arr [ j + 1 ] = last
DEDENT

FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT | def findDuplicateparenthesis ( string ) :
INDENT Stack = [ ]
for ch in string :
INDENT if ch == ')' :
INDENT top = Stack . pop ( )
elementsInside = 0
while top != '(' :
INDENT elementsInside += 1
top = Stack . pop ( )
DEDENT if elementsInside < 1 :
INDENT return True
DEDENT DEDENT else :
INDENT Stack . append ( ch )
DEDENT DEDENT return False
DEDENT

FIND_REPETITIVE_ELEMENT_1_N_1 | def findRepeating ( arr, n ) :
INDENT return sum ( arr ) - ( ( ( n - 1 ) * n ) //2)
DEDENT


CHECK_ARRAY_CONTAINS_CONTIGUOUS_INTEGERS_DUPLICATES_ALLOWED | def areElementsContiguous ( arr, n ) :
INDENT max1 = max ( arr )
min1 = min ( arr )
m = max1 - min1 + 1
if ( m > n ) :
INDENT return False
DEDENT visited = [ 0 ] * m
for i in range ( 0, n ) :
INDENT visited [ arr [ i ] - min1 ] = True
DEDENT for i in range ( 0, m ) :
INDENT if ( visited [ i ] == False ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1 | def maxLength ( s, n ) :
INDENT invalidOpenBraces = 0;

invalidCloseBraces = 0;

for i in range ( n ) :
INDENT if ( s [ i ] == '(' ) :
INDENT invalidOpenBraces += 1
DEDENT else :
INDENT if ( invalidOpenBraces == 0 ) :
INDENT invalidCloseBraces += 1
DEDENT else :
INDENT invalidOpenBraces -= 1
DEDENT DEDENT DEDENT return ( n - ( invalidOpenBraces + invalidCloseBraces ) )
DEDENT

SUM_SERIES_ALTERNATE_SIGNED_SQUARES_AP_1 | def seiresSum ( n, a ) :
INDENT return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) )
DEDENT

EQUILIBRIUM_INDEX_OF_AN_ARRAY | def equilibrium ( arr ) :
INDENT leftsum = 0
rightsum = 0
n = len ( arr )
for i in range ( n ) :
INDENT leftsum = 0
rightsum = 0
for j in range ( i ) :
INDENT leftsum += arr [ j ]
DEDENT for j in range ( i + 1, n ) :
INDENT rightsum += arr [ j ]
DEDENT if leftsum == rightsum :
INDENT return i
DEDENT DEDENT return - 1
DEDENT

COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3 | def findStep ( n ) :
INDENT if ( n == 1 or n == 0 ) :
INDENT return 1
DEDENT elif ( n == 2 ) :
INDENT return 2
DEDENT else :
INDENT return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 )
DEDENT DEDENT

FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE | def minCoins ( coins, m, V ) :
INDENT if ( V == 0 ) :
INDENT return 0
DEDENT res = sys . maxsize
for i in range ( 0, m ) :
INDENT if ( coins [ i ] <= V ) :
INDENT sub_res = minCoins ( coins, m, V - coins [ i ] )
if ( sub_res != sys . maxsize and sub_res + 1 < res ) :
INDENT res = sub_res + 1
DEDENT DEDENT DEDENT return res
DEDENT

BELL_NUMBERS_NUMBER_OF_WAYS_TO_PARTITION_A_SET | def bellNumber ( n ) :
INDENT bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]
bell [ 0 ] [ 0 ] = 1
for i in range ( 1, n + 1 ) :
INDENT bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ]
for j in range ( 1, i + 1 ) :
INDENT bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ]
DEDENT DEDENT return bell [ n ] [ 0 ]
DEDENT

FIND_ELEMENT_GIVEN_INDEX_NUMBER_ROTATIONS | def findElement ( arr, ranges, rotations, index ) :
INDENT for i in range ( rotations - 1, - 1, - 1 ) :
INDENT left = ranges [ i ] [ 0 ]
right = ranges [ i ] [ 1 ]
if ( left <= index and right >= index ) :
INDENT if ( index == left ) :
INDENT index = right
DEDENT else :
INDENT index = index - 1
DEDENT DEDENT DEDENT return arr [ index ]
DEDENT

DYCK_PATH | def countDyckPaths ( n ) :
INDENT res = 1
for i in range ( 0, n ) :
INDENT res *= ( 2 * n - i )
res /= ( i + 1 )
DEDENT return res / ( n + 1 )
DEDENT

COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE | def numberOfWays ( x ) :
INDENT if x == 0 or x == 1 :
INDENT return 1
DEDENT else :
INDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) )
DEDENT DEDENT

PROGRAM_DISPLAY_ASTROLOGICAL_SIGN_ZODIAC_SIGN_GIVEN_DATE_BIRTH | def zodiac_sign ( day, month ) :
INDENT if month == 'december' :
INDENT astro_sign = 'Sagittarius' if ( day < 22 ) else 'capricorn'
DEDENT elif month == 'january' :
INDENT astro_sign = 'Capricorn' if ( day < 20 ) else 'aquarius'
DEDENT elif month == 'february' :
INDENT astro_sign = 'Aquarius' if ( day < 19 ) else 'pisces'
DEDENT elif month == 'march' :
INDENT astro_sign = 'Pisces' if ( day < 21 ) else 'aries'
DEDENT elif month == 'april' :
INDENT astro_sign = 'Aries' if ( day < 20 ) else 'taurus'
DEDENT elif month == 'may' :
INDENT astro_sign = 'Taurus' if ( day < 21 ) else 'gemini'
DEDENT elif month == 'june' :
INDENT astro_sign = 'Gemini' if ( day < 21 ) else 'cancer'
DEDENT elif month == 'july' :
INDENT astro_sign = 'Cancer' if ( day < 23 ) else 'leo'
DEDENT elif month == 'august' :
INDENT astro_sign = 'Leo' if ( day < 23 ) else 'virgo'
DEDENT elif month == 'september' :
INDENT astro_sign = 'Virgo' if ( day < 23 ) else 'libra'
DEDENT elif month == 'october' :
INDENT astro_sign = 'Libra' if ( day < 23 ) else 'scorpio'
DEDENT elif month == 'november' :
INDENT astro_sign = 'scorpio' if ( day < 22 ) else 'sagittarius'
DEDENT print ( astro_sign )
DEDENT

PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2 | def recursiveReverse ( str, i = 0 ) :
INDENT n = len ( str )
if i == n //2:
INDENTreturn
DEDENTstr[i],str[n-i-1]=str[n-i-1],str[i]
recursiveReverse(str,i+1)
DEDENT


K_TH_DIGIT_RAISED_POWER_B | def kthdigit ( a, b, k ) :
INDENT p = a * * b
count = 0
while ( p > 0 and count < k ) :
INDENT rem = p % 10
count = count + 1
if ( count == k ) :
INDENT return rem
DEDENT p = p / 10;

DEDENT DEDENT

SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS | def findSmallestDifference ( A, B, m, n ) :
INDENT A . sort ( )
B . sort ( )
a = 0
b = 0
result = sys . maxsize
while ( a < m and b < n ) :
INDENT if ( abs ( A [ a ] - B [ b ] ) < result ) :
INDENT result = abs ( A [ a ] - B [ b ] )
DEDENT if ( A [ a ] < B [ b ] ) :
INDENT a += 1
DEDENT else :
INDENT b += 1
DEDENT DEDENT return result
DEDENT

MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY_1 | def findArea ( arr, n ) :
INDENT s = [ ]
first = 0
second = 0
for i in range ( n ) :
INDENT if arr [ i ] not in s :
INDENT s . append ( arr [ i ] )
continue
DEDENT if ( arr [ i ] > first ) :
INDENT second = first
first = arr [ i ]
DEDENT elif ( arr [ i ] > second ) :
INDENT second = arr [ i ]
DEDENT DEDENT return ( first * second )
DEDENT

PROGRAM_PAGE_REPLACEMENT_ALGORITHMS_SET_2_FIFO | def pageFaults ( pages, n, capacity ) :
INDENT s = set ( )
indexes = Queue ( )
page_faults = 0
for i in range ( n ) :
INDENT if ( len ( s ) < capacity ) :
INDENT if ( pages [ i ] not in s ) :
INDENT s . add ( pages [ i ] )
page_faults += 1
indexes . put ( pages [ i ] )
DEDENT DEDENT else :
INDENT if ( pages [ i ] not in s ) :
INDENT val = indexes . queue [ 0 ]
indexes . get ( )
s . remove ( val )
s . add ( pages [ i ] )
indexes . put ( pages [ i ] )
page_faults += 1
DEDENT DEDENT DEDENT return page_faults
DEDENT

FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1 | def findFourElements ( arr, n ) :
INDENT mp = dict ( )
for i in range ( n - 1 ) :
INDENT for j in range ( i + 1, n ) :
INDENT mp [ arr [ i ] + arr [ j ] ] = ( i, j )
DEDENT DEDENT d = - 10 * * 9
for i in range ( n - 1 ) :
INDENT for j in range ( i + 1, n ) :
INDENT abs_diff = abs ( arr [ i ] - arr [ j ] )
if abs_diff in mp . keys ( ) :
INDENT p = mp [ abs_diff ]
if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) :
INDENT d = max ( d, max ( arr [ i ], arr [ j ] ) )
DEDENT DEDENT DEDENT DEDENT return d
DEDENT

PRINT_GIVEN_MATRIX_REVERSE_SPIRAL_FORM | def ReversespiralPrint ( m, n, a ) :
INDENT b = [ 0 for i in range ( 100 ) ]
i, k, l = 0, 0, 0
z = 0
size = m * n
while ( k < m and l < n ) :
INDENT val = 0
for i in range ( l, n ) :
INDENT val = a [ k ] [ i ]
b [ z ] = val
z += 1
DEDENT k += 1
for i in range ( k, m ) :
INDENT val = a [ i ] [ n - 1 ]
b [ z ] = val
z += 1
DEDENT n -= 1
if ( k < m ) :
INDENT for i in range ( n - 1, l - 1, - 1 ) :
INDENT val = a [ m - 1 ] [ i ]
b [ z ] = val
z += 1
DEDENT DEDENT m -= 1
if ( l < n ) :
INDENT for i in range ( m - 1, k - 1, - 1 ) :
INDENT val = a [ i ] [ l ]
b [ z ] = val
z += 1
DEDENT l += 1
DEDENT DEDENT for i in range ( size - 1, - 1, - 1 ) :
INDENT print ( b [ i ], end = " " )
DEDENT DEDENT

NUMBER_N_DIGITS_NON_DECREASING_INTEGERS | def nonDecNums ( n ) :
INDENT a = np . zeros ( ( n + 1, 10 ) )
for i in range ( 10 ) :
INDENT a [ 0 ] [ i ] = 1
DEDENT for i in range ( 1, n + 1 ) :
INDENT a [ i ] [ 9 ] = 1
DEDENT for i in range ( 1, n + 1 ) :
INDENT for j in range ( 8, - 1, - 1 ) :
INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ]
DEDENT DEDENT return int ( a [ n ] [ 0 ] )
DEDENT

LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF | def findLength ( str ) :
INDENT n = len ( str )
maxlen = 0
for i in range ( 0, n ) :
INDENT for j in range ( i + 1, n, 2 ) :
INDENT length = j - i + 1
leftsum = 0
rightsum = 0
for k in range ( 0, int ( length / 2 ) ) :
INDENT leftsum += ( int ( str [ i + k ] ) - int ( '0' ) )
rightsum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) )
DEDENT if ( leftsum == rightsum and maxlen < length ) :
INDENT maxlen = length
DEDENT DEDENT DEDENT return maxlen
DEDENT

PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT | def worstFit ( blockSize, m, processSize, n ) :
INDENT allocation = [ - 1 ] * n
for i in range ( n ) :
INDENT wstIdx = - 1
for j in range ( m ) :
INDENT if blockSize [ j ] >= processSize [ i ] :
INDENT if wstIdx == - 1 :
INDENT wstIdx = j
DEDENT elif blockSize [ wstIdx ] < blockSize [ j ] :
INDENT wstIdx = j
DEDENT DEDENT DEDENT if wstIdx != - 1 :
INDENT allocation [ i ] = wstIdx
blockSize [ wstIdx ] -= processSize [ i ]
DEDENT DEDENT print ( "Process No. Process Size Block no." )
for i in range ( n ) :
INDENT print ( i + 1, "         ", processSize [ i ], end = "     " )
if allocation [ i ] != - 1 :
INDENT print ( allocation [ i ] + 1 )
DEDENT else :
INDENT print ( "Not Allocated" )
DEDENT DEDENT DEDENT

SUM_SUBSETS_SET_FORMED_FIRST_N_NATURAL_NUMBERS | def findSumSubsets ( n ) :
INDENT return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) )
DEDENT

ADD_TWO_NUMBERS_WITHOUT_USING_ARITHMETIC_OPERATORS | def Add ( x, y ) :
INDENT while ( y != 0 ) :
INDENT carry = x & y
x = x ^ y
y = carry << 1
DEDENT return x
DEDENT

MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE | def maxcoefficientvalue ( n ) :
INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ];

for i in range ( n + 1 ) :
INDENT for j in range ( min ( i, n ) + 1 ) :
INDENT if ( j == 0 or j == i ) :
INDENT C [ i ] [ j ] = 1;

DEDENT else :
INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] );

DEDENT DEDENT DEDENT maxvalue = 0;

for i in range ( n + 1 ) :
INDENT maxvalue = max ( maxvalue, C [ n ] [ i ] );

DEDENT return maxvalue;

DEDENT

EULERIAN_PATH_UNDIRECTED_GRAPH | def findpath ( graph ) :
INDENT n = len ( graph )
numofadj = list ( )
for i in range ( n ) :
INDENT numofadj . append ( sum ( graph [ i ] ) )
DEDENT startpoint = 0
numofodd = 0
for i in range ( n - 1, - 1, - 1 ) :
INDENT if ( numofadj [ i ] % 2 == 1 ) :
INDENT numofodd += 1
startpoint = i
DEDENT DEDENT if ( numofodd > 2 ) :
INDENT print ( "No Solution" )
return
DEDENT stack = list ( )
path = list ( )
cur = startpoint
while ( stack != [ ] or sum ( graph [ cur ] ) != 0 ) :
INDENT if ( sum ( graph [ cur ] ) == 0 ) :
INDENT path . append ( cur + 1 )
cur = stack . pop ( - 1 )
DEDENT else :
INDENT for i in range ( n ) :
INDENT if graph [ cur ] [ i ] == 1 :
INDENT stack . append ( cur )
graph [ cur ] [ i ] = 0
graph [ i ] [ cur ] = 0
cur = i
break
DEDENT DEDENT DEDENT DEDENT for ele in path :
INDENT print ( ele, "-> ", end = '' )
DEDENT print ( cur + 1 )
DEDENT

RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS | def countSubstrs ( str, i, j, n ) :
INDENT if ( n == 1 ) :
INDENT return 1
DEDENT if ( n <= 0 ) :
INDENT return 0
DEDENT res = ( countSubstrs ( str, i + 1, j, n - 1 ) + countSubstrs ( str, i, j - 1, n - 1 ) - countSubstrs ( str, i + 1, j - 1, n - 2 ) )
if ( str [ i ] == str [ j ] ) :
INDENT res += 1
DEDENT return res
DEDENT

FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1 | def count ( a, b ) :
INDENT m = len ( a )
n = len ( b )
lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ]
for i in range ( n + 1 ) :
INDENT lookup [ 0 ] [ i ] = 0
DEDENT for i in range ( m + 1 ) :
INDENT lookup [ i ] [ 0 ] = 1
DEDENT for i in range ( 1, m + 1 ) :
INDENT for j in range ( 1, n + 1 ) :
INDENT if a [ i - 1 ] == b [ j - 1 ] :
INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ]
DEDENT else :
INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ]
DEDENT DEDENT DEDENT return lookup [ m ] [ n ]
DEDENT

AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES | def polygonArea ( X, Y, n ) :
INDENT area = 0.0
j = n - 1
for i in range ( 0, n ) :
INDENT area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] )
j = i
DEDENT return int ( abs ( area / 2.0 ) )
DEDENT

PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N | def findConsecutive ( N ) :
INDENT start = 1
end = ( N + 1 ) //2
while(start<end):
INDENTSum=0
foriinrange(start,end+1):
INDENTSum=Sum+i
if(Sum==N):
INDENTforjinrange(start,i+1):
INDENTprint(j,end=" ")
DEDENTprint()
break
DEDENTif(Sum>N):
INDENTbreak
DEDENTDEDENTSum=0
start+=1
DEDENTDEDENT


BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_BRACKETS | def arrangeBraces ( n, pos, k ) :
INDENT h = [ False for i in range ( N ) ]
dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ]
for i in range ( k ) :
INDENT h [ pos [ i ] ] = 1
DEDENT dp [ 0 ] [ 0 ] = 1
for i in range ( 1, 2 * n + 1 ) :
INDENT for j in range ( 2 * n + 1 ) :
INDENT if ( h [ i ] ) :
INDENT if ( j != 0 ) :
INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]
DEDENT else :
INDENT dp [ i ] [ j ] = 0
DEDENT DEDENT else :
INDENT if ( j != 0 ) :
INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] )
DEDENT else :
INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]
DEDENT DEDENT DEDENT DEDENT return dp [ 2 * n ] [ 0 ]
DEDENT

GIVEN_1S_2S_3S_KS_PRINT_ZIG_ZAG_WAY | def ZigZag ( rows, columns, numbers ) :
INDENT k = 0
arr = [ [ 0 for i in range ( columns ) ] for j in range ( rows ) ]
for i in range ( rows ) :
INDENT if ( i % 2 == 0 ) :
INDENT j = 0
while j < columns and numbers [ k ] > 0 :
INDENT arr [ i ] [ j ] = k + 1
numbers [ k ] -= 1
if numbers [ k ] == 0 :
INDENT k += 1
DEDENT j += 1
DEDENT DEDENT else :
INDENT j = columns - 1
while j >= 0 and numbers [ k ] > 0 :
INDENT arr [ i ] [ j ] = k + 1
numbers [ k ] -= 1
if numbers [ k ] == 0 :
INDENT k += 1
DEDENT j -= 1
DEDENT DEDENT DEDENT for i in arr :
INDENT for j in i :
INDENT print ( j, end = " " )
DEDENT print ( )
DEDENT DEDENT

CONVERT_STRING_BINARY_SEQUENCE | def strToBinary ( s ) :
INDENT bin_conv = [ ]
for c in s :
INDENT ascii_val = ord ( c )
binary_val = bin ( ascii_val )
bin_conv . append ( binary_val [ 2 : ] )
DEDENT return ( ' ' . join ( bin_conv ) )
DEDENT

LUCKY_NUMBERS | def isLucky ( n ) :
INDENT next_position = n
if isLucky . counter > n :
INDENT return 1
DEDENT if n % isLucky . counter == 0 :
INDENT return 0
DEDENT next_position = next_position - next_position / isLucky . counter
isLucky . counter = isLucky . counter + 1
return isLucky ( next_position )
DEDENT

SMALLEST_SUM_CONTIGUOUS_SUBARRAY | def smallestSumSubarr ( arr, n ) :
INDENT min_ending_here = sys . maxsize
min_so_far = sys . maxsize
for i in range ( n ) :
INDENT if ( min_ending_here > 0 ) :
INDENT min_ending_here = arr [ i ]
DEDENT else :
INDENT min_ending_here += arr [ i ]
DEDENT min_so_far = min ( min_so_far, min_ending_here )
DEDENT return min_so_far
DEDENT

PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE | def sequence ( n ) :
INDENT f = [ 0, 1, 1 ]
print ( f [ 1 ], end = " " ),
print ( f [ 2 ], end = " " ),
for i in range ( 3, n + 1 ) :
INDENT f . append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] )
print ( f [ i ], end = " " ),
DEDENT DEDENT

MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES | def fib ( n ) :
INDENT if ( n <= 1 ) :
INDENT return n
DEDENT return fib ( n - 1 ) + fib ( n - 2 )
DEDENT

MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS | def cost ( a, n ) :
INDENT return ( ( n - 1 ) * min ( a ) )
DEDENT

CHOCOLATE_DISTRIBUTION_PROBLEM | def findMinDiff ( arr, n, m ) :
INDENT if ( m == 0 or n == 0 ) :
INDENT return 0
DEDENT arr . sort ( )
if ( n < m ) :
INDENT return - 1
DEDENT min_diff = sys . maxsize
first = 0
last = 0
i = 0
while ( i + m - 1 < n ) :
INDENT diff = arr [ i + m - 1 ] - arr [ i ]
if ( diff < min_diff ) :
INDENT min_diff = diff
first = i
last = i + m - 1
DEDENT i += 1
DEDENT return ( arr [ last ] - arr [ first ] )
DEDENT

FIND_ONE_EXTRA_CHARACTER_STRING_1 | def findExtraCharcter ( strA, strB ) :
INDENT res = 0
for i in range ( 0, len ( strA ) ) :
INDENT res = res ^ ( ord ) ( strA [ i ] )
DEDENT for i in range ( 0, len ( strB ) ) :
INDENT res = res ^ ( ord ) ( strB [ i ] )
DEDENT return ( ( chr ) ( res ) );

DEDENT

CHECK_WHETHER_TWO_STRINGS_ARE_ANAGRAM_OF_EACH_OTHER | def areAnagram ( str1, str2 ) :
INDENT n1 = len ( str1 )
n2 = len ( str2 )
if n1 != n2 :
INDENT return 0
DEDENT str1 = sorted ( str1 )
str2 = sorted ( str2 )
for i in range ( 0, n1 ) :
INDENT if str1 [ i ] != str2 [ i ] :
INDENT return 0
DEDENT DEDENT return 1
DEDENT

CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING | def calcMaxValue ( str ) :
INDENT res = ord ( str [ 0 ] ) - 48
for i in range ( 1, len ( str ) ) :
INDENT if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) :
INDENT res += ord ( str [ i ] ) - 48
DEDENT else :
INDENT res *= ord ( str [ i ] ) - 48
DEDENT DEDENT return res
DEDENT

FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER | def findSum ( N, K ) :
INDENT ans = 0;

for i in range ( 1, N + 1 ) :
INDENT ans += ( i % K );

DEDENT return ans;

DEDENT

DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1 | def checkCount ( arr, n, k ) :
INDENT mp = defaultdict ( lambda : 0 )
for i in range ( n ) :
INDENT mp [ arr [ i ] ] += 1
DEDENT for key, values in mp . items ( ) :
INDENT if values > 2 * k :
INDENT return False
DEDENT DEDENT return True
DEDENT

SEARCH_IN_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX | def search ( mat, n, x ) :
INDENT i = 0
j = n - 1
while ( i < n and j >= 0 ) :
INDENT if ( mat [ i ] [ j ] == x ) :
INDENT print ( "n Found at ", i, ", ", j )
return 1
DEDENT if ( mat [ i ] [ j ] > x ) :
INDENT j -= 1
DEDENT else :
INDENT i += 1
DEDENT DEDENT print ( "Element not found" )
return 0
DEDENT

RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX | def findLeft ( str ) :
INDENT n = len ( str ) - 1;

while ( n > 0 ) :
INDENT if ( str [ n ] == 'd' ) :
INDENT str = str [ 0 : n ] + 'c' + str [ n + 1 : ];

break;

DEDENT if ( str [ n ] == 'b' ) :
INDENT str = str [ 0 : n ] + 'a' + str [ n + 1 : ];

break;

DEDENT if ( str [ n ] == 'a' ) :
INDENT str = str [ 0 : n ] + 'b' + str [ n + 1 : ];

DEDENT elif ( str [ n ] == 'c' ) :
INDENT str = str [ 0 : n ] + 'd' + str [ n + 1 : ];

DEDENT n -= 1;

DEDENT return str;

DEDENT

SUM_FACTORS_NUMBER | def divSum ( n ) :
INDENT result = 0
for i in range ( 2, ( int ) ( math . sqrt ( n ) ) + 1 ) :
INDENT if ( n % i == 0 ) :
INDENT if ( i == ( n / i ) ) :
INDENT result = result + i
DEDENT else :
INDENT result = result + ( i + n //i)
DEDENTDEDENTDEDENTreturn(result+n+1)
DEDENT


HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT_2 | def sumDigits ( no ) :
INDENT return 0 if no == 0 else int ( no % 10 ) + sumDigits ( int ( no / 10 ) )
DEDENT

CHECK_POSSIBLE_SORT_ARRAY_CONDITIONAL_SWAPPING_ADJACENT_ALLOWED | def checkForSorting ( arr, n ) :
INDENT for i in range ( 0, n - 1 ) :
INDENT if ( arr [ i ] > arr [ i + 1 ] ) :
INDENT if ( arr [ i ] - arr [ i + 1 ] == 1 ) :
INDENT arr [ i ], arr [ i + 1 ] = arr [ i + 1 ], arr [ i ]
DEDENT else :
INDENT return False
DEDENT DEDENT DEDENT return True
DEDENT

SUPER_PRIME | def SieveOfEratosthenes ( n, isPrime ) :
INDENT isPrime [ 0 ] = isPrime [ 1 ] = False
for i in range ( 2, n + 1 ) :
INDENT isPrime [ i ] = True
DEDENT for p in range ( 2, n + 1 ) :
INDENT if ( p * p <= n and isPrime [ p ] == True ) :
INDENT for i in range ( p * 2, n + 1, p ) :
INDENT isPrime [ i ] = False
p += 1
DEDENT DEDENT DEDENT DEDENT

PROGRAM_BINARY_DECIMAL_CONVERSION_1 | def binaryToDecimal ( n ) :
INDENT num = n;

dec_value = 0;

base1 = 1;

len1 = len ( num );

for i in range ( len1 - 1, - 1, - 1 ) :
INDENT if ( num [ i ] == '1' ) :
INDENT dec_value += base1;

DEDENT base1 = base1 * 2;

DEDENT return dec_value;

DEDENT

LEONARDO_NUMBER | def leonardo ( n ) :
INDENT if ( n == 0 or n == 1 ) :
INDENT return 1
DEDENT return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 );

DEDENT

CHECK_ARRAY_CONTAINS_CONTIGUOUS_INTEGERS_DUPLICATES_ALLOWED_1 | def areElementsContiguous ( arr ) :
INDENT us = set ( )
for i in arr : us . add ( i )
count = 1
curr_ele = arr [ 0 ] - 1
while curr_ele in us :
INDENT count += 1
curr_ele -= 1
DEDENT curr_ele = arr [ 0 ] + 1
while curr_ele in us :
INDENT count += 1
curr_ele += 1
DEDENT return ( count == len ( us ) )
DEDENT

SQUARE_ROOT_OF_AN_INTEGER | def floorSqrt ( x ) :
INDENT if ( x == 0 or x == 1 ) :
INDENT return x
DEDENT i = 1;
result = 1
while ( result <= x ) :
INDENT i += 1
result = i * i
DEDENT return i - 1
DEDENT

LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_LEAST_K_TIMES | def subsequence ( s, t, n, k ) :
INDENT last = 0
cnt = 0
new_last = 0
size = 0
string = 'zyxwvutsrqponmlkjihgfedcba'
for ch in string :
INDENT cnt = 0
for i in range ( last, n ) :
INDENT if s [ i ] == ch :
INDENT cnt += 1
DEDENT DEDENT if cnt >= k :
INDENT for i in range ( last, n ) :
INDENT if s [ i ] == ch :
INDENT t [ size ] = ch
new_last = i
size += 1
DEDENT DEDENT last = new_last
DEDENT DEDENT DEDENT

RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM | def breakSum ( n ) :
INDENT if ( n == 0 or n == 1 ) :
INDENT return n
DEDENT return max ( ( breakSum ( n //2)+breakSum(n//3)+breakSum(n//4)),n)
DEDENT


MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY | def minSwaps ( arr ) :
INDENT n = len ( arr )
arrpos = [ * enumerate ( arr ) ]
arrpos . sort ( key = lambda it : it [ 1 ] )
vis = {
  k : False for k in range ( n ) }
  
  ans = 0
  for i in range ( n ) :
  INDENT if vis [ i ] or arrpos [ i ] [ 0 ] == i :
  INDENT continue
  DEDENT cycle_size = 0
  j = i
  while not vis [ j ] :
  INDENT vis [ j ] = True
  j = arrpos [ j ] [ 0 ]
  cycle_size += 1
  DEDENT if cycle_size > 0 :
  INDENT ans += ( cycle_size - 1 )
  DEDENT DEDENT return ans
  DEDENT

DIAGONALLY_DOMINANT_MATRIX | def isDDM ( m, n ) :
INDENT for i in range ( 0, n ) :
INDENT sum = 0
for j in range ( 0, n ) :
INDENT sum = sum + abs ( m [ i ] [ j ] )
DEDENT sum = sum - abs ( m [ i ] [ i ] )
if ( abs ( m [ i ] [ i ] ) < sum ) :
INDENT return False
DEDENT DEDENT return True
DEDENT

SPLIT_N_MAXIMUM_COMPOSITE_NUMBERS | def count ( n ) :
INDENT if ( n < 4 ) :
INDENT return - 1
DEDENT rem = n % 4
if ( rem == 0 ) :
INDENT return n //4
DEDENTif(rem==1):
INDENTif(n<9):
INDENTreturn-1
DEDENTreturn(n-9)//4+1
DEDENTif(rem==2):
INDENTreturn(n-6)//4+1
DEDENTif(rem==3):
INDENTif(n<15):
INDENTreturn-1
DEDENTreturn(n-15)//4+2
DEDENTDEDENT


FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE | def findDimen ( H, A ) :
INDENT if H * H < 4 * A :
INDENT print ( "Not Possible" )
return
DEDENT apb = sqrt ( H * H + 4 * A )
asb = sqrt ( H * H - 4 * A )
print ( "P = ", "%.2f" % ( ( apb - asb ) / 2.0 ) )
print ( "B = ", "%.2f" % ( ( apb + asb ) / 2.0 ) )
DEDENT

PRODUCT_MAXIMUM_FIRST_ARRAY_MINIMUM_SECOND_1 | def minMaxProduct ( arr1, arr2, n1, n2 ) :
INDENT max = arr1 [ 0 ]
min = arr2 [ 0 ]
i = 1
while ( i < n1 and i < n2 ) :
INDENT if ( arr1 [ i ] > max ) :
INDENT max = arr1 [ i ]
DEDENT if ( arr2 [ i ] < min ) :
INDENT min = arr2 [ i ]
DEDENT i += 1
DEDENT while ( i < n1 ) :
INDENT if ( arr1 [ i ] > max ) :
INDENT max = arr1 [ i ]
i += 1
DEDENT DEDENT while ( i < n2 ) :
INDENT if ( arr2 [ i ] < min ) :
INDENT min = arr2 [ i ]
i += 1
DEDENT DEDENT return max * min
DEDENT

PROGRAM_CALCULATE_VOLUME_OCTAHEDRON | def vol_of_octahedron ( side ) :
INDENT return ( ( side * side * side ) * ( math . sqrt ( 2 ) / 3 ) )
DEDENT

SORT_STRING_CHARACTERS_1 | def sortString ( str ) :
INDENT charCount = [ 0 for i in range ( MAX_CHAR ) ]
for i in range ( 0, len ( str ), 1 ) :
INDENT charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1
DEDENT for i in range ( 0, MAX_CHAR, 1 ) :
INDENT for j in range ( 0, charCount [ i ], 1 ) :
INDENT print ( chr ( ord ( 'a' ) + i ), end = "" )
DEDENT DEDENT DEDENT

MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL | def moveSpaceInFront ( s ) :
INDENT i = len ( s ) - 1;

for j in range ( i, - 1, - 1 ) :
INDENT if ( s [ j ] != ' ' ) :
INDENT s = s [ : i ] + s [ j ] + s [ i + 1 : ]
i -= 1;

DEDENT DEDENT while ( i >= 0 ) :
INDENT s = s [ : i ] + ' ' + s [ i + 1 : ]
i -= 1
DEDENT return s;

DEDENT

MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL | def minOps ( arr, n, k ) :
INDENT max1 = max ( arr )
res = 0
for i in range ( 0, n ) :
INDENT if ( ( max1 - arr [ i ] ) % k != 0 ) :
INDENT return - 1
DEDENT else :
INDENT res += ( max1 - arr [ i ] ) / k
DEDENT DEDENT return int ( res )
DEDENT

PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1 | def factorial ( n ) :
INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 );

DEDENT

MINIMUM_TIME_TO_FINISH_TASKS_WITHOUT_SKIPPING_TWO_CONSECUTIVE | def minTime ( arr, n ) :
INDENT if ( n <= 0 ) : return 0
incl = arr [ 0 ]
excl = 0
for i in range ( 1, n ) :
INDENT incl_new = arr [ i ] + min ( excl, incl )
excl_new = incl
incl = incl_new
excl = excl_new
DEDENT return min ( incl, excl )
DEDENT

CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT | def areEqual ( arr1, arr2, n, m ) :
INDENT if ( n != m ) :
INDENT return False;

DEDENT arr1 . sort ( );

arr2 . sort ( );

for i in range ( 0, n - 1 ) :
INDENT if ( arr1 [ i ] != arr2 [ i ] ) :
INDENT return False;

DEDENT DEDENT return True;

DEDENT

MINIMUM_DIFFERENCE_MAX_MIN_K_SIZE_SUBSETS | def minDifferenceAmongMaxMin ( arr, N, K ) :
INDENT arr . sort ( )
res = 2147483647
for i in range ( ( N - K ) + 1 ) :
INDENT curSeqDiff = arr [ i + K - 1 ] - arr [ i ]
res = min ( res, curSeqDiff )
DEDENT return res
DEDENT

SWAP_BITS_IN_A_GIVEN_NUMBER | def swapBits ( x, p1, p2, n ) :
INDENT set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 )
set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 )
xor = ( set1 ^ set2 )
xor = ( xor << p1 ) | ( xor << p2 )
result = x ^ xor
return result
DEDENT

COUNT_NUMBER_OF_WAYS_TO_FILL_A_N_X_4_GRID_USING_1_X_4_TILES | def count ( n ) :
INDENT dp = [ 0 for _ in range ( n + 1 ) ]
for i in range ( 1, n + 1 ) :
INDENT if i <= 3 :
INDENT dp [ i ] = 1
DEDENT elif i == 4 :
INDENT dp [ i ] = 2
DEDENT else :
INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ]
DEDENT DEDENT return dp [ n ]
DEDENT

MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1 | def maxRepeating ( str ) :
INDENT n = len ( str )
count = 0
res = str [ 0 ]
cur_count = 1
for i in range ( n ) :
INDENT if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) :
INDENT cur_count += 1
DEDENT else :
INDENT if cur_count > count :
INDENT count = cur_count
res = str [ i ]
DEDENT cur_count = 1
DEDENT DEDENT return res
DEDENT

PASCAL_TRIANGLE | def printPascal ( n : int ) :
INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]
for line in range ( 0, n ) :
INDENT for i in range ( 0, line + 1 ) :
INDENT if ( i is 0 or i is line ) :
INDENT arr [ line ] [ i ] = 1
print ( arr [ line ] [ i ], end = " " )
DEDENT else :
INDENT arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] )
print ( arr [ line ] [ i ], end = " " )
DEDENT DEDENT print ( "\n", end = "" )
DEDENT DEDENT

TURN_OFF_THE_RIGHTMOST_SET_BIT | def fun ( n ) :
INDENT return n & ( n - 1 )
DEDENT

REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE | def rearrange ( arr, n ) :
INDENT max_idx = n - 1
min_idx = 0
max_elem = arr [ n - 1 ] + 1
for i in range ( 0, n ) :
INDENT if i % 2 == 0 :
INDENT arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem
max_idx -= 1
DEDENT else :
INDENT arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem
min_idx += 1
DEDENT DEDENT for i in range ( 0, n ) :
INDENT arr [ i ] = arr [ i ] / max_elem
DEDENT DEDENT

COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX | def countZeroes ( mat ) :
INDENT N = 5;

row = N - 1;

col = 0;

count = 0;

while ( col < N ) :
INDENT while ( mat [ row ] [ col ] ) :
INDENT if ( row < 0 ) :
INDENT return count;

DEDENT row = row - 1;

DEDENT count = count + ( row + 1 );

col = col + 1;

DEDENT return count;

DEDENT

MINIMUM_COST_FOR_ACQUIRING_ALL_COINS_WITH_K_EXTRA_COINS_ALLOWED_WITH_EVERY_COIN | def minCost ( coin, n, k ) :
INDENT coin . sort ( )
coins_needed = math . ceil ( 1.0 * n //(k+1));
ans=0
foriinrange(coins_needed-1+1):
INDENTans+=coin[i]
DEDENTreturnans
DEDENT


COUNT_SUBARRAYS_TOTAL_DISTINCT_ELEMENTS_ORIGINAL_ARRAY | def countDistictSubarray ( arr, n ) :
INDENT vis = dict ( )
for i in range ( n ) :
INDENT vis [ arr [ i ] ] = 1
DEDENT k = len ( vis )
vid = dict ( )
ans = 0
right = 0
window = 0
for left in range ( n ) :
INDENT while ( right < n and window < k ) :
INDENT if arr [ right ] in vid . keys ( ) :
INDENT vid [ arr [ right ] ] += 1
DEDENT else :
INDENT vid [ arr [ right ] ] = 1
DEDENT if ( vid [ arr [ right ] ] == 1 ) :
INDENT window += 1
DEDENT right += 1
DEDENT if ( window == k ) :
INDENT ans += ( n - right + 1 )
DEDENT vid [ arr [ left ] ] -= 1
if ( vid [ arr [ left ] ] == 0 ) :
INDENT window -= 1
DEDENT DEDENT return ans
DEDENT

FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT | def possibleOrNot ( a1, a2, b1, b2, c1, c2 ) :
INDENT dis1 = ( pow ( b1 - a1, 2 ) + pow ( b2 - a2, 2 ) )
dis2 = ( pow ( c1 - b1, 2 ) + pow ( c2 - b2, 2 ) )
if ( dis1 != dis2 ) :
INDENT print ( "No" )
DEDENT elif ( b1 == ( ( a1 + c1 ) //2.0)andb2==((a2+c2)//2.0)):
INDENTprint("No")
DEDENTelse:
INDENTprint("Yes")
DEDENTDEDENT


TIME_MEET_ANIMALS | def timeToMeet ( s, v ) :
INDENT V = 3 * v / 2;

time = s / V;

print ( time );

DEDENT

BRESENHAMS_LINE_GENERATION_ALGORITHM | def bresenham ( x1, y1, x2, y2 ) :
INDENT m_new = 2 * ( y2 - y1 )
slope_error_new = m_new - ( x2 - x1 )
y = y1
for x in range ( x1, x2 + 1 ) :
INDENT print ( "(", x, ",", y, ")\n" )
slope_error_new = slope_error_new + m_new
if ( slope_error_new >= 0 ) :
INDENT y = y + 1
slope_error_new = slope_error_new - 2 * ( x2 - x1 )
DEDENT DEDENT DEDENT

MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS | def maxNumOfChocolates ( arr, n, k ) :
INDENT um, curr_rem, maxSum = {
},
0, 0
sm = [ 0 ] * n
sm [ 0 ] = arr [ 0 ]
for i in range ( 1, n ) :
INDENT sm [ i ] = sm [ i - 1 ] + arr [ i ]
DEDENT for i in range ( n ) :
INDENT curr_rem = sm [ i ] % k
if ( not curr_rem and maxSum < sm [ i ] ) :
INDENT maxSum = sm [ i ]
DEDENT elif ( not curr_rem in um ) :
INDENT um [ curr_rem ] = i
DEDENT elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) :
INDENT maxSum = sm [ i ] - sm [ um [ curr_rem ] ]
DEDENT DEDENT return maxSum //k
DEDENT


CHECK_TWO_STRINGS_K_ANAGRAMS_NOT_1 | def areKAnagrams ( str1, str2, k ) :
INDENT n = len ( str1 );

if ( len ( str2 ) != n ) :
INDENT return False;

DEDENT hash_str1 = [ 0 ] * ( MAX_CHAR );

for i in range ( n ) :
INDENT hash_str1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1;

DEDENT count = 0;

for i in range ( n ) :
INDENT if ( hash_str1 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] > 0 ) :
INDENT hash_str1 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] -= 1;

DEDENT else :
INDENT count += 1;

DEDENT if ( count > k ) :
INDENT return False;

DEDENT DEDENT return True;

DEDENT

DIVISIBILITY_CHECK | def divisibilityCheck ( arr, n ) :
INDENT s = dict ( )
max_ele = - 10 * * 9
for i in range ( n ) :
INDENT s [ arr [ i ] ] = 1
max_ele = max ( max_ele, arr [ i ] )
DEDENT res = dict ( )
for i in range ( n ) :
INDENT if ( arr [ i ] != 0 ) :
INDENT for j in range ( arr [ i ] * 2, max_ele + 1, arr [ i ] ) :
INDENT if ( j in s . keys ( ) ) :
INDENT res [ j ] = 1
DEDENT DEDENT DEDENT DEDENT for x in res :
INDENT print ( x, end = " " )
DEDENT DEDENT

MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER | def maxPrefix ( s, t ) :
INDENT count = 0
for i in range ( 0, len ( t ) ) :
INDENT if ( count == len ( s ) ) :
INDENT break
DEDENT if ( t [ i ] == s [ count ] ) :
INDENT count = count + 1
DEDENT DEDENT return count
DEDENT

COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K | def countDistinct ( arr, k, n ) :
INDENT mp = defaultdict ( lambda : 0 )
dist_count = 0
for i in range ( k ) :
INDENT if mp [ arr [ i ] ] == 0 :
INDENT dist_count += 1
DEDENT mp [ arr [ i ] ] += 1
DEDENT print ( dist_count )
for i in range ( k, n ) :
INDENT if mp [ arr [ i - k ] ] == 1 :
INDENT dist_count -= 1
DEDENT mp [ arr [ i - k ] ] -= 1
if mp [ arr [ i ] ] == 0 :
INDENT dist_count += 1
DEDENT mp [ arr [ i ] ] += 1
print ( dist_count )
DEDENT DEDENT

LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K | def longestSubsequenceCommonSegment ( k, s1, s2 ) :
INDENT n = len ( s1 )
m = len ( s2 )
lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]
cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]
for i in range ( 1, n + 1 ) :
INDENT for j in range ( 1, m + 1 ) :
INDENT lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ], lcs [ i ] [ j - 1 ] )
if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) :
INDENT cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1;

DEDENT if ( cnt [ i ] [ j ] >= k ) :
INDENT for a in range ( k, cnt [ i ] [ j ] + 1 ) :
INDENT lcs [ i ] [ j ] = max ( lcs [ i ] [ j ], lcs [ i - a ] [ j - a ] + a )
DEDENT DEDENT DEDENT DEDENT return lcs [ n ] [ m ]
DEDENT

PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1 | def printDistinct ( arr, n ) :
INDENT arr . sort ( );

for i in range ( n ) :
INDENT if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) :
INDENT while ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) :
INDENT i += 1;

DEDENT DEDENT else :
INDENT print ( arr [ i ], end = " " );

DEDENT DEDENT DEDENT

PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES | def isPrime ( p ) :
INDENT checkNumber = 2 * * p - 1
nextval = 4 % checkNumber
for i in range ( 1, p - 1 ) :
INDENT nextval = ( nextval * nextval - 2 ) % checkNumber
DEDENT if ( nextval == 0 ) : return True
else : return False
DEDENT

KTH_NON_REPEATING_CHARACTER | def kthNonRepeating ( str, k ) :
INDENT n = len ( str )
count = [ 0 ] * MAX_CHAR
index = [ 0 ] * MAX_CHAR
for i in range ( MAX_CHAR ) :
INDENT count [ i ] = 0
index [ i ] = n
DEDENT for i in range ( n ) :
INDENT x = str [ i ]
count [ ord ( x ) ] += 1
if ( count [ ord ( x ) ] == 1 ) :
INDENT index [ ord ( x ) ] = i
DEDENT if ( count [ ord ( x ) ] == 2 ) :
INDENT index [ ord ( x ) ] = n
DEDENT DEDENT index . sort ( )
return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1
DEDENT

FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE | def first ( str ) :
INDENT for i in range ( 0, len ( str ) ) :
INDENT if ( str [ i ] . istitle ( ) ) :
INDENT return str [ i ]
DEDENT DEDENT return 0
DEDENT

GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND | def isSubSequence ( string1, string2, m, n ) :
INDENT if m == 0 : return True
if n == 0 : return False
if string1 [ m - 1 ] == string2 [ n - 1 ] :
INDENT return isSubSequence ( string1, string2, m - 1, n - 1 )
DEDENT return isSubSequence ( string1, string2, m, n - 1 )
DEDENT

C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1 | def largest ( arr, n ) :
INDENT return max ( arr )
DEDENT

DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY | def findDiff ( arr, n ) :
INDENT arr . sort ( )
count = 0;
max_count = 0;
min_count = n
for i in range ( 0, ( n - 1 ) ) :
INDENT if arr [ i ] == arr [ i + 1 ] :
INDENT count += 1
continue
DEDENT else :
INDENT max_count = max ( max_count, count )
min_count = min ( min_count, count )
count = 0
DEDENT DEDENT return max_count - min_count
DEDENT

PROGRAM_FOR_FACTORIAL_OF_A_NUMBER | def factorial ( n ) :
INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 );

DEDENT

